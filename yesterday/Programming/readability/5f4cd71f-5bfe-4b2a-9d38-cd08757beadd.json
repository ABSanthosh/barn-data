{
  "id": "5f4cd71f-5bfe-4b2a-9d38-cd08757beadd",
  "title": "Design system annotations, part 2: Advanced methods of annotating components",
  "link": "https://github.blog/engineering/user-experience/design-system-annotations-part-2-advanced-methods-of-annotating-components/",
  "description": "How to build custom annotations for your design system components or use Figma’s Code Connect to help capture important accessibility details before development. The post Design system annotations, part 2: Advanced methods of annotating components appeared first on The GitHub Blog.",
  "author": "Jan Maarten",
  "published": "Fri, 09 May 2025 16:56:57 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Engineering",
    "User experience",
    "accessibility",
    "annotations",
    "ARIA",
    "Components",
    "design",
    "design systems",
    "Figma",
    "Primer"
  ],
  "byline": "Jan Maarten",
  "length": 13478,
  "excerpt": "How to build custom annotations for your design system components or use Figma’s Code Connect to help capture important accessibility details before development.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "In part one of our design system annotation series, we discussed the ways in which accessibility can get left out of design system components from one instance to another. Our solution? Using a set of “Preset annotations” for each component with Primer. This allows designers to include specific pre-set details that aren’t already built into the component and visually communicated in the design itself.  That being said, Preset annotations are unique to each design system — and while ours may be a helpful reference for how to build them — they’re not something other organizations can utilize if you’re not also using the Primer design system.  Luckily, you can build your own. Here’s how.  How to make Preset annotations for your design system Start by assessing components to understand which ones would need Preset annotations—not all of them will. Prioritize components that would benefit most from having a Preset annotation, and build that key information into each one. Next, determine what properties should be included. Only include key information that isn’t conveyed visually, isn’t in the component properties, and isn’t already baked into a coded component.  Prioritizing components When a design system has 60+ components, knowing where to start can be a challenge. Which components need these annotations the most? Which ones would have the highest impact for both design teams and our users?  When we set out to create a new set of Preset annotations based on our proof of concept, we decided to use ten Primer components that would benefit the most. To help pick them, we used an internal tool called Primer Query that tracks all component implementations across the GitHub codebase as well as any audit issues connected to them. Here is a video breakdown of how it works, if you’re curious.  We then prioritized new Preset annotations based on the following criteria: Components that align to organization priorities (i.e. high value products and/or those that receive a lot of traffic). Components that appear frequently in accessibility audit issues. Components with React implementations (as our preferred development framework). Most frequently implemented components.  Mapping out the properties For each component, we cross-referenced multiple sources to figure out what component properties and attributes would need to be added in each Preset annotation. The things we were looking for may only exist in one or two of those places, and thus are less likely to be accounted for all the way through the design and development lifecycle. The sources include: Component documentation on Primer.style Design system docs should contain usage guidance for designers and developers, and accessibility requirements should be a part of this guidance as well. Some of the guidance and requirements get built into the component’s Figma asset, while some only end up in the coded component.  Look for any accessibility requirements that are not built into either Figma or code. If it’s built in, putting the same info in the Preset annotation may be redundant or irrelevant. Coded demos in Storybook  Our component sandbox helped us see how each component is built in React or Rails, as well as what the HTML output is. We looked for any code structure or accessibility attributes that are not included in the component documentation or the Figma asset itself—especially when they may vary from one implementation to another.  Component properties in the Figma asset library Library assets provide a lot of flexibility through text layers, image fills, variants, and elaborate sets of component properties. We paid close attention to these options to understand what designers can and can’t change. Worthwhile additions to a Preset Annotation are accessibility attributes, requirements, and usage guidance in other sources that aren’t built into the Figma component.  Other potential sources  Experiences from team members: The designers, developers, and accessibility specialists you work with may have insight into things that the docs and design tools may have missed. If your team and design system have been around for a while, their insights may be more valuable than those you’ll find in the docs, component demos, or asset libraries. Take some time to ask which components have had challenging bugs and which get intentionally broken when implemented. Findings from recent audits: Design system components themselves may have unresolved audit issues and remediation recommendations. If that’s the case, those issues are likely present in Storybook demos and may be unaccounted for in the component documentation. Design system audit issues may have details that both help create a Preset annotation and offer insights about what should not be carried over from existing resources. What we learned from creating Preset annotations Preset annotations may not be for every team or organization. However, they are especially well suited for younger design systems and those that aren’t well adopted.  Mature design systems like Primer have frequent updates. This means that without close monitoring, the design system components themselves may fall out of sync with how a Preset annotation is built. This can end up causing confusion and rework after development starts, so it may be wise to make sure there’s some capacity to maintain these annotations after they’ve been created.  For newer teams at GitHub, new members of existing teams, and team members who were less familiar with the design system, the built-in guidance and links to documentation and component demos proved very useful. Those who are more experienced are also able to fine-tune the Presets and how they’re used. If you don’t already have extensive experience with the design system components (or peers to help build them), it can take a lot of time to assess and map out the properties needed to build a Preset. It can also be challenging to name a component property succinctly enough that it doesn’t get truncated in Figma’s properties panel. If the context is not self-evident, some training or additional documentation may help. It’s not always clear that you need a Preset annotation There may be enough overlap between the Preset annotation for a component and types of annotations that aren’t specific to the design system. For example, the GitHub Annotation Toolkit has components to annotate basic \u003ctextarea\u003e form elements in addition to a Preset annotation for our \u003cTextArea\u003e Primer component: In many instances, this flexibility may be confusing because you could use either annotation. For example, the Primer \u003cTextArea\u003e Preset has built-in links to specific Primer docs, and while the non-Preset version doesn’t, you could always add the links manually. While there’s some overlap between the two, using either one is better than none.  One way around this confusion is to add Primer-specific properties to the default set of annotations. This would allow you to do things like toggle a boolean property on a normal Button annotation and have it show links and properties specific to your design system’s button component.  Our Preset creation process may unlock automation There are currently a number of existing Figma plugins that advertise the ability to scan a design file to help with annotations. That being said, the results are often mixed and contain an unmanageable amount of noise and false positives. One of the reasons these issues happen is that these public plugins are design system agnostic. Current automated annotation tools aren’t able to understand that any design system components are being used without bespoke programming or thorough training of AI models. For plugins like this to be able to label design elements accurately, they first need to understand how to identify the components on the canvas, the variants used, and the set properties.  With that in mind, perhaps the most exciting insight is that the process of mapping out component properties for a Preset annotation—the things that don’t get conveyed in the visual design or in the code—is also something that would need to be done in any attempt to automate more usable annotations.  In other words, if a team uses a design system and wants to automate adding annotations, the tool they use would need to understand their components. In order for it to understand their components well enough to automate accurately, these hidden component properties would need to be mapped out. The task of creating a set of Preset annotations may be a vital stepping stone to something even more streamlined.  A promising new method: Figma’s Code Connect  While building our new set of Preset annotations, we experimented with other ways to enhance Primer with annotations. Though not all of those experiments worked out, one of them did: adding accessibility attributes through Code Connect.  Primer was one of the early adopters of Figma’s new Code Connect feature in Dev Mode. Says Lukas Oppermann, our staff systems designer, “With Code Connect, we can actually move the design and the code a little bit further apart again. We can concentrate on creating the best UX for the designers working in Figma with design libraries and, on the code side, we can have the best developer experience.”  To that end, Code Connect allows us to bypass much of our Preset annotations, as well as the downsides of some of our other experiments. It does this by adding key accessibility details directly into the code that developers can export from Figma. GitHub’s Octicons are used in many of our Primer components. They are decorative by default, but they sometimes need alt text or aria-label attributes depending on how they’re used. In the IconButton component, that button uses an Octicon and needs an accessible name to describe its function.  When using a basic annotation kit, this may mean adding stamps for a Button and Decorative Image as well as a note in the margins that specifies what the aria-label should be. When using Preset annotations, there are fewer things to add to the canvas and the annotation process takes less time. With Code Connect set up, Lukas added a hidden layer in the IconButton Figma component. It has a text property for aria-label which lets designers add the value directly from the component properties panel. No annotations needed. The hidden layer doesn’t disrupt any of the visuals, and the aria-label property gets exported directly with the rest of the component’s code. It takes time to set up Code Connect with each of your design system components. Here are a few tips to help: Consistency is key. Make sure that the properties you create and how you place hidden layers is consistent across components. This helps set clear expectations so your teams can understand how these hidden layers and properties function.  Use a branch of your design system library to experiment. Hiding attributes like aria-label is quite simple compared to other complex information that Preset annotations are capable of handling.  Use visual regression testing (VRT). Adding complexity directly to a component comes with increased risk of things breaking in the future, especially for those with many variants. Figma’s merge conflict UI is helpful, but may not catch everything. As we continue to innovate with annotations and make our components more accessible, we are aiming to release our GitHub Annotation Toolkit in the near future. Stay tuned! Further reading Accessibility annotation kits are a great resource, provided they’re used responsibly. Eric Bailey, one of the contributors to our forthcoming GitHub Annotation Toolkit, has written extensively about how annotations can highlight and amplify deeply structural issues when you’re building digital products. Tags: accessibility annotations ARIA Components design design systems Figma Primer Written by Jan Maarten (he/him) is a designer and accessibility specialist living on unceded Duwamish lands. He has two decades of experience as a full-stack designer wearing every kind of hat, from end-to-end product design and brand to strategy and leadership. In his previous role on the CVS Health Inclusive Design team, he co-created several new accessibility annotation toolkits for web and iOS. He is currently a Senior Accessibility Designer at GitHub, helping teams shift left and improving design infrastructure. Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more Enterprise content Executive insights, curated just for you Get started",
  "image": "https://github.blog/wp-content/uploads/2025/05/Design-System-Annotations-Part-2.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eIn part one of our design system annotation series, we discussed the ways in which \u003ca href=\"https://github.blog/engineering/user-experience/design-system-annotations-part-1-how-accessibility-gets-left-out-of-components/\"\u003eaccessibility can get left out of design system components\u003c/a\u003e from one instance to another. Our solution? \u003ca href=\"https://github.blog/engineering/user-experience/design-system-annotations-part-1-how-accessibility-gets-left-out-of-components/#introducing-our-primer-a11y-preset-annotations\"\u003eUsing a set of “Preset annotations”\u003c/a\u003e for each component with Primer. This allows designers to include specific pre-set details that aren’t already built into the component and visually communicated in the design itself. \u003c/p\u003e\n\n\n\n\u003cp\u003eThat being said, Preset annotations are unique to each design system — and while ours may be a helpful reference for how to build them — they’re not something other organizations can utilize if you’re not also using the \u003ca href=\"https://primer.style\"\u003ePrimer\u003c/a\u003e design system. \u003c/p\u003e\n\n\n\n\u003cp\u003eLuckily, you can build your own. Here’s how. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-how-to-make-preset-annotations-for-your-design-system\"\u003eHow to make Preset annotations for \u003cem\u003eyour\u003c/em\u003e design system\u003c/h2\u003e\n\n\n\n\u003cp\u003eStart by assessing components to understand which ones would need Preset annotations—not all of them will. Prioritize components that would benefit most from having a Preset annotation, and build that key information into each one. Next, determine what properties should be included. Only include key information that isn’t conveyed visually, isn’t in the component properties, and isn’t already baked into a coded component. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1200\" height=\"630\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/Figure-1-Prioritizing.png?resize=1200%2C630\" alt=\"The start of a list of Primer components with notes for those which need Preset annotations. There are notes pointing to ActionBar, ActionMenu, and Autocomplete with details about what information should be documented in their Preset.\" srcset=\"https://github.blog/wp-content/uploads/2025/05/Figure-1-Prioritizing.png?w=1200 1200w, https://github.blog/wp-content/uploads/2025/05/Figure-1-Prioritizing.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/Figure-1-Prioritizing.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/Figure-1-Prioritizing.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3 id=\"prioritizing-components\"\u003ePrioritizing components\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen a design system has 60+ components, knowing where to start can be a challenge. Which components need these annotations the most? Which ones would have the highest impact for both design teams and our users? \u003c/p\u003e\n\n\n\n\u003cp\u003eWhen we set out to create a new set of Preset annotations based on our proof of concept, we decided to use ten Primer components that would benefit the most. To help pick them, we used an internal tool called Primer Query that tracks all component implementations across the GitHub codebase as well as any audit issues connected to them. Here is a \u003ca href=\"https://youtu.be/lryIVrpwwWw\"\u003evideo breakdown\u003c/a\u003e of how it works, if you’re curious. \u003c/p\u003e\n\n\n\n\u003cp\u003eWe then prioritized new Preset annotations based on the following criteria:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eComponents that align to organization priorities (i.e. high value products and/or those that receive a lot of traffic).\u003c/li\u003e\n\n\n\n\u003cli\u003eComponents that appear frequently in accessibility audit issues.\u003c/li\u003e\n\n\n\n\u003cli\u003eComponents with React implementations (as our preferred development framework).\u003c/li\u003e\n\n\n\n\u003cli\u003eMost frequently implemented components. \u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003ch3 id=\"h-mapping-out-the-properties\"\u003eMapping out the properties\u003c/h3\u003e\n\n\n\n\u003cp\u003eFor each component, we cross-referenced multiple sources to figure out what component properties and attributes would need to be added in each Preset annotation. The things we were looking for may only exist in one or two of those places, and thus are less likely to be accounted for all the way through the design and development lifecycle. The sources include:\u003c/p\u003e\n\n\n\n\u003ch4 id=\"h-component-documentation-on-primer-style\"\u003e\u003cstrong\u003eComponent documentation on Primer.style\u003c/strong\u003e\u003c/h4\u003e\n\n\n\n\u003cp\u003eDesign system docs should contain usage guidance for designers and developers, and accessibility requirements should be a part of this guidance as well. Some of the guidance and requirements get built into the component’s Figma asset, while some only end up in the coded component. \u003c/p\u003e\n\n\n\n\u003cp\u003eLook for any accessibility requirements that are not built into either Figma or code. If it’s built in, putting the same info in the Preset annotation may be redundant or irrelevant.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch4 id=\"h-coded-demos-in-storybook-nbsp\"\u003e\u003cstrong\u003eCoded demos in Storybook \u003c/strong\u003e\u003c/h4\u003e\n\n\n\n\u003cp\u003eOur \u003ca href=\"https://primer.style/react/storybook/\"\u003ecomponent sandbox\u003c/a\u003e helped us see how each component is built in React or Rails, as well as what the HTML output is. We looked for any code structure or accessibility attributes that are not included in the component documentation or the Figma asset itself—especially when they may vary from one implementation to another. \u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch4 id=\"h-component-properties-in-the-figma-asset-library\"\u003e\u003cstrong\u003eComponent properties in the Figma asset library\u003c/strong\u003e\u003c/h4\u003e\n\n\n\n\u003cp\u003eLibrary assets provide a lot of flexibility through text layers, image fills, variants, and elaborate sets of component properties. We paid close attention to these options to understand what designers can and can’t change. Worthwhile additions to a Preset Annotation are accessibility attributes, requirements, and usage guidance in other sources that aren’t built into the Figma component. \u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch4 id=\"h-other-potential-sources-nbsp\"\u003e\u003cstrong\u003eOther potential sources \u003c/strong\u003e\u003c/h4\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eExperiences from team members: \u003c/strong\u003eThe designers, developers, and accessibility specialists you work with may have insight into things that the docs and design tools may have missed. If your team and design system have been around for a while, their insights may be more valuable than those you’ll find in the docs, component demos, or asset libraries. Take some time to ask which components have had challenging bugs and which get intentionally broken when implemented.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eFindings from recent audits: \u003c/strong\u003eDesign system components themselves may have unresolved audit issues and remediation recommendations. If that’s the case, those issues are likely present in Storybook demos and may be unaccounted for in the component documentation. Design system audit issues may have details that both help create a Preset annotation and offer insights about what \u003cstrong\u003eshould not\u003c/strong\u003e be carried over from existing resources.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\n\n\u003ch2 id=\"what-we-learned-from-creating-preset-annotations\"\u003eWhat we learned from creating Preset annotations\u003c/h2\u003e\n\n\n\n\u003cp\u003ePreset annotations may not be for every team or organization. However, they are especially well suited for younger design systems and those that aren’t well adopted. \u003c/p\u003e\n\n\n\n\u003cp\u003eMature design systems like Primer have frequent updates. This means that without close monitoring, the design system components themselves may fall out of sync with how a Preset annotation is built. This can end up causing confusion and rework after development starts, so it may be wise to make sure there’s some capacity to maintain these annotations after they’ve been created. \u003c/p\u003e\n\n\n\n\u003cp\u003eFor newer teams at GitHub, new members of existing teams, and team members who were less familiar with the design system, the built-in guidance and links to documentation and component demos proved very useful. Those who are more experienced are also able to fine-tune the Presets and how they’re used.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you don’t already have extensive experience with the design system components (or peers to help build them), it can take a lot of time to assess and map out the properties needed to build a Preset. It can also be challenging to name a component property succinctly enough that it doesn’t get truncated in \u003ca href=\"https://help.figma.com/hc/en-us/articles/5579474826519-Explore-component-properties\"\u003eFigma’s properties panel\u003c/a\u003e. If the context is not self-evident, some training or additional documentation may help.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"its-not-always-clear-that-you-need-a-preset-annotation\"\u003eIt’s not always clear that you need a Preset annotation\u003c/h3\u003e\n\n\n\n\u003cp\u003eThere may be enough overlap between the Preset annotation for a component and types of annotations that aren’t specific to the design system. \u003cbr/\u003eFor example, the GitHub Annotation Toolkit has components to annotate basic \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e form elements in addition to a Preset annotation for our \u003ccode\u003e\u0026lt;TextArea\u0026gt;\u003c/code\u003e Primer component:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1200\" height=\"630\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/Figure-6-Similar-annotation-types.png?resize=1200%2C630\" alt=\"Comparison between a Form Element annotation for the textarea HTML element and a Preset annotation for the TextArea Primer component.\" srcset=\"https://github.blog/wp-content/uploads/2025/05/Figure-6-Similar-annotation-types.png?w=1200 1200w, https://github.blog/wp-content/uploads/2025/05/Figure-6-Similar-annotation-types.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/Figure-6-Similar-annotation-types.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/Figure-6-Similar-annotation-types.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn many instances, this flexibility may be confusing because you could use either annotation. For example, the Primer \u003ccode\u003e\u0026lt;TextArea\u0026gt;\u003c/code\u003e Preset has built-in links to specific Primer docs, and while the non-Preset version doesn’t, you could always add the links manually. While there’s some overlap between the two, using either one is better than none. \u003c/p\u003e\n\n\n\n\u003cp\u003eOne way around this confusion is to add Primer-specific properties to the default set of annotations. This would allow you to do things like toggle a boolean property on a normal Button annotation and have it show links and properties specific to your design system’s button component. \u003c/p\u003e\n\n\n\n\u003ch3 id=\"our-preset-creation-process-may-unlock-automation\"\u003eOur Preset creation process may unlock automation\u003c/h3\u003e\n\n\n\n\u003cp\u003eThere are currently a number of existing Figma plugins that advertise the ability to scan a design file to help with annotations. That being said, the results are often mixed and contain an unmanageable amount of noise and false positives. One of the reasons these issues happen is that these public plugins are design system agnostic.\u003c/p\u003e\n\n\n\n\u003cp\u003eCurrent automated annotation tools aren’t able to understand that any design system components are being used without bespoke programming or thorough training of AI models. For plugins like this to be able to label design elements accurately, they first need to understand how to identify the components on the canvas, the variants used, and the set properties. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1200\" height=\"630\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/Figure-7-Unlocking-automation.png?resize=1200%2C630\" alt=\"A Figma file showing an open design for Releases with an expanded layer tree highlighting a Primer Button component in the design. To the left of the screenshot are several git-lines and a Preset annotation for a Primer Button with a zap icon intersecting it. The git-line trails and the direction of the annotation give the feeling of flying toward the layer tree, which visually suggests this Primer Button layer can be automatically identified and annotated.\" srcset=\"https://github.blog/wp-content/uploads/2025/05/Figure-7-Unlocking-automation.png?w=1200 1200w, https://github.blog/wp-content/uploads/2025/05/Figure-7-Unlocking-automation.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/Figure-7-Unlocking-automation.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/Figure-7-Unlocking-automation.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWith that in mind, perhaps the most exciting insight is that the process of mapping out component properties for a Preset annotation—the things that don’t get conveyed in the visual design or in the code—is also something that would need to be done in any attempt to automate more usable annotations. \u003c/p\u003e\n\n\n\n\u003cp\u003eIn other words, if a team uses a design system and wants to automate adding annotations, the tool they use would need to understand their components. In order for it to understand their components well enough to automate \u003cem\u003eaccurately\u003c/em\u003e, these hidden component properties would need to be mapped out. The task of creating a set of Preset annotations may be a vital stepping stone to something even more streamlined. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"a-promising-new-method-figmas-code-connect\"\u003eA promising new method: Figma’s Code Connect \u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile building our new set of Preset annotations, we experimented with other ways to enhance Primer with annotations. Though \u003ca href=\"http://janmaarten.com/design-system-annotation-experiments/\"\u003enot all of those experiments worked out\u003c/a\u003e, one of them did: adding accessibility attributes through Code Connect. \u003c/p\u003e\n\n\n\n\u003cp\u003ePrimer was \u003ca href=\"https://www.figma.com/blog/unlocking-the-power-of-code-connect/\"\u003eone of the early adopters\u003c/a\u003e of Figma’s new Code Connect feature in Dev Mode. Says \u003ca href=\"https://primer.style/about/#lukasoppermann\"\u003eLukas Oppermann\u003c/a\u003e, our staff systems designer, “With Code Connect, we can actually move the design and the code a little bit further apart again. We can concentrate on creating the best UX for the designers working in Figma with design libraries and, on the code side, we can have the best developer experience.” \u003c/p\u003e\n\n\n\n\u003cp\u003eTo that end, Code Connect allows us to bypass much of our Preset annotations, as well as the downsides of some of our other experiments. It does this by adding key accessibility details directly into the code that developers can export from Figma.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub’s \u003ca href=\"https://primer.style/foundations/icons\"\u003eOcticons\u003c/a\u003e are used in many of our Primer components. They are decorative by default, but they sometimes need \u003ccode\u003ealt\u003c/code\u003e text or \u003ccode\u003earia-label\u003c/code\u003e attributes depending on how they’re used. In the \u003ca href=\"https://primer.style/product/components/icon-button/\"\u003eIconButton\u003c/a\u003e component, that button uses an Octicon and needs an accessible name to describe its function. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhen using a basic annotation kit, this may mean adding stamps for a \u003cstrong\u003eButton\u003c/strong\u003e and \u003cstrong\u003eDecorative Image\u003c/strong\u003e as well as a note in the margins that specifies what the \u003ccode\u003earia-label\u003c/code\u003e should be. When using Preset annotations, there are fewer things to add to the canvas and the annotation process takes less time.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith Code Connect set up, Lukas added a hidden layer in the IconButton Figma component. It has a text property for \u003ccode\u003earia-label\u003c/code\u003e which lets designers add the value directly from the component properties panel. No annotations needed. The hidden layer doesn’t disrupt any of the visuals, and the \u003ccode\u003earia-label\u003c/code\u003e property gets exported directly with the rest of the component’s code.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1200\" height=\"630\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/Figure-8-Code-Connect-and-hidden-properties.png?resize=1200%2C630\" alt=\"An IconButton component with a code-review icon. On the left is a screenshot of the component’s properties panel, with an aria-label value of: Start code review. On the right is the Code Connect output showing usable React code for an IconButton that includes the parameter: aria-label=Start code review.\" srcset=\"https://github.blog/wp-content/uploads/2025/05/Figure-8-Code-Connect-and-hidden-properties.png?w=1200 1200w, https://github.blog/wp-content/uploads/2025/05/Figure-8-Code-Connect-and-hidden-properties.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/Figure-8-Code-Connect-and-hidden-properties.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/Figure-8-Code-Connect-and-hidden-properties.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt takes time to set up Code Connect with each of your design system components. Here are a few tips to help:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eConsistency is key. \u003c/strong\u003eMake sure that the properties you create and how you place hidden layers is consistent across components. This helps set clear expectations so your teams can understand how these hidden layers and properties function. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUse a branch of your design system library to experiment.\u003c/strong\u003e Hiding attributes like aria-label is quite simple compared to other complex information that Preset annotations are capable of handling. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ca href=\"https://medium.com/eightshapes-llc/component-visual-test-cases-e501e2d21def\"\u003e\u003cstrong\u003evisual regression testing\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e (VRT).\u003c/strong\u003e Adding complexity directly to a component comes with increased risk of things breaking in the future, especially for those with many variants. Figma’s merge conflict UI is helpful, but may not catch everything.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAs we continue to innovate with annotations and make our components more accessible, we are aiming to release our GitHub Annotation Toolkit in the near future. Stay tuned!\u003c/p\u003e\n\n\n\n\u003ch2 id=\"further-reading\"\u003eFurther reading\u003c/h2\u003e\n\n\n\n\u003cp\u003eAccessibility annotation kits are a great resource, provided they’re used responsibly. \u003ca href=\"https://primer.style/about/#ericwbailey\"\u003eEric Bailey\u003c/a\u003e, one of the contributors to our forthcoming GitHub Annotation Toolkit, has written extensively about \u003ca href=\"https://ericwbailey.website/published/accessibility-annotation-kits-only-annotate/?li\"\u003ehow annotations can highlight and amplify deeply structural issues\u003c/a\u003e when you’re building digital products.\u003c/p\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/accessibility/\" rel=\"tag\"\u003e\n\t\t\t\t\t\taccessibility\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/annotations/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tannotations\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/aria/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tARIA\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/components/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tComponents\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/design/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tdesign\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/design-systems/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tdesign systems\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/figma/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tFigma\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/primer/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tPrimer\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/83665577?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/83665577?v=4\u0026amp;s=200\" alt=\"Jan Maarten\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eJan Maarten (he/him) is a designer and accessibility specialist living on unceded Duwamish lands. He has two decades of experience as a full-stack designer wearing every kind of hat, from end-to-end product design and brand to strategy and leadership. In his previous role on the CVS Health Inclusive Design team, he co-created several new accessibility annotation toolkits for web and iOS. He is currently a Senior Accessibility Designer at GitHub, helping teams shift left and improving design infrastructure.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.com/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2022/05/careers.svg\" width=\"44\" height=\"44\" alt=\"Enterprise content\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tEnterprise content\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eExecutive insights, curated just for you\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Get started; ref_location:bottom recirculation;\" href=\"https://github.com/solutions/executive-insights\" target=\"_blank\" aria-label=\"Get started\"\u003e\n\t\t\t\t\tGet started\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-05-09T16:56:57Z",
  "modifiedTime": "2025-05-09T19:12:50Z"
}
