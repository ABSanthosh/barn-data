{
  "id": "1d968eb6-6385-41ac-8b53-0ce34d4a0d52",
  "title": "Integration Tests for Plugin Developers: Intro, Dependencies, and First Integration Test",
  "link": "https://blog.jetbrains.com/platform/2025/02/integration-tests-for-plugin-developers-intro-dependencies-and-first-integration-test/",
  "description": "Following the enthusiastic response to our Plugin Testing: Performance, UI, and Functional Testing session at JetBrains Plugin Developer Conf 2024, we’re launching a series of blog posts diving deeper into plugin testing strategies.  This first post will guide you through setting up your testing environment and creating your first integration test, with detailed step-by-step instructions. […]",
  "author": "Maxim Kolmakov",
  "published": "Thu, 20 Feb 2025 15:58:16 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "plugin-development",
    "marketplace",
    "plugins",
    "testing"
  ],
  "byline": "Maxim Kolmakov",
  "length": 14113,
  "excerpt": "The first post of the series will guide you through setting up your testing environment and creating your first integration test, with detailed step-by-step instructions.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Plugin and extension development for JetBrains products. Development Marketplace PluginsIntegration Tests for Plugin Developers: Intro, Dependencies, and First Integration Test Following the enthusiastic response to our Plugin Testing: Performance, UI, and Functional Testing session at JetBrains Plugin Developer Conf 2024, we’re launching a series of blog posts diving deeper into plugin testing strategies.  This first post will guide you through setting up your testing environment and creating your first integration test, with detailed step-by-step instructions. Integration tests You might be wondering: “Why do we need integration tests when we already have unit tests? Aren’t unit tests easier to write, maintain, and run?” This is a valid question!  While the IntelliJ department maintains over 400,000 unit tests, we also rely on approximately 1,000 integration tests.  Here’s why they’re essential:  Testing complex scenarios: Some scenarios, particularly UI interactions, cannot be effectively covered by unit tests alone.  Full product testing: Integration tests run against the complete product rather than isolated components. This helps identify issues that unit tests might miss, such as module interaction problems, classpath conflicts, and plugin declaration issues. User story validation: Integration tests typically mirror real user scenarios, ensuring your plugin works reliably from start to finish.  Despite common perceptions, integration tests aren’t as difficult to create as you might think! Let’s explore how to set them up.  Note: While the following instructions are based on the IntelliJ Platform Gradle Plugin, the general principles also apply to other setups. Adding dependencies Our integration testing framework consists of two main components: Starter: Handles IDE configuration, test project setup, IDE startup, and output collection.  Driver: Provides additional functionality we’ll explore in future blog posts. The Starter framework exclusively supports JUnit 5, as it leverages JUnit 5’s extensions and specialized listeners that aren’t available in JUnit 4. Add the following dependencies to your build.gradle.kts: dependencies { intellijPlatform { // Starter Framework testFramework(TestFrameworkType.Starter) } // JUnit 5 testImplementation(\"org.junit.jupiter:junit-jupiter:5.10.2\") // Dependency Injection for Starter configuration testImplementation(\"org.kodein.di:kodein-di-jvm:7.20.2\") } The testFramework will resolve Starter Framework dependencies automatically, referring to the version of the currently targeted IntelliJ Platform. If you don’t use IntelliJ Platform Gradle Plugin, you will need to add the following libraries to your Gradle file: // Starter Framework testImplementation(\"com.jetbrains.intellij.tools:ide-starter-squashed:LATEST-EAP-SNAPSHOT\") testImplementation(\"com.jetbrains.intellij.tools:ide-starter-junit5:LATEST-EAP-SNAPSHOT\") // Driver Framework testImplementation(\"com.jetbrains.intellij.tools:ide-starter-driver:LATEST-EAP-SNAPSHOT\") testImplementation(\"com.jetbrains.intellij.driver:driver-client:LATEST-EAP-SNAPSHOT\") testImplementation(\"com.jetbrains.intellij.driver:driver-sdk:LATEST-EAP-SNAPSHOT\") testImplementation(\"com.jetbrains.intellij.driver:driver-model:LATEST-EAP-SNAPSHOT\") Important notes: Use the same version across all framework libraries to avoid compatibility issues. As the Driver and UI components continue to evolve, we aim to keep the Starter API stable, with occasional breaking changes. Integrating Starter with IntelliJ Platform Gradle Plugin To test your plugin, the Starter framework needs to know where to find your plugin distribution for installation in the IDE. This requires configuring your Gradle test task.  Add the following configuration to your build.gradle.kts: tasks.test { dependsOn(\"buildPlugin\") systemProperty(\"path.to.build.plugin\", tasks.buildPlugin.get().archiveFile.get().asFile.absolutePath) useJUnitPlatform() } This configuration does the following: Makes the test task depend on buildPlugin, ensuring your plugin is built before tests run. Sets the path.to.build.plugin system property to point to your plugin distribution file. Enables JUnit Platform for test execution. Creating the first test Now that we’ve completed the configuration, let’s write our first integration test, which will:  Start the IDE with our plugin installed. Wait for all background processes to complete. Perform a shutdown. Create a new Kotlin file in src/test/kotlin with the following code: class PluginTest { @Test fun simpleTestWithoutProject() { Starter.newContext(testName = \"testExample\", TestCase(IdeProductProvider.IC, projectInfo = NoProject).withVersion(\"2024.3\")).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { } } } Let’s break down each part of the test: 1. Context creation Starter.newContext(testName = \"testExample\", TestCase(IdeProductProvider.IC, projectInfo = NoProject).withVersion(\"2024.3\")) The Context object stores IDE runtime configuration: IDE type (e.g., IntelliJ Community, PhpStorm, GoLand). IDE version (2024.3 in this example). Project configuration (using NoProject for this example). Custom VM options, paths, and SDK settings. The testName parameter defines the folder name for test artifacts, which is useful when running multiple IDE instances in a single test. We’re using IntelliJ IDEA Community Edition version 2024.3, and we’re starting the IDE without any project, so the welcome screen will be shown. 2. Plugin installation .apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) } This step configures plugin installation using the plugin path we defined in our Gradle configuration. Note: PluginConfigurator can install plugins from local paths or Marketplace. 3. IDE life cycle management .runIdeWithDriver().useDriverAndCloseIde { } These two methods: Start the IDE instance (runIdeWithDriver). Shut down the IDE (useDriverAndCloseIde). The empty lambda is used for IDE interactions (useDriverAndCloseIde). Note: When you run the test for the first time, it may take longer than expected since it needs to download the IDE. Subsequent runs will be faster, using the cached IDE version.  Understanding the test architecture You can now run the test and it should pass.  Integration tests operate across two separate processes:  Test process: Executes your test code, sending commands to the IDE.  Manages the IDE life cycle.  Controls test flow and assertions.  IDE process: Listens and executes commands from the test process.  This dual-process architecture explains several key aspects of integration testing:   Why debugging requires special considerations.  The need for a communication protocol between test and IDE processes.  Why a built plugin distribution is required.  The origin of certain test-specific exceptions.  Note: In upcoming blog posts, we’ll explore these aspects in detail, including debugging techniques and handling common scenarios. Opening projects in tests While starting an IDE with an empty project is useful, sometimes we need actual projects to verify real-world scenarios. Let’s modify our test to open a project. The framework supports several ways to specify test projects: GitHub projects: GitHubProject.fromGithub( branchName = \"master\", \"JetBrains/ij-perf-report-aggregator\" ) Remote archives: RemoteArchiveProjectInfo(\"https://github.com/JetBrains/intellij-community/archive/master.zip\") Local projects: LocalProjectInfo(Path(\"src/test/resources/test-projects/simple-project\")) Here’s our test modified to open a GitHub project: @Test fun simpleTest() { Starter.newContext( \"testExample\", TestCase( IdeProductProvider.IC, GitHubProject.fromGithub(branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\") ).withVersion(\"2024.3\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { waitForIndicators(5.minutes) } } While simple, this test verifies a critical aspect: our plugin doesn’t interfere with IDE startup. Note: We added a call waitForIndicators into the lambda to make sure that we wait till all indicators are gone before exiting the IDE. How to catch exceptions from the IDE? Our test has one critical limitation: it won’t detect exceptions or freezes occurring within the IDE process. Let’s understand why and how to fix this.  Due to the two-process architecture: Exceptions in the IDE process aren’t automatically propagated to the test process. A bundled plugin collects exceptions from the IDE’s MessageBus. These exceptions are stored in the error folder within the logs. The Starter framework uses TeamCity reporting by default, falling back to NoCIServer for other environments. However, we can customize this behavior using Kodein Dependency Injection. Here’s how to make tests fail when IDE exceptions occur: init { di = DI { extend(di) bindSingleton\u003cCIServer\u003e(overrides = true) { object : CIServer by NoCIServer { override fun reportTestFailure(testName: String, message: String, details: String, linkToLogs: String?) { fail { \"$testName fails: $message. \\n$details\" } } } } } } How it works We create a custom implementation of CIServer that extends NoCIServer. We override only the reportTestFailure method to fail the test with detailed error information. The Starter framework collects exceptions from the IDE and passes them to our custom implementation. Any IDE exception now causes the test to fail with a descriptive message. This extensibility pattern can be applied to customize other aspects of the Starter framework as needed. Putting it all together Here’s our complete test implementation that forms the foundation for future plugin testing:  import com.intellij.ide.starter.ci.CIServer import com.intellij.ide.starter.ci.NoCIServer import com.intellij.ide.starter.di.di import com.intellij.ide.starter.driver.engine.runIdeWithDriver import com.intellij.ide.starter.ide.IdeProductProvider import com.intellij.ide.starter.models.TestCase import com.intellij.ide.starter.plugins.PluginConfigurator import com.intellij.ide.starter.project.GitHubProject import com.intellij.ide.starter.runner.Starter import org.junit.jupiter.api.Test import org.junit.jupiter.api.fail import org.kodein.di.DI import org.kodein.di.bindSingleton import kotlin.io.path.Path class PluginTest { init { di = DI { extend(di) bindSingleton\u003cCIServer\u003e(overrides = true) { object : CIServer by NoCIServer { override fun reportTestFailure( testName: String, message: String, details: String, linkToLogs: String? ) { fail { \"$testName fails: $message. \\n$details\" } } } } } } @Test fun simpleTest() { val result = Starter.newContext( \"testExample\", TestCase( IdeProductProvider.IC, GitHubProject.fromGithub(branchName = \"master\", repoRelativeUrl = \"JetBrains/ij-perf-report-aggregator\") ).withVersion(\"2024.3\") ).apply { val pathToPlugin = System.getProperty(\"path.to.build.plugin\") PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin)) }.runIdeWithDriver().useDriverAndCloseIde { waitForIndicators(5.minutes) } } } You can find the source code here. This test provides a robust foundation for more elaborate tests by: Downloading and opening a real project. Starting the IDE with your plugin installed. Waiting for all background processes to complete. Monitoring for exceptions and freezes. Performing a shutdown. What’s next? Stay tuned for upcoming blog posts in this series where we’ll cover: UI testing: How to automate interface interactions. API testing: Working with plugin APIs effectively via JMX calls. GitHub Actions: Setting up continuous integration. Common pitfalls: Tips and tricks for stable UI tests. Each post will build upon this foundation, helping you create comprehensive test coverage for your plugin. Subscribe to JetBrains Platform updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/02/mp-social_share_blog_1280x720_en-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/platform/\"\u003e\n                                                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/JetBrains-icon-1.svg\" alt=\"Platform logo\"/\u003e\n                                                                                                                            \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003ePlugin and extension development for JetBrains products. \u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/platform/category/plugin-development/\"\u003eDevelopment\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/marketplace/\"\u003eMarketplace\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/platform/category/plugins/\"\u003ePlugins\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eIntegration Tests for Plugin Developers: Intro, Dependencies, and First Integration Test\u003c/h2\u003e                    \n                    \n\u003cp\u003eFollowing the enthusiastic response to our \u003cem\u003ePlugin Testing: Performance, UI, and Functional Testing\u003c/em\u003e \u003ca href=\"https://youtu.be/UJexzfG01Qo?feature=shared\" data-type=\"link\" data-id=\"https://youtu.be/UJexzfG01Qo?feature=shared\" target=\"_blank\" rel=\"noopener\"\u003esession\u003c/a\u003e at JetBrains Plugin Developer Conf 2024, we’re launching a series of blog posts diving deeper into plugin testing strategies. \u003c/p\u003e\n\n\n\n\u003cp\u003eThis first post will guide you through setting up your testing environment and creating your first integration test, with detailed step-by-step instructions.\u003c/p\u003e\n\n\n\n\u003ch2\u003eIntegration tests\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou might be wondering: “Why do we need integration tests when we already have unit tests? Aren’t unit tests easier to write, maintain, and run?” This is a valid question! \u003c/p\u003e\n\n\n\n\u003cp\u003eWhile the IntelliJ department maintains over 400,000 unit tests, we also rely on approximately 1,000 integration tests. \u003c/p\u003e\n\n\n\n\u003cp\u003eHere’s why they’re essential: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTesting complex scenarios\u003c/strong\u003e: Some scenarios, particularly UI interactions, cannot be effectively covered by unit tests alone. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eFull product testing\u003c/strong\u003e: Integration tests run against the complete product rather than isolated components. This helps identify issues that unit tests might miss, such as module interaction problems, classpath conflicts, and plugin declaration issues.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUser story validation\u003c/strong\u003e: Integration tests typically mirror real user scenarios, ensuring your plugin works reliably from start to finish. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eDespite common perceptions, integration tests aren’t as difficult to create as you might think! Let’s explore how to set them up. \u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: While the following instructions are based on the IntelliJ Platform Gradle Plugin, the general principles also apply to other setups.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eAdding dependencies\u003c/h2\u003e\n\n\n\n\u003cp\u003eOur integration testing framework consists of two main components:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStarter\u003c/strong\u003e: Handles IDE configuration, test project setup, IDE startup, and output collection. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDriver\u003c/strong\u003e: Provides additional functionality we’ll explore in future blog posts.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe Starter framework exclusively supports JUnit 5, as it leverages JUnit 5’s extensions and specialized listeners that aren’t available in JUnit 4.\u003c/p\u003e\n\n\n\n\u003cp\u003eAdd the following dependencies to your \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre\u003edependencies {\n    intellijPlatform {\n        // Starter Framework\n        testFramework(TestFrameworkType.Starter)\n    }\n\n    // JUnit 5\n    testImplementation(\u0026#34;org.junit.jupiter:junit-jupiter:5.10.2\u0026#34;)\n    // Dependency Injection for Starter configuration\n    testImplementation(\u0026#34;org.kodein.di:kodein-di-jvm:7.20.2\u0026#34;)\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003etestFramework\u003c/code\u003e will resolve Starter Framework dependencies automatically, referring to the version of the currently targeted IntelliJ Platform.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you don’t use IntelliJ Platform Gradle Plugin, you will need to add the following libraries to your Gradle file:\u003c/p\u003e\n\n\n\n\u003cpre\u003e// Starter Framework\ntestImplementation(\u0026#34;com.jetbrains.intellij.tools:ide-starter-squashed:LATEST-EAP-SNAPSHOT\u0026#34;)\ntestImplementation(\u0026#34;com.jetbrains.intellij.tools:ide-starter-junit5:LATEST-EAP-SNAPSHOT\u0026#34;)\n\n// Driver Framework\ntestImplementation(\u0026#34;com.jetbrains.intellij.tools:ide-starter-driver:LATEST-EAP-SNAPSHOT\u0026#34;)\ntestImplementation(\u0026#34;com.jetbrains.intellij.driver:driver-client:LATEST-EAP-SNAPSHOT\u0026#34;)\ntestImplementation(\u0026#34;com.jetbrains.intellij.driver:driver-sdk:LATEST-EAP-SNAPSHOT\u0026#34;)\ntestImplementation(\u0026#34;com.jetbrains.intellij.driver:driver-model:LATEST-EAP-SNAPSHOT\u0026#34;)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eImportant notes:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUse the same version across all framework libraries to avoid compatibility issues.\u003c/li\u003e\n\n\n\n\u003cli\u003eAs the Driver and UI components continue to evolve, we aim to keep the Starter API stable, with occasional breaking changes.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eIntegrating Starter with IntelliJ Platform Gradle Plugin\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo test your plugin, the Starter framework needs to know where to find your plugin distribution for installation in the IDE. This requires configuring your Gradle test task. \u003c/p\u003e\n\n\n\n\u003cp\u003eAdd the following configuration to your \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre\u003etasks.test {\n    dependsOn(\u0026#34;buildPlugin\u0026#34;)\n    systemProperty(\u0026#34;path.to.build.plugin\u0026#34;, tasks.buildPlugin.get().archiveFile.get().asFile.absolutePath)\n    useJUnitPlatform()\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis configuration does the following:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eMakes the test task depend on \u003ccode\u003ebuildPlugin\u003c/code\u003e, ensuring your plugin is built before tests run.\u003c/li\u003e\n\n\n\n\u003cli\u003eSets the \u003ccode\u003epath.to.build.plugin\u003c/code\u003e system property to point to your plugin distribution file.\u003c/li\u003e\n\n\n\n\u003cli\u003eEnables JUnit Platform for test execution.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eCreating the first test\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we’ve completed the configuration, let’s write our first integration test, which will: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eStart the IDE with our plugin installed.\u003c/li\u003e\n\n\n\n\u003cli\u003eWait for all background processes to complete.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerform a shutdown.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCreate a new Kotlin file in \u003cem\u003esrc/test/kotlin\u003c/em\u003e with the following code:\u003c/p\u003e\n\n\n\n\u003cpre\u003eclass PluginTest {\n   @Test\n   fun simpleTestWithoutProject() {\n       Starter.newContext(testName = \u0026#34;testExample\u0026#34;, TestCase(IdeProductProvider.IC, projectInfo = NoProject).withVersion(\u0026#34;2024.3\u0026#34;)).apply {\n           val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n           PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n       }.runIdeWithDriver().useDriverAndCloseIde {\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s break down each part of the test:\u003c/p\u003e\n\n\n\n\u003ch3\u003e1. Context creation\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eStarter.newContext(testName = \u0026#34;testExample\u0026#34;, TestCase(IdeProductProvider.IC, projectInfo = NoProject).withVersion(\u0026#34;2024.3\u0026#34;))\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Context object stores IDE runtime configuration:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIDE type (e.g., IntelliJ Community, PhpStorm, GoLand).\u003c/li\u003e\n\n\n\n\u003cli\u003eIDE version (2024.3 in this example).\u003c/li\u003e\n\n\n\n\u003cli\u003eProject configuration (using \u003ccode\u003eNoProject \u003c/code\u003efor this example).\u003c/li\u003e\n\n\n\n\u003cli\u003eCustom VM options, paths, and SDK settings.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003etestName\u003c/code\u003e parameter defines the folder name for test artifacts, which is useful when running multiple IDE instances in a single test. We’re using IntelliJ IDEA Community Edition version 2024.3, and we’re starting the IDE without any project, so the welcome screen will be shown.\u003c/p\u003e\n\n\n\n\u003ch3\u003e2. Plugin installation\u003c/h3\u003e\n\n\n\n\u003cpre\u003e.apply {\n    val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n    PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis step configures plugin installation using the plugin path we defined in our Gradle configuration.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: \u003c/em\u003e\u003ccode\u003e\u003cem\u003ePluginConfigurator\u003c/em\u003e\u003c/code\u003e \u003cem\u003ecan install plugins from local paths or Marketplace.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch3\u003e3. IDE life cycle management\u003c/h3\u003e\n\n\n\n\u003cpre\u003e.runIdeWithDriver().useDriverAndCloseIde {\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThese two methods:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eStart the IDE instance (\u003ccode\u003erunIdeWithDriver\u003c/code\u003e).\u003c/li\u003e\n\n\n\n\u003cli\u003eShut down the IDE (\u003ccode\u003euseDriverAndCloseIde\u003c/code\u003e\u003cem\u003e).\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe empty lambda is used for IDE interactions (\u003ccode\u003euseDriverAndCloseIde\u003c/code\u003e\u003cem\u003e).\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: When you run the test for the first time, it may take longer than expected since it needs to download the IDE. Subsequent runs will be faster, using the cached IDE version. \u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eUnderstanding the test architecture\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou can now run the test and it should pass. \u003c/p\u003e\n\n\n\n\u003cp\u003eIntegration tests operate across two separate processes: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTest process\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eExecutes your test code, sending commands to the IDE. \u003c/li\u003e\n\n\n\n\u003cli\u003eManages the IDE life cycle. \u003c/li\u003e\n\n\n\n\u003cli\u003eControls test flow and assertions. \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eIDE process\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eListens and executes commands from the test process. \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis dual-process architecture explains several key aspects of integration testing:  \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWhy debugging requires special considerations. \u003c/li\u003e\n\n\n\n\u003cli\u003eThe need for a communication protocol between test and IDE processes. \u003c/li\u003e\n\n\n\n\u003cli\u003eWhy a built plugin distribution is required. \u003c/li\u003e\n\n\n\n\u003cli\u003eThe origin of certain test-specific exceptions. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: In upcoming blog posts, we’ll explore these aspects in detail, including debugging techniques and handling common scenarios.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eOpening projects in tests\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile starting an IDE with an empty project is useful, sometimes we need actual projects to verify real-world scenarios. Let’s modify our test to open a project.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe framework supports several ways to specify test projects:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub projects: \u003c/strong\u003e\u003ccode\u003eGitHubProject.fromGithub( branchName = \u0026#34;master\u0026#34;, \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34; )\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eRemote archives: \u003c/strong\u003e\u003ccode\u003eRemoteArchiveProjectInfo(\u0026#34;\u003ca href=\"https://github.com/JetBrains/intellij-community/archive/master.zip\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/JetBrains/intellij-community/archive/master.zip\u003c/a\u003e\u0026#34;)\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eLocal projects: \u003c/strong\u003e\u003ccode\u003eLocalProjectInfo(Path(\u0026#34;src/test/resources/test-projects/simple-project\u0026#34;))\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eHere’s our test modified to open a GitHub project:\u003c/p\u003e\n\n\n\n\u003cpre\u003e@Test\nfun simpleTest() {\n   Starter.newContext(\n       \u0026#34;testExample\u0026#34;,\n       TestCase(\n           IdeProductProvider.IC,\n           GitHubProject.fromGithub(branchName = \u0026#34;master\u0026#34;, repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;)\n       ).withVersion(\u0026#34;2024.3\u0026#34;)\n   ).apply {\n       val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n       PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n   }.runIdeWithDriver().useDriverAndCloseIde {\n       waitForIndicators(5.minutes)\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile simple, this test verifies a critical aspect: our plugin doesn’t interfere with IDE startup.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: We added a call \u003ccode\u003ewaitForIndicators\u003c/code\u003e into the lambda to make sure that we wait till all indicators are gone before exiting the IDE.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow to catch exceptions from the IDE?\u003c/h2\u003e\n\n\n\n\u003cp\u003eOur test has one critical limitation: it won’t detect exceptions or freezes occurring within the IDE process. Let’s understand why and how to fix this. \u003c/p\u003e\n\n\n\n\u003cp\u003eDue to the two-process architecture:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eExceptions in the IDE process aren’t automatically propagated to the test process.\u003c/li\u003e\n\n\n\n\u003cli\u003eA bundled plugin collects exceptions from the IDE’s MessageBus.\u003c/li\u003e\n\n\n\n\u003cli\u003eThese exceptions are stored in the \u003cem\u003eerror\u003c/em\u003e folder within the logs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe Starter framework uses TeamCity reporting by default, falling back to \u003ccode\u003eNoCIServer\u003c/code\u003e for other environments. However, we can customize this behavior using Kodein Dependency Injection. Here’s how to make tests fail when IDE exceptions occur:\u003c/p\u003e\n\n\n\n\u003cpre\u003einit {\n   di = DI {\n       extend(di)\n       bindSingleton\u0026lt;CIServer\u0026gt;(overrides = true) {\n           object : CIServer by NoCIServer {\n               override fun reportTestFailure(testName: String, message: String, details: String, linkToLogs: String?) {\n                   fail { \u0026#34;$testName fails: $message. \\n$details\u0026#34; }\n               }\n           }\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eHow it works\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe create a custom implementation of \u003ccode\u003eCIServer\u003c/code\u003e that extends \u003ccode\u003eNoCIServer\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe override only the \u003ccode\u003ereportTestFailure\u003c/code\u003e method to fail the test with detailed error information.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe Starter framework collects exceptions from the IDE and passes them to our custom implementation.\u003c/li\u003e\n\n\n\n\u003cli\u003eAny IDE exception now causes the test to fail with a descriptive message.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis extensibility pattern can be applied to customize other aspects of the Starter framework as needed.\u003c/p\u003e\n\n\n\n\u003ch2\u003ePutting it all together\u003c/h2\u003e\n\n\n\n\u003cp\u003eHere’s our complete test implementation that forms the foundation for future plugin testing: \u003c/p\u003e\n\n\n\n\u003cpre\u003eimport com.intellij.ide.starter.ci.CIServer\nimport com.intellij.ide.starter.ci.NoCIServer\nimport com.intellij.ide.starter.di.di\nimport com.intellij.ide.starter.driver.engine.runIdeWithDriver\nimport com.intellij.ide.starter.ide.IdeProductProvider\nimport com.intellij.ide.starter.models.TestCase\nimport com.intellij.ide.starter.plugins.PluginConfigurator\nimport com.intellij.ide.starter.project.GitHubProject\nimport com.intellij.ide.starter.runner.Starter\nimport org.junit.jupiter.api.Test\nimport org.junit.jupiter.api.fail\nimport org.kodein.di.DI\nimport org.kodein.di.bindSingleton\nimport kotlin.io.path.Path\n\nclass PluginTest {\n   init {\n       di = DI {\n           extend(di)\n           bindSingleton\u0026lt;CIServer\u0026gt;(overrides = true) {\n               object : CIServer by NoCIServer {\n                   override fun reportTestFailure(\n                       testName: String,\n                       message: String,\n                       details: String,\n                       linkToLogs: String?\n                   ) {\n                       fail { \u0026#34;$testName fails: $message. \\n$details\u0026#34; }\n                   }\n               }\n           }\n       }\n   }\n\n   @Test\n   fun simpleTest() {\n       val result = Starter.newContext(\n           \u0026#34;testExample\u0026#34;,\n           TestCase(\n               IdeProductProvider.IC,\n               GitHubProject.fromGithub(branchName = \u0026#34;master\u0026#34;, repoRelativeUrl = \u0026#34;JetBrains/ij-perf-report-aggregator\u0026#34;)\n           ).withVersion(\u0026#34;2024.3\u0026#34;)\n       ).apply {\n           val pathToPlugin = System.getProperty(\u0026#34;path.to.build.plugin\u0026#34;)\n           PluginConfigurator(this).installPluginFromPath(Path(pathToPlugin))\n       }.runIdeWithDriver().useDriverAndCloseIde {\n           waitForIndicators(5.minutes)\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can find the source code \u003ca href=\"https://github.com/MaXal/IntelliJ-Platform-Gradle-Plugin-and-Starter-Demo/blob/blog-part1/src/test/kotlin/PluginTest.kt\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis test provides a robust foundation for more elaborate tests by:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDownloading and opening a real project.\u003c/li\u003e\n\n\n\n\u003cli\u003eStarting the IDE with your plugin installed.\u003c/li\u003e\n\n\n\n\u003cli\u003eWaiting for all background processes to complete.\u003c/li\u003e\n\n\n\n\u003cli\u003eMonitoring for exceptions and freezes.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerforming a shutdown.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eWhat’s next?\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eStay tuned for upcoming blog posts in this series where we’ll cover:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUI testing: How to automate interface interactions.\u003c/li\u003e\n\n\n\n\u003cli\u003eAPI testing: Working with plugin APIs effectively via JMX calls.\u003c/li\u003e\n\n\n\n\u003cli\u003eGitHub Actions: Setting up continuous integration.\u003c/li\u003e\n\n\n\n\u003cli\u003eCommon pitfalls: Tips and tricks for stable UI tests.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eEach post will build upon this foundation, helping you create comprehensive test coverage for your plugin.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to JetBrains Platform updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
