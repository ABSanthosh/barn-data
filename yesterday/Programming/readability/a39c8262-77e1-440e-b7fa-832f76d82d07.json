{
  "id": "a39c8262-77e1-440e-b7fa-832f76d82d07",
  "title": "Go 1.24 Brings Generic Type Aliases, Weak Pointers, Improved Finalizers, and More",
  "link": "https://www.infoq.com/news/2025/02/go-1-24-generic-aliases/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "The latest release of the Go language, Go 1.24, introduces several important features, including generic type aliases, weak pointers, improved cleanup finalizers, and more. It also enhances runtime performance in map default implementation, small object allocation, and mutexes handling. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Mon, 24 Feb 2025 16:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "System Programming",
    "Cloud",
    "Programming Languages",
    "Imperative Programming",
    "Go Language",
    "Development",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 3465,
  "excerpt": "The latest release of the Go language, Go 1.24, introduces several important features, including generic type aliases, weak pointers, improved cleanup finalizers, and more. It also enhances runtime pe",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20250213201535/apple-touch-icon.png",
  "text": "The latest release of the Go language, Go 1.24, introduces several important features, including generic type aliases, weak pointers, improved cleanup finalizers, and more. It also enhances runtime performance in map default implementation, small object allocation, and mutexes handling. A type alias in Go provides a synonym for an existing type, which can be useful for readability and conciseness. Now, Go 1.24 allows creating type aliases for generic types, that is, a type alias can specify a type parameter. type ComparableVector[T comparable] = Vector[T] type ComparableVectorOfInts = ComparableVector[int] type ThisWouldBeAnError = ComparableVector[[]int] It's worth recalling here that Go provides a similar syntax for defining a new type based on an existing type, e.g. type NewInt int. Albeit the syntax only differs in the missing =, the implications are great since NewInt cannot be used in place of int. Interestingly, the discussion about whether introducing generic type aliases and their implications on the language has been going on for over three years. Weak pointers do not increase the reference count of an object, so when an object is referenced only by weak pointers, the garbage collector can free it. As a consequence, you should check a weak pointer is not nil before attempting to use its value: var strongInt int = 5 var weakInt *int weakInt = \u0026strongInt ... weakInt.Value() Weak pointers may be useful when you want to implement, for example, an object cache to avoid objects being retained for the mere fact of being included in the cache. Go finalizers serve the purpose of cleaning up things when an object is garbage collected. Prior to Go 1.24, this could be accomplished using [runtime.SetFinalizer](https://tip.golang.org/pkg/runtime#SetFinalizer), which has several caveats, including the impossibility of defining more than one finalizer on the same object, the fact that finalizers will not work on objects involved in a reference cycle, and so on. To overcome these limitations, Go 1.24 provides a new runtime function, AddCleanup, which can be used to register a cleanup function with an object: runtime.AddCleanup(objPointer, cleanupFunc, resourceToCleanUp) ... func cleanupFunc(resourceToCleanUp CleanUpArgType) { ... } The cleanup mechanism fixes the issues with finalizers mentioned above. Additionally, it ensures all cleanup functions are called sequentially in a separate goroutine. As mentioned, Go 1.24 improves the runtime performance of maps. In particular, it adopts SwissTable as a base for map implementation and uses a concurrent hash-trie for the implementation of sync.Map. Using SwissTable brings 30% faster access and assignment of large maps, 35% faster assignment on pre-sized maps, and 10-60% faster iteration depending on the number and size of items in the map. Similarly, adopting a concurrent hash-trie enables the new sync.Map implementation to beat the old one on almost every benchmark. Go 1.24 includes many more improvements and changes than what can be covered here, including new functions in bytes and strings packages, omitzero json tag, directory-limited filesystem access, etc. While the release notes are as usual quite terse you can find great video summaries on Reddit user GreenTowel3732's YouTube channel. About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2025/02/go-1-24-generic-aliases/en/headerimage/go-1-19-released-1740409282804.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eThe \u003ca href=\"https://go.dev/blog/go1.24\"\u003elatest release of the Go language, Go 1.24\u003c/a\u003e, introduces several important features, including generic type aliases, weak pointers, improved cleanup finalizers, and more. It also enhances runtime performance in \u003ccode\u003emap\u003c/code\u003e default implementation, small object allocation, and mutexes handling.\u003c/p\u003e\n\n\u003cp\u003eA type alias in Go provides a synonym for an existing type, which can be useful for readability and conciseness. Now, Go 1.24 allows creating type aliases for generic types, that is, \u003ca href=\"https://go.dev/ref/spec#Alias_declarations\"\u003ea type alias can specify a type parameter\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etype ComparableVector[T comparable] = Vector[T]\ntype ComparableVectorOfInts = ComparableVector[int]\ntype ThisWouldBeAnError = ComparableVector[[]int]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt\u0026#39;s worth recalling here that Go provides a similar syntax for defining a new type based on an existing type, e.g. \u003ccode\u003etype NewInt int\u003c/code\u003e. Albeit the syntax only differs in the missing \u003ccode\u003e=\u003c/code\u003e, the implications are great since \u003ccode\u003eNewInt\u003c/code\u003e cannot be used in place of \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eInterestingly, the \u003ca href=\"https://go.dev/issue/46477\"\u003ediscussion about whether introducing generic type aliases and their implications on the language has been going on for over three years\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eWeak pointers do not increase the reference count of an object, so when an object is referenced only by weak pointers, the garbage collector can free it. As a consequence, you should check a weak pointer is not \u003ccode\u003enil\u003c/code\u003e before attempting to use its value:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evar strongInt int = 5\nvar weakInt *int\nweakInt = \u0026amp;strongInt\n...\nweakInt.Value()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWeak pointers may be useful when you want to implement, for example, an object cache to avoid objects being retained for the mere fact of being included in the cache.\u003c/p\u003e\n\n\u003cp\u003eGo finalizers serve the purpose of cleaning up things when an object is garbage collected. Prior to Go 1.24, this could be accomplished using \u003ccode\u003e[runtime.SetFinalizer](https://tip.golang.org/pkg/runtime#SetFinalizer)\u003c/code\u003e, which has several caveats, including the impossibility of defining more than one finalizer on the same object, the fact that finalizers will not work on objects involved in a reference cycle, and so on. To overcome these limitations, Go 1.24 provides a new runtime function, \u003ca href=\"https://github.com/golang/go/issues/67535\"\u003e\u003ccode\u003eAddCleanup\u003c/code\u003e\u003c/a\u003e, which can be used to register a cleanup function with an object:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eruntime.AddCleanup(objPointer, cleanupFunc, resourceToCleanUp)\n...\nfunc cleanupFunc(resourceToCleanUp CleanUpArgType) {\n ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe cleanup mechanism fixes the issues with finalizers mentioned above. Additionally, it ensures all cleanup functions are called sequentially in a separate goroutine.\u003c/p\u003e\n\n\u003cp\u003eAs mentioned, Go 1.24 improves the runtime performance of maps. In particular, it adopts \u003ca href=\"https://abseil.io/about/design/swisstables\"\u003eSwissTable\u003c/a\u003e as a base for \u003ccode\u003emap\u003c/code\u003e implementation and uses a concurrent hash-trie for the implementation of \u003ccode\u003esync.Map\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://go.dev/issue/54766\"\u003eUsing SwissTable\u003c/a\u003e brings 30% faster access and assignment of large maps, 35% faster assignment on pre-sized maps, and 10-60% faster iteration depending on the number and size of items in the map.\u003c/p\u003e\n\n\u003cp\u003eSimilarly, adopting a concurrent hash-trie enables the new \u003ccode\u003esync.Map\u003c/code\u003e implementation to beat the old one on \u003ca href=\"https://github.com/golang/go/issues/70683\"\u003ealmost every benchmark\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eGo 1.24 includes many more improvements and changes than what can be covered here, including new functions in bytes and strings packages, omitzero json tag, directory-limited filesystem access, etc. While the release notes are as usual quite terse you can find great video \u003ca href=\"https://youtu.be/kcNZ-iLXroA\"\u003esummaries\u003c/a\u003e on Reddit user GreenTowel3732\u0026#39;s YouTube channel.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-02-24T00:00:00Z",
  "modifiedTime": null
}
