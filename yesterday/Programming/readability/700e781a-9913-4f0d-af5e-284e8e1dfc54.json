{
  "id": "700e781a-9913-4f0d-af5e-284e8e1dfc54",
  "title": "Emulating SQL FILTER with Oracle JSON Aggregate Functions",
  "link": "https://blog.jooq.org/emulating-sql-filter-with-oracle-json-aggregate-functions/",
  "description": "A cool standard SQL:2003 feature is the aggregate FILTER clause, which is supported natively by at least these RDBMS: The following aggregate function computes the number of rows per group which satifsy the FILTER clause: This is useful for pivot style queries, where multiple aggregate values are computed in one go. For most basic types … Continue reading Emulating SQL FILTER with Oracle JSON Aggregate Functions →",
  "author": "lukaseder",
  "published": "Mon, 03 Jun 2024 12:17:41 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "aggregate functions",
    "FILTER",
    "FILTER clause",
    "JSON",
    "JSON aggregate functions",
    "JSON_ARRAYAGG",
    "JSON_OBJECTAGG",
    "Oracle",
    "SQL/JSON"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 4253,
  "excerpt": "Oracle 23ai still doesn't support the standard SQL FILTER clause on aggregate functions, which can prove to be tricky to emulate on JSON aggregate functions",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "A cool standard SQL:2003 feature is the aggregate FILTER clause, which is supported natively by at least these RDBMS: ClickHouse CockroachDB DuckDB Firebird H2 HSQLDB PostgreSQL SQLite Trino YugabyteDB The following aggregate function computes the number of rows per group which satifsy the FILTER clause: SELECT COUNT(*) FILTER (WHERE BOOK.TITLE LIKE 'A%'), COUNT(*) FILTER (WHERE BOOK.TITLE LIKE 'B%'), ... FROM BOOK This is useful for pivot style queries, where multiple aggregate values are computed in one go. For most basic types of aggregate function, it can be emulated simply by using CASE expressions, because standard aggregate functions ignore NULL values when aggregating. The following is equivalent to the above, in all RDBMS: SELECT COUNT(CASE WHEN BOOK.TITLE LIKE 'A%' THEN 1 END), COUNT(CASE WHEN BOOK.TITLE LIKE 'B%' THEN 1 END), ... FROM BOOK What if we’re aggregating JSON? Things are a bit different when aggregating JSON. Look at the following example, where we don’t want to count the books, but list them in a JSON array, or object: SELECT JSON_ARRAYAGG(BOOK.TITLE) FILTER (WHERE BOOK.LANGUAGE_ID = 1), JSON_OBJECTAGG('id-' || BOOK.ID, BOOK.TITLE) FILTER (WHERE BOOK.LANGUAGE_ID = 2), ... FROM BOOK Things are different with these collection aggregate functions, because NULL values are actually interesting there, so we want to list them in the resulting JSON document. Assuming there are books with a NULL title, we might get: |JSON_ARRAYAGG |JSON_OBJECTAGG ||-----------------------------|------------------------------------||[\"1984\", \"Animal Farm\", null]|{ \"id-4\" : \"Brida\", \"id-17\" : null }| This makes emulating the FILTER clause (e.g. on Oracle) much harder, because we cannot just use ABSENT ON NULL like this: SELECT JSON_ARRAYAGG( CASE WHEN T_BOOK.LANGUAGE_ID = 1 THEN T_BOOK.TITLE END ABSENT ON NULL ), JSON_OBJECTAGG( 'id-' || T_BOOK.ID, CASE WHEN T_BOOK.LANGUAGE_ID = 2 THEN T_BOOK.TITLE END ABSENT ON NULL ) FROM T_BOOK; Because now, the legitimate null titled books are missing and we’re getting this instead: |JSON_ARRAYAGG |JSON_OBJECTAGG ||----------------------|----------------||[\"1984\",\"Animal Farm\"]|{\"id-4\":\"Brida\"}| We cannot use NULL ON NULL either, because that would just turn the FILTER semantics into a mapping semantics, and produce too many values: |JSON_ARRAYAGG |JSON_OBJECTAGG ||-------------------------------------|-----------------------------------------------------------------||[\"1984\",\"Animal Farm\",null,null,null]|{\"id-1\":null,\"id-4\":\"Brida\",\"id-3\":null,\"id-2\":null,\"id-17\":null}| E.g. while id-3 and id-2 values are NULL because the FILTER emulating CASE expression maps them to NULL, the id-17 value really has a NULL title. Workaround: Wrap data in an array As a workaround, we can: Wrap legitimate data into an array Apply ABSENT ON NULL to remove rows due to the FILTER emulation Unwrap data again from the array For the unwrapping, we’re going to be using JSON_TRANSFORM: SELECT JSON_TRANSFORM( JSON_ARRAYAGG( CASE WHEN T_BOOK.LANGUAGE_ID = 1 -- Wrap legitimate data into an array, including nulls THEN JSON_ARRAY(T_BOOK.TITLE NULL ON NULL) END -- Remove NULLs due to FILTER emulation ABSENT ON NULL ), -- Unwrap data gain from the array NESTED PATH '$[*]' (REPLACE '@' = PATH '@[0]') ), JSON_TRANSFORM( JSON_OBJECTAGG( 'id-' || T_BOOK.ID, CASE WHEN T_BOOK.LANGUAGE_ID = 2 -- Wrap legitimate data into an array, including nulls THEN JSON_ARRAY(T_BOOK.TITLE NULL ON NULL) END -- Remove NULLs due to FILTER emulation ABSENT ON NULL ), -- Unwrap data gain from the array NESTED PATH '$.*' (REPLACE '@' = PATH '@[0]') ) FROM T_BOOK; jOOQ support jOOQ 3.20 will implement the above emulations for: #12073: JSON_ARRAYAGG #16751: JSON_OBJECTAGG This way, you can continue to transparently use FILTER on any aggregate function, also in Oracle.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12635\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eA cool standard SQL:2003 feature is the \u003ca href=\"https://blog.jooq.org/the-awesome-postgresql-9-4-sql2003-filter-clause-for-aggregate-functions/\" data-type=\"post\" data-id=\"4852\"\u003eaggregate \u003ccode\u003eFILTER\u003c/code\u003e clause\u003c/a\u003e, which is supported natively by at least these RDBMS:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eClickHouse\u003c/li\u003e\n\n\n\n\u003cli\u003eCockroachDB\u003c/li\u003e\n\n\n\n\u003cli\u003eDuckDB\u003c/li\u003e\n\n\n\n\u003cli\u003eFirebird\u003c/li\u003e\n\n\n\n\u003cli\u003eH2\u003c/li\u003e\n\n\n\n\u003cli\u003eHSQLDB\u003c/li\u003e\n\n\n\n\u003cli\u003ePostgreSQL\u003c/li\u003e\n\n\n\n\u003cli\u003eSQLite\u003c/li\u003e\n\n\n\n\u003cli\u003eTrino\u003c/li\u003e\n\n\n\n\u003cli\u003eYugabyteDB\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe following aggregate function computes the number of rows per group which satifsy the \u003ccode\u003eFILTER\u003c/code\u003e clause:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  COUNT(*) FILTER (WHERE BOOK.TITLE LIKE \u0026#39;A%\u0026#39;),\n  COUNT(*) FILTER (WHERE BOOK.TITLE LIKE \u0026#39;B%\u0026#39;),\n  ...\nFROM BOOK\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis is useful for \u003ca href=\"https://blog.jooq.org/are-you-using-sql-pivot-yet-you-should/\" data-type=\"post\" data-id=\"4318\"\u003epivot style queries\u003c/a\u003e, where \u003ca href=\"https://blog.jooq.org/how-to-calculate-multiple-aggregate-functions-in-a-single-query/\" data-type=\"post\" data-id=\"6908\"\u003emultiple aggregate values are computed in one go\u003c/a\u003e. For most basic types of aggregate function, it can be emulated simply by using \u003ccode\u003eCASE\u003c/code\u003e expressions, because standard aggregate functions ignore \u003ccode\u003eNULL\u003c/code\u003e values when aggregating. The following is equivalent to the above, in all RDBMS:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  COUNT(CASE WHEN BOOK.TITLE LIKE \u0026#39;A%\u0026#39; THEN 1 END),\n  COUNT(CASE WHEN BOOK.TITLE LIKE \u0026#39;B%\u0026#39; THEN 1 END),\n  ...\nFROM BOOK\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003eWhat if we’re aggregating JSON?\u003c/h3\u003e\n\n\n\n\u003cp\u003eThings are a bit different when aggregating JSON. Look at the following example, where we don’t want to count the books, but list them in a JSON array, or object:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  JSON_ARRAYAGG(BOOK.TITLE)\n    FILTER (WHERE BOOK.LANGUAGE_ID = 1),\n  JSON_OBJECTAGG(\u0026#39;id-\u0026#39; || BOOK.ID, BOOK.TITLE)\n    FILTER (WHERE BOOK.LANGUAGE_ID = 2),\n  ...\nFROM BOOK\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThings are different with these collection aggregate functions, because \u003ccode\u003eNULL\u003c/code\u003e values are actually interesting there, so we want to list them in the resulting JSON document. Assuming there are books with a \u003ccode\u003eNULL\u003c/code\u003e title, we might get:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|JSON_ARRAYAGG                |JSON_OBJECTAGG                      |\u003cbr/\u003e|-----------------------------|------------------------------------|\u003cbr/\u003e|[\u0026#34;1984\u0026#34;, \u0026#34;Animal Farm\u0026#34;, null]|{ \u0026#34;id-4\u0026#34; : \u0026#34;Brida\u0026#34;, \u0026#34;id-17\u0026#34; : null }|\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis makes emulating the \u003ccode\u003eFILTER\u003c/code\u003e clause (e.g. on Oracle) much harder, because we cannot just use \u003ccode\u003eABSENT ON NULL\u003c/code\u003e like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  JSON_ARRAYAGG(\n    CASE WHEN T_BOOK.LANGUAGE_ID = 1 THEN T_BOOK.TITLE END \n    ABSENT ON NULL\n  ),\n  JSON_OBJECTAGG(\n    \u0026#39;id-\u0026#39; || T_BOOK.ID, \n    CASE WHEN T_BOOK.LANGUAGE_ID = 2 THEN T_BOOK.TITLE END\n    ABSENT ON NULL\n  )\nFROM T_BOOK;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBecause now, the legitimate \u003ccode\u003enull\u003c/code\u003e titled books are missing and we’re getting this instead:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|JSON_ARRAYAGG         |JSON_OBJECTAGG  |\u003cbr/\u003e|----------------------|----------------|\u003cbr/\u003e|[\u0026#34;1984\u0026#34;,\u0026#34;Animal Farm\u0026#34;]|{\u0026#34;id-4\u0026#34;:\u0026#34;Brida\u0026#34;}|\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe cannot use \u003ccode\u003eNULL ON NULL\u003c/code\u003e either, because that would just turn the \u003ccode\u003eFILTER\u003c/code\u003e semantics into a mapping semantics, and produce too many values:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|JSON_ARRAYAGG                        |JSON_OBJECTAGG                                                   |\u003cbr/\u003e|-------------------------------------|-----------------------------------------------------------------|\u003cbr/\u003e|[\u0026#34;1984\u0026#34;,\u0026#34;Animal Farm\u0026#34;,null,null,null]|{\u0026#34;id-1\u0026#34;:null,\u0026#34;id-4\u0026#34;:\u0026#34;Brida\u0026#34;,\u0026#34;id-3\u0026#34;:null,\u0026#34;id-2\u0026#34;:null,\u0026#34;id-17\u0026#34;:null}|\u003c/pre\u003e\n\n\n\n\u003cp\u003eE.g. while \u003ccode\u003eid-3\u003c/code\u003e and \u003ccode\u003eid-2\u003c/code\u003e values are \u003ccode\u003eNULL\u003c/code\u003e because the \u003ccode\u003eFILTER\u003c/code\u003e emulating \u003ccode\u003eCASE\u003c/code\u003e expression maps them to \u003ccode\u003eNULL\u003c/code\u003e, the \u003ccode\u003eid-17\u003c/code\u003e value really has a \u003ccode\u003eNULL\u003c/code\u003e title.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWorkaround: Wrap data in an array\u003c/h3\u003e\n\n\n\n\u003cp\u003eAs a workaround, we can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWrap legitimate data into an array\u003c/li\u003e\n\n\n\n\u003cli\u003eApply \u003ccode\u003eABSENT ON NULL\u003c/code\u003e to remove rows due to the \u003ccode\u003eFILTER\u003c/code\u003e emulation\u003c/li\u003e\n\n\n\n\u003cli\u003eUnwrap data again from the array\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor the unwrapping, we’re going to be using \u003ccode\u003e\u003ca href=\"https://oracle-base.com/articles/23/json_transform-enhancements-23\" data-type=\"link\" data-id=\"https://oracle-base.com/articles/23/json_transform-enhancements-23\"\u003eJSON_TRANSFORM\u003c/a\u003e\u003c/code\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  JSON_TRANSFORM(\n    JSON_ARRAYAGG(\n      CASE \n        WHEN T_BOOK.LANGUAGE_ID = 1 \n\n        -- Wrap legitimate data into an array, including nulls\n        THEN JSON_ARRAY(T_BOOK.TITLE NULL ON NULL)\n      END \n\n      -- Remove NULLs due to FILTER emulation\n      ABSENT ON NULL\n    ),\n\n    -- Unwrap data gain from the array\n    NESTED PATH \u0026#39;$[*]\u0026#39; (REPLACE \u0026#39;@\u0026#39; = PATH \u0026#39;@[0]\u0026#39;)\n  ),\n\n  JSON_TRANSFORM(\n    JSON_OBJECTAGG(\n      \u0026#39;id-\u0026#39; || T_BOOK.ID, \n      CASE \n        WHEN T_BOOK.LANGUAGE_ID = 2 \n\n        -- Wrap legitimate data into an array, including nulls\n        THEN JSON_ARRAY(T_BOOK.TITLE NULL ON NULL)\n      END\n\n      -- Remove NULLs due to FILTER emulation\n      ABSENT ON NULL\n    ),\n\n    -- Unwrap data gain from the array\n    NESTED PATH \u0026#39;$.*\u0026#39; (REPLACE \u0026#39;@\u0026#39; = PATH \u0026#39;@[0]\u0026#39;)\n  )\nFROM T_BOOK;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003ejOOQ support\u003c/h3\u003e\n\n\n\n\u003cp\u003ejOOQ 3.20 will implement the above emulations for:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jOOQ/jOOQ/issues/12073\" data-type=\"link\" data-id=\"https://github.com/jOOQ/jOOQ/issues/12073\"\u003e#12073\u003c/a\u003e: \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/aggregate-functions/json-arrayagg-function/\" data-type=\"link\" data-id=\"https://github.com/jOOQ/jOOQ/issues/12073\"\u003eJSON_ARRAYAGG\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/jOOQ/jOOQ/issues/16751\" data-type=\"link\" data-id=\"https://github.com/jOOQ/jOOQ/issues/16751\"\u003e#16751\u003c/a\u003e: \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/aggregate-functions/json-objectagg-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/aggregate-functions/json-objectagg-function/\"\u003eJSON_OBJECTAGG\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis way, you can continue to transparently use \u003ccode\u003eFILTER\u003c/code\u003e on any aggregate function, also in Oracle.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-06-03T12:17:41Z",
  "modifiedTime": "2024-06-03T12:17:41Z"
}
