{
  "id": "e43b5e56-9fe9-4567-9d11-f0b969c351fc",
  "title": "Translating Java to Kotlin at Scale",
  "link": "https://engineering.fb.com/2024/12/18/android/translating-java-to-kotlin-at-scale/",
  "description": "Meta has been on a years-long undertaking to translate our entire Android codebase from Java to Kotlin. Today, despite having one of the largest Android codebases in the world, we’re well past the halfway point and still going. We’re sharing some of the tradeoffs we’ve made to support automating our transition to Kotlin, seemingly simple [...] Read More... The post Translating Java to Kotlin at Scale appeared first on Engineering at Meta.",
  "author": "",
  "published": "Wed, 18 Dec 2024 17:00:18 +0000",
  "source": "https://engineering.fb.com/feed/",
  "categories": [
    "Android",
    "DevInfra"
  ],
  "byline": "By Jocelyn Luizzi, Jingbo Yang, Eve Matthaey",
  "length": 18867,
  "excerpt": "Meta has been on a years-long undertaking to translate our entire Android codebase from Java to Kotlin. Today, despite having one of the largest Android codebases in the world, we’re well pas…",
  "siteName": "Engineering at Meta",
  "favicon": "",
  "text": "Meta has been on a years-long undertaking to translate our entire Android codebase from Java to Kotlin. Today, despite having one of the largest Android codebases in the world, we’re well past the halfway point and still going. We’re sharing some of the tradeoffs we’ve made to support automating our transition to Kotlin, seemingly simple transformations that are surprisingly tricky, and how we’re collaborating with other companies to capture hundreds more corner cases. Android development at Meta has been Kotlin-first since 2020, and developers have been saying they prefer Kotlin as a language for even longer. But, adoption doesn’t necessarily entail translation. We could simply decide to write all new code in Kotlin and leave our existing Java code as is, just as many other companies have. Or we could take it a little further and translate just the most important files. Instead, we decided that the only way to leverage the full value of Kotlin was to go all in on conversion, even if it meant building our own infrastructure to automate translation at scale. So, a few years ago, engineers at Meta decided to take roughly ten million lines of perfectly good Java code and rewrite them in Kotlin. Of course, we had to solve problems beyond translation, such as slow build speeds and insufficient linters. To learn more about Meta’s broader adoption effort, see Omer Strulovich’s 2022 blog post on our migration from Java to Kotlin or Lisa Watkin’s talk about Kotlin adoption at Instagram. How much translation is enough? To maximize our gains in developer productivity and null safety, we’re aiming to translate virtually all of our actively developed code, plus any code that’s central in the dependency graph. Not surprisingly, that’s most of our code, which adds up to tens of millions of lines, including some of the most complex files. It’s pretty intuitive that if we want to maximize productivity gains, we should translate our actively developed code. It’s a little less obvious why translating beyond that provides incremental null-safety benefits. The short answer is that any remaining Java code can be an agent of nullability chaos, especially if it’s not null safe and even more so if it’s central to the dependency graph. (For a more detailed explanation, see the section below on null safety.) We also want to minimize the drawbacks of a mixed codebase. As long as we have substantial amounts of Java, we need to continue supporting parallel tool chains. There’s also the much-lamented issue of slower build speeds: Compiling Kotlin is slower than compiling Java, but compiling both together is the slowest of all.  How did we get here? Like most folks in the industry, we started migrating incrementally by repeatedly clicking a button in the Intellij IDE. This button would trigger Intellij’s translation tool, commonly known as J2K. It quickly became clear that this approach wasn’t going to scale for a codebase of our size: We would have to click that button—and then wait the couple of minutes it takes to run—almost 100,000 times to translate our Android codebase.  With this in mind, we set out to automate the conversion process and minimize interference with our developers’ daily work. The result was a tool we call the Kotlinator that we built around J2K. It’s now comprised of six phases: “Deep” build: Building the code we’re about to translate helps the IDE resolve all the symbols, especially when third-party dependencies or generated code are involved. Preprocessing: This phase is built on top of our custom tool, Editus. It contains about 50 steps for nullability, J2K workarounds, changes to support our custom DI framework, and more. Headless J2K: The J2K we know and love, but server-friendly! Postprocessing: This phase is similar in architecture to our preprocessing. It consists of about 150 steps for Android-specific changes, as well as more nullability changes, and tweaks to make the resulting Kotlin more idiomatic. Linters: Running our linters with autofixes allows us to implement perennial fixes in a way that benefits both conversion diffs and regular diffs going forward. Build error-based fixes: Finally, the Kotlinator makes even more fixes based on build errors. After a failed build of the just-translated code, we parse the errors and apply further fixes (e.g., adding a missing import or inserting a !!). We’ll dive into more detail on the most interesting phases below. Going headless with J2K The first step was creating a headless version of J2K that could run on a remote machine—not easy, given how tightly coupled J2K and the rest of the Intellij IDE are. We considered a few approaches, including running J2K using a setup similar to Intellij’s testing environment, but after talking to JetBrains’ J2K expert, Ilya Kirillov, we eventually settled on something more like a headless inspection. To implement this approach, we created an Intellij plugin that includes a class extending ApplicationStarter and calling directly into the JavaToKotlinConverter class that’s also referenced by the IDE’s conversion button. On top of not blocking developers’ local IDEs, the headless approach allowed us to translate multiple files at once, and it unblocked all sorts of helpful but time-consuming steps, like the “build and fix errors” process detailed below. Overall conversion time grew longer (a typical remote conversion now takes about 30 minutes to run), but time spent by the developers decreased substantially. Of course, going headless presents another conundrum: If developers aren’t clicking the button themselves, who decides what to translate, and how does it get reviewed and shipped? The answer turned out to be pretty easy: Meta has an internal system that allows developers to set up what is essentially a cron job that produces a daily batch of diffs (our version of pull requests) based on user-defined selection criteria. This system also helps choose relevant reviewers, ensures that tests and other validations pass, and ships the diff once it’s approved by a human. We also offer a web UI for developers to trigger a remote conversion of a specific file or module; behind the scenes, it runs the same process as the cron job. As for choosing what and when to translate, we don’t enforce any particular order beyond prioritizing actively developed files. At this point, the Kotlinator is sophisticated enough to handle most compatibility changes required in external files (for example, changing Kotlin dependents’ references of foo.getName() to foo.name), so there’s no need to order our translations based on the dependency graph.  Adding custom pre- and post-conversion steps Due to the size of our codebase and the custom frameworks we use, the vast majority of conversion diffs produced by the vanilla J2K would not build. To address this problem, we added two custom phases to our conversion process, preprocessing and postprocessing. Both phases contain dozens of steps that take in the file being translated, analyze it (and sometimes its dependencies and dependents, too), and perform a Java-\u003eJava or Kotlin-\u003eKotlin transformation if needed. A few of our postprocessing transformations have been open-sourced. These custom translation steps are built on top of an internal metaprogramming tool that leverages Jetbrains’ PSI libraries for both Java and Kotlin. Unlike most metaprogramming tools, it is very much not a compiler plugin, so it can analyze broken code across both languages, and does so very quickly. This is especially helpful for postprocessing because it’s often running on code with compilation errors, doing analysis that requires type information. Some postprocessing steps that deal with dependents may need to resolve symbols across several thousand unbuildable Java and Kotlin files. For example, one of our postprocessing steps helps translate interfaces by examining its Kotlin implementers and updating overridden getter functions to instead be overridden properties, like in the example below. interface JustConverted { val name: String // I used to be a method called `getName` } class ConvertedAWhileAgo : JustConverted {   override fun getName(): String = \"JustConvertedImpl\" } class ConvertedAWhileAgo : JustConverted {   override val name: String = \"JustConvertedImpl\" } The downside to this tool’s speed and flexibility is that it can’t always provide answers about type information, especially when symbols are defined in third-party libraries. In those cases, it bails quickly and obviously, so we don’t execute a transformation with false confidence. The resulting Kotlin code might not build, but the appropriate fix is usually pretty obvious to a human (if a little tedious). We originally added these custom phases to reduce developer effort, but over time we also leveraged them to reduce developer unreliability. Contrary to popular belief, we’ve found it’s often safer to leave the most delicate transformations to bots. There are certain fixes we’ve automated as part of postprocessing, even though they aren’t strictly necessary, because we want to minimize the temptation for human (i.e., error-prone) intervention. One example is condensing long chains of null checks: The resulting Kotlin code isn’t more correct, but it’s less susceptible to a well-meaning developer accidentally dropping a negation.  Leveraging build errors In the course of doing our own conversions, we noticed that we spent a lot of time at the end repeatedly building and fixing our code based on the compiler’s error messages. In theory, we could fix many of these problems in our custom postprocessing, but doing so would require us to reimplement a lot of complex logic that’s baked into the Kotlin compiler.  Instead, we added a new, final step in the Kotlinator that leverages the compiler’s error messages the same way a human would. Like postprocessing, these fixes are performed with a metaprogramming that can analyze unbuildable code. The limitations of custom tooling Between the preprocessing, postprocessing, and post-build phases, the Kotlinator contains well over 200 custom steps. Unfortunately, some conversion issues simply can’t be solved by adding even more steps. Originally we treated J2K as a black box—even though it was open sourced—because its code was complex and not actively developed; diving in and submitting PRs didn’t seem worth the effort. That changed early in 2024, however, when JetBrains began work to make J2K compatible with the new Kotlin compiler, K2. We took the opportunity to work with JetBrains to improve J2K and address problems that had been plaguing us for years, such as disappearing override keywords. Collaborating with JetBrains also gave us the opportunity to insert hooks into J2K that would allow clients like Meta to run their own custom steps directly in the IDE before and after conversion. This may sound strange, given the number of custom processing steps we’ve already written, but there are a couple of major benefits: Improved symbol resolution. Our custom symbol resolution is fast and flexible, but it’s less precise than J2K’s, especially when it comes to resolving symbols defined in third-party libraries. Porting some of our preprocessing and postprocessing steps over to leverage J2K’s extension points will make them more accurate, and allow us to use Intellij’s more sophisticated static-analysis tooling. Easier open sourcing and collaboration. Some of our custom steps are too Android-specific to be incorporated into J2K but might still be useful to other companies. Unfortunately, most of them depend on our custom symbol resolution. Porting these steps over to instead rely on J2K’s symbol resolution gives us the option to open-source them and benefit from the community’s pooled efforts. But first, null safety! In order to translate our code without spewing null-pointer exceptions (NPEs) everywhere, it first needs to be null safe (by “null safe” we mean code checked by a static analyzer such as Nullsafe or NullAway). Null safety still isn’t sufficient to eliminate the possibility of NPEs, but it’s an excellent start. Unfortunately, making code null safe is easier said than done. Even null-safe Java throws NPEs sometimes Anyone who has worked with null-safe Java code long enough knows that while it’s more reliable than vanilla Java code, it’s still prone to NPEs. Unfortunately static analysis is only 100% effective for 100% code coverage, which is simply not viable in any large mobile codebase that interacts with the server and third-party libraries. Here’s a canonical example of a seemingly innocuous change that can introduce an NPE: MyNullsafeClass.java @Nullsafe public class MyNullsafeClass {   void doThing(String s) {     // can we safely add this dereference?     // s.length;   } } Say there are a dozen dependents that call MyNullsafeJava::doThing. A single non-null-safe dependent could pass in a null argument (for example,  MyNullsafeJava().doThing(null)), which would lead to an NPE if a dereference is inserted in the body of doThing.  Of course, while we can’t eliminate NPEs in Java via null-safety coverage, we can greatly reduce their frequency. In the example above, NPEs are possible but fairly rare when there’s only one non-null-safe dependent. If multiple transitive dependents lacked null safety, or if one of the more central dependent nodes did, the NPE risk would be much higher. What makes Kotlin different The biggest difference between null-safe Java and Kotlin is the presence of runtime validation in Kotlin bytecode at the interlanguage boundary. This validation is invisible but powerful because it allows developers to trust the stated nullability annotations in any code they’re modifying or calling. If we return to our earlier example, MyNullsafeClass.java, and translate it to Kotlin, we get something like: MyNullsafeClass.kt class MyNullsafeClass {   fun doThing(s: String) {     // there's an invisible `checkNotNull(s)` here in the bytecode     // so adding this dereference is now risk-free!     // s.length   } } Now there’s an invisible checkNotNull(s) in the bytecode at the start of doThing’s body, so we can safely add a dereference to s, because if s were nullable, this code would already be crashing. As you can imagine, this certainty makes for much smoother, safer development. There are also some differences at the static analysis level: The Kotlin compiler enforces a slightly stricter set of null safety rules than Nullsafe does when it comes to concurrency. More specifically, the Kotlin compiler throws an error for dereferences of class-level properties that could have been set to null in another thread. This difference isn’t terribly important to us, but it does lead to more !! than one might expect when translating null-safe code. Great, let’s translate it all to Kotlin! Not so fast. As is always the case, going from more ambiguity to less ambiguity doesn’t come for free. For a case like MyNullsafeClass, development is much easier after Kotlin translation, but someone has to take that initial risk of effectively inserting a nonnull assertion for its hopefully-really-not-nullable parameter s. That “someone” is whichever developer or bot ends up shipping the Kotlin conversion. We can take a number of steps to minimize the risk of introducing new NPEs during conversion, the simplest of which is erring on the side of “more nullable” when translating parameters and return types. In the case of MyNullsafeClass, the Kotlinator would have used context clues (in this case, the absence of any dereferences in the body of doThing) to infer that String s should be translated to s: String?. One of the changes we ask developers to scrutinize most when reviewing conversion diffs is the addition of !! outside of preexisting dereferences. Funnily enough, we’re not worried about an expression like foo!!.name, because it’s not any more likely to crash in Kotlin than it was in Java. An expression such as someMethodDefinedInJava(foo!!) is much more concerning, however, because it’s possible that someMethodDefinedInJava is simply missing a @Nullable on its parameter, and so adding !! will introduce a very unnecessary NPE. To avoid problems like adding unnecessary !! during conversion, we run over a dozen complementary codemods that comb through the codebase looking for parameters, return types, and member variables that might be missing @Nullable. More accurate nullability across the codebase—even in Java files that we may never translate—is not only safer, it’s also conducive to more successful conversions, especially as we approach the final stretch in this project. Of course, the last remaining null safety issues in our Java code have usually stuck around because they’re very hard to solve. Previous attempts to resolve them relied mostly on static analysis, so we decided to borrow an idea from the Kotlin compiler and create a Java compiler plugin that helps us collect runtime nullability data. This plugin allows us to collect data on all return types and parameters that are receiving/returning a null value and are not annotated as such. Whether these are from Java/Kotlin interop or classes that were annotated incorrectly at a local level, we can determine ultimate sources of truth and use codemods to finally fix the annotations. Other ways to break your code On top of the risks of regressing null safety, there are dozens of other ways to break your code during conversion. In the course of shipping over 40,000 conversions, we’ve learned about many of these the hard way and now have several layers of validation to prevent them. Here are a couple of our favorites: Confusing initialization with getters // Incorrect! val name: String = getCurrentUser().name // Correct val name: String   get() = getCurrentUser().name Nullable booleans // Original if (foo != null \u0026\u0026 !foo.isEnabled) println(\"Foo is not null and disabled\") // Incorrect! if (foo?.isEnabled != true) println(\"Foo is not null and disabled\") // Correct if (foo?.isEnabled == false) println(\"Foo is not null and disabled\") The fun part At this point, more than half of Meta’s Android Java code has been translated to Kotlin (or, more rarely, deleted). But that was the easy half! The really fun part lies ahead of us, and it’s a doozy. There are still thousands of fully automated conversions we hope to unblock by adding and refining custom steps and by contributing to J2K. And there are thousands more semi-automated conversions we hope to ship smoothly and safely as a result of other Kotlinator improvements. Many of the problems we face also affect other companies translating their Android codebases. If this sounds like you, we’d love for you to leverage our fixes and share some of your own. Come chat with us and others in the #j2k channel of the Kotlinlang Slack.",
  "image": "https://engineering.fb.com/wp-content/uploads/2022/11/Eng-Blog-Self-Serve-Hero-Images-ANALYTICS-401-Orange.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\u003cul\u003e\n\u003cli\u003eMeta has been on a years-long undertaking to translate our entire Android codebase from Java to Kotlin.\u003c/li\u003e\n\u003cli\u003eToday, despite having one of the largest Android codebases in the world, we’re well past the halfway point and still going.\u003c/li\u003e\n\u003cli\u003eWe’re sharing some of the tradeoffs we’ve made to support automating our transition to Kotlin, seemingly simple transformations that are surprisingly tricky, and how we’re collaborating with other companies to capture hundreds more corner cases.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cspan\u003eAndroid development at Meta has been Kotlin-first since 2020, and developers have been saying they prefer Kotlin as a language for even longer.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eBut, adoption doesn’t necessarily entail translation. We could simply decide to write all new code in Kotlin and leave our existing Java code as is, just as many other companies have. Or we could take it a little further and translate just the most important files. Instead, we decided that the only way to leverage the full value of Kotlin was to go all in on conversion, even if it meant building our own infrastructure to automate translation at scale. So, a few years ago, engineers at Meta decided to take \u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eroughly ten million lines of perfectly good Java code and rewrite them in Kotlin\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOf course, we had to solve problems beyond translation, such as slow build speeds and insufficient linters\u003c/span\u003e\u003cspan\u003e. To learn more about Meta’s broader adoption effort, see Omer Strulovich’s 2022 blog post on our \u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003emigration from Java to Kotlin\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e or Lisa Watkin’s talk about \u003c/span\u003e\u003ca href=\"https://atscaleconference.com/videos/kotlin-instagram/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eKotlin adoption at Instagram\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003ciframe title=\"Translating Java to Kotlin at Scale | Eve Matthaey\" width=\"1778\" height=\"1000\" src=\"https://www.youtube.com/embed/zfnOjAYdWrc?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eHow much translation is enough?\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eTo maximize our gains in developer productivity and null safety, we’re aiming to translate virtually all of our actively developed code, \u003c/span\u003e\u003ci\u003e\u003cspan\u003eplus\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e any code that’s central in the dependency graph. Not surprisingly, that’s most of our code, which adds up to tens of millions of lines, including some of the most complex files.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIt’s pretty intuitive that if we want to maximize productivity gains, we should translate our actively developed code. It’s a little less obvious why translating beyond that provides incremental null-safety benefits. The short answer is that any remaining Java code can be an agent of nullability chaos, especially if it’s not null safe and even more so if it’s central to the dependency graph. (For a more detailed explanation, see the section below on null safety.)\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe also want to minimize the drawbacks of a mixed codebase. As long as we have substantial amounts of Java, we need to continue supporting parallel tool chains. There’s also the much-lamented issue of slower build speeds: Compiling Kotlin is slower than compiling Java, but compiling both together is the slowest of all. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eHow did we get here?\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eLike most folks in the industry, we started migrating incrementally by repeatedly clicking a button in the Intellij IDE. This button would trigger \u003c/span\u003e\u003ca href=\"https://github.com/JetBrains/intellij-community/tree/master/plugins/kotlin/j2k\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eIntellij’s translation tool\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, commonly known as J2K. It quickly became clear that this approach wasn’t going to scale for a codebase of our size: We would have to click that button—and then wait the couple of minutes it takes to run—almost 100,000 times to translate our Android codebase. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWith this in mind, we set out to automate the conversion process and minimize interference with our developers’ daily work. The result was a tool we call the Kotlinator that we built around J2K. It’s now comprised of six phases:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003e“Deep” build:\u003c/b\u003e\u003cspan\u003e Building the code we’re about to translate helps the IDE resolve all the symbols, especially when third-party dependencies or generated code are involved.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003ePreprocessing:\u003c/b\u003e\u003cspan\u003e This phase is built on top of our custom tool, Editus. It contains about 50 steps for nullability, J2K workarounds, changes to support our custom DI framework, and more.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eHeadless J2K:\u003c/b\u003e\u003cspan\u003e The J2K we know and love, but server-friendly!\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003ePostprocessing:\u003c/b\u003e\u003cspan\u003e This phase is similar in architecture to our preprocessing. It consists of about 150 steps for Android-specific changes, as well as more nullability changes, and tweaks to make the resulting Kotlin more idiomatic.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eLinters:\u003c/b\u003e\u003cspan\u003e Running our linters with autofixes allows us to implement perennial fixes in a way that benefits both conversion diffs and regular diffs going forward.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eBuild error-based fixes:\u003c/b\u003e\u003cspan\u003e Finally, the Kotlinator makes even more fixes based on build errors. After a failed build of the just-translated code, we parse the errors and apply further fixes (e.g., adding a missing import or inserting a \u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cspan\u003eWe’ll dive into more detail on the most interesting phases below.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eGoing headless with J2K\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe first step was creating a headless version of J2K that could run on a remote machine—not easy, given how tightly coupled J2K and the rest of the Intellij IDE are. We considered a few approaches, including running J2K using a setup similar to Intellij’s testing environment, but after talking to JetBrains’ J2K expert, Ilya Kirillov, we eventually settled on something more like a headless inspection. To implement this approach, we created an Intellij plugin that includes a class extending \u003c/span\u003e\u003cspan\u003eApplicationStarter\u003c/span\u003e\u003cspan\u003e and calling directly into the \u003c/span\u003e\u003cspan\u003eJavaToKotlinConverter\u003c/span\u003e\u003cspan\u003e class that’s also referenced by the IDE’s conversion button.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOn top of not blocking developers’ local IDEs, the headless approach allowed us to translate multiple files at once, and it unblocked all sorts of helpful but time-consuming steps, like the “build and fix errors” process detailed below. Overall conversion time grew longer (a typical remote conversion now takes about 30 minutes to run), but time spent by the developers decreased substantially.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOf course, going headless presents another conundrum: If developers aren’t clicking the button themselves, who decides what to translate, and how does it get reviewed and shipped? The answer turned out to be pretty easy: Meta has an internal system that allows developers to set up what is essentially a cron job that produces a daily batch of \u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2024/10/25/developer-tools/diff-authoring-time-dat-measuring-developer-productivity-meta/\"\u003e\u003cspan\u003ediffs\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e (our version of pull requests) based on user-defined selection criteria. This system also helps choose relevant reviewers, ensures that tests and other validations pass, and ships the diff once it’s approved by a human. We also offer a web UI for developers to trigger a remote conversion of a specific file or module; behind the scenes, it runs the same process as the cron job.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAs for choosing what and when to translate, we don’t enforce any particular order beyond prioritizing actively developed files. At this point, the Kotlinator is sophisticated enough to handle most compatibility changes required in external files (for example, changing Kotlin dependents’ references of \u003c/span\u003e\u003cspan\u003efoo.getName()\u003c/span\u003e\u003cspan\u003e to \u003c/span\u003e\u003cspan\u003efoo.name\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e, so there’s no need to order our translations based on the dependency graph. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eAdding custom pre- and post-conversion steps\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eDue to the size of our codebase and the custom frameworks we use, the vast majority of conversion diffs produced by the vanilla J2K would not build. To address this problem, we added two custom phases to our conversion process, preprocessing and postprocessing. Both phases contain dozens of steps that take in the file being translated, analyze it (and sometimes its dependencies and dependents, too), and perform a Java-\u0026gt;Java or Kotlin-\u0026gt;Kotlin transformation if needed. \u003c/span\u003e\u003ca href=\"https://github.com/fbsamples/kotlin_ast_tools\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eA few of our postprocessing transformations have been open-sourced\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThese custom translation steps are built on top of an internal metaprogramming tool that leverages Jetbrains’ PSI libraries for both Java and Kotlin. Unlike most metaprogramming tools, it is very much \u003c/span\u003e\u003ci\u003e\u003cspan\u003enot\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e a compiler plugin, so it can analyze broken code across both languages, and does so very quickly. This is especially helpful for postprocessing because it’s often running on code with compilation errors, doing analysis that requires type information. Some postprocessing steps that deal with dependents may need to resolve symbols across several thousand unbuildable Java and Kotlin files. For example, one of our postprocessing steps helps translate interfaces by examining its Kotlin implementers and updating overridden getter functions to instead be overridden properties, like in the example below.\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface JustConverted {\n  val name: String // I used to be a method called `getName`\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eclass ConvertedAWhileAgo : JustConverted {\n  override fun getName(): String = \u0026#34;JustConvertedImpl\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eclass ConvertedAWhileAgo : JustConverted {\n  override val name: String = \u0026#34;JustConvertedImpl\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan\u003eThe downside to this tool’s speed and flexibility is that it can’t always provide answers about type information, especially when symbols are defined in third-party libraries. In those cases, it bails quickly and obviously, so we don’t execute a transformation with false confidence. The resulting Kotlin code might not build, but the appropriate fix is usually pretty obvious to a human (if a little tedious).\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe originally added these custom phases to reduce developer effort, but over time we also leveraged them to reduce developer unreliability. Contrary to popular belief, we’ve found it’s often safer to leave the most delicate transformations to bots. There are certain fixes we’ve automated as part of postprocessing, even though they aren’t strictly necessary, because we want to minimize the temptation for human (i.e., error-prone) intervention. One example is condensing long chains of null checks: The resulting Kotlin code isn’t more correct, but it’s less susceptible to a well-meaning developer accidentally dropping a negation. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eLeveraging build errors\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eIn the course of doing our own conversions, we noticed that we spent a lot of time at the end repeatedly building and fixing our code based on the compiler’s error messages. In theory, we could fix many of these problems in our custom postprocessing, but doing so would require us to reimplement a lot of complex logic that’s baked into the Kotlin compiler. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eInstead, we added a new, final step in the Kotlinator that leverages the compiler’s error messages the same way a human would. Like postprocessing, these fixes are performed with a metaprogramming that can analyze unbuildable code.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eThe limitations of custom tooling\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eBetween the preprocessing, postprocessing, and post-build phases, the Kotlinator contains well over 200 custom steps. Unfortunately, some conversion issues simply can’t be solved by adding even more steps.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOriginally we treated J2K as a black box—even though it was open sourced—because its code was complex and not actively developed; diving in and submitting PRs didn’t seem worth the effort. That changed early in 2024, however, when JetBrains began work to make J2K compatible with the new Kotlin compiler, K2. We took the opportunity to work with JetBrains to improve J2K and address problems that had been plaguing us for years, such as disappearing \u003c/span\u003e\u003cspan\u003eoverride\u003c/span\u003e\u003cspan\u003e keywords.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eCollaborating with JetBrains also gave us the opportunity to insert hooks into J2K that would allow clients like Meta to run their own custom steps directly in the IDE before and after conversion. This may sound strange, given the number of custom processing steps we’ve already written, but there are a couple of major benefits:\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eImproved symbol resolution\u003c/b\u003e\u003cspan\u003e. Our custom symbol resolution is fast and flexible, but it’s less precise than J2K’s, especially when it comes to resolving symbols defined in third-party libraries. Porting some of our preprocessing and postprocessing steps over to leverage J2K’s extension points will make them more accurate, and allow us to use Intellij’s more sophisticated static-analysis tooling.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cb\u003eEasier open sourcing and collaboration\u003c/b\u003e\u003cspan\u003e. Some of our custom steps are too Android-specific to be incorporated into J2K but might still be useful to other companies. Unfortunately, most of them depend on our custom symbol resolution. Porting these steps over to instead rely on J2K’s symbol resolution gives us the option to open-source them and benefit from the community’s pooled efforts.\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e\u003cspan\u003eBut first, null safety!\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eIn order to translate our code without spewing null-pointer exceptions (NPEs) everywhere, it first needs to be null safe (by “null safe” we mean code checked by a static analyzer such as \u003c/span\u003e\u003ca href=\"https://github.com/facebook/infer/blob/main/infer/annotations/src/main/java/com/facebook/infer/annotation/Nullsafe.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eNullsafe\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e or \u003c/span\u003e\u003ca href=\"https://github.com/uber/NullAway\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eNullAway\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e). Null safety still isn’t sufficient to eliminate the possibility of NPEs, but it’s an excellent start. Unfortunately, making code null safe is easier said than done.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eEven null-safe Java throws NPEs sometimes\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eAnyone who has worked with null-safe Java code long enough knows that while it’s more reliable than vanilla Java code, it’s still prone to NPEs. Unfortunately \u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2022/11/22/developer-tools/meta-java-nullsafe/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003estatic analysis is only 100% effective for 100% code coverage\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, which is simply not viable in any large mobile codebase that interacts with the server and third-party libraries.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eHere’s a canonical example of a seemingly innocuous change that can introduce an NPE:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eMyNullsafeClass.java\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Nullsafe\npublic class MyNullsafeClass {\n\n  void doThing(String s) {\n    // can we safely add this dereference?\n    // s.length;\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan\u003eSay there are a dozen dependents that call \u003c/span\u003e\u003cspan\u003eMyNullsafeJava::doThing\u003c/span\u003e\u003cspan\u003e. A single non-null-safe dependent could pass in a null argument (for example,  \u003c/span\u003e\u003cspan\u003eMyNullsafeJava().doThing(null)\u003c/span\u003e\u003cspan\u003e), which would lead to an NPE if a dereference is inserted in the body of \u003c/span\u003e\u003cspan\u003edoThing\u003c/span\u003e\u003cspan\u003e. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOf course, while we can’t \u003c/span\u003e\u003ci\u003e\u003cspan\u003eeliminate\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e NPEs in Java via null-safety coverage, we can greatly reduce their frequency. In the example above, NPEs are possible but fairly rare when there’s only one non-null-safe dependent. If multiple transitive dependents lacked null safety, or if one of the more central dependent nodes did, the NPE risk would be much higher.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eWhat makes Kotlin different\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe biggest difference between null-safe Java and Kotlin is the presence of \u003c/span\u003e\u003ca href=\"https://kotlinlang.org/docs/java-interop.html#null-safety-and-platform-types\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eruntime validation in Kotlin bytecode\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e at the interlanguage boundary. This validation is invisible but powerful because it allows developers to trust the stated nullability annotations in any code they’re modifying or calling.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIf we return to our earlier example, \u003c/span\u003e\u003cspan\u003eMyNullsafeClass.java\u003c/span\u003e\u003cspan\u003e, and translate it to Kotlin, we get something like:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eMyNullsafeClass.kt\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass MyNullsafeClass {\n\n  fun doThing(s: String) {\n    // there\u0026#39;s an invisible `checkNotNull(s)` here in the bytecode\n    // so adding this dereference is now risk-free!\n    // s.length\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan\u003eNow there’s an invisible \u003c/span\u003e\u003cspan\u003echeckNotNull(s)\u003c/span\u003e\u003cspan\u003e in the bytecode at the start of \u003c/span\u003e\u003cspan\u003edoThing\u003c/span\u003e\u003cspan\u003e’s body, so we can safely add a dereference to \u003c/span\u003e\u003cspan\u003e\u003cspan\u003es\u003c/span\u003e,\u003c/span\u003e\u003cspan\u003e because if \u003c/span\u003e\u003cspan\u003es\u003c/span\u003e \u003ci\u003e\u003cspan\u003ewere\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e nullable, this code would already be crashing. As you can imagine, this certainty makes for much smoother, safer development.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThere are also some differences at the static analysis level: The Kotlin compiler enforces a slightly \u003c/span\u003e\u003ca href=\"https://kotlinlang.org/docs/null-safety.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003estricter set of null safety rules\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e than Nullsafe does when it comes to concurrency. More specifically, the Kotlin compiler throws an error for \u003c/span\u003e\u003ca href=\"https://discuss.kotlinlang.org/t/smartcast-for-nullable-variable-properties/8976\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003edereferences of class-level properties\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e that could have been set to null in another thread. This difference isn’t terribly important to us, but it does lead to more \u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e than one might expect when translating null-safe code.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eGreat, let’s translate it all to Kotlin!\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eNot so fast. As is always the case, going from more ambiguity to less ambiguity doesn’t come for free. For a case like \u003c/span\u003e\u003cspan\u003e\u003cspan\u003eMyNullsafeClass\u003c/span\u003e,\u003c/span\u003e\u003cspan\u003e development is much easier after Kotlin translation, but someone has to take that initial risk of effectively inserting a nonnull assertion for its hopefully-really-not-nullable parameter \u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e. That “someone” is whichever developer or bot ends up shipping the Kotlin conversion.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe can take a number of steps to minimize the risk of introducing new NPEs during conversion, the simplest of which is erring on the side of “more nullable” when translating parameters and return types. In the case of \u003c/span\u003e\u003cspan\u003eMyNullsafeClass,\u003c/span\u003e\u003cspan\u003e the Kotlinator would have used context clues (in this case, the absence of any dereferences in the body of \u003c/span\u003e\u003cspan\u003edoThing\u003c/span\u003e\u003cspan\u003e) to infer that \u003c/span\u003e\u003cspan\u003e\u003cspan\u003eString\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e should be translated to \u003c/span\u003e\u003cspan\u003es: String?\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOne of the changes we ask developers to scrutinize most when reviewing conversion diffs is the addition of \u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e outside of preexisting dereferences. Funnily enough, we’re not worried about an expression like \u003c/span\u003e\u003cspan\u003efoo!!.name\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e because it’s not any more likely to crash in Kotlin than it was in Java. An expression such as \u003c/span\u003e\u003cspan\u003esomeMethodDefinedInJava(foo!!)\u003c/span\u003e\u003cspan\u003e is much more concerning, however, because it’s possible that \u003c/span\u003e\u003cspan\u003esomeMethodDefinedInJava\u003c/span\u003e\u003cspan\u003e is simply missing a \u003c/span\u003e\u003cspan\u003e@Nullable\u003c/span\u003e\u003cspan\u003e on its parameter, and so adding \u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e will introduce a very unnecessary NPE.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTo avoid problems like adding unnecessary \u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\u003cspan\u003e during conversion, we run over a dozen complementary codemods that comb through the codebase looking for parameters, return types, and member variables that might be missing \u003c/span\u003e\u003cspan\u003e@Nullable\u003c/span\u003e\u003cspan\u003e. More accurate nullability across the codebase—even in Java files that we may never translate—is not only safer, it’s also conducive to more successful conversions, especially as we approach the final stretch in this project.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOf course, the last remaining null safety issues in our Java code have usually stuck around because they’re very hard to solve. Previous attempts to resolve them relied mostly on static analysis, so we decided to borrow an idea from the Kotlin compiler and create a Java compiler plugin that helps us collect runtime nullability data. This plugin allows us to collect data on all return types and parameters that are receiving/returning a null value and are not annotated as such. Whether these are from Java/Kotlin interop or classes that were annotated incorrectly at a local level, we can determine ultimate sources of truth and use codemods to finally fix the annotations.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eOther ways to break your code\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eOn top of the risks of regressing null safety, there are dozens of other ways to break your code during conversion. In the course of shipping over 40,000 conversions, we’ve learned about many of these the hard way and now have several layers of validation to prevent them. Here are a couple of our favorites:\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eConfusing initialization with getters\u003c/span\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e// Incorrect!\nval name: String = getCurrentUser().name\n\n// Correct\nval name: String\n  get() = getCurrentUser().name\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cspan\u003eNullable booleans\u003c/span\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e// Original\nif (foo != null \u0026amp;\u0026amp; !foo.isEnabled) println(\u0026#34;Foo is not null and disabled\u0026#34;)\n\n// Incorrect!\nif (foo?.isEnabled != true) println(\u0026#34;Foo is not null and disabled\u0026#34;)\n\n// Correct\nif (foo?.isEnabled == false) println(\u0026#34;Foo is not null and disabled\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e\u003cspan\u003eThe fun part\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eAt this point, more than half of Meta’s Android Java code has been translated to Kotlin (or, more rarely, deleted). But that was the easy half! The \u003c/span\u003e\u003ci\u003e\u003cspan\u003ereally\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e fun part lies ahead of us, and it’s a doozy. There are still thousands of fully automated conversions we hope to unblock by adding and refining custom steps and by contributing to J2K. And there are thousands more semi-automated conversions we hope to ship smoothly and safely as a result of other Kotlinator improvements.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMany of the problems we face also affect other companies translating their Android codebases. If this sounds like you, we’d love for you to leverage our \u003c/span\u003e\u003ca href=\"https://github.com/fbsamples/kotlin_ast_tools\"\u003e\u003cspan\u003efixes\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e and share some of your own. Come chat with us and others in the \u003c/span\u003e\u003ca href=\"https://slack-chats.kotlinlang.org/c/j2k\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003e#j2k channel of the Kotlinlang Slack\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-12-18T17:00:18Z",
  "modifiedTime": "2024-12-18T00:37:37Z"
}
