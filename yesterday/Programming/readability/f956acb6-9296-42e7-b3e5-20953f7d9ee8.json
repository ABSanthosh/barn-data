{
  "id": "f956acb6-9296-42e7-b3e5-20953f7d9ee8",
  "title": "Demystifying Spring Boot With Spring Debugger",
  "link": "https://blog.jetbrains.com/idea/2025/06/demystifying-spring-boot-with-spring-debugger/",
  "description": "Spring Boot is a marvel of developer productivity. It hides the plumbing and gets you up and running fast. Components are ‚Äúmiraculously‚Äù autowired, properties are ‚Äúmagically‚Äù resolved, and database connections materialize seemingly without explicit configuration. But when something goes wrong, the magic becomes a mystery, and debugging becomes a deep dive into the framework‚Äôs internal [‚Ä¶]",
  "author": "Andrey Belyaev",
  "published": "Wed, 25 Jun 2025 07:22:11 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "tutorials",
    "debug",
    "intellij-idea",
    "spring-boot",
    "spring-debugger"
  ],
  "byline": "Andrey Belyaev",
  "length": 8499,
  "excerpt": "Pull back the curtain on the Spring Boot magic and see how the Spring Debugger plugin makes the invisible visible.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin TutorialsDemystifying Spring Boot With Spring Debugger Spring Boot is a marvel of developer productivity. It hides the plumbing and gets you up and running fast. Components are ‚Äúmiraculously‚Äù autowired, properties are ‚Äúmagically‚Äù resolved, and database connections materialize seemingly without explicit configuration. But when something goes wrong, the magic becomes a mystery, and debugging becomes a deep dive into the framework‚Äôs internal mechanics. Regular debuggers handle plain Java classes and objects, lacking framework-specific context. To inspect a property, track a bean, or examine an entity state, you need to dig into the internals of Spring Boot. (Remember how to access the application context from the debugger evaluator? Neither do we.)The rabbit was always in the hat ‚Äì you just had to know where to look. IntelliJ IDEA has long allowed you to inspect loaded beans or trace the source of a property value using the debugger, but doing so wasn‚Äôt exactly straightforward. Our goal is to change that ‚Äì to make debugging Spring applications as comfortable and productive as the rest of your development experience in IntelliJ IDEA. The first step was an additional structure view, and now we‚Äôre going further.¬† Let‚Äôs pull back the curtain on the Spring Boot magic and see how the Spring Debugger plugin makes the invisible visible.¬† If you prefer watching and listening, have a look at Marco Behler‚Äôs talk at Spring I/O 2025. Spring Debugger: A New Way To Demystify Spring Boot‚Äôs Magic by Marco Behler @ Spring I/O 2025 The bean that wasn‚Äôt there Spring Debugger is built with a focus on real-world tasks, helping you uncover what‚Äôs really happening inside your Spring application.¬† You‚Äôve written the class. You‚Äôve annotated it as a bean. But it‚Äôs not doing anything.¬† Maybe it‚Äôs not in the right package. Maybe it‚Äôs excluded by a conditional. Maybe it‚Äôs overridden in a test.¬† Spring Debugger exposes the full bean landscape: You can see all Spring-managed beans directly in the Project view. Grayed-out entries tell you which ones were scanned but not instantiated. Using Mockito in tests? All mocked beans are clearly marked in orange. And it goes deeper.¬† While stepping through the code, you can inspect a bean‚Äôs metadata, including the scope, profile, context, and even originating factory method. No more guesswork ‚Äì bean definitions are now first-class citizens in your debugging workflow.¬† The property maze You set a property in application.properties, but your app uses a different value. Why? Spring Boot‚Äôs property resolution is layered: file values, profiles, environment variables, system properties, command-line args, post-processors‚Ä¶ It‚Äôs a maze. Even professional developers need additional tools to get through. Spring Debugger flattens the hierarchy: It shows the effective runtime value inline in .properties and .yaml files. It highlights overridden values and source locations. For environment-based or external values, the evaluator reveals the origin clearly. For values from environment variables or external sources, it still shows where they came from in the debugger evaluator. Since you no longer need to trace values back manually, you save time and reduce the number of misconfigurations. The missing transaction You annotated your method with @Transactional, but it is not committing. Even worse, you‚Äôre getting a LazyInitializationException. What happened? Spring Debugger helps you understand what‚Äôs going on: It shows inline indicators for methods executing inside active transactions. It displays full transaction details, including isolation, propagation, and the method that started it all. A visual hierarchy for nested transactions helps you understand call chains and propagation effects. For JPA, it shows the L1 cache state and updates it in real time. Now you know whether your method is inside the transaction you expected ‚Äì and where it actually began.¬† The database client that configured itself Your app connects to a database ‚Äì but how? From which config? Which JDBC URL is used? In tests, is it using a Testcontainer? Or is it perhaps an in-memory database like H2? Spring Debugger makes all of this explicit: It detects all active DataSource connections automatically. It groups them under their corresponding run/debug configurations. It integrates with IntelliJ IDEA‚Äôs Database tool window for inspection. No need to manually register database connections or dig through logs. You can see every live DataSource and explore it interactively. üìå In-memory databases are currently shown, but browsing data is not supported. Reading beans from thin air The debugger is paused. You want to trigger a service, add test data, or inspect a Spring bean. Can you do this the normal way? No. Spring Debugger changes that by letting you: Auto-complete all loaded beans in the expression evaluator. Invoke any method on any bean on the fly. The process of bean evaluation is getting better: We can evaluate any configuration property value right in the debugger. All we need to do is select the evaluator on the right side.¬† It‚Äôs like a REPL for your Spring context. You can poke, prod, simulate, and confirm behavior without restarting the app or adding test code. For curious developers: How it works internally¬† Spring Debugger doesn‚Äôt require Spring Boot Actuator or any additional runtime agent. All data is analyzed locally without any network calls, data sharing, or risks of leakage, ensuring full privacy. Under the hood, the plugin uses non-suspending breakpoints set inside the Spring Boot framework libraries. During application startup, after the context is loaded, Spring Debugger gathers information from the debug session, memory heap, and stack trace. This lets it access ‚Äúraw‚Äù internal application data without relying on external libraries. Thanks to the IntelliJ IDEA Debugger API, we were able to invoke required methods from Spring Boot libraries, build an application runtime model, and display it in the IDE. The Spring Debugger project also led to an extension of the debugger‚Äôs evaluator API, allowing us to add property evaluators alongside the standard Java one. In the future, we may extend this further to evaluate not just properties but also SpEL, SQL, or similar expressions. Summary Spring Boot is powerful, but its abstractions can be hard to debug. Spring Debugger turns IntelliJ IDEA into a lens that sees through those layers. It‚Äôs designed to keep you productive, improve code quality, and clarify real-world problems, all while offering ultimate comfort in your daily workflow. Beans, configs, and contexts ‚Äì visually decoded. Transactions ‚Äì made traceable. Properties ‚Äì unmasked and source-mapped. Databases ‚Äì auto-detected and accessible. Evaluator ‚Äì context-aware and interactive. The debugger doesn‚Äôt undermine the ‚Äúmagic‚Äù of the Spring. It lets you understand and control it. Simply run your app in debug mode and see what‚Äôs really happening. Try it now! Install Spring Debugger and make Spring internals visible. Documentation is available to help you get started.¬† We value your feedback!¬† Feel free to share your thoughts via plugin reviews or in the comments.¬† Happy coding! Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/IJ-social-BlogSocialShare-1280x720-2x-4.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA ‚Äì the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eDemystifying Spring Boot With Spring Debugger\u003c/h2\u003e                    \n                    \n\u003cp\u003eSpring Boot is a marvel of developer productivity. It hides the plumbing and gets you up and running fast. Components are ‚Äúmiraculously‚Äù autowired, properties are ‚Äúmagically‚Äù resolved, and database connections materialize seemingly without explicit configuration.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut when something goes wrong, the magic becomes a mystery, and debugging becomes a deep dive into the framework‚Äôs internal mechanics.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eRegular debuggers handle plain Java classes and objects, lacking framework-specific context. To inspect a property, track a bean, or examine an entity state, you need to dig into the internals of Spring Boot. (Remember how to access the application context from the debugger evaluator? Neither do we.)\u003c/p\u003e\u003cp\u003eThe rabbit was always in the hat ‚Äì you just had to know where to look. IntelliJ IDEA has long allowed you to inspect loaded beans or trace the source of a property value using the debugger, but doing so wasn‚Äôt exactly straightforward. Our goal is to change that ‚Äì to make debugging Spring applications as comfortable and productive as the rest of your development experience in IntelliJ IDEA. The first step was an additional \u003ca href=\"https://blog.jetbrains.com/idea/2024/11/from-code-to-clarity-with-the-redesigned-structure-tool-window/\"\u003estructure view\u003c/a\u003e, and now we‚Äôre going further.¬†\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cp\u003eLet‚Äôs pull back the curtain on the Spring Boot magic and see how the \u003ca href=\"https://plugins.jetbrains.com/plugin/25302-spring-debugger\" target=\"_blank\" rel=\"noopener\"\u003eSpring Debugger\u003c/a\u003e plugin makes the invisible visible.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you prefer watching and listening, have a look at Marco Behler‚Äôs talk at Spring I/O 2025.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003e\n\u003ciframe title=\"Spring Debugger: A New Way To Demystify Spring Boot\u0026#39;s Magic by Marco Behler @ Spring I/O 2025\" width=\"500\" height=\"281\" src=\"https://www.youtube.com/embed/K2tYAHG2XJ8?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\u003cfigcaption\u003eSpring Debugger: A New Way To Demystify Spring Boot‚Äôs Magic by Marco Behler @ Spring I/O 2025\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe bean that wasn‚Äôt there\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eSpring Debugger is built with a focus on real-world tasks, helping you uncover what‚Äôs really happening inside your Spring application.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eYou‚Äôve written the class. You‚Äôve annotated it as a bean. But it‚Äôs not doing anything.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eMaybe it‚Äôs not in the right package. Maybe it‚Äôs excluded by a conditional. Maybe it‚Äôs overridden in a test.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eSpring Debugger exposes the full bean landscape:\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXefCypu3nbH5O5mom6Ag0zpCBgMJyFVzPOxnZu_Ux2SB1SmziV3pD3wfyHYLW87B_wZEfbHWrJBv-t3bI3n5G3g2JvuYF9WYPK_5uYOC5OYnOqPX6pwGrHtn_mol5Xnwebxl1bY?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cul\u003e\n\u003cli\u003eYou can see all Spring-managed beans directly in the \u003cem\u003eProject\u003c/em\u003e view.\u003c/li\u003e\n\n\n\n\u003cli\u003eGrayed-out entries tell you which ones were scanned but not instantiated.\u003c/li\u003e\n\n\n\n\u003cli\u003eUsing Mockito in tests? All mocked beans are clearly marked in orange.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAnd it goes deeper.¬†\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"2580\" height=\"1922\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/5_1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhile stepping through the code, you can inspect a bean‚Äôs metadata, including the scope, profile, context, and even originating factory method. No more guesswork ‚Äì bean definitions are now first-class citizens in your debugging workflow.¬†\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe property maze\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou set a property in \u003ccode\u003eapplication.properties\u003c/code\u003e, but your app uses a different value. Why?\u003c/p\u003e\n\n\n\n\u003cp\u003eSpring Boot‚Äôs property resolution is layered: file values, profiles, environment variables, system properties, command-line args, post-processors‚Ä¶ It‚Äôs a maze. Even professional developers need additional tools to get through.\u003c/p\u003e\n\n\n\n\u003cp\u003eSpring Debugger flattens the hierarchy:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt shows the effective runtime value inline in \u003ccode\u003e.properties\u003c/code\u003e and \u003ccode\u003e.yaml\u003c/code\u003e files.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt highlights overridden values and source locations.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor environment-based or external values, the evaluator reveals the origin clearly.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdmi5Kc3fimapQFDB2orGMVla8aQIJt3fvnLZRgkjU7_2DN9yF_ODFNKQhW4GNkwq8_TU-IpTma6gQCHnrI41gK8qFx17HhAQ-dC5YptRe_gJ9lpZJ57MC85qZeYEc41985h4IhlA?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFor values from environment variables or external sources, it still shows where they came from in the debugger evaluator. Since you no longer need to trace values back manually, you save time and reduce the number of misconfigurations.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe missing transaction\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou annotated your method with \u003ccode\u003e@Transactional\u003c/code\u003e, but it is not committing. Even worse, you‚Äôre getting a \u003ccode\u003eLazyInitializationException\u003c/code\u003e. What happened?\u003c/p\u003e\n\n\n\n\u003cp\u003eSpring Debugger helps you understand what‚Äôs going on:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt shows inline indicators for methods executing inside active transactions.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt displays full transaction details, including isolation, propagation, and the method that started it all.\u003c/li\u003e\n\n\n\n\u003cli\u003eA visual hierarchy for nested transactions helps you understand call chains and propagation effects.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor JPA, it shows the L1 cache state and updates it in real time.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcIqPaUk80KBL3mFqhocnSwgTUXX0VUsbvGyewnWGC8Y07s6gmoYX2cXkgDpP1qnVP2vmLzQ0-bG9afHH56o_W0y_KMoIB4klokohQij_T5BPFsz8_O098ndzi2RFnlGHgT799M?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow you know whether your method is inside the transaction you expected ‚Äì and where it actually began.¬†\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eThe database client that configured itself\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eYour app connects to a database ‚Äì but how? From which config? Which JDBC URL is used? In tests, is it using a Testcontainer? Or is it perhaps an in-memory database like H2?\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdin2lbLH4m7s4kfQve85eGiP4d7tVWy7yC5uPII0BfnZC1qZJGlQNh_UCOV77B-7AbRwyo8kUOoczz60CAafoHZdVo6iHjHTBYqbPwALUJO3xjb1wdVfYxp67JstdxFBOiAOUrgw?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSpring Debugger makes all of this explicit:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt detects all active \u003ccode\u003eDataSource\u003c/code\u003e connections automatically.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt groups them under their corresponding run/debug configurations.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt integrates with IntelliJ IDEA‚Äôs \u003cem\u003eDatabase \u003c/em\u003etool window for inspection.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNo need to manually register database connections or dig through logs. You can see every live DataSource and explore it interactively.\u003c/p\u003e\n\n\n\n\u003cp\u003eüìå In-memory databases are currently shown, but browsing data is not supported.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eReading beans from thin air\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe debugger is paused. You want to trigger a service, add test data, or inspect a Spring bean. Can you do this the normal way? No.\u003c/p\u003e\n\n\n\n\u003cp\u003eSpring Debugger changes that by letting you:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAuto-complete all loaded beans in the expression evaluator.\u003c/li\u003e\n\n\n\n\u003cli\u003eInvoke any method on any bean on the fly.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdcBBP4bfMrowE3G0HCPvaVdQK2Cxbg1mNYoeAAxAOL7YE5SRkQVitxo2YXB-HNKji3Wz2ri45VEfYnKJqFApR7ieBGQKOaiihHgx6sasJv3WXDyi47FJP-_PSH-8MmsIL0j1zk?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe process of bean evaluation is getting better: We can evaluate any configuration property value right in the debugger. All we need to do is select the evaluator on the right side.¬†\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcCslrh_inD11HBBE7fh-OSh6TpNoBE1kbIjUuVkkSo4j3WKWAkcHFe0npvj_d4LRJNLVqC1H4P7rLkU-5JA7GIazuYf8X1KY0_MKkE4Of5eF0_PHchZZNlVGuDNYZz5kbpYxt5rg?key=LvQR1ZdOOW3a1cEaOR6hqg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt‚Äôs like a REPL for your Spring context. You can poke, prod, simulate, and confirm behavior without restarting the app or adding test code.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eFor curious developers: How it works internally¬†\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eSpring Debugger doesn‚Äôt require Spring Boot Actuator or any additional runtime agent. All data is analyzed locally without any network calls, data sharing, or risks of leakage, ensuring full privacy. Under the hood, the plugin uses non-suspending \u003ca href=\"https://www.jetbrains.com/help/idea/using-breakpoints.html#suspend_policy\" target=\"_blank\" rel=\"noopener\"\u003ebreakpoints\u003c/a\u003e set inside the Spring Boot framework libraries. During application startup, after the context is loaded, Spring Debugger gathers information from the debug session, memory heap, and stack trace. This lets it access ‚Äúraw‚Äù internal application data without relying on external libraries.\u003c/p\u003e\n\n\n\n\u003cp\u003eThanks to the IntelliJ IDEA Debugger API, we were able to invoke required methods from Spring Boot libraries, build an application runtime model, and display it in the IDE.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Spring Debugger project also led to an extension of the debugger‚Äôs evaluator API, allowing us to add property evaluators alongside the standard Java one. In the future, we may extend this further to evaluate not just properties but also SpEL, SQL, or similar expressions.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eSummary\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eSpring Boot is powerful, but its abstractions can be hard to debug. Spring Debugger turns IntelliJ IDEA into a lens that sees through those layers. It‚Äôs designed to keep you productive, improve code quality, and clarify real-world problems, all while offering ultimate comfort in your daily workflow.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBeans, configs, and contexts ‚Äì visually decoded.\u003c/li\u003e\n\n\n\n\u003cli\u003eTransactions ‚Äì made traceable.\u003c/li\u003e\n\n\n\n\u003cli\u003eProperties ‚Äì unmasked and source-mapped.\u003c/li\u003e\n\n\n\n\u003cli\u003eDatabases ‚Äì auto-detected and accessible.\u003c/li\u003e\n\n\n\n\u003cli\u003eEvaluator ‚Äì context-aware and interactive.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe debugger doesn‚Äôt undermine the ‚Äúmagic‚Äù of the Spring. It lets you understand and control it. Simply run your app in debug mode and see what‚Äôs really happening.\u003c/p\u003e\n\n\n\n\u003cp\u003eTry it now! \u003ca href=\"https://plugins.jetbrains.com/plugin/25302-spring-debugger\" target=\"_blank\" rel=\"noopener\"\u003eInstall Spring Debugger\u003c/a\u003e and make Spring internals visible. \u003ca href=\"https://www.jetbrains.com/help/idea/spring-debugger.html\" target=\"_blank\" rel=\"noopener\"\u003eDocumentation\u003c/a\u003e is available to help you get started.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eWe value your feedback!¬† Feel free to share your thoughts via plugin reviews or in the comments.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eHappy coding!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
