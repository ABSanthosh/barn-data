{
  "id": "ae48af90-6cd8-4996-8ad2-360b020862fe",
  "title": "Beyond prompt crafting: How to be a better partner for your AI pair programmer",
  "link": "https://github.blog/ai-and-ml/github-copilot/beyond-prompt-crafting-how-to-be-a-better-partner-for-your-ai-pair-programmer/",
  "description": "Ensuring quality code suggestions from Copilot goes beyond the perfect prompt. Context is key to success when working with your AI pair programmer. The post Beyond prompt crafting: How to be a better partner for your AI pair programmer appeared first on The GitHub Blog.",
  "author": "Christopher Harrison",
  "published": "Wed, 09 Jul 2025 16:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "AI \u0026 ML",
    "GitHub Copilot"
  ],
  "byline": "Christopher Harrison",
  "length": 13638,
  "excerpt": "Ensuring quality code suggestions from Copilot goes beyond the perfect prompt. Context is key to success when working with your AI pair programmer.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "When a developer first starts working with GitHub Copilot there‚Äôs (rightly) a focus on prompt crafting ‚Äî or the art of providing good context and information to generate quality suggestions.¬† But context goes beyond typing out a couple of lines into Copilot Chat in VS Code. We want to ensure Copilot is considering the right files when performing operations, that these files are easy for Copilot to read, and that we provide Copilot any extra guidance it may need about the project or specific task.¬† So let‚Äôs explore taking the next step beyond prompt crafting, and think about how we can be a better partner for our AI pair programmer. Context is key I always like to talk about context by starting with a story. The other day my partner and I woke up and she said, ‚ÄúLet‚Äôs go to brunch!‚Äù Fantastic! Who doesn‚Äôt love brunch?¬† I recommended a spot, one of our favorites, and she said, ‚ÄúYou know‚Ä¶ we‚Äôve been there quite a bit lately. I‚Äôd like to try something different.‚Äù I recommended another spot to which she replied, ‚ÄúNow that I‚Äôm thinking about it, I really want waffles. Let‚Äôs find somewhere that does good waffles.‚Äù This conversation is, of course, pretty normal. My partner asked a question, I responded, she provided more context, and back and forth we went. All of my suggestions were perfectly reasonable based on the information I had, and when she didn‚Äôt hear what she was expecting she provided a bit more guidance. As we continued talking, she realized she had a craving for waffles, which she discovered as she considered my suggestions. This is very much how we both talk with other people, but also how we approach working with generative AI tools, including Copilot. We ask questions, get answers, and work back and forth providing more context and making decisions based on what we see.¬† If we don‚Äôt receive the suggestions we‚Äôre expecting, or if something isn‚Äôt built to the specs we had in mind, it‚Äôs very likely Copilot didn‚Äôt have the context it needed ‚Äî just as I didn‚Äôt have the context to suggest somewhere new when I started the conversation with my partner. How GitHub Copilot works with code To understand how Copilot in the IDE gets its context, it‚Äôs important to understand how it works. Except for agent mode, which performs external tasks, Copilot doesn‚Äôt build or run the code as it generates code suggestions. In fact, it behaves very similarly to, well, a pair programmer. It reads the code (and comments) of the files we‚Äôve pointed it at just as another developer would.¬† But unlike a teammate, Copilot doesn‚Äôt have ‚Äúinstitutional knowledge,‚Äù or the background information that comes with experience (although you can add custom instructions, but more on that later). This could be the history of why things were built a certain way (which isn‚Äôt documented somewhere but everyone just ‚Äúknows‚Äù üôÑ), that an internal library or framework that should always be used, or patterns that need to be followed. Obviously, all of this background info is important to get the right code suggestions from Copilot. If we‚Äôre using a data abstraction layer (DAL), for instance, but Copilot is generating raw SQL code, the suggestions aren‚Äôt going to be that helpful.¬† The problem isn‚Äôt that Copilot is generating invalid code. Instead, it‚Äôs lacking the context to generate the code in the format and structure we need. Basically, we want waffles and it‚Äôs giving us an omelette. Let‚Äôs see what we can do to get waffles. There‚Äôs a common belief that quality code shouldn‚Äôt need comments, and that adding comments is a ‚Äúcode smell,‚Äù or an indication that something could be improved. While it‚Äôs noble to strive to write code that‚Äôs as readable as possible, it‚Äôs something we often fall short of in our day-to-day work. Even when we do ‚Äúhit the mark‚Äù, we need to remember that just because code might be readable to one developer, it doesn‚Äôt mean it‚Äôs readable to all developers. A couple of lines of comments can go a long way to ensuring readability. The same holds true for Copilot! As we highlighted above, Copilot doesn‚Äôt run or compile your code except in specific situations. Instead, it ‚Äúreads‚Äù your code much like a developer would.¬† Following the guidelines for having docstrings in functions/modules in Python, for example, can help ensure Copilot has a better understanding of what the code does and how it does it. This allows Copilot to generate higher-quality suggestions by using your existing code to ensure any new code follows the same patterns and practices already in place. üí° Pro tip: When you open a file, it‚Äôs always a good idea to leave it in a better state than when you found it. One of the little improvements you could make is to add a few comments to places to help describe the code. You could always ask Copilot to generate the first draft of the comments, and you can add any additional details Copilot missed! The benefit of using custom instructions with GitHub Copilot on your projects To generate quality suggestions, Copilot benefits from having context around what you‚Äôre doing and how you‚Äôre doing it. Knowing the technology and frameworks you‚Äôre using, what coding standards to follow, and even some background on what you‚Äôre building helps Copilot raise the quality bar on its suggestions. This is where custom instructions come into play. Custom instructions help you provide all of this background information and set ground rules (things like what APIs you want to call, naming patterns you want followed, or even stylistic preferences).¬† To get started, you place everything that‚Äôs important into a file named copilot-instructions.md inside your .github folder. It‚Äôs a markdown file, so you can create sections like Project structure, Technologies, Coding standards, and any other notes you want Copilot to consider on every single chat request. You can also add any guidance on tasks where you see Copilot not always choosing the right path, like maybe using class-based React components instead of function-based components (all the cool kids are using function based-components). Keep in mind that custom instructions are sent to Copilot on every single chat request. You want to keep your instructions limited to information that‚Äôs relevant to the entire project. Providing too many details can make it a bit harder for Copilot to determine what‚Äôs important. In simpler terms, you can basically think about the one friend you have who maybe shares too much detail when they‚Äôre telling a story, and how it can make it tricky to focus on the main plot points. It‚Äôs the same thing with Copilot. Provide some project-level guidance and overviews, so it best understands the environment in which it‚Äôs working. A good rule of thumb is to have sections that highlight the various aspects of your project. An outline for a monorepo with a client and server for a web app might look like this: # Tailspin Toys Crowd Funding Website for crowd funding for games. ## Backend The backend is written using: - Flask for the API - SQLAlchemy for the ORM - SQLite for the database ## Frontend The frontend is written using: - Astro for routing - Svelte for the components and interactivity - Tailwind CSS for styling ## Code standards - Use good variable names, avoiding abbreviations and single letter variables - Use the casing standard for the language in question (camelCasing for TypeScript, snake_casing for Python, etc.) - Use type hints in all languages which support them ## Project structure - `client` contains the frontend code - `docs` contains the documentation for the project - `scripts` contains the scripts used to install services, start the app, and run tests - `server` contains the backend code This is relatively abbreviated, but notice the structure. We‚Äôre telling Copilot about the project we have, its structure, the techs in use, and some guidance about how we want our code to be created. We don‚Äôt have anything specific to tasks, like maybe writing unit tests, because we have another way to tell Copilot that information! Providing specific instructions for specific tasks Continuing our conversation about instruction files‚Ä¶ (I‚Äôm Gen-X, so I‚Äôm required to use the Gen-X ellipsis at least once.) VS Code and Codespaces also support .instructions.md files. These are just like the copilot-instructions.md file we spoke about previously, only they‚Äôre designed to be used for specific types of tasks and placed in .github/instructions. Consider a project where you‚Äôre building out Flask Blueprints for the routes for an API. There might be requirements around how the file should be structured and how unit tests should be created. You can create a custom instructions file called flask-endpoint.instructions.md, place it in .github/instructions, then add it as context to the chat when you request Copilot to create a new endpoint. It might look something like: # Endpoint creation guidelines ## Endpoint notes - Endpoints are created in Flask using blueprints - Create a centralized function for accessing data - All endpoints require tests - Use the `unittest` module for testing - All tests must pass - A script is provided to run tests at `scripts/run-server-tests.sh` ## Project notes - The Python virtual environment is located in the root of the project in a **venv** folder - Register all blueprints in `server/app.py` - Use the [test instructions](./python-tests.instructions.md) when creating tests ## Prototype files - [Endpoint prototype](../../server/routes/games.py) - [Tests prototype](../../server/tests/test_games.py) Notice how we‚Äôre providing specific information about how we want our endpoints created. You‚Äôll also notice we‚Äôre even linking out to other files in the project using hyperlinks ‚Äî both existing files for Copilot to use as representative examples, and other instructions files for more information. Additionally, you can also apply instructions to file types based on a pattern. Let‚Äôs take the tests for example. If they were all located in server/tests, and started with test_, you could add metadata to the top to ensure Copilot always includes the instructions when working on a test file: --- applyTo: server/tests/test_*.py --- This gives you a lot of flexibility in ensuring Copilot is able to access the right information at the right time. This can be done explicitly by adding in the instructions file, or implicitly by providing a pattern for Copilot to use when building certain files. Just as before, these are artifacts in your repository. It can take some time to build a collection of instruction files, but that investment will pay off in the form of higher-quality code and, in turn, improved productivity. Fully reusable prompts The VS Code team recently published a new, experimental feature called prompt files. Because they‚Äôre still in development I don‚Äôt want to dig too deep into them, but you can read more about prompt files in the docs and see how to utilize them as they are currently implemented. In a nutshell, they allow you to effectively create scripted prompts for Copilot. You can choose the Copilot modes they‚Äôre available in (ask, edit and agent), the tools to be called, and what questions to ask the developer. These can be created by the team for enhanced reuse and consistency. Extending GitHub Copilot‚Äôs capabilities with Model Context Protocol (MCP) In an ever changing software development landscape, we need to ensure the information we‚Äôre working with is accurate, relevant, and up to date. This is what MCP, or Model Context Protocol, is built for! Developed initially by Anthropic, MCP is an open source protocol that lets organizations expose their services or data to generative AI tools.¬† When you add an MCP server to your IDE, you allow Copilot to ‚Äúphone a friend‚Äù to find information, or even perform tasks on your behalf. For example, the Playwright MCP server helps create Playwright end-to-end tests, while the GitHub MCP server provides access to GitHub services like repositories, issues, and pull requests. Let‚Äôs say, for instance, that you added the Playwright MCP server to your IDE. When you ask Copilot to create a new test to validate functionality on your website, Copilot can consult an authoritative source, allowing it to generate the best code it can. You can even create your own MCP servers! One question I commonly hear is about how you can allow Copilot to look through an internal codebase or suite of libraries. With a custom MCP server, you could provide a facade for Copilot to perform these types of queries, then utilize the information discovered to suggest code based on your internal environment. MCP is large enough to have its own blog post, which my colleague Cassidy wrote, sharing tips, tricks, and insights about MCP. Thinking beyond prompts Let me be clear: prompt crafting is important. It‚Äôs one of the first skills any developer should learn when they begin using GitHub Copilot.¬† But writing a good prompt is only one piece Copilot considers when generating an answer. By using the best practices highlighted above ‚Äî comments and good code, custom instructions, and MCP servers ‚Äî you can help Copilot understand what you want it to do and how you want it to do it. To bring it back to my analogy, you can ensure Copilot knows when you want waffles instead of omelettes. And on that note, I‚Äôm off to brunch. Get started with GitHub Copilot \u003e Written by Senior Developer Advocate, GitHub",
  "image": "https://github.blog/wp-content/uploads/2025/06/wallpaper-copilot-generic-logo-dark.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eWhen a developer first starts working with \u003ca href=\"https://github.com/features/copilot\"\u003eGitHub Copilot\u003c/a\u003e there‚Äôs (rightly) a focus on prompt crafting ‚Äî or the art of providing good context and information to generate quality suggestions.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eBut context goes beyond typing out a couple of lines into Copilot Chat in VS Code. We want to ensure Copilot is considering the right files when performing operations, that these files are easy for Copilot to read, and that we provide Copilot any extra guidance it may need about the project or specific task.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eSo let‚Äôs explore taking the next step beyond prompt crafting, and think about how we can be a better partner for our AI pair programmer.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-context-is-key\"\u003eContext is key\u003c/h2\u003e\n\n\n\n\u003cp\u003eI always like to talk about context by starting with a story. The other day my partner and I woke up and she said, ‚ÄúLet‚Äôs go to brunch!‚Äù Fantastic! Who doesn‚Äôt love brunch?¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eI recommended a spot, one of our favorites, and she said, ‚ÄúYou know‚Ä¶ we‚Äôve been there quite a bit lately. I‚Äôd like to try something different.‚Äù I recommended another spot to which she replied, ‚ÄúNow that I‚Äôm thinking about it, I really want waffles. Let‚Äôs find somewhere that does good waffles.‚Äù\u003c/p\u003e\n\n\n\n\u003cp\u003eThis conversation is, of course, pretty normal. My partner asked a question, I responded, she provided more context, and back and forth we went. All of my suggestions were perfectly reasonable based on the information I had, and when she didn‚Äôt hear what she was expecting she provided a bit more guidance. As we continued talking, she realized she had a craving for waffles, which she discovered as she considered my suggestions.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is very much how we both talk with other people, but also how we approach working with generative AI tools, including Copilot. We ask questions, get answers, and work back and forth providing more context and making decisions based on what we see.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eIf we don‚Äôt receive the suggestions we‚Äôre expecting, or if something isn‚Äôt built to the specs we had in mind, it‚Äôs very likely Copilot didn‚Äôt have the context it needed ‚Äî just as I didn‚Äôt have the context to suggest somewhere new when I started the conversation with my partner.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-how-github-copilot-works-with-code\"\u003eHow GitHub Copilot works with code\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo understand how Copilot in the IDE gets its context, it‚Äôs important to understand how it works. Except for \u003ca href=\"https://github.blog/news-insights/product-news/from-pair-to-peer-programmer-our-vision-for-agentic-workflows-in-github-copilot/\"\u003eagent mode, which performs external tasks\u003c/a\u003e, Copilot doesn‚Äôt build or run the code as it generates code suggestions. In fact, it behaves very similarly to, well, a pair programmer. It reads the code (and comments) of the files we‚Äôve pointed it at just as another developer would.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eBut unlike a teammate, Copilot doesn‚Äôt have ‚Äúinstitutional knowledge,‚Äù or the background information that comes with experience (although \u003ca href=\"https://docs.github.com/en/copilot/how-tos/custom-instructions/adding-repository-custom-instructions-for-github-copilot\"\u003eyou can add custom instructions\u003c/a\u003e, but more on that later). This could be the history of why things were built a certain way (which isn‚Äôt documented somewhere but everyone just ‚Äúknows‚Äù üôÑ), that an internal library or framework that should always be used, or patterns that need to be followed.\u003c/p\u003e\n\n\n\n\u003cp\u003eObviously, all of this background info is important to get the right code suggestions from Copilot. If we‚Äôre using a data abstraction layer (DAL), for instance, but Copilot is generating raw SQL code, the suggestions aren‚Äôt going to be that helpful.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eThe problem isn‚Äôt that Copilot is generating invalid code. Instead, it‚Äôs lacking the context to generate the code in the format and structure we need. Basically, we want waffles and it‚Äôs giving us an omelette. Let‚Äôs see what we can do to get waffles.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThere‚Äôs a common belief that quality code shouldn‚Äôt need comments, and that adding comments is a ‚Äúcode smell,‚Äù or an indication that something could be improved. While it‚Äôs noble to strive to write code that‚Äôs as readable as possible, it‚Äôs something we often fall short of in our day-to-day work.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven when we do ‚Äúhit the mark‚Äù, we need to remember that just because code might be readable to one developer, it doesn‚Äôt mean it‚Äôs readable to all developers. A couple of lines of comments can go a long way to ensuring readability.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe same holds true for Copilot! As we highlighted above, Copilot doesn‚Äôt run or compile your code except in specific situations. Instead, it ‚Äúreads‚Äù your code much like a developer would.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eFollowing the guidelines for having \u003ca href=\"https://peps.python.org/pep-0257/\"\u003edocstrings\u003c/a\u003e in functions/modules in Python, for example, can help ensure Copilot has a better understanding of what the code does and how it does it. This allows Copilot to generate higher-quality suggestions by using your existing code to ensure any new code follows the same patterns and practices already in place.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003eüí° \u003cstrong\u003ePro tip\u003c/strong\u003e: \u003cstrong\u003eWhen you open a file, it‚Äôs always a good idea to leave it in a better state than when you found it\u003c/strong\u003e. One of the little improvements you could make is to add a few comments to places to help describe the code. You could always ask Copilot to generate the first draft of the comments, and you can add any additional details Copilot missed!\u003c/p\u003e\u003c/figure\u003e\n\n\n\n\u003ch2 id=\"the-benefit-of-using-custom-instructions-with-github-copilot-on-your-projects\"\u003eThe benefit of using custom instructions with GitHub Copilot on your projects\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo generate quality suggestions, Copilot benefits from having context around what you‚Äôre doing and how you‚Äôre doing it. Knowing the technology and frameworks you‚Äôre using, what coding standards to follow, and even some background on what you‚Äôre building helps Copilot raise the quality bar on its suggestions. This is where \u003ca href=\"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot\"\u003ecustom instructions\u003c/a\u003e come into play.\u003c/p\u003e\n\n\n\n\u003cp\u003eCustom instructions help you provide all of this background information and set ground rules (things like what APIs you want to call, naming patterns you want followed, or even stylistic preferences).¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eTo get started, you place everything that‚Äôs important into a file named \u003cstrong\u003ecopilot-instructions.md\u003c/strong\u003e inside your \u003cstrong\u003e.github\u003c/strong\u003e folder. It‚Äôs a markdown file, so you can create sections like \u003cstrong\u003eProject structure\u003c/strong\u003e, \u003cstrong\u003eTechnologies\u003c/strong\u003e, \u003cstrong\u003eCoding standards\u003c/strong\u003e, and any other notes you want Copilot to consider on every single chat request. You can also add any guidance on tasks where you see Copilot not always choosing the right path, like maybe using class-based React components instead of function-based components (all the cool kids are using function based-components).\u003c/p\u003e\n\n\n\n\u003cp\u003eKeep in mind that custom instructions are sent to Copilot on \u003cstrong\u003eevery single\u003c/strong\u003e chat request. You want to keep your instructions limited to information that‚Äôs relevant to the entire project. Providing too many details can make it a bit harder for Copilot to determine what‚Äôs important.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn simpler terms, you can basically think about the one friend you have who maybe shares too much detail when they‚Äôre telling a story, and how it can make it tricky to focus on the main plot points. It‚Äôs the same thing with Copilot. Provide some project-level guidance and overviews, so it best understands the environment in which it‚Äôs working.\u003c/p\u003e\n\n\n\n\u003cp\u003eA good rule of thumb is to have sections that highlight the various aspects of your project. An outline for a monorepo with a client and server for a web app might look like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e# Tailspin Toys Crowd Funding\n\nWebsite for crowd funding for games.\n\n## Backend\n\nThe backend is written using:\n\n- Flask for the API\n- SQLAlchemy for the ORM\n- SQLite for the database\n\n## Frontend\n\nThe frontend is written using:\n\n- Astro for routing\n- Svelte for the components and interactivity\n- Tailwind CSS for styling\n\n## Code standards\n\n- Use good variable names, avoiding abbreviations and single letter variables\n- Use the casing standard for the language in question (camelCasing for TypeScript, snake_casing for Python, etc.)\n- Use type hints in all languages which support them\n\n## Project structure\n\n- `client` contains the frontend code\n- `docs` contains the documentation for the project\n- `scripts` contains the scripts used to install services, start the app, and run tests\n- `server` contains the backend code \u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is relatively abbreviated, but notice the structure. We‚Äôre telling Copilot about the project we have, its structure, the techs in use, and some guidance about how we want our code to be created. We don‚Äôt have anything specific to tasks, like maybe writing unit tests, because we have another way to tell Copilot that information!\u003c/p\u003e\n\n\n\n\u003ch2 id=\"providing-specific-instructions-for-specific-tasks\"\u003eProviding specific instructions for specific tasks\u003c/h2\u003e\n\n\n\n\u003cp\u003eContinuing our conversation about instruction files‚Ä¶ (I‚Äôm Gen-X, so \u003ca href=\"https://www.reddit.com/r/GenX/comments/108t56v/so_umm_theres_that/\"\u003eI‚Äôm required to use the Gen-X ellipsis at least once\u003c/a\u003e.)\u003c/p\u003e\n\n\n\n\u003cp\u003eVS Code and Codespaces also support \u003ca href=\"https://code.visualstudio.com/docs/copilot/copilot-customization#_use-instructionsmd-files\"\u003e\u003ccode\u003e.instructions.md\u003c/code\u003e\u003c/a\u003e files. These are just like the \u003ccode\u003ecopilot-instructions.md\u003c/code\u003e file we spoke about previously, only they‚Äôre designed to be used for specific types of tasks and placed in \u003ccode\u003e.github/instructions\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eConsider a project where you‚Äôre building out \u003ca href=\"https://flask.palletsprojects.com/en/stable/blueprints/\"\u003eFlask Blueprints\u003c/a\u003e for the routes for an API. There might be requirements around how the file should be structured and how unit tests should be created. You can create a custom instructions file called \u003ccode\u003eflask-endpoint.instructions.md\u003c/code\u003e, place it in \u003ccode\u003e.github/instructions\u003c/code\u003e, then add it as context to the chat when you request Copilot to create a new endpoint. It might look something like:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e# Endpoint creation guidelines\n\n## Endpoint notes\n\n- Endpoints are created in Flask using blueprints\n- Create a centralized function for accessing data\n- All endpoints require tests\n    - Use the `unittest` module for testing\n    - All tests must pass\n    - A script is provided to run tests at `scripts/run-server-tests.sh`\n\n## Project notes\n\n- The Python virtual environment is located in the root of the project in a **venv** folder\n- Register all blueprints in `server/app.py`\n- Use the [test instructions](./python-tests.instructions.md) when creating tests\n\n## Prototype files\n\n- [Endpoint prototype](../../server/routes/games.py)\n- [Tests prototype](../../server/tests/test_games.py)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNotice how we‚Äôre providing specific information about how we want our endpoints created. You‚Äôll also notice we‚Äôre even linking out to other files \u003cstrong\u003ein the project\u003c/strong\u003e using hyperlinks ‚Äî both existing files for Copilot to use as representative examples, and other instructions files for more information.\u003c/p\u003e\n\n\n\n\u003cp\u003eAdditionally, you can also apply instructions to file types based on a pattern. Let‚Äôs take the tests for example. If they were all located in \u003ccode\u003eserver/tests\u003c/code\u003e, and started with \u003ccode\u003etest_\u003c/code\u003e, you could add metadata to the top to ensure Copilot always includes the instructions when working on a test file:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e---\napplyTo: server/tests/test_*.py\n---\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis gives you a lot of flexibility in ensuring Copilot is able to access the right information at the right time. This can be done explicitly by adding in the instructions file, or implicitly by providing a pattern for Copilot to use when building certain files.\u003c/p\u003e\n\n\n\n\u003cp\u003eJust as before, these are artifacts in your repository. It can take some time to build a collection of instruction files, but that investment will pay off in the form of higher-quality code and, in turn, improved productivity.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"fully-reusable-prompts\"\u003eFully reusable prompts\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe VS Code team recently published a new, experimental feature called prompt files. Because they‚Äôre still in development I don‚Äôt want to dig too deep into them, but you can read more about \u003ca href=\"https://code.visualstudio.com/docs/copilot/copilot-customization#_prompt-files-experimental\"\u003eprompt files in the docs\u003c/a\u003e and see how to utilize them as they are currently implemented. In a nutshell, they allow you to effectively create scripted prompts for Copilot. You can choose the Copilot modes they‚Äôre available in (ask, edit and agent), the tools to be called, and what questions to ask the developer. These can be created by the team for enhanced reuse and consistency.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"extending-github-copilots-capabilities-with-model-context-protocol-mcp\"\u003eExtending GitHub Copilot‚Äôs capabilities with Model Context Protocol (MCP)\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn an ever changing software development landscape, we need to ensure the information we‚Äôre working with is accurate, relevant, and up to date. This is what MCP, or Model Context Protocol, is built for! Developed initially by Anthropic, MCP is an open source protocol that lets organizations expose their services or data to generative AI tools.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you add an MCP server to your IDE, you allow Copilot to ‚Äúphone a friend‚Äù to find information, or even perform tasks on your behalf. For example, the \u003ca href=\"https://github.com/microsoft/playwright-mcp\"\u003ePlaywright MCP server\u003c/a\u003e helps create \u003ca href=\"https://playwright.dev/\"\u003ePlaywright\u003c/a\u003e end-to-end tests, while the \u003ca href=\"https://github.com/github/github-mcp-server\"\u003eGitHub MCP server\u003c/a\u003e provides access to GitHub services like repositories, issues, and pull requests.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet‚Äôs say, for instance, that you added the Playwright MCP server to your IDE. When you ask Copilot to create a new test to validate functionality on your website, Copilot can consult an authoritative source, allowing it to generate the best code it can.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can even create your own MCP servers! One question I commonly hear is about how you can allow Copilot to look through an internal codebase or suite of libraries. With a custom MCP server, you could provide a facade for Copilot to perform these types of queries, then utilize the information discovered to suggest code based on your internal environment.\u003c/p\u003e\n\n\n\n\u003cp\u003eMCP is large enough to have its own blog post, which my colleague Cassidy wrote, sharing \u003ca href=\"https://github.blog/ai-and-ml/llms/what-the-heck-is-mcp-and-why-is-everyone-talking-about-it/\"\u003etips, tricks, and insights about MCP\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"thinking-beyond-prompts\"\u003eThinking beyond prompts\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet me be clear: prompt crafting is important. It‚Äôs one of the first skills any developer should learn when they begin using GitHub Copilot.¬†\u003c/p\u003e\n\n\n\n\u003cp\u003eBut writing a good prompt is only one piece Copilot considers when generating an answer. By using the best practices highlighted above ‚Äî comments and good code, custom instructions, and MCP servers ‚Äî you can help Copilot understand what you want it to do and how you want it to do it. To bring it back to my analogy, you can ensure Copilot knows when you want waffles instead of omelettes.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd on that note, I‚Äôm off to brunch.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eGet started\u003c/strong\u003e with \u003ca href=\"https://github.com/features/copilot\"\u003eGitHub Copilot \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/6109729?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/6109729?v=4\u0026amp;s=200\" alt=\"Christopher Harrison\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSenior Developer Advocate, GitHub\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-07-09T16:00:00Z",
  "modifiedTime": null
}
