{
  "id": "d09006bd-7747-4bef-9932-6d618c8fa152",
  "title": "SwiftUI views versus modifiers",
  "link": "https://www.swiftbysundell.com/articles/swiftui-views-versus-modifiers",
  "description": "What’s really the difference between building a piece of UI as a view versus a modifier, and how to choose between those two solutions?",
  "author": "",
  "published": "Mon, 27 Feb 2023 11:05:00 +0100",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 11230,
  "excerpt": "What’s really the difference between building a piece of UI as a view versus a modifier, and how to choose between those two solutions?",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "One of the most interesting aspects of SwiftUI, at least from an architectural perspective, is how it essentially treats views as data. After all, a SwiftUI view isn’t a direct representation of the pixels that are being rendered on the screen, but rather a description of how a given piece of UI should work, look, and behave.That very data-driven approach gives us a ton of flexibility when it comes to how we structure our view code — to the point where one might even start to question what the difference actually is between defining a piece of UI as a view type, versus implementing that same code as a modifier instead.Take the following FeaturedLabel view as an example — it adds a leading star image to a given text, and also applies a specific foreground color and font to make that text stand out as being “featured”:struct FeaturedLabel: View { var text: String var body: some View { HStack { Image(systemName: \"star\") Text(text) } .foregroundColor(.orange) .font(.headline) } }While the above may look like a typical custom view, the exact same rendered UI could just as easily be achieved using a “modifier-like” View protocol extension instead — like this:extension View { func featured() -\u003e some View { HStack { Image(systemName: \"star\") self } .foregroundColor(.orange) .font(.headline) } }Here’s what those two different solutions look like side-by-side when placed within an example ContentView:struct ContentView: View { var body: some View { VStack { // View-based version: FeaturedLabel(text: \"Hello, world!\") // Modifier-based version: Text(\"Hello, world!\").featured() } } }One key difference between our two solutions, though, is that the latter can be applied to any view, while the former only enables us to create String-based featured labels. That’s something that we could address, though, by turning our FeaturedLabel into a custom container view that accepts any kind of View-conforming content, rather than just a plain string:struct FeaturedLabel\u003cContent: View\u003e: View { @ViewBuilder var content: () -\u003e Content var body: some View { HStack { Image(systemName: \"star\") content() } .foregroundColor(.orange) .font(.headline) } }Above we’re adding the ViewBuilder attribute to our content closure in order to enable the full power of SwiftUI’s view building API to be used at each call site (which, for example, lets us use if and switch statements when building the content for each FeaturedLabel).We might still want to make it easy to initialize a FeaturedLabel instance with a string, though, rather than always having to pass a closure containing a Text view. Thankfully, that’s something that we can easily make possible using a type-constrained extension:extension FeaturedLabel where Content == Text { init(_ text: String) { self.init { Text(text) } } }Above we’re using an underscore to remove the external parameter label for text, to mimic the way SwiftUI’s own, built-in convenience APIs work for types like Button and NavigationLink.With those changes in place, both of our two solutions now have the exact same amount of flexibility, and can easily be used to create both text-based labels, as well as labels that render any kind of SwiftUI view that we want:struct ContentView: View { @State private var isToggleOn = false var body: some View { VStack { // Using texts: Group { // View-based version: FeaturedLabel(\"Hello, world!\") // Modifier-based version: Text(\"Hello, world!\").featured() } // Using toggles: Group { // View-based version: FeaturedLabel { Toggle(\"Toggle\", isOn: $isToggleOn) } // Modifier-based version: Toggle(\"Toggle\", isOn: $isToggleOn).featured() } } } }So at this point, we might really start to ask ourselves — what exactly is the difference between defining a piece of UI as a view versus a modifier? Is there really any practical differences at all, besides code style and structure?Well, what about state? Let’s say that we wanted to make our new featured labels automatically fade in when they first appear? That would require us to define something like a @State-marked opacity property that we’d then animate over using an onAppear closure — for example like this:struct FeaturedLabel\u003cContent: View\u003e: View { @ViewBuilder var content: () -\u003e Content @State private var opacity = 0.0 var body: some View { HStack { Image(systemName: \"star\") content() } .foregroundColor(.orange) .font(.headline) .opacity(opacity) .onAppear { withAnimation { opacity = 1 } } } }At first, participating in the SwiftUI state management system might seem like something that only proper view types can do, but it turns out that modifiers have the exact same capability — as long as we define such a modifier as a proper ViewModifier-conforming type, rather than just using a View protocol extension:struct FeaturedModifier: ViewModifier { @State private var opacity = 0.0 func body(content: Content) -\u003e some View { HStack { Image(systemName: \"star\") content } .foregroundColor(.orange) .font(.headline) .opacity(opacity) .onAppear { withAnimation { opacity = 1 } } } }With the above in place, we can now replace our previous featured method implementation with a call to add our new FeaturedModifier to the current view — and both of our two featured label approaches will once again have the exact same end result:extension View { func featured() -\u003e some View { modifier(FeaturedModifier()) } }Also worth noting is that when wrapping our code within a ViewModifier type, that code is lazily evaluated when needed, rather than being executed up-front when the modifier is first added, which could make a difference performance-wise in certain situations.So, regardless of whether we want to change the styles or structure of a view, or introduce a new piece of state, it’s starting to become clear that SwiftUI views and modifiers have the exact same capabilities. But that brings us to the next question — if there are no practical differences between the two approaches, how do we choose between them?At least to me, it all comes down to the structure of the resulting view hierarchy. Although we were, technically, changing the view hierarchy when wrapping one of our featured labels within an HStack in order to add our star image, conceptually, that was more about styling than it was about structure. When applying the featured modifier to a view, its layout or placement within the view hierarchy didn’t really change in any meaningful way — it still just remained a single view with the exact same kind of overall layout, at least from a high-level perspective.That’s not always the case, though. So let’s take a look at another example which should illustrate the potential structural differences between views and modifiers a bit more clearly.Here we’ve written a SplitView container, which takes two views — one leading, and one trailing — and then renders them side-by-side with a divider between them, while also maximizing their frames so that they’ll end up splitting the available space equally:struct SplitView\u003cLeading: View, Trailing: View\u003e: View { @ViewBuilder var leading: () -\u003e Leading @ViewBuilder var trailing: () -\u003e Trailing var body: some View { HStack { prepareSubview(leading()) Divider() prepareSubview(trailing()) } } private func prepareSubview(_ view: some View) -\u003e some View { view.frame(maxWidth: .infinity, maxHeight: .infinity) } }Just like before, we could definitely achieve the exact same result using a modifier-based approach instead — which could look like this:extension View { func split(with trailingView: some View) -\u003e some View { HStack { maximize() Divider() trailingView.maximize() } } func maximize() -\u003e some View { frame(maxWidth: .infinity, maxHeight: .infinity) } }However, if we once again put our two solutions next to each other within the same example ContentView, then we can start to see that this time the two approaches do look quite different in terms of structure and clarity:struct ContentView: View { var body: some View { VStack { // View-based version: SplitView(leading: { Text(\"Leading\") }, trailing: { Text(\"Trailing\") }) // Modifier-based version: Text(\"Leading\").split(with: Text(\"Trailing\")) } } }Looking at the view-based call site above, it’s very clear that our two texts are being wrapped within a container, and it’s also easy to tell which of those two texts will end up being the leading versus trailing view.That same thing can’t really be said for the modifier-based version this time, though, which really requires us to know that the view that we’re applying the modifier to will end up in the leading slot. Plus, we can’t really tell that those two texts will end up being wrapped in some kind of container at all. It looks more like we’re styling the leading label using the trailing label somehow, which really isn’t the case.While we could attempt to solve that clarity problem with more verbose API naming, the core issue would still remain — that the modifier-based version doesn’t properly show what the resulting view hierarchy will be in this case. So, in situations like the one above, when we’re wrapping multiple siblings within a parent container, opting for a view-based solution will often give us a much clearer end result.On the flip side, if all that we’re doing is applying a set of styles to a single view, then implementing that as either a “modifier-like” extension, or using a proper ViewModifier type, will most often be the way to go. And for everything in between — such as our earlier “featured label” example — it all really comes down to code style and personal preference as to which solution will be the best fit for each given project.Just look at how SwiftUI’s built-in API was designed — containers (such as HStack and VStack) are views, while styling APIs (such as padding and foregroundColor) are implemented as modifiers. So, if we follow that same approach as much as possible within our own projects, then we’ll likely end up with UI code that feels consistent and inline with SwiftUI itself.I hope that you found this article interesting and useful. Feel free to find me on Mastodon, or contact me via email, if you have any questions, comments, or feedback.Thanks for reading!",
  "image": "https://www.swiftbysundell.com/images/articles/swiftui-views-versus-modifiers.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eOne of the most interesting aspects of SwiftUI, at least from an architectural perspective, is how it essentially treats views as data. After all, a SwiftUI view isn’t a direct representation of the pixels that are being rendered on the screen, but rather a \u003cem\u003edescription\u003c/em\u003e of how a given piece of UI should work, look, and behave.\u003c/p\u003e\u003cp\u003eThat very data-driven approach gives us a ton of flexibility when it comes to how we structure our view code — to the point where one might even start to question what the difference actually is between defining a piece of UI as a view type, versus implementing that same code as a modifier instead.\u003c/p\u003e\u003cp\u003eTake the following \u003ccode\u003eFeaturedLabel\u003c/code\u003e view as an example — it adds a leading star image to a given text, and also applies a specific foreground color and font to make that text stand out as being “featured”:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e FeaturedLabel: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e text: \u003cspan\u003eString\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003eText\u003c/span\u003e(text)\n        }\n        .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003eorange\u003c/span\u003e)\n        .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003eheadline\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile the above may look like a typical custom view, the exact same rendered UI could just as easily be achieved using a “modifier-like” \u003ccode\u003eView\u003c/code\u003e protocol extension instead — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e featured() -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003e\u003cspan\u003eself\u003c/span\u003e\u003c/span\u003e\n        }\n        .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003eorange\u003c/span\u003e)\n        .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003eheadline\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere’s what those two different solutions look like side-by-side when placed within an example \u003ccode\u003eContentView\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e ContentView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e {\n            \u003cspan\u003e// View-based version:\u003c/span\u003e\n            \u003cspan\u003eFeaturedLabel\u003c/span\u003e(text: \u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e)\n\n            \u003cspan\u003e// Modifier-based version:\u003c/span\u003e\n            \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e).\u003cspan\u003efeatured\u003c/span\u003e()\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne key difference between our two solutions, though, is that the latter can be applied to \u003cem\u003eany view\u003c/em\u003e, while the former only enables us to create \u003ccode\u003eString\u003c/code\u003e-based featured labels. That’s something that we could address, though, by turning our \u003ccode\u003eFeaturedLabel\u003c/code\u003e into a custom container view that accepts any kind of \u003ccode\u003eView\u003c/code\u003e-conforming content, rather than just a plain string:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e FeaturedLabel\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@ViewBuilder var\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003e\u003cspan\u003econtent\u003c/span\u003e()\u003c/span\u003e\n        }\n        .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003eorange\u003c/span\u003e)\n        .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003eheadline\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAbove we’re adding the \u003ccode\u003eViewBuilder\u003c/code\u003e attribute to our \u003ccode\u003econtent\u003c/code\u003e closure in order to enable the full power of SwiftUI’s view building API to be used at each call site (which, for example, lets us use \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e statements when building the content for each \u003ccode\u003eFeaturedLabel\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eWe might still want to make it easy to initialize a \u003ccode\u003eFeaturedLabel\u003c/code\u003e instance with a string, though, rather than always having to pass a closure containing a \u003ccode\u003eText\u003c/code\u003e view. Thankfully, that’s something that we can easily make possible using a type-constrained extension:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eFeaturedLabel\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ewhere\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e == \u003cspan\u003eText\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003einit\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e text: \u003cspan\u003eString\u003c/span\u003e) {\n        \u003cspan\u003eself\u003c/span\u003e.\u003cspan\u003einit\u003c/span\u003e {\n            \u003cspan\u003eText\u003c/span\u003e(text)\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAbove we’re using an underscore to remove the external parameter label for \u003ccode\u003etext\u003c/code\u003e, to mimic the way SwiftUI’s own, built-in convenience APIs work for types like \u003ccode\u003eButton\u003c/code\u003e and \u003ccode\u003eNavigationLink\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWith those changes in place, both of our two solutions now have the exact same amount of flexibility, and can easily be used to create both text-based labels, as well as labels that render any kind of SwiftUI view that we want:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e ContentView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@State private var\u003c/span\u003e isToggleOn = \u003cspan\u003efalse\n\n    var\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e {\n            \u003cspan\u003e// Using texts:\u003c/span\u003e\n            \u003cspan\u003eGroup\u003c/span\u003e {\n                \u003cspan\u003e// View-based version:\u003c/span\u003e\n                \u003cspan\u003eFeaturedLabel\u003c/span\u003e(\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e)\n\n                \u003cspan\u003e// Modifier-based version:\u003c/span\u003e\n                \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e).\u003cspan\u003efeatured\u003c/span\u003e()\n            }\n\n            \u003cspan\u003e// Using toggles:\u003c/span\u003e\n            \u003cspan\u003eGroup\u003c/span\u003e {\n                \u003cspan\u003e// View-based version:\u003c/span\u003e\n                \u003cspan\u003eFeaturedLabel\u003c/span\u003e {\n                    \u003cspan\u003eToggle\u003c/span\u003e(\u003cspan\u003e\u0026#34;Toggle\u0026#34;\u003c/span\u003e, isOn: \u003cspan\u003e$isToggleOn\u003c/span\u003e)\n                }\n\n                \u003cspan\u003e// Modifier-based version:\u003c/span\u003e\n                \u003cspan\u003eToggle\u003c/span\u003e(\u003cspan\u003e\u0026#34;Toggle\u0026#34;\u003c/span\u003e, isOn: \u003cspan\u003e$isToggleOn\u003c/span\u003e).\u003cspan\u003efeatured\u003c/span\u003e()\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo at this point, we might \u003cem\u003ereally\u003c/em\u003e start to ask ourselves — what exactly is the difference between defining a piece of UI as a view versus a modifier? Is there really any practical differences at all, besides code style and structure?\u003c/p\u003e\u003cp\u003eWell, what about state? Let’s say that we wanted to make our new featured labels automatically fade in when they first appear? That would require us to define something like a \u003ccode\u003e@State\u003c/code\u003e-marked \u003ccode\u003eopacity\u003c/code\u003e property that we’d then animate over using an \u003ccode\u003eonAppear\u003c/code\u003e closure — for example like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e FeaturedLabel\u0026lt;Content: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e content: () -\u0026gt; \u003cspan\u003eContent\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003e@State private var\u003c/span\u003e opacity = \u003cspan\u003e0.0\u003c/span\u003e\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n            \u003cspan\u003econtent\u003c/span\u003e()\n        }\n        .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003eorange\u003c/span\u003e)\n        .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003eheadline\u003c/span\u003e)\n        \u003cspan\u003e.\u003cspan\u003eopacity\u003c/span\u003e(opacity)\n.\u003cspan\u003eonAppear\u003c/span\u003e {\n    \u003cspan\u003ewithAnimation\u003c/span\u003e {\n        opacity = \u003cspan\u003e1\u003c/span\u003e\n    }\n}\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt first, participating in the SwiftUI state management system might seem like something that only proper view types can do, but it turns out that modifiers have the exact same capability — as long as we define such a modifier as a proper \u003ccode\u003eViewModifier\u003c/code\u003e-conforming type, rather than just using a \u003ccode\u003eView\u003c/code\u003e protocol extension:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e FeaturedModifier: \u003cspan\u003eViewModifier\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003e@State private var\u003c/span\u003e opacity = \u003cspan\u003e0.0\u003c/span\u003e\u003c/span\u003e\n\n    \u003cspan\u003efunc\u003c/span\u003e body(content: \u003cspan\u003eContent\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eImage\u003c/span\u003e(systemName: \u003cspan\u003e\u0026#34;star\u0026#34;\u003c/span\u003e)\n            content\n        }\n        .\u003cspan\u003eforegroundColor\u003c/span\u003e(.\u003cspan\u003eorange\u003c/span\u003e)\n        .\u003cspan\u003efont\u003c/span\u003e(.\u003cspan\u003eheadline\u003c/span\u003e)\n        \u003cspan\u003e.\u003cspan\u003eopacity\u003c/span\u003e(opacity)\n.\u003cspan\u003eonAppear\u003c/span\u003e {\n    \u003cspan\u003ewithAnimation\u003c/span\u003e {\n        opacity = \u003cspan\u003e1\u003c/span\u003e\n    }\n}\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the above in place, we can now replace our previous \u003ccode\u003efeatured\u003c/code\u003e method implementation with a call to add our new \u003ccode\u003eFeaturedModifier\u003c/code\u003e to the current view — and both of our two featured label approaches will once again have the exact same end result:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e featured() -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003emodifier\u003c/span\u003e(\u003cspan\u003eFeaturedModifier\u003c/span\u003e())\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlso worth noting is that when wrapping our code within a \u003ccode\u003eViewModifier\u003c/code\u003e type, that code is lazily evaluated when needed, rather than being executed up-front when the modifier is first added, which could make a difference performance-wise in certain situations.\u003c/p\u003e\u003cp\u003eSo, regardless of whether we want to change the styles or structure of a view, or introduce a new piece of state, it’s starting to become clear that SwiftUI views and modifiers have the exact same capabilities. But that brings us to the next question — if there are no practical differences between the two approaches, how do we choose between them?\u003c/p\u003e\u003cp\u003eAt least to me, it all comes down to the \u003cem\u003estructure\u003c/em\u003e of the resulting view hierarchy. Although we were, technically, changing the view hierarchy when wrapping one of our featured labels within an \u003ccode\u003eHStack\u003c/code\u003e in order to add our star image, conceptually, that was more about \u003cem\u003estyling\u003c/em\u003e than it was about structure. When applying the \u003ccode\u003efeatured\u003c/code\u003e modifier to a view, its layout or placement within the view hierarchy didn’t really change in any meaningful way — it still just remained a single view with the exact same kind of overall layout, at least from a high-level perspective.\u003c/p\u003e\u003cp\u003eThat’s not always the case, though. So let’s take a look at another example which should illustrate the potential structural differences between views and modifiers a bit more clearly.\u003c/p\u003e\u003cp\u003eHere we’ve written a \u003ccode\u003eSplitView\u003c/code\u003e container, which takes two views — one leading, and one trailing — and then renders them side-by-side with a divider between them, while also maximizing their frames so that they’ll end up splitting the available space equally:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e SplitView\u0026lt;Leading: \u003cspan\u003eView\u003c/span\u003e, Trailing: \u003cspan\u003eView\u003c/span\u003e\u0026gt;: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e leading: () -\u0026gt; \u003cspan\u003eLeading\u003c/span\u003e\n    \u003cspan\u003e@ViewBuilder var\u003c/span\u003e trailing: () -\u0026gt; \u003cspan\u003eTrailing\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003eprepareSubview\u003c/span\u003e(\u003cspan\u003eleading\u003c/span\u003e())\n            \u003cspan\u003eDivider\u003c/span\u003e()\n            \u003cspan\u003eprepareSubview\u003c/span\u003e(\u003cspan\u003etrailing\u003c/span\u003e())\n        }\n    }\n\n    \u003cspan\u003eprivate func\u003c/span\u003e prepareSubview(\u003cspan\u003e_\u003c/span\u003e view: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        view.\u003cspan\u003eframe\u003c/span\u003e(maxWidth: .\u003cspan\u003einfinity\u003c/span\u003e, maxHeight: .\u003cspan\u003einfinity\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJust like before, we could definitely achieve the exact same result using a modifier-based approach instead — which could look like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e split(with trailingView: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e) -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eHStack\u003c/span\u003e {\n            \u003cspan\u003emaximize\u003c/span\u003e()\n            \u003cspan\u003eDivider\u003c/span\u003e()\n            trailingView.\u003cspan\u003emaximize\u003c/span\u003e()\n        }\n    }\n\n    \u003cspan\u003efunc\u003c/span\u003e maximize() -\u0026gt; \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eframe\u003c/span\u003e(maxWidth: .\u003cspan\u003einfinity\u003c/span\u003e, maxHeight: .\u003cspan\u003einfinity\u003c/span\u003e)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, if we once again put our two solutions next to each other within the same example \u003ccode\u003eContentView\u003c/code\u003e, then we can start to see that this time the two approaches do look quite different in terms of structure and clarity:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e ContentView: \u003cspan\u003eView\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e body: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e {\n        \u003cspan\u003eVStack\u003c/span\u003e {\n            \u003cspan\u003e// View-based version:\u003c/span\u003e\n            \u003cspan\u003eSplitView\u003c/span\u003e(leading: {\n                \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Leading\u0026#34;\u003c/span\u003e)\n            }, trailing: {\n                \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Trailing\u0026#34;\u003c/span\u003e)\n            })\n\n            \u003cspan\u003e// Modifier-based version:\u003c/span\u003e\n            \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Leading\u0026#34;\u003c/span\u003e).\u003cspan\u003esplit\u003c/span\u003e(with: \u003cspan\u003eText\u003c/span\u003e(\u003cspan\u003e\u0026#34;Trailing\u0026#34;\u003c/span\u003e))\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLooking at the view-based call site above, it’s very clear that our two texts are being wrapped within a container, and it’s also easy to tell which of those two texts will end up being the leading versus trailing view.\u003c/p\u003e\u003cp\u003eThat same thing can’t really be said for the modifier-based version this time, though, which really requires us to know that the view that we’re \u003cem\u003eapplying\u003c/em\u003e the modifier to will end up in the leading slot. Plus, we can’t really tell that those two texts will end up being wrapped in some kind of container at all. It looks more like we’re styling the leading label using the trailing label somehow, which really isn’t the case.\u003c/p\u003e\u003cp\u003eWhile we could attempt to solve that clarity problem with more verbose API naming, the core issue would still remain — that the modifier-based version doesn’t properly show what the resulting view hierarchy will be in this case. So, in situations like the one above, when we’re wrapping multiple siblings within a parent container, opting for a view-based solution will often give us a much clearer end result.\u003c/p\u003e\u003cp\u003eOn the flip side, if all that we’re doing is applying a set of styles to a single view, then implementing that as either a “modifier-like” extension, or using a proper \u003ccode\u003eViewModifier\u003c/code\u003e type, will most often be the way to go. And for everything in between — such as our earlier “featured label” example — it all really comes down to code style and personal preference as to which solution will be the best fit for each given project.\u003c/p\u003e\u003cp\u003eJust look at how SwiftUI’s built-in API was designed — containers (such as \u003ccode\u003eHStack\u003c/code\u003e and \u003ccode\u003eVStack\u003c/code\u003e) are views, while styling APIs (such as \u003ccode\u003epadding\u003c/code\u003e and \u003ccode\u003eforegroundColor\u003c/code\u003e) are implemented as modifiers. So, if we follow that same approach as much as possible within our own projects, then we’ll likely end up with UI code that feels consistent and inline with SwiftUI itself.\u003c/p\u003e\u003cp\u003eI hope that you found this article interesting and useful. Feel free to \u003ca href=\"https://mastodon.social/@johnsundell\"\u003efind me on Mastodon\u003c/a\u003e, or \u003ca href=\"https://www.swiftbysundell.com/contact\"\u003econtact me via email\u003c/a\u003e, if you have any questions, comments, or feedback.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
