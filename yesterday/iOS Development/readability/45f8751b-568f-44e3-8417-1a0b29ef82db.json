{
  "id": "45f8751b-568f-44e3-8417-1a0b29ef82db",
  "title": "SwiftUI Self-Sizing Flow Layouts",
  "link": "https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/",
  "description": "The UIKit combination of UICollectionView and the UICollectionViewFlowLayout gives a lot of flexibility and control to build grid-like flow layouts. How do we do that with SwiftUI? Self-Sizing Flow Layouts The UICollectionViewFlowLayout documentation describes a flow layout as laying out a collection of items using a fixed distance in one direction and a scrollable distance in the other. For example, a vertically scrolling layout where cells flow from one row to the next, each row containing as many cells as fit in the available width. One such example I find useful is a card layout where the cards are of equal size, but sized to fit the largest content in the cells (within some minimum/maximum constraints). For example, this card style layout on an 11\" iPad, shown in landscape. At default text sizes this produces a grid with seven columns and five rows. As the text size increases the card size increases and the layout adjusts. At the largest accessibility sizes this produces a grid with three columns and eleven rows. The flow layout also adjusts for the size of the container so on an iPhone the grid reduces to two columns, scrolling vertically: Let’s look at how we could build a similar layout with SwiftUI. SwiftUI Layout Protocol (iOS 16) Apple introduced the Layout protocol back in iOS 16. It has two required methods: // Return the size of the composite view, given a // proposed size and the view's subviews. sizeThatFits(proposal:subviews:cache:) // Assigns positions to each of the layout's subviews. placeSubviews(in:proposal:subviews:cache:) The first method calculates the overall size of the layout. It roughly compares to the UICollectionViewDelegateFlowLayout method to calculate the size of each item: // Asks the delegate for the size of the specified item's cell. collectionView(_:layout:sizeForItemAt:) To get started, let’s create a conforming type with some view metrics for padding, margins, and width constraints: struct CardLayout: Layout { private enum ViewMetrics { static let padding: CGFloat = 8 static let margin: CGFloat = 8 static let minimumWidth: CGFloat = 150 static let maximumWidth: CGFloat = 400 static let aspectRatio: CGFloat = 1.5 } } The Ideal Size The sizeThatFits method gets a proposed view size from the parent view, a collection of proxies for the subviews to layout, and an optional cache for calculated data. I’m going to ignore the cache for now, and return early with zero size if we have no subviews to layout: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) -\u003e CGSize { guard !subviews.isEmpty else { return .zero } // calculate size... } The proposal from the parent view is of type ProposedViewSize, a struct with an optional width and height. Apple’s documentation mentions that the parent view can call this method more than once with different proposals: A proposal of .zero size for the layout’s minimum size. A proposal of .infinity size for the layout’s maximum size. A proposal of .unspecified for the layout’s ideal size. I’m always going to ask my subviews for their ideal size. Since I need to do that more than once I’ve created a utility method: private func fittingSize(subviews: Subviews) -\u003e CGSize { // Return size of subviews } We start my mapping over our collection of subviews asking each for their ideal size: let sizes = subviews.map { $0.sizeThatFits(.unspecified) } Then I’ll use the maximum width and height from the ideal sizes of my subviews: var fittingSize: CGSize = sizes.reduce(.zero) { currentMax, size in CGSize( width: max(currentMax.width, size.width), height: max(currentMax.height, size.height) ) } Now I’ll apply some constraints on my card size. I’ve chosen suitable view metrics for my expected content but my card text can still be truncated. First enforcing the aspect ratio: if fittingSize.width / fittingSize.height \u003e ViewMetrics.aspectRatio { fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } else { fittingSize.width = fittingSize.height * ViewMetrics.aspectRatio } Then the minimum width, maintaining the aspect ratio: if fittingSize.width \u003c ViewMetrics.minimumWidth { fittingSize.width = ViewMetrics.minimumWidth fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } Finally, I limit the card to a maximum width: if fittingSize.width \u003e ViewMetrics.maximumWidth { fittingSize.width = ViewMetrics.maximumWidth fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } We now have our “ideal” card size: return fittingSize } There’s one more constraint I want to apply to my cards which is enforce that they are never wider than any proposed width from the container view. If the parent has proposed a width, we limit our card size so that it fits within the margins, maintaining the aspect ratio: private func maxSize( fittingSize: CGSize, containerProposal: ProposedViewSize) -\u003e CGSize { guard let containerWidth = containerProposal.width else { return fittingSize } let maxWidth = containerWidth - 2 * ViewMetrics.margin if fittingSize.width \u003e maxWidth { return CGSize( width: maxWidth, height: maxWidth / ViewMetrics.aspectRatio) } return fittingSize } Now we have the size of the cards we can calculate how many columns we need from the card width, desired padding and margins: private func cardsInRow( cardSize: CGSize, proposal: ProposedViewSize) -\u003e Int { let bounds = proposal.replacingUnspecifiedDimensions() let cardsInRow = Int( (bounds.width + ViewMetrics.padding - 2 * ViewMetrics.margin) / (cardSize.width + ViewMetrics.padding) ) return cardsInRow } Note that to convert any optional height or width in the proposed size to a default value (10) using replacingUnspecifiedDimensions(). Then to find out how many rows we need: private func cardsInColumn( cardsInRow: Int, totalCards: Int) -\u003e Int { Int(ceil(Double(totalCards) / Double(cardsInRow))) } With that work done we can complete our size that fits method, calculating the overall container size: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout Void ) -\u003e CGSize { guard !subviews.isEmpty else { return .zero } let fittingSize = fittingSize(subviews: subviews) let maxSize = maxSize( fittingSize: fittingSize, containerProposal: proposal) let cardsInRow: Int = cardsInRow( cardSize: maxSize, proposal: proposal) let cardsInColumn = cardsInColumn( cardsInRow: cardsInRow, totalCards: subviews.count) let width = 2 * ViewMetrics.margin + CGFloat(cardsInRow) * (maxSize.width + ViewMetrics.padding) - ViewMetrics.padding let height = 2 * ViewMetrics.margin + CGFloat(cardsInColumn) * (maxSize.height + ViewMetrics.padding) - ViewMetrics.padding return CGSize(width: width, height: height) } Placing Views The second required Layout method positions each of the subviews in the bounds of the container: func placeSubviews( in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) { guard !subviews.isEmpty else { return } // Position subviews } The bounds rectangle matches a size we returned from the sizeThatFits method. We need to recalculate our fitting size and again check our card size fits in the container bounds: let fittingSize = fittingSize(subviews: subviews) let boundsProposal = ProposedViewSize( width: bounds.width, height: bounds.height) let maxSize = maxSize( fittingSize: fittingSize, containerProposal: boundsProposal) We inset our starting position to allow for the margin: var nextX = bounds.minX + ViewMetrics.margin var nextY = bounds.minY + ViewMetrics.margin Now we iterate over the subviews calling the place(at:anchor:proposal:) method to tell each subview where to position itself. We propose our ideal size to each card: let placementProposal = ProposedViewSize( width: maxSize.width, height: maxSize.height) for index in subviews.indices { subviews[index].place( at: CGPoint(x: nextX, y: nextY), anchor: .topLeading, proposal: placementProposal) nextX += maxSize.width + ViewMetrics.padding if nextX + ViewMetrics.margin \u003e bounds.maxX { nextX = bounds.minX + ViewMetrics.margin nextY += maxSize.height + ViewMetrics.padding } } } Note that I’m placing each subview at the top-leading anchor. I’m using a fixed padding between the views. You can ask each subview for its preferred spacing: let spacing = subviews[index].spacing.distance( to: subviews[index + 1].spacing, along: .horizontal) Caching Apple recommends implementing caching only if profiling shows that it improves performance. For the small datasets I’m using I haven’t seen any need but you can implement the makeCache method. For example, to cache the result of my cards fitting size: struct CacheData { let fittingSize: CGSize } func makeCache(subviews: Subviews) -\u003e CacheData { let fittingSize = fittingSize(subviews: subviews) return CacheData(fittingSize: fittingSize) } There’s also an updateCache method that SwiftUI calls anytime the layout container or subviews change. The default implementation calls the makeCache method to recreate the cache. Don’t forget to change the type of the cache parameter to both layout methods: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData ) -\u003e CGSize { ... } func placeSubviews( in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData ) { ... } Finally, I can replace the call to fittingSize in each method to use the cached value: // let fittingSize = fittingSize(subviews: subviews) let fittingSize = cache.fittingSize Using the Layout To use my card layout I’ll place it in a vertical scroll view and pass it a collection of CardView views: struct ContentView: View { var body: some View { ScrollView { CardLayout { ForEach(Cards.all) { card in CardView(card: card) } } } } } Apple added some improvements to iOS 18 to build a custom container view but that’s for another time. Learn More WWDC22 Compose custom layouts with SwiftUI WWDC24 Demystify SwiftUI containers SwiftUI Self-Sizing Flow Layouts was originally posted 04 Nov 2024 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 04 Nov 2024 13:26:41 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 10417,
  "excerpt": "How do you build flexible grid-like flow layouts with SwiftUI?",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "The UIKit combination of UICollectionView and the UICollectionViewFlowLayout gives a lot of flexibility and control to build grid-like flow layouts. How do we do that with SwiftUI? Self-Sizing Flow Layouts The UICollectionViewFlowLayout documentation describes a flow layout as laying out a collection of items using a fixed distance in one direction and a scrollable distance in the other. For example, a vertically scrolling layout where cells flow from one row to the next, each row containing as many cells as fit in the available width. One such example I find useful is a card layout where the cards are of equal size, but sized to fit the largest content in the cells (within some minimum/maximum constraints). For example, this card style layout on an 11\" iPad, shown in landscape. At default text sizes this produces a grid with seven columns and five rows. As the text size increases the card size increases and the layout adjusts. At the largest accessibility sizes this produces a grid with three columns and eleven rows. The flow layout also adjusts for the size of the container so on an iPhone the grid reduces to two columns, scrolling vertically: Let’s look at how we could build a similar layout with SwiftUI. SwiftUI Layout Protocol (iOS 16) Apple introduced the Layout protocol back in iOS 16. It has two required methods: // Return the size of the composite view, given a // proposed size and the view's subviews. sizeThatFits(proposal:subviews:cache:) // Assigns positions to each of the layout's subviews. placeSubviews(in:proposal:subviews:cache:) The first method calculates the overall size of the layout. It roughly compares to the UICollectionViewDelegateFlowLayout method to calculate the size of each item: // Asks the delegate for the size of the specified item's cell. collectionView(_:layout:sizeForItemAt:) To get started, let’s create a conforming type with some view metrics for padding, margins, and width constraints: struct CardLayout: Layout { private enum ViewMetrics { static let padding: CGFloat = 8 static let margin: CGFloat = 8 static let minimumWidth: CGFloat = 150 static let maximumWidth: CGFloat = 400 static let aspectRatio: CGFloat = 1.5 } } The Ideal Size The sizeThatFits method gets a proposed view size from the parent view, a collection of proxies for the subviews to layout, and an optional cache for calculated data. I’m going to ignore the cache for now, and return early with zero size if we have no subviews to layout: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) -\u003e CGSize { guard !subviews.isEmpty else { return .zero } // calculate size... } The proposal from the parent view is of type ProposedViewSize, a struct with an optional width and height. Apple’s documentation mentions that the parent view can call this method more than once with different proposals: A proposal of .zero size for the layout’s minimum size. A proposal of .infinity size for the layout’s maximum size. A proposal of .unspecified for the layout’s ideal size. I’m always going to ask my subviews for their ideal size. Since I need to do that more than once I’ve created a utility method: private func fittingSize(subviews: Subviews) -\u003e CGSize { // Return size of subviews } We start my mapping over our collection of subviews asking each for their ideal size: let sizes = subviews.map { $0.sizeThatFits(.unspecified) } Then I’ll use the maximum width and height from the ideal sizes of my subviews: var fittingSize: CGSize = sizes.reduce(.zero) { currentMax, size in CGSize( width: max(currentMax.width, size.width), height: max(currentMax.height, size.height) ) } Now I’ll apply some constraints on my card size. I’ve chosen suitable view metrics for my expected content but my card text can still be truncated. First enforcing the aspect ratio: if fittingSize.width / fittingSize.height \u003e ViewMetrics.aspectRatio { fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } else { fittingSize.width = fittingSize.height * ViewMetrics.aspectRatio } Then the minimum width, maintaining the aspect ratio: if fittingSize.width \u003c ViewMetrics.minimumWidth { fittingSize.width = ViewMetrics.minimumWidth fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } Finally, I limit the card to a maximum width: if fittingSize.width \u003e ViewMetrics.maximumWidth { fittingSize.width = ViewMetrics.maximumWidth fittingSize.height = fittingSize.width / ViewMetrics.aspectRatio } We now have our “ideal” card size: There’s one more constraint I want to apply to my cards which is enforce that they are never wider than any proposed width from the container view. If the parent has proposed a width, we limit our card size so that it fits within the margins, maintaining the aspect ratio: private func maxSize( fittingSize: CGSize, containerProposal: ProposedViewSize) -\u003e CGSize { guard let containerWidth = containerProposal.width else { return fittingSize } let maxWidth = containerWidth - 2 * ViewMetrics.margin if fittingSize.width \u003e maxWidth { return CGSize( width: maxWidth, height: maxWidth / ViewMetrics.aspectRatio) } return fittingSize } Now we have the size of the cards we can calculate how many columns we need from the card width, desired padding and margins: private func cardsInRow( cardSize: CGSize, proposal: ProposedViewSize) -\u003e Int { let bounds = proposal.replacingUnspecifiedDimensions() let cardsInRow = Int( (bounds.width + ViewMetrics.padding - 2 * ViewMetrics.margin) / (cardSize.width + ViewMetrics.padding) ) return cardsInRow } Note that to convert any optional height or width in the proposed size to a default value (10) using replacingUnspecifiedDimensions(). Then to find out how many rows we need: private func cardsInColumn( cardsInRow: Int, totalCards: Int) -\u003e Int { Int(ceil(Double(totalCards) / Double(cardsInRow))) } With that work done we can complete our size that fits method, calculating the overall container size: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout Void ) -\u003e CGSize { guard !subviews.isEmpty else { return .zero } let fittingSize = fittingSize(subviews: subviews) let maxSize = maxSize( fittingSize: fittingSize, containerProposal: proposal) let cardsInRow: Int = cardsInRow( cardSize: maxSize, proposal: proposal) let cardsInColumn = cardsInColumn( cardsInRow: cardsInRow, totalCards: subviews.count) let width = 2 * ViewMetrics.margin + CGFloat(cardsInRow) * (maxSize.width + ViewMetrics.padding) - ViewMetrics.padding let height = 2 * ViewMetrics.margin + CGFloat(cardsInColumn) * (maxSize.height + ViewMetrics.padding) - ViewMetrics.padding return CGSize(width: width, height: height) } Placing Views The second required Layout method positions each of the subviews in the bounds of the container: func placeSubviews( in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) { guard !subviews.isEmpty else { return } // Position subviews } The bounds rectangle matches a size we returned from the sizeThatFits method. We need to recalculate our fitting size and again check our card size fits in the container bounds: let fittingSize = fittingSize(subviews: subviews) let boundsProposal = ProposedViewSize( width: bounds.width, height: bounds.height) let maxSize = maxSize( fittingSize: fittingSize, containerProposal: boundsProposal) We inset our starting position to allow for the margin: var nextX = bounds.minX + ViewMetrics.margin var nextY = bounds.minY + ViewMetrics.margin Now we iterate over the subviews calling the place(at:anchor:proposal:) method to tell each subview where to position itself. We propose our ideal size to each card: let placementProposal = ProposedViewSize( width: maxSize.width, height: maxSize.height) for index in subviews.indices { subviews[index].place( at: CGPoint(x: nextX, y: nextY), anchor: .topLeading, proposal: placementProposal) nextX += maxSize.width + ViewMetrics.padding if nextX + ViewMetrics.margin \u003e bounds.maxX { nextX = bounds.minX + ViewMetrics.margin nextY += maxSize.height + ViewMetrics.padding } } } Note that I’m placing each subview at the top-leading anchor. I’m using a fixed padding between the views. You can ask each subview for its preferred spacing: let spacing = subviews[index].spacing.distance( to: subviews[index + 1].spacing, along: .horizontal) Caching Apple recommends implementing caching only if profiling shows that it improves performance. For the small datasets I’m using I haven’t seen any need but you can implement the makeCache method. For example, to cache the result of my cards fitting size: struct CacheData { let fittingSize: CGSize } func makeCache(subviews: Subviews) -\u003e CacheData { let fittingSize = fittingSize(subviews: subviews) return CacheData(fittingSize: fittingSize) } There’s also an updateCache method that SwiftUI calls anytime the layout container or subviews change. The default implementation calls the makeCache method to recreate the cache. Don’t forget to change the type of the cache parameter to both layout methods: func sizeThatFits( proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData ) -\u003e CGSize { ... } func placeSubviews( in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData ) { ... } Finally, I can replace the call to fittingSize in each method to use the cached value: // let fittingSize = fittingSize(subviews: subviews) let fittingSize = cache.fittingSize Using the Layout To use my card layout I’ll place it in a vertical scroll view and pass it a collection of CardView views: struct ContentView: View { var body: some View { ScrollView { CardLayout { ForEach(Cards.all) { card in CardView(card: card) } } } } } Apple added some improvements to iOS 18 to build a custom container view but that’s for another time. Learn More WWDC22 Compose custom layouts with SwiftUI WWDC24 Demystify SwiftUI containers",
  "image": "https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eThe UIKit combination of UICollectionView and the UICollectionViewFlowLayout gives a lot of flexibility and control to build grid-like flow layouts. How do we do that with SwiftUI?\u003c/p\u003e\n\u003ch3 id=\"self-sizing-flow-layouts\"\u003eSelf-Sizing Flow Layouts\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eUICollectionViewFlowLayout\u003c/code\u003e documentation describes a \u003cstrong\u003eflow layout\u003c/strong\u003e as laying out a collection of items using a fixed distance in one direction and a scrollable distance in the other. For example, a vertically scrolling layout where cells flow from one row to the next, each row containing as many cells as fit in the available width.\u003c/p\u003e\n\u003cp\u003eOne such example I find useful is a card layout where the cards are of equal size, but sized to fit the largest content in the cells (within some minimum/maximum constraints).\u003c/p\u003e\n\u003cp\u003eFor example, this card style layout on an 11\u0026#34; iPad, shown in landscape. At default text sizes this produces a grid with seven columns and five rows. As the text size increases the card size increases and the layout adjusts. At the largest accessibility sizes this produces a grid with three columns and eleven rows.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/001.png\" alt=\"Three screenshots of an iPad in landscape with a grid of yellow numbered cards. The text and card sizes increase in each screenshot. The first shows a 7 by 5 grid of yellow cards, the second with a 6 by 6 grid, and the final with much larger cards so that only a 3 by four grid is visible.\" width=\"561\" height=\"140\" srcset=\"https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/001@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe flow layout also adjusts for the size of the container so on an iPhone the grid reduces to two columns, scrolling vertically:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/002.png\" alt=\"An iPhone, in portrait, show a grid of 2 by 7 yellow numbered cards. The last row of cards is only partially visible\" width=\"260\" height=\"518\" srcset=\"https://useyourloaf.com/blog/swiftui-self-sizing-flow-layouts/002@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s look at how we could build a similar layout with SwiftUI.\u003c/p\u003e\n\u003ch3 id=\"swiftui-layout-protocol-ios-16\"\u003eSwiftUI Layout Protocol (iOS 16)\u003c/h3\u003e\n\u003cp\u003eApple introduced the \u003ccode\u003eLayout\u003c/code\u003e protocol back in iOS 16. It has two required methods:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Return the size of the composite view, given a\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// proposed size and the view\u0026#39;s subviews.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Assigns positions to each of the layout\u0026#39;s subviews.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eplaceSubviews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe first method calculates the overall size of the layout. It roughly compares to the \u003ccode\u003eUICollectionViewDelegateFlowLayout\u003c/code\u003e method to calculate the size of each item:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// Asks the delegate for the size of the specified item\u0026#39;s cell.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ecollectionView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003elayout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003esizeForItemAt\u003c/span\u003e\u003cspan\u003e:)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo get started, let’s create a conforming type with some view metrics for padding, margins, and width constraints:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eCardLayout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLayout\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emargin\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eminimumWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e150\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emaximumWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003easpectRatio\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1.5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"the-ideal-size\"\u003eThe Ideal Size\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003esizeThatFits\u003c/code\u003e method gets a proposed view size from the parent view, a collection of proxies for the subviews to layout, and an optional cache for calculated data. I’m going to ignore the cache for now, and return early with zero size if we have no subviews to layout:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eVoid\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisEmpty\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// calculate size...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe proposal from the parent view is of type \u003ccode\u003eProposedViewSize\u003c/code\u003e,  a struct with an optional width and height. Apple’s documentation mentions that the parent view can call this method more than once with different proposals:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA proposal of \u003ccode\u003e.zero\u003c/code\u003e size for the layout’s \u003cstrong\u003eminimum\u003c/strong\u003e size.\u003c/li\u003e\n\u003cli\u003eA proposal of \u003ccode\u003e.infinity\u003c/code\u003e size for the layout’s \u003cstrong\u003emaximum\u003c/strong\u003e size.\u003c/li\u003e\n\u003cli\u003eA proposal of \u003ccode\u003e.unspecified\u003c/code\u003e for the layout’s \u003cstrong\u003eideal\u003c/strong\u003e size.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI’m always going to ask my subviews for their ideal size. Since I need to do that more than once I’ve created a utility method:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// Return size of subviews\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe start my mapping over our collection of subviews asking each for their ideal size:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esizes\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e$0\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003eunspecified\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThen I’ll use the maximum width and height from the ideal sizes of my subviews:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esizes\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereduce\u003c/span\u003e\u003cspan\u003e(.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ecurrentMax\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003esize\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emax\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrentMax\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emax\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrentMax\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow I’ll apply some constraints on my card size. I’ve chosen suitable view metrics for my expected content but my card text can still be truncated. First enforcing the aspect ratio:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThen the minimum width, maintaining the aspect ratio:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eminimumWidth\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eminimumWidth\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFinally, I limit the card to a maximum width:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emaximumWidth\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emaximumWidth\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe now have our “ideal” card size:\u003c/p\u003e\n\u003cp\u003eThere’s one more constraint I want to apply to my cards which is enforce that they are never wider than any proposed width from the container view. If the parent has proposed a width, we limit our card size so that it fits within the margins, maintaining the aspect ratio:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003econtainerProposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003econtainerWidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtainerProposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emaxWidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econtainerWidth\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003emaxWidth\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emaxWidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emaxWidth\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easpectRatio\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we have the size of the cards we can calculate how many columns we need from the card width, desired padding and margins:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecardSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ereplacingUnspecifiedDimensions\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecardSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote that to convert any optional height or width in the proposed size to a default value (10) using \u003ccode\u003ereplacingUnspecifiedDimensions()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThen to find out how many rows we need:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecardsInColumn\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003etotalCards\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eceil\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etotalCards\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith that work done we can complete our size that fits method, calculating the overall container size:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eVoid\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisEmpty\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e     \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e     \u003cspan\u003econtainerProposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecardSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecardsInColumn\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecardsInColumn\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etotalCards\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecardsInRow\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecardsInColumn\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"placing-views\"\u003ePlacing Views\u003c/h3\u003e\n\u003cp\u003eThe second required \u003ccode\u003eLayout\u003c/code\u003e method positions each of the subviews in the bounds of the container:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eplaceSubviews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eVoid\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisEmpty\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e// Position subviews\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe bounds rectangle matches a size we returned from the \u003ccode\u003esizeThatFits\u003c/code\u003e method. We need to recalculate our fitting size and again check our card size fits in the container bounds:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eboundsProposal\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainerProposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eboundsProposal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe inset our starting position to allow for the margin:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003enextX\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eminX\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003enextY\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eminY\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we iterate over the subviews calling the \u003ccode\u003eplace(at:anchor:proposal:)\u003c/code\u003e method to tell each subview where to position itself. We propose our ideal size to each card:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eplacementProposal\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eindices\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003eplace\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eat\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003enextX\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003enextY\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eanchor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etopLeading\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eplacementProposal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003enextX\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003enextX\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emaxX\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003enextX\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eminX\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emargin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003enextY\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003emaxSize\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eViewMetrics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNote that I’m placing each subview at the top-leading anchor. I’m using a fixed padding between the views. You can ask each subview for its preferred spacing:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003espacing\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ealong\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ehorizontal\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"caching\"\u003eCaching\u003c/h3\u003e\n\u003cp\u003eApple recommends implementing caching only if profiling shows that it improves performance. For the small datasets I’m using I haven’t seen any need but you can implement the \u003ccode\u003emakeCache\u003c/code\u003e method. For example, to cache the result of my cards fitting size:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eCacheData\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003emakeCache\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCacheData\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCacheData\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThere’s also an updateCache method that SwiftUI calls anytime the layout container or subviews change. The default implementation calls the makeCache method to recreate the cache.\u003c/p\u003e\n\u003cp\u003eDon’t forget to change the type of the cache parameter to both layout methods:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esizeThatFits\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eCacheData\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGSize\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eplaceSubviews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003ebounds\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eproposal\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eProposedViewSize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esubviews\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSubviews\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eCacheData\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFinally, I can replace the call to fittingSize in each method to use the cached value:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e//  let fittingSize = fittingSize(subviews: subviews)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efittingSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecache\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efittingSize\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"using-the-layout\"\u003eUsing the Layout\u003c/h3\u003e\n\u003cp\u003eTo use my card layout I’ll place it in a vertical scroll view and pass it a collection of CardView views:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eContentView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eScrollView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eCardLayout\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eForEach\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eCards\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eall\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ecard\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e          \u003cspan\u003eCardView\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecard\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecard\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eApple added some improvements to iOS 18 to build a custom container view but that’s for another time.\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2022/10056\"\u003eWWDC22 Compose custom layouts with SwiftUI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2024/10146/\"\u003eWWDC24 Demystify SwiftUI containers\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-11-04T13:26:41Z",
  "modifiedTime": "2024-11-06T15:45:50Z"
}
