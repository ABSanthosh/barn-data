{
  "id": "675a065a-0d86-4297-aa13-c5545ba0b505",
  "title": "Decoding Swift types that require additional data",
  "link": "https://www.swiftbysundell.com/articles/decoding-swift-types-that-require-additional-data",
  "description": "How Swift’s CodableWithConfiguration API can be used to inject additional, required data into a type’s decoding process, without having to use optionals or declare any additional decoding-specific types.",
  "author": "",
  "published": "Mon, 30 Jun 2025 15:35:00 +0200",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 9621,
  "excerpt": "How Swift’s CodableWithConfiguration API can be used to inject additional, required data into a type’s decoding process, without having to use optionals or declare any additional decoding-specific types.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "Swift’s Codable API — which consists of the Encodable protocol for encoding, and Decodable for decoding — offers a powerful, built-in mechanism for converting native Swift types to and from a serialized format, such as JSON. Thanks to its integration with the Swift compiler, we often don’t have to do any additional work to enable one of our types to become Codable, such as this Movie type:struct Movie: Identifiable, Codable { let id: UUID var title: String var releaseDate: Date var genre: Genre var directorName: String }Just by adding that Codable conformance (which is a type alias for both Encodable and Decodable), our above Movie type can now be serialized and deserialized automatically, as long as the data format (such as JSON) that we’re working with follows the same structure as our Swift type declaration.However, sometimes we might be working with a type that requires some additional data that’s not present in the JSON (or whichever data format we’re decoding from) in order to be initialized. For example, the following User type includes a favorites property — which is a Favorites value that contains the user’s favorites, such as their favorite director and movie genre:struct User: Identifiable { let id: UUID var name: String var membershipPoints: Int var favorites: Favorites } struct Favorites: Codable { var genre: Genre var directorName: String var movieIDs: [Movie.ID] }However, the JSON response that our app receives from the server when loading the data for a user doesn’t include the Favorites data, which instead need to be loaded from a separate server endpoint:// User server response: { \"id\": \"7CBE0CC1-7779-42E9-AAF1-C4B145F3CAE9\", \"name\": \"John Appleseed\", \"membershipPoints\": 192 } // Favorites server response: { \"genre\": \"action\", \"directorName\": \"Christopher Nolan\", \"movieIDs\": [ \"F028CAB5-74D7-4B86-8450-D0046C32DFA0\", \"D2657C95-1A35-446C-97D4-FAAA4783F2AA\", \"5159AF60-DF61-4A0C-A6BA-AE0E027E2BC2\" ] }Now the question is, how do we make User conform to Codable (or more specifically, Decodable) without being able to decode the required Favorites data from the server’s JSON response?One option would be to simply make the favorites property optional — but that would have several downsides. First, it would make our data model more fragile, as we could easily miss to populate that property when loading User values within various contexts (and the compiler wouldn’t be able to warn us about it). Second, and arguably more important, is that we’d constantly have to unwrap that optional favorites value every time we access it, leading to either extra boilerplate code (and potentially ambiguous states), or dangerous force unwrapping.Another, more robust option would be to use a secondary, partial model when decoding our User data, which we would then combine with a Favorites value in order to form our final model — like this:extension User { struct Partial: Decodable { let id: UUID var name: String var membershipPoints: Int } } struct Networking { var session = URLSession.shared ... func loadUser(withID id: User.ID) async throws -\u003e User { let favoritesURL = favoritesURLForUser(withID: id) let userURL = urlForUser(withID: id) // Load the user's favorites and the partial user data // that our server responds with: async let favorites = request(favoritesURL) as Favorites async let partialUser = request(userURL) as User.Partial // Form our final user model by combining the partial // model with the favorites that were loaded: return try await User( id: partialUser.id, name: partialUser.name, membershipPoints: partialUser.membershipPoints, favorites: favorites ) } ... private func request\u003cT: Decodable\u003e(_ url: URL) async throws -\u003e T { let (data, _) = try await session.data(from: url) return try JSONDecoder().decode(T.self, from: data) } }While the above works perfectly fine, it would be really nice to find a solution that doesn’t require us to duplicate all of our User model’s properties by declaring a separate, decoding-specific Partial model. Thankfully, the Swift Codable system* does actually include such a solution — the somewhat lesser known CodableWithConfiguration API.* CodableWithConfiguration is not technically a direct part of Codable, which is defined within Swift’s standard library, but is instead an extension defined within Foundation. That doesn’t make much of a difference when targeting any of Apple’s platforms, though.When a type conforms to either EncodableWithConfiguration or DecodableWithConfiguration, it requires an additional configuration value to be passed when either encoding or decoding it (and the compiler will enforce that requirement). That’s incredibly useful in situations such as when decoding our User type, since we can define that Favorites is the required DecodingConfiguration for our type — meaning that we can ensure that such a value will always be present during decoding, without having to declare any additional partial types.So let’s go ahead and update our User type to conform to DecodableWithConfiguration, which does require a manual decoding implementation, unfortunately:extension User: Encodable, DecodableWithConfiguration { enum CodingKeys: CodingKey { case id case name case membershipPoints } init(from decoder: Decoder, configuration: Favorites) throws { let container = try decoder.container(keyedBy: CodingKeys.self) id = try container.decode(UUID.self, forKey: .id) name = try container.decode(String.self, forKey: .name) membershipPoints = try container.decode( Int.self, forKey: .membershipPoints ) favorites = configuration } }So we still have to write a bit of boilerplate in order to enable our new decoding setup, but the advantage is that we can now make our networking code a lot simpler — all that we need is another overload of our private request method, which works with types conforming to DecodableWithConfiguration, and we’ll now be able to leverage type inference to make our decoding call site a lot simpler:struct Networking { ... func loadUser(withID id: User.ID) async throws -\u003e User { let favoritesURL = favoritesURLForUser(withID: id) let userURL = urlForUser(withID: id) return try await request(userURL, with: request(favoritesURL)) } ... private func request\u003cT: Decodable\u003e(_ url: URL) async throws -\u003e T { ... } private func request\u003cT: DecodableWithConfiguration\u003e( _ url: URL, with config: T.DecodingConfiguration ) async throws -\u003e T { let (data, _) = try await session.data(from: url) return try JSONDecoder().decode( T.self, from: data, configuration: config ) } }However, one thing that’s a bit puzzling about the Codable WithConfiguration API is that even though the protocol itself, as well as the KeyedCodingContainer methods that enable us to perform nested decoding of such types, are all available from iOS 15, the top-level configuration-compatible JSONDecoder API wasn’t added until iOS 17.Thankfully, that’s something that we can quite easily work around if working on a project that needs to support iOS 16 and earlier — by introducing our own implementation of that API, which uses Codable’s userInfo mechanism to store the configuration of the value that we’re currently decoding:extension JSONDecoder { // First, we define a wrapper type which we'll use to decode // values that require a configuration type: private struct ConfigurationDecodingWrapper\u003c Wrapped: DecodableWithConfiguration \u003e: Decodable { var wrapped: Wrapped init(from decoder: Decoder) throws { let configuration = decoder.userInfo[configurationUserInfoKey] wrapped = try Wrapped( from: decoder, configuration: configuration as! Wrapped.DecodingConfiguration ) } } private static let configurationUserInfoKey = CodingUserInfoKey( rawValue: \"configuration\" )! // Then, we declare our own decode method (which omits the // type parameter in order to not conflict with the built-in // API), which will work on iOS 15 and above: func decode\u003cT: DecodableWithConfiguration\u003e( from data: Data, configuration: T.DecodingConfiguration ) throws -\u003e T { let decoder = JSONDecoder() decoder.userInfo[Self.configurationUserInfoKey] = configuration let wrapper = try decoder.decode( ConfigurationDecodingWrapper\u003cT\u003e.self, from: data ) return wrapper.wrapped } }CodableWithConfiguration is really quite useful when using Swift’s built-in serialization API to encode and decode types that require additional data in order to be initialized, without having to resort to modeling required data as optional, or having to define additional types that are only ever used for decoding purposes.I hope that you found this article useful. Feel free to reach out via either either Mastodon or Bluesky if you have any questions or feedback.Thanks for reading!Swift by Sundell is brought to you by the Genius Scan SDK — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. Try it today.",
  "image": "https://www.swiftbysundell.com/images/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSwift’s \u003ccode\u003eCodable\u003c/code\u003e API — which consists of the \u003ccode\u003eEncodable\u003c/code\u003e protocol for encoding, and \u003ccode\u003eDecodable\u003c/code\u003e for decoding — offers a powerful, built-in mechanism for converting native Swift types to and from a serialized format, such as JSON. Thanks to its integration with the Swift compiler, we often don’t have to do any additional work to enable one of our types to become \u003ccode\u003eCodable\u003c/code\u003e, such as this \u003ccode\u003eMovie\u003c/code\u003e type:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Movie: \u003cspan\u003eIdentifiable\u003c/span\u003e, \u003cspan\u003e\u003cspan\u003eCodable\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e title: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e releaseDate: \u003cspan\u003eDate\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e genre: \u003cspan\u003eGenre\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e directorName: \u003cspan\u003eString\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eJust by adding that \u003ccode\u003eCodable\u003c/code\u003e conformance (which is a type alias for both \u003ccode\u003eEncodable\u003c/code\u003e and \u003ccode\u003eDecodable\u003c/code\u003e), our above \u003ccode\u003eMovie\u003c/code\u003e type can now be serialized and deserialized automatically, as long as the data format (such as JSON) that we’re working with follows the same structure as our Swift type declaration.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eHowever, sometimes we might be working with a type that requires some \u003cem\u003eadditional\u003c/em\u003e data that’s not present in the JSON (or whichever data format we’re decoding from) in order to be initialized. For example, the following \u003ccode\u003eUser\u003c/code\u003e type includes a \u003ccode\u003efavorites\u003c/code\u003e property — which is a \u003ccode\u003eFavorites\u003c/code\u003e value that contains the user’s favorites, such as their favorite director and movie genre:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e User: \u003cspan\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e membershipPoints: \u003cspan\u003eInt\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003evar\u003c/span\u003e favorites: \u003cspan\u003eFavorites\u003c/span\u003e\u003c/span\u003e\n}\n\n\u003cspan\u003estruct\u003c/span\u003e Favorites: \u003cspan\u003eCodable\u003c/span\u003e {\n    \u003cspan\u003evar\u003c/span\u003e genre: \u003cspan\u003eGenre\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e directorName: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e movieIDs: [\u003cspan\u003eMovie\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, the JSON response that our app receives from the server when loading the data for a user doesn’t include the \u003ccode\u003eFavorites\u003c/code\u003e data, which instead need to be loaded from a separate server endpoint:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// User server response:\n{\n    \u0026#34;id\u0026#34;: \u0026#34;7CBE0CC1-7779-42E9-AAF1-C4B145F3CAE9\u0026#34;,\n    \u0026#34;name\u0026#34;: \u0026#34;John Appleseed\u0026#34;,\n    \u0026#34;membershipPoints\u0026#34;: 192\n}\n\n// Favorites server response:\n{\n    \u0026#34;genre\u0026#34;: \u0026#34;action\u0026#34;,\n    \u0026#34;directorName\u0026#34;: \u0026#34;Christopher Nolan\u0026#34;,\n    \u0026#34;movieIDs\u0026#34;: [\n        \u0026#34;F028CAB5-74D7-4B86-8450-D0046C32DFA0\u0026#34;,\n        \u0026#34;D2657C95-1A35-446C-97D4-FAAA4783F2AA\u0026#34;,\n        \u0026#34;5159AF60-DF61-4A0C-A6BA-AE0E027E2BC2\u0026#34;\n    ]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the question is, how do we make \u003ccode\u003eUser\u003c/code\u003e conform to \u003ccode\u003eCodable\u003c/code\u003e (or more specifically, \u003ccode\u003eDecodable\u003c/code\u003e) without being able to decode the required \u003ccode\u003eFavorites\u003c/code\u003e data from the server’s JSON response?\u003c/p\u003e\u003cp\u003eOne option would be to simply make the \u003ccode\u003efavorites\u003c/code\u003e property optional — but that would have several downsides. First, it would make our data model more fragile, as we could easily miss to populate that property when loading \u003ccode\u003eUser\u003c/code\u003e values within various contexts (and the compiler wouldn’t be able to warn us about it). Second, and arguably more important, is that we’d constantly have to unwrap that optional \u003ccode\u003efavorites\u003c/code\u003e value every time we access it, leading to either extra boilerplate code (and potentially ambiguous states), or dangerous force unwrapping.\u003c/p\u003e\u003cp\u003eAnother, more robust option would be to use a secondary, \u003cem\u003epartial\u003c/em\u003e model when decoding our \u003ccode\u003eUser\u003c/code\u003e data, which we would then combine with a \u003ccode\u003eFavorites\u003c/code\u003e value in order to form our final model — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e {\n    \u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e Partial: \u003cspan\u003eDecodable\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e id: \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e membershipPoints: \u003cspan\u003eInt\u003c/span\u003e\n}\u003c/span\u003e\n}\n\n\u003cspan\u003estruct\u003c/span\u003e Networking {\n    \u003cspan\u003evar\u003c/span\u003e session = \u003cspan\u003eURLSession\u003c/span\u003e.\u003cspan\u003eshared\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eUser\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e favoritesURL = \u003cspan\u003efavoritesURLForUser\u003c/span\u003e(withID: id)\n        \u003cspan\u003elet\u003c/span\u003e userURL = \u003cspan\u003eurlForUser\u003c/span\u003e(withID: id)\n\n        \u003cspan\u003e// Load the user\u0026#39;s favorites and the partial user data\n        // that our server responds with:\u003c/span\u003e\n        \u003cspan\u003easync let\u003c/span\u003e favorites = \u003cspan\u003erequest\u003c/span\u003e(favoritesURL) \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eFavorites\u003c/span\u003e\n        \u003cspan\u003easync let\u003c/span\u003e partialUser = \u003cspan\u003erequest\u003c/span\u003e(userURL) \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003ePartial\u003c/span\u003e\n\n        \u003cspan\u003e// Form our final user model by combining the partial\n        // model with the favorites that were loaded:\u003c/span\u003e\n        \u003cspan\u003ereturn try await\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e(\n            \u003cspan\u003eid: partialUser.\u003cspan\u003eid\u003c/span\u003e,\nname: partialUser.\u003cspan\u003ename\u003c/span\u003e,\nmembershipPoints: partialUser.\u003cspan\u003emembershipPoints\u003c/span\u003e\u003c/span\u003e,\n            favorites: favorites\n        )\n    }\n    \n    ...\n\n    \u003cspan\u003eprivate func\u003c/span\u003e request\u0026lt;T: \u003cspan\u003eDecodable\u003c/span\u003e\u0026gt;(\u003cspan\u003e_\u003c/span\u003e url: \u003cspan\u003eURL\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eT\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e (data, \u003cspan\u003e_\u003c/span\u003e) = \u003cspan\u003etry await\u003c/span\u003e session.\u003cspan\u003edata\u003c/span\u003e(from: url)\n        \u003cspan\u003ereturn try\u003c/span\u003e \u003cspan\u003eJSONDecoder\u003c/span\u003e().\u003cspan\u003edecode\u003c/span\u003e(\u003cspan\u003eT\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, from: data)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile the above works perfectly fine, it would be really nice to find a solution that doesn’t require us to duplicate all of our \u003ccode\u003eUser\u003c/code\u003e model’s properties by declaring a separate, decoding-specific \u003ccode\u003ePartial\u003c/code\u003e model. Thankfully, the Swift Codable system* does actually include such a solution — the somewhat lesser known \u003ccode\u003eCodableWithConfiguration\u003c/code\u003e API.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e* CodableWithConfiguration is not technically a direct part of Codable, which is defined within Swift’s standard library, but is instead an extension defined within Foundation. That doesn’t make much of a difference when targeting any of Apple’s platforms, though.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWhen a type conforms to either \u003ccode\u003eEncodableWithConfiguration\u003c/code\u003e or \u003ccode\u003eDecodableWithConfiguration\u003c/code\u003e, it requires an additional configuration value to be passed when either encoding or decoding it (and the compiler will enforce that requirement). That’s incredibly useful in situations such as when decoding our \u003ccode\u003eUser\u003c/code\u003e type, since we can define that \u003ccode\u003eFavorites\u003c/code\u003e is the required \u003ccode\u003eDecodingConfiguration\u003c/code\u003e for our type — meaning that we can ensure that such a value will always be present during decoding, without having to declare any additional partial types.\u003c/p\u003e\u003cp\u003eSo let’s go ahead and update our \u003ccode\u003eUser\u003c/code\u003e type to conform to \u003ccode\u003eDecodableWithConfiguration\u003c/code\u003e, which does require a manual decoding implementation, unfortunately:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e: \u003cspan\u003eEncodable\u003c/span\u003e, \u003cspan\u003e\u003cspan\u003eDecodableWithConfiguration\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan\u003eenum\u003c/span\u003e CodingKeys: \u003cspan\u003eCodingKey\u003c/span\u003e {\n        \u003cspan\u003ecase\u003c/span\u003e id\n        \u003cspan\u003ecase\u003c/span\u003e name\n        \u003cspan\u003ecase\u003c/span\u003e membershipPoints\n    }\n\n    \u003cspan\u003einit\u003c/span\u003e(from decoder: \u003cspan\u003eDecoder\u003c/span\u003e, \u003cspan\u003econfiguration: \u003cspan\u003eFavorites\u003c/span\u003e\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e container = \u003cspan\u003etry\u003c/span\u003e decoder.\u003cspan\u003econtainer\u003c/span\u003e(keyedBy: \u003cspan\u003eCodingKeys\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e)\n\n        id = \u003cspan\u003etry\u003c/span\u003e container.\u003cspan\u003edecode\u003c/span\u003e(\u003cspan\u003eUUID\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, forKey: .\u003cspan\u003eid\u003c/span\u003e)\n        name = \u003cspan\u003etry\u003c/span\u003e container.\u003cspan\u003edecode\u003c/span\u003e(\u003cspan\u003eString\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e, forKey: .\u003cspan\u003ename\u003c/span\u003e)\n        membershipPoints = \u003cspan\u003etry\u003c/span\u003e container.\u003cspan\u003edecode\u003c/span\u003e(\n            \u003cspan\u003eInt\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e,\n            forKey: .\u003cspan\u003emembershipPoints\u003c/span\u003e\n        )\n        favorites = configuration\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo we still have to write a bit of boilerplate in order to enable our new decoding setup, but the advantage is that we can now make our networking code a lot simpler — all that we need is another overload of our private \u003ccode\u003erequest\u003c/code\u003e method, which works with types conforming to \u003ccode\u003eDecodableWithConfiguration\u003c/code\u003e, and we’ll now be able to leverage type inference to make our decoding call site a lot simpler:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Networking {\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eUser\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e favoritesURL = \u003cspan\u003efavoritesURLForUser\u003c/span\u003e(withID: id)\n        \u003cspan\u003elet\u003c/span\u003e userURL = \u003cspan\u003eurlForUser\u003c/span\u003e(withID: id)\n\n        \u003cspan\u003e\u003cspan\u003ereturn try await\u003c/span\u003e \u003cspan\u003erequest\u003c/span\u003e(userURL, with: \u003cspan\u003erequest\u003c/span\u003e(favoritesURL))\u003c/span\u003e\n    }\n    \n    ...\n\n    \u003cspan\u003eprivate func\u003c/span\u003e request\u0026lt;T: \u003cspan\u003eDecodable\u003c/span\u003e\u0026gt;(\u003cspan\u003e_\u003c/span\u003e url: \u003cspan\u003eURL\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eT\u003c/span\u003e {\n        ...\n    }\n\n    \u003cspan\u003eprivate func\u003c/span\u003e request\u0026lt;T: \u003cspan\u003eDecodableWithConfiguration\u003c/span\u003e\u0026gt;(\n        \u003cspan\u003e_\u003c/span\u003e url: \u003cspan\u003eURL\u003c/span\u003e,\n        with config: \u003cspan\u003eT\u003c/span\u003e.\u003cspan\u003eDecodingConfiguration\u003c/span\u003e\n    ) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eT\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e (data, \u003cspan\u003e_\u003c/span\u003e) = \u003cspan\u003etry await\u003c/span\u003e session.\u003cspan\u003edata\u003c/span\u003e(from: url)\n\n        \u003cspan\u003e\u003cspan\u003ereturn try\u003c/span\u003e \u003cspan\u003eJSONDecoder\u003c/span\u003e().\u003cspan\u003edecode\u003c/span\u003e(\n    \u003cspan\u003eT\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e,\n    from: data,\n    configuration: config\n)\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, one thing that’s a bit puzzling about the \u003ccode\u003eCodable WithConfiguration\u003c/code\u003e API is that even though the protocol itself, as well as the \u003ccode\u003eKeyedCodingContainer\u003c/code\u003e methods that enable us to perform nested decoding of such types, are all available from iOS 15, the top-level configuration-compatible \u003ccode\u003eJSONDecoder\u003c/code\u003e API wasn’t added until iOS 17.\u003c/p\u003e\u003cp\u003eThankfully, that’s something that we can quite easily work around if working on a project that needs to support iOS 16 and earlier — by introducing our own implementation of that API, which uses Codable’s \u003ccode\u003euserInfo\u003c/code\u003e mechanism to store the configuration of the value that we’re currently decoding:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eJSONDecoder\u003c/span\u003e {\n    \u003cspan\u003e// First, we define a wrapper type which we\u0026#39;ll use to decode\n    // values that require a configuration type:\u003c/span\u003e\n    \u003cspan\u003eprivate struct\u003c/span\u003e ConfigurationDecodingWrapper\u0026lt;\n        Wrapped: \u003cspan\u003eDecodableWithConfiguration\u003c/span\u003e\n    \u0026gt;: \u003cspan\u003eDecodable\u003c/span\u003e {\n        \u003cspan\u003evar\u003c/span\u003e wrapped: \u003cspan\u003eWrapped\u003c/span\u003e\n\n        \u003cspan\u003einit\u003c/span\u003e(from decoder: \u003cspan\u003eDecoder\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n            \u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e configuration = decoder.\u003cspan\u003euserInfo\u003c/span\u003e[configurationUserInfoKey]\u003c/span\u003e\n\n            wrapped = \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003eWrapped\u003c/span\u003e(\n                from: decoder,\n                configuration: configuration \u003cspan\u003eas\u003c/span\u003e! \u003cspan\u003eWrapped\u003c/span\u003e.\u003cspan\u003eDecodingConfiguration\u003c/span\u003e\n            )\n        }\n    }\n\n    \u003cspan\u003eprivate static let\u003c/span\u003e configurationUserInfoKey = \u003cspan\u003eCodingUserInfoKey\u003c/span\u003e(\n        rawValue: \u003cspan\u003e\u0026#34;configuration\u0026#34;\u003c/span\u003e\n    )!\n\n    \u003cspan\u003e// Then, we declare our own decode method (which omits the\n    // type parameter in order to not conflict with the built-in\n    // API), which will work on iOS 15 and above:\u003c/span\u003e\n    \u003cspan\u003efunc\u003c/span\u003e decode\u0026lt;T: \u003cspan\u003eDecodableWithConfiguration\u003c/span\u003e\u0026gt;(\n        from data: \u003cspan\u003eData\u003c/span\u003e,\n        configuration: \u003cspan\u003eT\u003c/span\u003e.\u003cspan\u003eDecodingConfiguration\u003c/span\u003e\n    ) \u003cspan\u003ethrows\u003c/span\u003e -\u0026gt; \u003cspan\u003eT\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e decoder = \u003cspan\u003eJSONDecoder\u003c/span\u003e()\n        \u003cspan\u003edecoder.\u003cspan\u003euserInfo\u003c/span\u003e[\u003cspan\u003eSelf\u003c/span\u003e.\u003cspan\u003econfigurationUserInfoKey\u003c/span\u003e] = configuration\u003c/span\u003e\n\n        \u003cspan\u003elet\u003c/span\u003e wrapper = \u003cspan\u003etry\u003c/span\u003e decoder.\u003cspan\u003edecode\u003c/span\u003e(\n            \u003cspan\u003eConfigurationDecodingWrapper\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e\u0026gt;.\u003cspan\u003eself\u003c/span\u003e,\n            from: data\n        )\n\n        \u003cspan\u003ereturn\u003c/span\u003e wrapper.\u003cspan\u003ewrapped\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eCodableWithConfiguration\u003c/code\u003e is really quite useful when using Swift’s built-in serialization API to encode and decode types that require additional data in order to be initialized, without having to resort to modeling required data as optional, or having to define additional types that are only ever used for decoding purposes.\u003c/p\u003e\u003cp\u003eI hope that you found this article useful. Feel free to reach out via either either \u003ca href=\"https://mastodon.social/@johnsundell\"\u003eMastodon\u003c/a\u003e or \u003ca href=\"https://bsky.app/profile/johnsundell.bsky.social\"\u003eBluesky\u003c/a\u003e if you have any questions or feedback.\u003c/p\u003e\u003cp\u003eThanks for reading!\u003c/p\u003e\u003ca href=\"https://geniusscansdk.com/swiftbysundell?utm_content=inline_ad\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"https://www.swiftbysundell.com/images/supporters/geniusScan-image.png\" alt=\"Genius Scan SDK\"/\u003e\u003cp\u003eSwift by Sundell is brought to you by the \u003cstrong\u003eGenius Scan SDK\u003c/strong\u003e — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. \u003cu\u003eTry it today\u003c/u\u003e.\u003c/p\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
