{
  "id": "c0a17d08-e5f1-4238-bf2d-3e09638e58e2",
  "title": "How to setup a Swift Package Registry in Artifactory",
  "link": "https://albertodebortoli.com/2025/06/06/how-to-setup-a-swift-package-registry-in-artifactory/",
  "description": "A quick guide to setting up a Swift Package Registry with Artifactory to speed up builds and streamline dependency management.",
  "author": "Alberto De Bortoli",
  "published": "Fri, 06 Jun 2025 08:00:00 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "swift",
    "registry",
    "artifactory"
  ],
  "byline": "Alberto De Bortoli",
  "length": 14166,
  "excerpt": "A quick guide to setting up a Swift Package Registry with Artifactory to speed up builds and streamline dependency management.",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "IntroductionIt's very difficult to have GenAI not hallucinate when in comes to Swift Package Registry. No surprise there: the feature is definitely niche, has not been vastly adopted and there's a lack of examples online. As Dave put it, Swift Package Registries had an even rockier start compared to SPM.I've recently implemented a Swift Package Registry on Artifactory for my team and I thought of summarising my experience here since it's still fresh in my head. While some details are left out, the happy path should be covered. I hope with this article to help you all indirectly by providing more material to the LLMs overlords.ProblemThe main problem that led us to look into Swift Package Registry is due to SPM deep-cloning entire Git repositories for each dependency, which became time-consuming.Currently, our CI jobs take a few minutes just to pull all the Swift packages. For dependencies with very large repositories, such as SendbirdUIKit (which is more than 2GB), one could rely on pre-compiled XCFrameworks as a workaround. Airbnb provides a workaround via the SPM-specific repo for Lottie.A Swift Registry allows to serve dependencies as zip artifacts containing only the required revision, avoiding the deep clone of the git repositories.What is a Swift Package Registry?A Swift Package Registry is a server that stores and vends Swift packages by implementing SE-0292 and the corresponding specification. Instead of relying on Git repositories to source our dependencies, we can use a registry to download them as versioned archives (zip files).swift-package-manager/Documentation/PackageRegistry/PackageRegistryUsage.md at main · swiftlang/swift-package-managerThe Package Manager for the Swift Programming Language - swiftlang/swift-package-managerGitHubswiftlangThe primary advantages of using a Swift Package Registry are:Reduced CI/CD Pipeline Times: by fetching lightweight zip archives from the registry rather than cloning the entire repositories from GitHub.Improved Developer Machine Performance: the same time savings on CI are reflected on the developers' machines during dependency resolution.Availability: by hosting a registry, teams are no longer dependent on the availability of external source control systems like GitHub, but rather on internal ones (for example, self-hosted Artifactory).Security: injecting vulnerabilities in popular open-source projects is known as a supply chain attack and has become increasingly popular in recent years. A registry allows to adopt a process to trust the sources published on it.PlatformsApple has accepted the Swift Registry specification and implemented support to interact with registries within SPM but has left the implementation of actual registries to third-party platforms.Apple is not in the business of providing a Swift Registry.The main platform having adopted Swift Registries is Artifactory.Artifactory, Your Swift Package RepositoryJFrog now offers the first and only Swift binary package repository, enabling developers to use JFrog Artifactory for resolving Swift dependencies instead of enterprise source control (Git) systems.JFroggiannitalthough AWS CodeArtifact, Cloudsmith and Tuist provide support too:New – Add Your Swift Packages to AWS CodeArtifact | Amazon Web ServicesStarting today, Swift developers who write code for Apple platforms (iOS, iPadOS, macOS, tvOS, watchOS, or visionOS) or for Swift applications running on the server side can use AWS CodeArtifact to securely store and retrieve their package dependencies. CodeArtifact integrates with standard developer tools such as Xcode, xcodebuild, and the Swift Package Manager (the swift […]Amazon Web ServicesSébastien StormacqPrivate, secure, hosted Swift registryCloudsmith offers secure, private Swift registries as a service, with cloud native performance. Book a demo today.CloudsmithAnnouncing Tuist RegistryWe’re thrilled to announce the launch of the Tuist Registry – a new feature that optimizes the resolution of Swift packages in your projects.TuistMarek FořtThe benefits are usually appealing to teams with large apps, hence it's reasonable to believe that only big companies have looked into adopting a registry successfully.Artifactory SetupLet's assume a JFrog Artifactory to host our Swift Package Registry exists at https://packages.acme.com. Artifactory support local, remote, and virtual repositories but a realistic setup consists of only local and virtual repositories.Source: ArtifactoryLocal Repositories are meant to be used for publishing dependencies from CI pipelines. Virtual Repositories are instead meant to be used for resolving (pulling) dependencies on both CI and the developers' machines.Following the documentation at https://jfrog.com/help/r/jfrog-artifactory-documentation/set-up-a-swift-registry, let's create 2 repositories with the following names:local repository: swift-localvirtual repository: swift-virtualLocal SetupTo pull dependencies from the Swift Package Registry, we need to configure the local environment.1. Set the Registry URLFirst, we need to inform SPM about the existence of the registry. We can do this on a per-project basis or globally for the user account.From a package's root directory, run the following command. This will create a .swiftpm/configuration/registries.json file within your project folder.swift package-registry set \"https://packages.acme.com/artifactory/api/swift/swift-virtual\"The resulting registries.json file will look like this:{ \"authentication\": {}, \"registries\": { \"[default]\": { \"supportsAvailability\": false, \"url\": \"https://packages.acme.com/artifactory/api/swift/swift-virtual\" } }, \"version\": 1 }To set the registry for all your projects, use the --global flag.swift package-registry set --global \"https://packages.acme.com/artifactory/api/swift/swift-virtual\" This will create the configuration file at ~/.swiftpm/configuration/registries.json.2. AuthenticationTo pull packages, authenticating with Artifactory is usually required. It's reasonable though that your company allows all artifacts from Artifactory to be read without authentication as long as one is connected to the company VPN.In cases where authentication is required, SPM uses a .netrc file in the home directory to find credentials for remote servers. This file is a standard way to handle login information for various network protocols.Using a token generated from the Artifactory dashboard, the line to add to the .netrc file would be:machine packages.acme.com login \u003cyour_artifactory_username\u003e password \u003cyour_artifactory_token\u003eAlternatively, it's possible to log in using the swift package-registry login command. This command securely stores your token in the system's keychain.swift package-registry login \"https://packages.acme.com/artifactory/api/swift/swift-virtual\" \\ --token \u003ctoken\u003e # or swift package-registry login \"https://packages.acme.com/artifactory/api/swift/swift-virtual\" \\ --username \u003cusername\u003e \\ --password \u003ctoken_treated_as_password\u003eCI/CD SetupOn CI, the setup is slightly different as the goals are:to resolve dependencies in CI/CD jobs into publish new package versions in CD jobs for both internal and external dependenciesThe steps described for the local setup are valid for the resolution on CI too. The interesting part here is how publishing is done. I will assume the usage of GitHub Actions.1. Retrieving the Artifactory TokenThe JFrog CLI can be used via the setup-jfrog-cli action to authenticate using the most appropriate method. You might want to wrap the action in a custom composable one exporting the token as the output of a step:TOKEN=$(jf config export) echo \"::add-mask::$TOKEN\" echo \"artifactory-token=$TOKEN\"\u003e\u003e \"$GITHUB_OUTPUT\"2. Logging into the RegistryThe CI job must log in to the local repository (swift-local) to gain push permissions. The token retrieved in the previous step is used for this purpose.swift package-registry login \\ \"https://packages.acme.com/artifactory/api/swift/swift-local\" \\ --token ${{ steps.get-token.outputs.artifactory-token }}3. Publishing PackagesSwift Registry requires archives created with the swift package archive-source command from the dependency folder. E.g.swift package archive-source -o \"Alamofire-5.10.2.zip\"We could avoid creating the archive and instead download it directly from GitHub releases.curl -L -o Alamofire-5.10.1.zip \\ https://github.com/Alamofire/Alamofire/archive/refs/tags/5.10.1.zipUploading the archive can then be done by using the JFrog CLI that needs customization via the setup-jfrog-cli action. If going down this route, the upload command would be:jf rt upload Alamofire-5.10.1.zip \\ https://packages.acme.com/artifactory/api/swift/swift-local/acme/Alamofire/Alamofire-5.10.1.zipThere is a specific structure to respect:\u003cREPOSITORY\u003e/\u003cSCOPE\u003e/\u003cNAME\u003e/\u003cNAME\u003e-\u003cVERSION\u003e.zipwhich is the last part of the above URL:swift-local/acme/Alamofire/Alamofire-5.10.1.zipToo bad that using the steps above causes a downstream problem with SPM not being able to resolve the dependencies in the registry. I tried extensively and couldn't find the reason why SPM wouldn't be happy with how the packages were published. I might have missed something but eventually I necessarily had to switch to use the publish command.Using the swift package-registry publish command instead, doesn't present this issue hence it's the solution adopted in this workflow.swift package-registry publish acme.Alamofire 5.10.1 \\ --url https://packages.acme.com/artifactory/api/swift/swift-local \\ --scratch-directory $(mktemp -d)To verify the upload and indexing succeeded, check that the uploaded *.zip artifact is available and that the .swift exists (indication that the indexing has occurred). If the specific structure is not respected, the .swift folder wouldn't be generated.Consuming Packages from the RegistryPackagesThe easiest and only documented way to consume a package from a registry is via a Package. In the Package.swift file, declare dependencies using the .package(id:from:) syntax to declare a registry-based dependency. The id is a combination of the scope and the package name. ... dependencies: [ .package(id: \"acme.Alamofire\", from: \"5.10.1\"), ], targets: [ .target( name: \"MyApp\", dependencies: [ .product(name: \"Alamofire\", package: \"acme.Alamofire\"), ] ), ... ] ) Run swift package resolve or simply build the Package in Xcode to pull the dependencies.You might bump into transitive dependencies (i.e. dependencies listed in the Package.swift files of the packages published on the registry) pointing to GitHub. In this case, it'd be great to instruct SPM to use the corresponding versions on the registry. The --replace-scm-with-registry flag is designed to work for the entire dependency graph, including transitive dependencies. The cornerstone of associating a registry-hosted package with its GitHub origin is the package-metadata.json file. This file allows to provide essential metadata about the packages at the time of publishing (the --metadata-path flag of the publish command defaults to pacakge-metadata.json).Crucially, it includes a field to specify the source control repository URLs. When swift package resolve --replace-scm-with-registry is executed, SPM queries the configured registry. The registry then uses the information from the package-metadata.json to map the package identity to its corresponding GitHub URL, enabling a smooth and transparent resolution process.The metadata file must conform to the JSON schema defined in SE-0391. It is recommended to include all URL variations (e.g., SSH, HTTPS) for the same repository. E.g.{ \"repositoryURLs\": [ \"https://github.com/Alamofire/Alamofire\", \"https://github.com/Alamofire/Alamofire.git\", \"git@github.com:Alamofire/Alamofire.git\" ] }Printing the dependencies should confirm the source of the dependencies:swift package show-dependencies --replace-scm-with-registryWhen loading a package with Xcode, the flag can be enabled via an environment variable in the schemeIDEPackageDependencySCMToRegistryTransformation=useRegistryIdentityAndSourcesToo bad that for packages, the schemes won't load until SPM completes the resolution hence running the following from the terminal would address the issue:defaults write com.apple.dt.Xcode IDEPackageDependencySCMToRegistryTransformation useRegistryIdentityAndSourcesthat can be unset with:defaults delete com.apple.dt.Xcode IDEPackageDependencySCMToRegistryTransformationXcodeIt's likely that you'll want to use the registry from Xcode projects for direct dependencies. If using the Tuist registry, it seems you would be able to leverage a Package Collection to add dependencies from the registry from the Xcode UI. Note that until Xcode 16.4, it's not possible to add registry dependencies directly in the Xcode UI, but if you use Tuist to generate your project (as you should), you can use the Package.registry (introduced with https://github.com/tuist/tuist/pull/7225). E.g.let project = Project( ... packages: [ .registry( identifier: \"acme.Alamofire\", requirement: .exact(Version(stringLiteral: \"5.10.1\")) ) ], ... )If not using Tuist, you'd have to rely on setting IDEPackageDependencySCMToRegistryTransformation either as an environment variable in the scheme or globally via the terminal.ConclusionsWe’ve found that using an in-house Swift registry can significantly reduce dependency resolution time by downloading only the required revision instead of the entire, potentially large, Git repository. This improvement benefits both CI pipelines and developers’ local environments. Additionally, registries help mitigate the risk of supply chain attacks.As of this writing, Swift registries are not widely adopted, which is reflected in the limited number of platforms that support them. It's unclear whether adoption will grow, but when working with dependencies in large repositories, registries offer a more efficient and secure alternative to using XCFrameworks in production builds.",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2025/06/Gemini_Generated_Image_p2p1t1p2p1t1p2p1.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\u003cp\u003eIt\u0026#39;s very difficult to have GenAI not hallucinate when in comes to Swift Package Registry. No surprise there: the feature is definitely niche, has not been vastly adopted and there\u0026#39;s a lack of examples online. As Dave \u003ca href=\"https://iosdevweekly.com/issues/696/?ref=albertodebortoli.com\"\u003eput it\u003c/a\u003e, \u003cem\u003eSwift Package Registries had an even rockier start compared to SPM.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eI\u0026#39;ve recently implemented a Swift Package Registry on Artifactory for my team and I thought of summarising my experience here since it\u0026#39;s still fresh in my head. While some details are left out, the happy path should be covered. I hope with this article to help you all indirectly by providing more material to the LLMs overlords.\u003c/p\u003e\u003ch2 id=\"problem\"\u003eProblem\u003c/h2\u003e\u003cp\u003eThe main problem that led us to look into Swift Package Registry is due to SPM \u003ca href=\"https://github.com/swiftlang/swift-package-manager/blob/7b98bedc91ac8b6581ed6785990ee62c97cde363/Sources/SourceControl/GitRepository.swift?ref=albertodebortoli.com#L32\"\u003edeep-cloning\u003c/a\u003e entire Git repositories for each dependency, which became time-consuming.\u003c/p\u003e\u003cp\u003eCurrently, our CI jobs take a few minutes just to pull all the Swift packages. For dependencies with very large repositories, such as \u003ca href=\"https://github.com/sendbird/sendbird-uikit-ios?ref=albertodebortoli.com\"\u003eSendbirdUIKit\u003c/a\u003e (which is more than 2GB), one could rely on pre-compiled XCFrameworks as a workaround. Airbnb provides a workaround via the \u003ca href=\"https://github.com/airbnb/lottie-spm?ref=albertodebortoli.com\"\u003eSPM-specific repo\u003c/a\u003e for Lottie.\u003c/p\u003e\u003cp\u003eA Swift Registry allows to serve dependencies as zip artifacts containing only the required revision, avoiding the deep clone of the git repositories.\u003c/p\u003e\u003ch2 id=\"what-is-a-swift-package-registry\"\u003eWhat is a Swift Package Registry?\u003c/h2\u003e\u003cp\u003eA Swift Package Registry is a server that stores and vends Swift packages by implementing \u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0292-package-registry-service.md?ref=albertodebortoli.com\"\u003eSE-0292\u003c/a\u003e and the corresponding \u003ca href=\"https://github.com/swiftlang/swift-package-manager/blob/main/Documentation/PackageRegistry/Registry.md?ref=albertodebortoli.com\"\u003especification\u003c/a\u003e. Instead of relying on Git repositories to source our dependencies, we can use a registry to download them as versioned archives (zip files).\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://github.com/swiftlang/swift-package-manager/blob/main/Documentation/PackageRegistry/PackageRegistryUsage.md?ref=albertodebortoli.com\"\u003e\u003cdiv\u003e\u003cp\u003eswift-package-manager/Documentation/PackageRegistry/PackageRegistryUsage.md at main · swiftlang/swift-package-manager\u003c/p\u003e\u003cp\u003eThe Package Manager for the Swift Programming Language - swiftlang/swift-package-manager\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/icon/pinned-octocat-093da3e6fa40.svg\" alt=\"\"/\u003e\u003cspan\u003eGitHub\u003c/span\u003e\u003cspan\u003eswiftlang\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/thumbnail/swift-package-manager\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cp\u003eThe primary advantages of using a Swift Package Registry are:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eReduced CI/CD Pipeline Times:\u003c/strong\u003e by fetching lightweight zip archives from the registry rather than cloning the entire repositories from GitHub.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eImproved Developer Machine Performance:\u003c/strong\u003e the same time savings on CI are reflected on the developers\u0026#39; machines during dependency resolution.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAvailability:\u003c/strong\u003e by hosting a registry, teams are no longer dependent on the availability of external source control systems like GitHub, but rather on internal ones (for example, self-hosted Artifactory).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSecurity\u003c/strong\u003e: injecting vulnerabilities in popular open-source projects is known as a \u003ca href=\"https://en.wikipedia.org/wiki/Supply_chain_attack?ref=albertodebortoli.com\"\u003esupply chain attack\u003c/a\u003e and has become increasingly popular in recent years. A registry allows to adopt a process to trust the sources published on it.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"platforms\"\u003ePlatforms\u003c/h2\u003e\u003cp\u003eApple has accepted the Swift Registry specification and implemented support to interact with registries within SPM but has left the implementation of actual registries to third-party platforms.\u003c/p\u003e\u003cp\u003eApple is not in the business of providing a Swift Registry.\u003c/p\u003e\u003cp\u003eThe main platform having adopted Swift Registries is Artifactory.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://jfrog.com/blog/artifactory-your-swift-package-repository/?ref=albertodebortoli.com\"\u003e\u003cdiv\u003e\u003cp\u003eArtifactory, Your Swift Package Repository\u003c/p\u003e\u003cp\u003eJFrog now offers the first and only Swift binary package repository, enabling developers to use JFrog Artifactory for resolving Swift dependencies instead of enterprise source control (Git) systems.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/icon/Jfrog16-1.png\" alt=\"\"/\u003e\u003cspan\u003eJFrog\u003c/span\u003e\u003cspan\u003egiannit\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/thumbnail/1200x628_BTN.png\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cp\u003ealthough AWS CodeArtifact, Cloudsmith and Tuist provide support too:\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://aws.amazon.com/blogs/aws/new-add-your-swift-packages-to-aws-codeartifact/?ref=albertodebortoli.com\"\u003e\u003cdiv\u003e\u003cp\u003eNew – Add Your Swift Packages to AWS CodeArtifact | Amazon Web Services\u003c/p\u003e\u003cp\u003eStarting today, Swift developers who write code for Apple platforms (iOS, iPadOS, macOS, tvOS, watchOS, or visionOS) or for Swift applications running on the server side can use AWS CodeArtifact to securely store and retrieve their package dependencies. CodeArtifact integrates with standard developer tools such as Xcode, xcodebuild, and the Swift Package Manager (the swift […]\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/icon/touch-icon-ipad-144-smile-1.png\" alt=\"\"/\u003e\u003cspan\u003eAmazon Web Services\u003c/span\u003e\u003cspan\u003eSébastien Stormacq\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/thumbnail/2023-09-12_00-03-46-1260x397-1.png\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cfigure\u003e\u003ca href=\"https://cloudsmith.com/product/formats/swift?ref=albertodebortoli.com\"\u003e\u003cdiv\u003e\u003cp\u003ePrivate, secure, hosted Swift registry\u003c/p\u003e\u003cp\u003eCloudsmith offers secure, private Swift registries as a service, with cloud native performance. Book a demo today.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/icon/favicon.svg\" alt=\"\"/\u003e\u003cspan\u003eCloudsmith\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/thumbnail/opengraph.png\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cfigure\u003e\u003ca href=\"https://tuist.dev/blog/2025/01/22/announcing-tuist-registry?ref=albertodebortoli.com\"\u003e\u003cdiv\u003e\u003cp\u003eAnnouncing Tuist Registry\u003c/p\u003e\u003cp\u003eWe’re thrilled to announce the launch of the Tuist Registry – a new feature that optimizes the resolution of Swift packages in your projects.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/icon/favicon-1.ico\" alt=\"\"/\u003e\u003cspan\u003eTuist\u003c/span\u003e\u003cspan\u003eMarek Fořt\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/thumbnail/og.jpg\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cp\u003eThe benefits are usually appealing to teams with large apps, hence it\u0026#39;s reasonable to believe that only big companies have looked into adopting a registry successfully.\u003c/p\u003e\u003ch2 id=\"artifactory-setup\"\u003eArtifactory Setup\u003c/h2\u003e\u003cp\u003eLet\u0026#39;s assume a JFrog Artifactory to host our Swift Package Registry exists at \u003ca href=\"https://artifacts.takeaway.com/?ref=albertodebortoli.com\"\u003ehttps://packages.acme.com\u003c/a\u003e. Artifactory support local, remote, and virtual repositories but a realistic setup consists of only local and virtual repositories.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://speedmedia.jfrog.com/08612fe1-9391-4cf3-ac1a-6dd49c36b276/media.jfrog.com/wp-content/uploads/2022/06/03190625/Artifactory_Swift_Flow.png\" alt=\"\" loading=\"lazy\" width=\"1686\" height=\"634\"/\u003e\u003cfigcaption\u003e\u003cspan\u003eSource: \u003c/span\u003e\u003ca href=\"https://jfrog.com/blog/artifactory-your-swift-package-repository/?ref=albertodebortoli.com\"\u003e\u003cspan\u003eArtifactory\u003c/span\u003e\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eLocal Repositories are meant to be used for publishing dependencies from CI pipelines. Virtual Repositories are instead meant to be used for resolving (pulling) dependencies on both CI and the developers\u0026#39; machines.\u003c/p\u003e\u003cp\u003eFollowing the documentation at \u003ca href=\"https://jfrog.com/help/r/jfrog-artifactory-documentation/set-up-a-swift-registry?ref=albertodebortoli.com\"\u003ehttps://jfrog.com/help/r/jfrog-artifactory-documentation/set-up-a-swift-registry\u003c/a\u003e, let\u0026#39;s create 2 repositories with the following names:\u003c/p\u003e\u003cul\u003e\u003cli\u003elocal repository: \u003ccode\u003eswift-local\u003c/code\u003e\u003c/li\u003e\u003cli\u003evirtual repository: \u003ccode\u003eswift-virtual\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"local-setup\"\u003eLocal Setup\u003c/h2\u003e\u003cp\u003eTo pull dependencies from the Swift Package Registry, we need to configure the local environment.\u003c/p\u003e\u003ch3 id=\"1-set-the-registry-url\"\u003e1. Set the Registry URL\u003c/h3\u003e\u003cp\u003eFirst, we need to inform SPM about the existence of the registry. We can do this on a per-project basis or globally for the user account.\u003c/p\u003e\u003cp\u003eFrom a package\u0026#39;s root directory, run the following command. This will create a \u003ccode\u003e.swiftpm/configuration/registries.json\u003c/code\u003e file within your project folder.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package-registry set \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-virtual\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe resulting registries.json file will look like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;authentication\u0026#34;: {},\n  \u0026#34;registries\u0026#34;: {\n    \u0026#34;[default]\u0026#34;: {\n      \u0026#34;supportsAvailability\u0026#34;: false,\n      \u0026#34;url\u0026#34;: \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-virtual\u0026#34;\n    }\n  },\n  \u0026#34;version\u0026#34;: 1\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo set the registry for all your projects, use the \u003ccode\u003e--global\u003c/code\u003e flag.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package-registry set --global \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-virtual\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e This will create the configuration file at \u003ccode\u003e~/.swiftpm/configuration/registries.json\u003c/code\u003e.\u003c/p\u003e\u003ch3 id=\"2-authentication\"\u003e2. Authentication\u003c/h3\u003e\u003cp\u003eTo pull packages, authenticating with Artifactory is usually required. It\u0026#39;s reasonable though that your company allows all artifacts from Artifactory to be read without authentication as long as one is connected to the company VPN.\u003c/p\u003e\u003cp\u003eIn cases where authentication is required, SPM uses a \u003ccode\u003e.netrc\u003c/code\u003e file in the home directory to find credentials for remote servers. This file is a standard way to handle login information for various network protocols.\u003c/p\u003e\u003cp\u003eUsing a token generated from the Artifactory dashboard, the line to add to the \u003ccode\u003e.netrc\u003c/code\u003e file would be:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003emachine packages.acme.com login \u0026lt;your_artifactory_username\u0026gt; password \u0026lt;your_artifactory_token\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlternatively, it\u0026#39;s possible to log in using the \u003ccode\u003eswift package-registry login\u003c/code\u003e command. This command securely stores your token in the system\u0026#39;s keychain.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package-registry login \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-virtual\u0026#34; \\\n  --token \u0026lt;token\u0026gt;\n\n# or\n\nswift package-registry login \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-virtual\u0026#34; \\\n  --username \u0026lt;username\u0026gt; \\\n  --password \u0026lt;token_treated_as_password\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"cicd-setup\"\u003eCI/CD Setup\u003c/h2\u003e\u003cp\u003eOn CI, the setup is slightly different as the goals are:\u003c/p\u003e\u003cul\u003e\u003cli\u003eto \u003cem\u003eresolve\u003c/em\u003e dependencies in CI/CD jobs in\u003c/li\u003e\u003cli\u003eto \u003cem\u003epublish\u003c/em\u003e new package versions in CD jobs for both internal and external dependencies\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe steps described for the local setup are valid for the resolution on CI too. The interesting part here is how publishing is done. I will assume the usage of GitHub Actions.\u003c/p\u003e\u003ch3 id=\"1-retrieving-the-artifactory-token\"\u003e1. Retrieving the Artifactory Token\u003c/h3\u003e\u003cp\u003eThe JFrog CLI can be used via the \u003ca href=\"https://github.com/jfrog/setup-jfrog-cli?ref=albertodebortoli.com\"\u003esetup-jfrog-cli\u003c/a\u003e action to authenticate using the most appropriate method. You might want to wrap the action in a custom composable one exporting the token as the output of a step:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eTOKEN=$(jf config export) \necho \u0026#34;::add-mask::$TOKEN\u0026#34;\necho \u0026#34;artifactory-token=$TOKEN\u0026#34;\u0026gt;\u0026gt; \u0026#34;$GITHUB_OUTPUT\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"2-logging-into-the-registry\"\u003e2. Logging into the Registry\u003c/h3\u003e\u003cp\u003eThe CI job must log in to the local repository (\u003ccode\u003eswift-local\u003c/code\u003e) to gain push permissions. The token retrieved in the previous step is used for this purpose.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package-registry login \\\n  \u0026#34;https://packages.acme.com/artifactory/api/swift/swift-local\u0026#34; \\\n  --token ${{ steps.get-token.outputs.artifactory-token }}\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"3-publishing-packages\"\u003e3. Publishing Packages\u003c/h3\u003e\u003cp\u003eSwift Registry requires archives created with the \u003ccode\u003eswift package archive-source\u003c/code\u003e command from the dependency folder. E.g.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package archive-source -o \u0026#34;Alamofire-5.10.2.zip\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe could avoid creating the archive and instead download it directly from GitHub releases.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecurl -L -o Alamofire-5.10.1.zip \\\n  https://github.com/Alamofire/Alamofire/archive/refs/tags/5.10.1.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUploading the archive can then be done by using the JFrog CLI that needs customization via the \u003ca href=\"https://github.com/jfrog/setup-jfrog-cli?ref=albertodebortoli.com\"\u003esetup-jfrog-cli\u003c/a\u003e action. If going down this route, the upload command would be:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ejf rt upload Alamofire-5.10.1.zip \\\n  https://packages.acme.com/artifactory/api/swift/swift-local/acme/Alamofire/Alamofire-5.10.1.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere is a \u003ca href=\"https://jfrog.com/help/r/jfrog-artifactory-documentation/swift-repository-structure?ref=albertodebortoli.com\"\u003especific structure\u003c/a\u003e to respect:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;REPOSITORY\u0026gt;/\u0026lt;SCOPE\u0026gt;/\u0026lt;NAME\u0026gt;/\u0026lt;NAME\u0026gt;-\u0026lt;VERSION\u0026gt;.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewhich is the last part of the above URL:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift-local/acme/Alamofire/Alamofire-5.10.1.zip\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eToo bad that using the steps above causes a downstream problem with SPM not being able to resolve the dependencies in the registry. I tried extensively and couldn\u0026#39;t find the reason why SPM wouldn\u0026#39;t be happy with how the packages were published. I might have missed something but eventually I necessarily had to switch to use the \u003ccode\u003epublish\u003c/code\u003e command.\u003c/p\u003e\u003cp\u003eUsing the \u003ccode\u003eswift package-registry publish\u003c/code\u003e command instead, doesn\u0026#39;t present this issue hence it\u0026#39;s the solution adopted in this workflow.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package-registry publish acme.Alamofire 5.10.1 \\\n  --url https://packages.acme.com/artifactory/api/swift/swift-local \\\n  --scratch-directory $(mktemp -d)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo verify the upload and indexing succeeded, check that the uploaded \u003ccode\u003e*.zip\u003c/code\u003e artifact is available and that the \u003ccode\u003e.swift\u003c/code\u003e exists (indication that the indexing has occurred). If the specific structure is not respected, the \u003ccode\u003e.swift\u003c/code\u003e folder wouldn\u0026#39;t be generated.\u003c/p\u003e\u003ch2 id=\"consuming-packages-from-the-registry\"\u003eConsuming Packages from the Registry\u003c/h2\u003e\u003ch3 id=\"packages\"\u003ePackages\u003c/h3\u003e\u003cp\u003eThe easiest and only documented way to consume a package from a registry is via a Package. In the \u003ccode\u003ePackage.swift\u003c/code\u003e file, declare dependencies using the \u003ccode\u003e.package(id:from:)\u003c/code\u003e syntax to declare a registry-based dependency. The \u003ccode\u003eid\u003c/code\u003e is a combination of the scope and the package name.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e    ...\n    dependencies: [\n        .package(id: \u0026#34;acme.Alamofire\u0026#34;, from: \u0026#34;5.10.1\u0026#34;),\n    ],\n    targets: [\n        .target(\n            name: \u0026#34;MyApp\u0026#34;,\n            dependencies: [\n                .product(name: \u0026#34;Alamofire\u0026#34;, package: \u0026#34;acme.Alamofire\u0026#34;),\n            ]\n        ),\n        ...\n    ]\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun \u003ccode\u003eswift package resolve\u003c/code\u003e or simply build the Package in Xcode to pull the dependencies.\u003c/p\u003e\u003cp\u003eYou might bump into transitive dependencies (i.e. dependencies listed in the \u003ccode\u003ePackage.swift\u003c/code\u003e files of the packages published on the registry) pointing to GitHub. In this case, it\u0026#39;d be great to instruct SPM to use the corresponding versions on the registry. The \u003ccode\u003e--replace-scm-with-registry\u003c/code\u003e flag is designed to work for the entire dependency graph, including transitive dependencies. \u003c/p\u003e\u003cp\u003eThe cornerstone of associating a registry-hosted package with its GitHub origin is the \u003ccode\u003epackage-metadata.json\u003c/code\u003e file. This file allows to provide essential metadata about the packages at the time of publishing (the \u003ccode\u003e--metadata-path\u003c/code\u003e flag of the \u003ccode\u003epublish\u003c/code\u003e command defaults to \u003ccode\u003epacakge-metadata.json\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eCrucially, it includes a field to specify the source control repository URLs. When \u003ccode\u003eswift package resolve --replace-scm-with-registry\u003c/code\u003e is executed, SPM queries the configured registry. The registry then uses the information from the \u003ccode\u003epackage-metadata.json\u003c/code\u003e to map the package identity to its corresponding GitHub URL, enabling a smooth and transparent resolution process.\u003c/p\u003e\u003cp\u003eThe metadata file must conform to the \u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0391-package-registry-publish.md?ref=albertodebortoli.com#package-release-metadata-standards\"\u003eJSON schema\u003c/a\u003e defined in \u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0391-package-registry-publish.md?ref=albertodebortoli.com\" rel=\"noreferrer\"\u003eSE-0391\u003c/a\u003e. It is recommended to include all URL variations (e.g., SSH, HTTPS) for the same repository. E.g.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;repositoryURLs\u0026#34;: [\n    \u0026#34;https://github.com/Alamofire/Alamofire\u0026#34;,\n    \u0026#34;https://github.com/Alamofire/Alamofire.git\u0026#34;,\n    \u0026#34;git@github.com:Alamofire/Alamofire.git\u0026#34;\n  ]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePrinting the dependencies should confirm the source of the dependencies:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package show-dependencies --replace-scm-with-registry\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen loading a package with Xcode, the flag can be enabled via an environment variable in the scheme\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eIDEPackageDependencySCMToRegistryTransformation=useRegistryIdentityAndSources\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eToo bad that for packages, the schemes won\u0026#39;t load until SPM completes the resolution hence running the following from the terminal would address the issue:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edefaults write com.apple.dt.Xcode IDEPackageDependencySCMToRegistryTransformation useRegistryIdentityAndSources\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ethat can be unset with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edefaults delete com.apple.dt.Xcode IDEPackageDependencySCMToRegistryTransformation\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"xcode\"\u003eXcode\u003c/h3\u003e\u003cp\u003eIt\u0026#39;s likely that you\u0026#39;ll want to use the registry from Xcode projects for direct dependencies. If using the \u003ca href=\"https://tuist.dev/blog/2025/01/22/announcing-tuist-registry?ref=albertodebortoli.com\"\u003eTuist registry\u003c/a\u003e, it seems you would be able to leverage a Package Collection to add dependencies from the registry from the Xcode UI. Note that until Xcode 16.4, it\u0026#39;s not possible to add registry dependencies directly in the Xcode UI, but if you use Tuist to generate your project (as you should), you can use the \u003ccode\u003ePackage.registry\u003c/code\u003e (introduced with \u003ca href=\"https://github.com/tuist/tuist/pull/7225?ref=albertodebortoli.com\"\u003ehttps://github.com/tuist/tuist/pull/7225\u003c/a\u003e). E.g.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet project = Project(\n    ...\n    packages: [\n        .registry(\n            identifier: \u0026#34;acme.Alamofire\u0026#34;,\n            requirement: .exact(Version(stringLiteral: \u0026#34;5.10.1\u0026#34;))\n        )\n    ],\n    ...\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf not using Tuist, you\u0026#39;d have to rely on setting \u003ccode\u003eIDEPackageDependencySCMToRegistryTransformation\u003c/code\u003e either as an environment variable in the scheme or globally via the terminal.\u003c/p\u003e\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\u003cp\u003eWe’ve found that using an in-house Swift registry can significantly reduce dependency resolution time by downloading only the required revision instead of the entire, potentially large, Git repository. This improvement benefits both CI pipelines and developers’ local environments. Additionally, registries help mitigate the risk of supply chain attacks.\u003c/p\u003e\u003cp\u003eAs of this writing, Swift registries are not widely adopted, which is reflected in the limited number of platforms that support them. It\u0026#39;s unclear whether adoption will grow, but when working with dependencies in large repositories, registries offer a more efficient and secure alternative to using XCFrameworks in production builds.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-06-06T08:00:00Z",
  "modifiedTime": "2025-06-14T10:38:27Z"
}
