{
  "id": "06ab7691-83be-4b36-af73-ea4fcc258ad8",
  "title": "Modern URL construction in Swift",
  "link": "https://www.swiftbysundell.com/articles/modern-url-construction-in-swift",
  "description": "How to combine Foundation’s latest URL APIs with Swift features like macros, to be able to work with both static and dynamic URLs in simpler and more predictable ways.",
  "author": "",
  "published": "Mon, 31 Mar 2025 13:00:00 +0200",
  "source": "https://www.swiftbysundell.com/feed.rss",
  "categories": null,
  "byline": "",
  "length": 12654,
  "excerpt": "How to combine Foundation’s latest URL APIs with Swift features like macros, to be able to work with both static and dynamic URLs in simpler and more predictable ways.",
  "siteName": "Swift by Sundell",
  "favicon": "https://www.swiftbysundell.com/images/favicon.png",
  "text": "These days, most applications need to work with URLs in some form. Perhaps they’re used to make network calls, to read and write files, or to perform various kinds of database operations. In Swift, URLs are by convention (and through the design of Apple’s frameworks) represented using the dedicated URL type, rather than just using plain strings, which ensures that we’re actually working with valid, properly formatted URLs.However, that also means that anytime that we have a string that we wish to treat as a URL, we have to perform a conversion that returns an optional — such as in this case:guard let url = URL(string: \"https://swiftbysundell.com\") else { // Hmmm... now what? return print(\"Invalid URL\") }For URLs such as the one above, which are constructed using static string literals, using a conversion that can fail does arguably feel a bit unnecessary. After all, there’s no runtime variance involved here, so there’s really no significant risk that the above kind of conversion will result in nil, unless we’ve made a typo within our code.So, when working with such static URLs, it’s very common to simply use force unwrapping to turn the resulting optional URL into a non-optional one:let url = URL(string: \"https://swiftbysundell.com\")!However, having to do the above kind of force unwrapping manually every time we want to construct a URL is not quite ideal — so let’s see if we can improve things. First, let’s extend URL with an initializer that accepts a StaticString (which are Swift string literals without any kind of interpolation or dynamic components), within which we can perform the required unwrapping, but this time we’ll use a custom fatalError message in case the conversion to a URL failed:extension URL { init(staticString: StaticString) { guard let url = Self(string: \"\\(staticString)\") else { fatalError(\"Invalid static URL string: \\(staticString)\") } self = url } }Using a custom fatalError call in situations when we have to force unwrap a value is in general a good practice, since that lets us provide additional context that can be incredibly useful if we ever need to debug a crash caused by a nil value.With the above in place, we can now easily convert any static string within our code base into a URL, without having to deal with optionals at every single call site:let url = URL(staticString: \"https://swiftbysundell.com\")Nice! Up until Swift 5.9, the above approach was more or less the best simple way to work with inline, static URLs in a non-optional manner (without requiring any external tools, such as code generation). However, Swift 5.9 introduced a new feature that can be incredibly useful in situations like this — macros.It’s macro time!Let’s see if we can write a Swift macro that’ll let us not just convert, but also validate static URL strings at compile time. We’ll start by jumping over to the command line, where we’ll run the following command to create a new macro-based Swift package:swift package init --type macro --name StaticURLOne thing that’s neat about macro packages, is that they come pre-filled with most of the boilerplate that we’ll need to define and vend our macro to any other targets that wish to use it — and it just so happens that the stringify macro that’s added as an example is the exact same type of macro that we’re looking to add — a freestanding expression macro.So let’s go ahead and simply rename the definition of stringify to staticURL, and change its input and output types to match the URL extension we created earlier:import Foundation @freestanding(expression) public macro staticURL(_ value: StaticString) -\u003e URL = #externalMacro( module: \"StaticURLMacros\", type: \"StaticURLMacro\" )Next, let’s rename the StringifyMacro implementation to StaticURLMacro (matching the above definition’s type argument), and replace its previous expansion code with some logic that first ensures that the passed argument is indeed a string literal (although the Swift type system should already have verified that for us), and then extracts the string and attempts to construct a URL using it.If all checks pass, then we generate the same kind of force-unwrapping URL construction code that we manually used to write, which will be the output of our macro. Here’s what all of that looks like:public struct StaticURLMacro: ExpressionMacro { public static func expansion( of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext ) throws -\u003e ExprSyntax { // Verify that a string literal was passed, and extract // the first segment. We can be sure that only one // segment exists, since we're only accepting static // strings (which cannot have any dynamic components): guard let argument = node.arguments.first?.expression, let literal = argument.as(StringLiteralExprSyntax.self), case .stringSegment(let segment) = literal.segments.first else { throw StaticURLMacroError.notAStringLiteral } // Verify that the passed string is indeed a valid URL: guard URL(string: segment.content.text) != nil else { throw StaticURLMacroError.invalidURL } // Generate the code required to construct a URL value // for the passed string at runtime: return \"Foundation.URL(string: \\(argument))!\" } }Note how we prefix the URL type with its parent module (Foundation) above. That’s to avoid conflicts if our macro is used within a context that has declared its own URL type. Applying such prefixes isn’t typically necessary when writing code manually, but is a good practice when writing macros, since we don’t know up-front exactly where our macros will end up being used.With our macro implementation done, all that remains is to define the StaticURLMacroError type that’s used above, and to update our CompilerPlugin to provide the correct macro type:enum StaticURLMacroError: String, Error, CustomStringConvertible { case notAStringLiteral = \"Argument is not a string literal\" case invalidURL = \"Argument is not a valid URL\" public var description: String { rawValue } } @main struct StaticURLPlugin: CompilerPlugin { let providingMacros: [Macro.Type] = [StaticURLMacro.self] }With all those pieces in place, if we integrate our new StaticURL macro package within an application, then we can now easily define static, 100% compile-time validated URLs wherever we’d like:let url = #staticURL(\"https://swiftbysundell.com\")Neat! It could definitely be argued that using a macro isn’t really necessary for a use case like this, given that our earlier StaticString-based extension approach worked just fine (apart from the danger of typos). Like in many cases when working with Swift, this is essentially a trade-off between increased complexity and compile-time safety, and whether or not the additional complexity of a macro will be worth it will likely vary from project to project.Dynamic componentsSo far, we’ve been working with URLs that are known at compile time, but what about ones that have to be constructed at runtime? For example, here we’re using string interpolation to define a URL that’ll be used to load User data from a given web API endpoint:actor NetworkingService { private static let baseURL = \"https://api.myapp.com\" ... func loadUser(withID id: User.ID) async throws -\u003e User { guard let url = URL( string: \"\\(Self.baseURL)/users/\\(id)?refresh=true\" ) else { throw NetworkingError.invalidURL } ... } }Here we’re facing a very similar problem as when working with static URLs — when reading the above code, we can see that there’s no way that the performed URL conversion will ever result in nil, given that our baseURL and /users/ strings are both static, and if we assume that User.ID values are always URL-safe.So would it be possible to convince the compiler that a nil result can never occur, even when working with dynamic URL components? An initial idea might be to use Foundation’s dedicated URLComponents builder — which offers a structured way to construct dynamic URLs.While that approach does have some key advantages over using string interpolation (since we’re now assigning values to explicit parts of the URL we’re building, rather than just working with a loosely formed string) — it’s significantly more verbose in comparison, while still not getting rid of having to unwrap our URL as an optional:actor NetworkingService { private static let baseURLComponents = { var components = URLComponents() components.scheme = \"https\" components.host = \"api.myapp.com\" return components }() ... func loadUser(withID id: User.ID) async throws -\u003e User { var urlComponents = Self.baseURLComponents urlComponents.path = \"/users/\\(id)\" urlComponents.queryItems = [ URLQueryItem(name: \"refresh\", value: \"true\") ] guard let url = urlComponents.url else { throw NetworkingError.invalidURL } ... } }Thankfully, it turns out that there’s a much simpler suite of APIs for dynamic URL construction that were introduced in iOS 16 (and the other 2022 Apple operating system versions) that — when combined with our static URL handling code from before — lets us both completely get rid of optionals, and gives us a really nice syntax for constructing our API call URL.If we declare our base URL as a static URL value (rather than a string, or a URLComponents value), then we can simply call different overloads of the appending API on that value to construct our dynamic URL in a completely optional-free manner — like this:actor NetworkingService { private static let baseURL = #staticURL(\"https://api.myapp.com\") ... func loadUser(withID id: User.ID) async throws -\u003e User { let url = Self.baseURL .appending(components: \"users\", id) .appending(queryItems: [ URLQueryItem(name: \"refresh\", value: \"true\") ]) ... } }Very nice! And the good news is that we’re not limited to just using the above kind of solution when constructing URLs used to perform network calls — we can also use the same suite of APIs when working with file system URLs that we’d previously resolve using FileManager, such as in this example:private extension NetworkingService { func cacheResponseOnDisk(_ response: Response) throws { guard let cacheFolderURL = FileManager.default.urls( for: .cachesDirectory, in: .userDomainMask ).first else { throw NetworkingError.failedToResolveCacheFolder } ... } }If we now convert the above code to use the new URL construction APIs, then we’ll end up with a another non-optional solution, just as when constructing our web API URL:private extension NetworkingService { func cacheResponseOnDisk(_ response: Response) throws { let cacheURL = URL .cachesDirectory .appending(component: response.cacheID) ... } }URL now also contains a number of other static properties that can be used to reference common folders on Apple’s platforms, such as the home and temporary directories — all of which hold a predictable, non-optional value:URL.homeDirectory URL.documentsDirectory URL.desktopDirectory URL.temporaryDirectorySo, as long as we’re targeting the equivalent of iOS 16 or above within a given project, then we’re now able to quite easily construct both web and file system URLs, even when they contain dynamic paths and components, such as query items.Swift by Sundell is brought to you by the Genius Scan SDK — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. Try it today.ConclusionUsing Foundation’s modern URL construction APIs to be able to avoid optionals when creating URL values doesn’t just simplify our code, it also reduces the risk of bugs and crashes, and further lets us work with URLs in more structured ways — by replacing things like string interpolation with dedicated APIs for appending path components and query items.I hope you’ve enjoyed reading this first Swift by Sundell article in over two years, and that you’ll find it useful when working on your Swift projects. If you have any questions, feedback, or comments, then feel free to reach out via either Mastodon or Bluesky.Thanks for reading — and hey, it’s good to be back!",
  "image": "https://www.swiftbysundell.com/images/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eThese days, most applications need to work with URLs in some form. Perhaps they’re used to make network calls, to read and write files, or to perform various kinds of database operations. In Swift, URLs are by convention (and through the design of Apple’s frameworks) represented using the dedicated \u003ccode\u003eURL\u003c/code\u003e type, rather than just using plain strings, which ensures that we’re actually working with valid, properly formatted URLs.\u003c/p\u003e\u003cp\u003eHowever, that also means that anytime that we have a string that we wish to treat as a URL, we have to perform a conversion that returns an optional — such as in this case:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eguard let\u003c/span\u003e url = \u003cspan\u003eURL\u003c/span\u003e(string: \u003cspan\u003e\u0026#34;https://swiftbysundell.com\u0026#34;\u003c/span\u003e) \u003cspan\u003eelse\u003c/span\u003e {\n    \u003cspan\u003e// Hmmm... now what?\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\u0026#34;Invalid URL\u0026#34;\u003c/span\u003e)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor URLs such as the one above, which are constructed using static string literals, using a conversion that can fail does arguably feel a bit \u003cem\u003eunnecessary\u003c/em\u003e. After all, there’s no runtime variance involved here, so there’s really no significant risk that the above kind of conversion will result in \u003ccode\u003enil\u003c/code\u003e, unless we’ve made a typo within our code.\u003c/p\u003e\u003cp\u003eSo, when working with such static URLs, it’s very common to simply use force unwrapping to turn the resulting optional \u003ccode\u003eURL\u003c/code\u003e into a non-optional one:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eURL\u003c/span\u003e(string: \u003cspan\u003e\u0026#34;https://swiftbysundell.com\u0026#34;\u003c/span\u003e)!\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, having to do the above kind of force unwrapping manually every time we want to construct a URL is not quite ideal — so let’s see if we can improve things. First, let’s extend \u003ccode\u003eURL\u003c/code\u003e with an initializer that accepts a \u003ccode\u003eStaticString\u003c/code\u003e (which are Swift string literals without any kind of interpolation or dynamic components), within which we can perform the required unwrapping, but this time we’ll use a custom \u003ccode\u003efatalError\u003c/code\u003e message in case the conversion to a \u003ccode\u003eURL\u003c/code\u003e failed:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextension\u003c/span\u003e \u003cspan\u003eURL\u003c/span\u003e {\n    \u003cspan\u003einit\u003c/span\u003e(staticString: \u003cspan\u003eStaticString\u003c/span\u003e) {\n        \u003cspan\u003eguard let\u003c/span\u003e url = \u003cspan\u003eSelf\u003c/span\u003e(string: \u003cspan\u003e\u0026#34;\u003c/span\u003e\\(staticString)\u003cspan\u003e\u0026#34;\u003c/span\u003e) \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003efatalError\u003c/span\u003e(\u003cspan\u003e\u0026#34;Invalid static URL string:\u003c/span\u003e \\(staticString)\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n        }\n\n        \u003cspan\u003eself\u003c/span\u003e = url\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eUsing a custom \u003ccode\u003efatalError\u003c/code\u003e call in situations when we \u003cem\u003ehave\u003c/em\u003e to force unwrap a value is in general a good practice, since that lets us provide additional context that can be incredibly useful if we ever need to debug a crash caused by a \u003ccode\u003enil\u003c/code\u003e value.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWith the above in place, we can now easily convert any static string within our code base into a \u003ccode\u003eURL\u003c/code\u003e, without having to deal with optionals at every single call site:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eURL\u003c/span\u003e(staticString: \u003cspan\u003e\u0026#34;https://swiftbysundell.com\u0026#34;\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNice! Up until Swift 5.9, the above approach was more or less the best simple way to work with inline, static URLs in a non-optional manner (without requiring any external tools, such as code generation). However, Swift 5.9 introduced a new feature that can be incredibly useful in situations like this — \u003cem\u003emacros\u003c/em\u003e.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"its-macro-time\" href=\"#its-macro-time\"\u003eIt’s macro time!\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s see if we can write a Swift macro that’ll let us not just convert, but also \u003cem\u003evalidate\u003c/em\u003e static URL strings at compile time. We’ll start by jumping over to the command line, where we’ll run the following command to create a new macro-based Swift package:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eswift package init --type macro --name StaticURL\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne thing that’s neat about macro packages, is that they come pre-filled with most of the boilerplate that we’ll need to define and vend our macro to any other targets that wish to use it — and it just so happens that the \u003ccode\u003estringify\u003c/code\u003e macro that’s added as an example is the exact same type of macro that we’re looking to add — a \u003cem\u003efreestanding expression macro\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eSo let’s go ahead and simply rename the definition of \u003ccode\u003estringify\u003c/code\u003e to \u003ccode\u003estaticURL\u003c/code\u003e, and change its input and output types to match the \u003ccode\u003eURL\u003c/code\u003e extension we created earlier:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e Foundation\n\n\u003cspan\u003e@freestanding\u003c/span\u003e(expression)\n\u003cspan\u003epublic macro\u003c/span\u003e staticURL(\u003cspan\u003e_\u003c/span\u003e value: \u003cspan\u003eStaticString\u003c/span\u003e) -\u0026gt; \u003cspan\u003eURL\u003c/span\u003e = \u003cspan\u003e#externalMacro\u003c/span\u003e(\n    module: \u003cspan\u003e\u0026#34;StaticURLMacros\u0026#34;\u003c/span\u003e,\n    type: \u003cspan\u003e\u0026#34;StaticURLMacro\u0026#34;\u003c/span\u003e\n)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, let’s rename the \u003ccode\u003eStringifyMacro\u003c/code\u003e implementation to \u003ccode\u003eStaticURLMacro\u003c/code\u003e (matching the above definition’s \u003ccode\u003etype\u003c/code\u003e argument), and replace its previous \u003ccode\u003eexpansion\u003c/code\u003e code with some logic that first ensures that the passed argument is indeed a string literal (although the Swift type system should already have verified that for us), and then extracts the string and attempts to construct a URL using it.\u003c/p\u003e\u003cp\u003eIf all checks pass, then we generate the same kind of force-unwrapping \u003ccode\u003eURL\u003c/code\u003e construction code that we manually used to write, which will be the output of our macro. Here’s what all of that looks like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic struct\u003c/span\u003e StaticURLMacro: \u003cspan\u003eExpressionMacro\u003c/span\u003e {\n    \u003cspan\u003epublic static func\u003c/span\u003e expansion(\n        of node: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eFreestandingMacroExpansionSyntax\u003c/span\u003e,\n        in context: \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eMacroExpansionContext\u003c/span\u003e\n    ) \u003cspan\u003ethrows\u003c/span\u003e -\u0026gt; \u003cspan\u003eExprSyntax\u003c/span\u003e {\n        \u003cspan\u003e// Verify that a string literal was passed, and extract\n        // the first segment. We can be sure that only one\n        // segment exists, since we\u0026#39;re only accepting static\n        // strings (which cannot have any dynamic components):\u003c/span\u003e\n        \u003cspan\u003eguard let\u003c/span\u003e argument = node.\u003cspan\u003earguments\u003c/span\u003e.\u003cspan\u003efirst\u003c/span\u003e?.\u003cspan\u003eexpression\u003c/span\u003e,\n              \u003cspan\u003elet\u003c/span\u003e literal = argument.\u003cspan\u003eas\u003c/span\u003e(\u003cspan\u003eStringLiteralExprSyntax\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e),\n              \u003cspan\u003ecase\u003c/span\u003e .\u003cspan\u003estringSegment\u003c/span\u003e(\u003cspan\u003elet\u003c/span\u003e segment) = literal.\u003cspan\u003esegments\u003c/span\u003e.\u003cspan\u003efirst\u003c/span\u003e\n        \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eStaticURLMacroError\u003c/span\u003e.\u003cspan\u003enotAStringLiteral\u003c/span\u003e\n        }\n        \n        \u003cspan\u003e// Verify that the passed string is indeed a valid URL:\u003c/span\u003e\n        \u003cspan\u003eguard\u003c/span\u003e \u003cspan\u003eURL\u003c/span\u003e(string: segment.\u003cspan\u003econtent\u003c/span\u003e.\u003cspan\u003etext\u003c/span\u003e) != \u003cspan\u003enil else\u003c/span\u003e {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eStaticURLMacroError\u003c/span\u003e.\u003cspan\u003einvalidURL\u003c/span\u003e\n        }\n\n        \u003cspan\u003e// Generate the code required to construct a URL value\n        // for the passed string at runtime:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;Foundation.URL(string:\u003c/span\u003e \\(argument)\u003cspan\u003e)!\u0026#34;\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003eNote how we prefix the \u003ccode\u003eURL\u003c/code\u003e type with its parent module (\u003ccode\u003eFoundation\u003c/code\u003e) above. That’s to avoid conflicts if our macro is used within a context that has declared its own \u003ccode\u003eURL\u003c/code\u003e type. Applying such prefixes isn’t typically necessary when writing code manually, but is a good practice when writing macros, since we don’t know up-front exactly where our macros will end up being used.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWith our macro implementation done, all that remains is to define the \u003ccode\u003eStaticURLMacroError\u003c/code\u003e type that’s used above, and to update our \u003ccode\u003eCompilerPlugin\u003c/code\u003e to provide the correct macro type:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eenum\u003c/span\u003e StaticURLMacroError: \u003cspan\u003eString\u003c/span\u003e, \u003cspan\u003eError\u003c/span\u003e, \u003cspan\u003eCustomStringConvertible\u003c/span\u003e {\n    \u003cspan\u003ecase\u003c/span\u003e notAStringLiteral = \u003cspan\u003e\u0026#34;Argument is not a string literal\u0026#34;\u003c/span\u003e\n    \u003cspan\u003ecase\u003c/span\u003e invalidURL = \u003cspan\u003e\u0026#34;Argument is not a valid URL\u0026#34;\u003c/span\u003e\n\n    \u003cspan\u003epublic var\u003c/span\u003e description: \u003cspan\u003eString\u003c/span\u003e { rawValue }\n}\n\n\u003cspan\u003e@main struct\u003c/span\u003e StaticURLPlugin: \u003cspan\u003eCompilerPlugin\u003c/span\u003e {\n    \u003cspan\u003elet\u003c/span\u003e providingMacros: [\u003cspan\u003eMacro\u003c/span\u003e.\u003cspan\u003eType\u003c/span\u003e] = [\u003cspan\u003eStaticURLMacro\u003c/span\u003e.\u003cspan\u003eself\u003c/span\u003e]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith all those pieces in place, if we integrate our new \u003ccode\u003eStaticURL\u003c/code\u003e macro package within an application, then we can now easily define static, 100% compile-time validated URLs wherever we’d like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003e#staticURL\u003c/span\u003e(\u003cspan\u003e\u0026#34;https://swiftbysundell.com\u0026#34;\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNeat! It could definitely be argued that using a macro isn’t really necessary for a use case like this, given that our earlier \u003ccode\u003eStaticString\u003c/code\u003e-based extension approach worked just fine (apart from the danger of typos). Like in many cases when working with Swift, this is essentially a trade-off between increased complexity and compile-time safety, and whether or not the additional complexity of a macro will be worth it will likely vary from project to project.\u003c/p\u003e\u003ch2\u003e\u003ca id=\"dynamic-components\" href=\"#dynamic-components\"\u003eDynamic components\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSo far, we’ve been working with URLs that are known at compile time, but what about ones that have to be constructed at runtime? For example, here we’re using string interpolation to define a URL that’ll be used to load \u003ccode\u003eUser\u003c/code\u003e data from a given web API endpoint:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e NetworkingService {\n    \u003cspan\u003eprivate static let\u003c/span\u003e baseURL = \u003cspan\u003e\u0026#34;https://api.myapp.com\u0026#34;\u003c/span\u003e\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eUser\u003c/span\u003e {\n        \u003cspan\u003eguard let\u003c/span\u003e url = \u003cspan\u003eURL\u003c/span\u003e(\n            string: \u003cspan\u003e\u0026#34;\u003c/span\u003e\\(\u003cspan\u003eSelf\u003c/span\u003e.\u003cspan\u003ebaseURL\u003c/span\u003e)\u003cspan\u003e/users/\u003c/span\u003e\\(id)\u003cspan\u003e?refresh=true\u0026#34;\u003c/span\u003e\n        ) \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eNetworkingError\u003c/span\u003e.\u003cspan\u003einvalidURL\u003c/span\u003e\n        }\n\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we’re facing a very similar problem as when working with static URLs — when reading the above code, we can see that there’s no way that the performed \u003ccode\u003eURL\u003c/code\u003e conversion will ever result in \u003ccode\u003enil\u003c/code\u003e, given that our \u003ccode\u003ebaseURL\u003c/code\u003e and \u003ccode\u003e/users/\u003c/code\u003e strings are both static, and if we assume that \u003ccode\u003eUser.ID\u003c/code\u003e values are always URL-safe.\u003c/p\u003e\u003cp\u003eSo would it be possible to convince the compiler that a \u003ccode\u003enil\u003c/code\u003e result can never occur, even when working with dynamic URL components? An initial idea might be to use Foundation’s dedicated \u003ccode\u003eURLComponents\u003c/code\u003e builder — which offers a structured way to construct dynamic URLs.\u003c/p\u003e\u003cp\u003eWhile that approach \u003cem\u003edoes\u003c/em\u003e have some key advantages over using string interpolation (since we’re now assigning values to explicit parts of the URL we’re building, rather than just working with a loosely formed string) — it’s significantly more verbose in comparison, while still not getting rid of having to unwrap our URL as an optional:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e NetworkingService {\n    \u003cspan\u003eprivate static let\u003c/span\u003e baseURLComponents = {\n        \u003cspan\u003evar\u003c/span\u003e components = \u003cspan\u003eURLComponents\u003c/span\u003e()\n        components.\u003cspan\u003escheme\u003c/span\u003e = \u003cspan\u003e\u0026#34;https\u0026#34;\u003c/span\u003e\n        components.\u003cspan\u003ehost\u003c/span\u003e = \u003cspan\u003e\u0026#34;api.myapp.com\u0026#34;\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e components\n    }()\n    \n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eUser\u003c/span\u003e {\n        \u003cspan\u003evar\u003c/span\u003e urlComponents = \u003cspan\u003eSelf\u003c/span\u003e.\u003cspan\u003ebaseURLComponents\u003c/span\u003e\n        urlComponents.\u003cspan\u003epath\u003c/span\u003e = \u003cspan\u003e\u0026#34;/users/\u003c/span\u003e\\(id)\u003cspan\u003e\u0026#34;\u003c/span\u003e\n        urlComponents.\u003cspan\u003equeryItems\u003c/span\u003e = [\n            \u003cspan\u003eURLQueryItem\u003c/span\u003e(name: \u003cspan\u003e\u0026#34;refresh\u0026#34;\u003c/span\u003e, value: \u003cspan\u003e\u0026#34;true\u0026#34;\u003c/span\u003e)\n        ]\n\n        \u003cspan\u003eguard let\u003c/span\u003e url = urlComponents.\u003cspan\u003eurl\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eNetworkingError\u003c/span\u003e.\u003cspan\u003einvalidURL\u003c/span\u003e\n        }\n\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThankfully, it turns out that there’s a much simpler suite of APIs for dynamic URL construction that were introduced in iOS 16 (and the other 2022 Apple operating system versions) that — when combined with our static URL handling code from before — lets us both completely get rid of optionals, and gives us a really nice syntax for constructing our API call URL.\u003c/p\u003e\u003cp\u003eIf we declare our base URL as a static \u003ccode\u003eURL\u003c/code\u003e value (rather than a string, or a \u003ccode\u003eURLComponents\u003c/code\u003e value), then we can simply call different overloads of the \u003ccode\u003eappending\u003c/code\u003e API on that value to construct our dynamic URL in a completely optional-free manner — like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eactor\u003c/span\u003e NetworkingService {\n    \u003cspan\u003eprivate static let\u003c/span\u003e baseURL = \u003cspan\u003e#staticURL\u003c/span\u003e(\u003cspan\u003e\u0026#34;https://api.myapp.com\u0026#34;\u003c/span\u003e)\n    ...\n\n    \u003cspan\u003efunc\u003c/span\u003e loadUser(withID id: \u003cspan\u003eUser\u003c/span\u003e.\u003cspan\u003eID\u003c/span\u003e) \u003cspan\u003easync throws\u003c/span\u003e -\u0026gt; \u003cspan\u003eUser\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e url = \u003cspan\u003eSelf\u003c/span\u003e.\u003cspan\u003ebaseURL\u003c/span\u003e\n            .\u003cspan\u003eappending\u003c/span\u003e(components: \u003cspan\u003e\u0026#34;users\u0026#34;\u003c/span\u003e, id)\n            .\u003cspan\u003eappending\u003c/span\u003e(queryItems: [\n                \u003cspan\u003eURLQueryItem\u003c/span\u003e(name: \u003cspan\u003e\u0026#34;refresh\u0026#34;\u003c/span\u003e, value: \u003cspan\u003e\u0026#34;true\u0026#34;\u003c/span\u003e)\n            ])\n            \n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVery nice! And the good news is that we’re not limited to just using the above kind of solution when constructing URLs used to perform network calls — we can also use the same suite of APIs when working with file system URLs that we’d previously resolve using \u003ccode\u003eFileManager\u003c/code\u003e, such as in this example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eNetworkingService\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e cacheResponseOnDisk(\u003cspan\u003e_\u003c/span\u003e response: \u003cspan\u003eResponse\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n        \u003cspan\u003eguard let\u003c/span\u003e cacheFolderURL = \u003cspan\u003eFileManager\u003c/span\u003e.\u003cspan\u003edefault\u003c/span\u003e.\u003cspan\u003eurls\u003c/span\u003e(\n            for: .\u003cspan\u003ecachesDirectory\u003c/span\u003e,\n            in: .\u003cspan\u003euserDomainMask\u003c/span\u003e\n        ).\u003cspan\u003efirst\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e {\n            \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003eNetworkingError\u003c/span\u003e.\u003cspan\u003efailedToResolveCacheFolder\u003c/span\u003e\n        }\n\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf we now convert the above code to use the new URL construction APIs, then we’ll end up with a another non-optional solution, just as when constructing our web API URL:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate extension\u003c/span\u003e \u003cspan\u003eNetworkingService\u003c/span\u003e {\n    \u003cspan\u003efunc\u003c/span\u003e cacheResponseOnDisk(\u003cspan\u003e_\u003c/span\u003e response: \u003cspan\u003eResponse\u003c/span\u003e) \u003cspan\u003ethrows\u003c/span\u003e {\n        \u003cspan\u003elet\u003c/span\u003e cacheURL = \u003cspan\u003eURL\u003c/span\u003e\n            .\u003cspan\u003ecachesDirectory\u003c/span\u003e\n            .\u003cspan\u003eappending\u003c/span\u003e(component: response.\u003cspan\u003ecacheID\u003c/span\u003e)\n\n        ...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eURL\u003c/code\u003e now also contains a number of other static properties that can be used to reference common folders on Apple’s platforms, such as the home and temporary directories — all of which hold a predictable, non-optional value:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eURL\u003c/span\u003e.\u003cspan\u003ehomeDirectory\u003c/span\u003e\n\u003cspan\u003eURL\u003c/span\u003e.\u003cspan\u003edocumentsDirectory\u003c/span\u003e\n\u003cspan\u003eURL\u003c/span\u003e.\u003cspan\u003edesktopDirectory\u003c/span\u003e\n\u003cspan\u003eURL\u003c/span\u003e.\u003cspan\u003etemporaryDirectory\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo, as long as we’re targeting the equivalent of iOS 16 or above within a given project, then we’re now able to quite easily construct both web and file system URLs, even when they contain dynamic paths and components, such as query items.\u003c/p\u003e\u003ca href=\"https://geniusscansdk.com/swiftbysundell?utm_content=inline_ad\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"https://www.swiftbysundell.com/images/supporters/geniusScan-image.png\" alt=\"Genius Scan SDK\"/\u003e\u003cp\u003eSwift by Sundell is brought to you by the \u003cstrong\u003eGenius Scan SDK\u003c/strong\u003e — Add a powerful document scanner to any mobile app, and turn scans into high-quality PDFs with one line of code. \u003cu\u003eTry it today\u003c/u\u003e.\u003c/p\u003e\u003c/a\u003e\u003ch2\u003e\u003ca id=\"conclusion\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eUsing Foundation’s modern URL construction APIs to be able to avoid optionals when creating \u003ccode\u003eURL\u003c/code\u003e values doesn’t just simplify our code, it also reduces the risk of bugs and crashes, and further lets us work with URLs in more structured ways — by replacing things like string interpolation with dedicated APIs for appending path components and query items.\u003c/p\u003e\u003cp\u003eI hope you’ve enjoyed reading this first Swift by Sundell article in over two years, and that you’ll find it useful when working on your Swift projects. If you have any questions, feedback, or comments, then feel free to reach out via either \u003ca href=\"https://mastodon.social/@johnsundell\"\u003eMastodon\u003c/a\u003e or \u003ca href=\"https://bsky.app/profile/johnsundell.bsky.social\"\u003eBluesky\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThanks for reading — and hey, it’s good to be back!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
