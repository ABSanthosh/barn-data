{
  "id": "e6d378e6-60b9-49bb-ad9b-f82c1346e64b",
  "title": "NetNewsWire and Conditional GET Issues",
  "link": "https://inessential.com/2024/08/03/netnewswire_and_conditional_get_issues.html",
  "description": "I had thought that NetNewsWire’s conditional GET support was rock-solid — and so my first reaction was to be very surprised to learn that it’s not! My second reaction was to be appreciative — Rachel’s work here on setting up a test server and reporting on the results is really great. My goal has always been to make NetNewsWire a model net citizen, and learning where it’s not is super valuable. So: much respect and thanks to Rachel for this. The Data Let’s look at some data and try to figure out what’s happening. Here’s Rachel’s report for NetNewsWire. Things to know: these are all requests for a NetNewsWire-specific feed, and the copy of NetNewsWire making these requests is on my personal laptop. That laptop is occasionally used for development, which can throw things off, but not often. You can even see in the data a gap lasting just over two weeks where there were no requests (I was on vacation). (You can also see some anomalies from when I had it on my dev machine also — ignore every row where ip is v6, since that’s my dev machine.) Another thing to know: this is testing direct feed-reading, as with the On My Mac (or iPhone/iPad) and iCloud accounts. With systems such as Feedly, Feedbin, and so on, we get the data from the sync system and not directly from the site. Ignoring Timing Issues Let’s set aside, at least for today, the timing issues. That situation could be improved, but it very much reflects that this is a desktop app with a command that allows you to refresh feeds manually, without having to wait for the next poll. Conditional GET Issues First, a refresher on how this should work. When a server returns a Last-Modified header, the client should return that exact same string in follow-up requests in an If-Modified-Since header. The server then looks at the If-Modified-Since header and decides to either return a 200 plus the feed — if it has been modified since — or return a 304 Not Modified response and an empty body. It’s the same story with the Etag header. The client should save it and return it in follow-up requests in an If-None-Match header. This is great because it can save a ton of bandwidth, which is great for server and app alike. And NetNewsWire’s been doing this since the early 2000s. But clearly there’s a bug! In some cases, NetNewsWire is not picking up and saving the changed Last-Modified and Etag headers. Sometimes it does, and sometimes it keeps using whatever it already had and ignores the new ones. What could account for this? Let’s look at the logic. Feed processing logic Here’s what happens when a feed download completes without errors and the content is non-empty: First we check the hash of the raw feed data against the hash of the raw feed data the last time it actually changed. If those hashes match, then the app stops processing, because the feed hasn’t changed: it’s exactly the same as last time. This is an optimization that deals with the fact that many servers unfortunately don’t support conditional GET. It allows the app to skip feed parsing and updating the database. Saves a bunch of work. Good for battery life. If the hashes don’t match, then processing continues: it parses the feed and then sends the parsed articles to the code that updates the database. After that it updates and saves the hash of the raw feed data, and finally it stores the conditional GET info — it saves any Last-Modified and Etag header values to send with the next request. This isn’t actually the code, but it’s what the logic looks like: downloadDidComplete(httpResponse, feed, feedData) hash = feedData.md5 if hash == feed.previousHash then return parsedFeed = parse(feedData) updateDatabase(feed, parsedFeed) feed.previousHash = hash feed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse) My theory There’s a great chance you’ve already spotted what I think is the issue: it’s that optimization where we check the hash of the raw feed data and return if it matches the previous hash. Here’s what I think has happened in some of the tests: the raw feed data was unchanged, but one or both of the Last-Modified and Etag header values did change. NetNewsWire never picked up the changes to those headers, because that code didn’t run — it had already bailed when it saw that the raw feed data was unchanged. The assumption I made when I wrote this code was that if the raw feed data was unchanged then of course the Last-Modified and Etag header values would be unchanged too, so there was no need to check to see if they were new. And I think that in real-world situations this is probably true pretty much all the time, and it’s only in tests like this where my assumption wouldn’t be true. But I can’t say that for sure! This is a real bug, and we’ll fix it and add a test or tests to make sure it doesn’t happen again. Here’s what the new logic should look like: downloadDidComplete(httpResponse, feedData, feed) hash = feedData.md5 if hash != feed.previousHash { parsedFeed = parse(feedData) updateDatabase(feed, parsedFeed) feed.previousHash = hash } feed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse) With the above logic, conditionalGetInfo gets updated no matter what. PS There could be other bugs My theory does point to a bug that should get fixed. But is it the only bug? Is it even the bug that causes the issues in these tests? Though I’m pretty confident that this is the bug — seems pretty obvious, right? — more investigation and testing is warranted.",
  "author": "",
  "published": "Sat, 03 Aug 2024 14:21:37 -0700",
  "source": "https://inessential.com/xml/rss.xml",
  "categories": null,
  "byline": "by Brent Simmons",
  "length": 5536,
  "excerpt": "I had thought that NetNewsWire’s conditional GET support was rock-solid — and so my first reaction was to be very surprised to learn that it’s not!",
  "siteName": "",
  "favicon": "",
  "text": "I had thought that NetNewsWire’s conditional GET support was rock-solid — and so my first reaction was to be very surprised to learn that it’s not! My second reaction was to be appreciative — Rachel’s work here on setting up a test server and reporting on the results is really great. My goal has always been to make NetNewsWire a model net citizen, and learning where it’s not is super valuable. So: much respect and thanks to Rachel for this. The Data Let’s look at some data and try to figure out what’s happening. Here’s Rachel’s report for NetNewsWire. Things to know: these are all requests for a NetNewsWire-specific feed, and the copy of NetNewsWire making these requests is on my personal laptop. That laptop is occasionally used for development, which can throw things off, but not often. You can even see in the data a gap lasting just over two weeks where there were no requests (I was on vacation). (You can also see some anomalies from when I had it on my dev machine also — ignore every row where ip is v6, since that’s my dev machine.) Another thing to know: this is testing direct feed-reading, as with the On My Mac (or iPhone/iPad) and iCloud accounts. With systems such as Feedly, Feedbin, and so on, we get the data from the sync system and not directly from the site. Ignoring Timing Issues Let’s set aside, at least for today, the timing issues. That situation could be improved, but it very much reflects that this is a desktop app with a command that allows you to refresh feeds manually, without having to wait for the next poll. Conditional GET Issues First, a refresher on how this should work. When a server returns a Last-Modified header, the client should return that exact same string in follow-up requests in an If-Modified-Since header. The server then looks at the If-Modified-Since header and decides to either return a 200 plus the feed — if it has been modified since — or return a 304 Not Modified response and an empty body. It’s the same story with the Etag header. The client should save it and return it in follow-up requests in an If-None-Match header. This is great because it can save a ton of bandwidth, which is great for server and app alike. And NetNewsWire’s been doing this since the early 2000s. But clearly there’s a bug! In some cases, NetNewsWire is not picking up and saving the changed Last-Modified and Etag headers. Sometimes it does, and sometimes it keeps using whatever it already had and ignores the new ones. What could account for this? Let’s look at the logic. Feed processing logic Here’s what happens when a feed download completes without errors and the content is non-empty: First we check the hash of the raw feed data against the hash of the raw feed data the last time it actually changed. If those hashes match, then the app stops processing, because the feed hasn’t changed: it’s exactly the same as last time. This is an optimization that deals with the fact that many servers unfortunately don’t support conditional GET. It allows the app to skip feed parsing and updating the database. Saves a bunch of work. Good for battery life. If the hashes don’t match, then processing continues: it parses the feed and then sends the parsed articles to the code that updates the database. After that it updates and saves the hash of the raw feed data, and finally it stores the conditional GET info — it saves any Last-Modified and Etag header values to send with the next request. This isn’t actually the code, but it’s what the logic looks like: downloadDidComplete(httpResponse, feed, feedData) hash = feedData.md5 if hash == feed.previousHash then return parsedFeed = parse(feedData) updateDatabase(feed, parsedFeed) feed.previousHash = hash feed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse) My theory There’s a great chance you’ve already spotted what I think is the issue: it’s that optimization where we check the hash of the raw feed data and return if it matches the previous hash. Here’s what I think has happened in some of the tests: the raw feed data was unchanged, but one or both of the Last-Modified and Etag header values did change. NetNewsWire never picked up the changes to those headers, because that code didn’t run — it had already bailed when it saw that the raw feed data was unchanged. The assumption I made when I wrote this code was that if the raw feed data was unchanged then of course the Last-Modified and Etag header values would be unchanged too, so there was no need to check to see if they were new. And I think that in real-world situations this is probably true pretty much all the time, and it’s only in tests like this where my assumption wouldn’t be true. But I can’t say that for sure! This is a real bug, and we’ll fix it and add a test or tests to make sure it doesn’t happen again. Here’s what the new logic should look like: downloadDidComplete(httpResponse, feedData, feed) hash = feedData.md5 if hash != feed.previousHash { parsedFeed = parse(feedData) updateDatabase(feed, parsedFeed) feed.previousHash = hash } feed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse) With the above logic, conditionalGetInfo gets updated no matter what. PS There could be other bugs My theory does point to a bug that should get fixed. But is it the only bug? Is it even the bug that causes the issues in these tests? Though I’m pretty confident that this is the bug — seems pretty obvious, right? — more investigation and testing is warranted.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eI had thought that NetNewsWire’s conditional GET support was rock-solid — and so my first reaction was to be very surprised to \u003ca href=\"https://rachelbythebay.com/w/2024/08/02/fs/\"\u003elearn that it’s not\u003c/a\u003e!\u003c/p\u003e\n\n\u003cp\u003eMy second reaction was to be appreciative — Rachel’s work here on setting up a test server and reporting on the results is really great. My goal has always been to make NetNewsWire a model net citizen, and learning where it’s not is super valuable. So: much respect and thanks to Rachel for this.\u003c/p\u003e\n\n\u003ch4 id=\"the-data\"\u003eThe Data\u003c/h4\u003e\n\n\u003cp\u003eLet’s look at some data and try to figure out what’s happening. \u003ca href=\"https://rachelbythebay.com/api/fsr/4467c09c31370b8375c6b2a320aa77cd5d999cd4\"\u003eHere’s Rachel’s report for NetNewsWire\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThings to know: these are all requests for a NetNewsWire-specific feed, and the copy of NetNewsWire making these requests is on my personal laptop. That laptop is occasionally used for development, which can throw things off, but not often. You can even see in the data a gap lasting just over two weeks where there were no requests (I was on vacation).\u003c/p\u003e\n\n\u003cp\u003e(You can also see some anomalies from when I had it on my dev machine also — ignore every row where ip is v6, since that’s my dev machine.)\u003c/p\u003e\n\n\u003cp\u003eAnother thing to know: this is testing direct feed-reading, as with the On My Mac (or iPhone/iPad) and iCloud accounts. With systems such as Feedly, Feedbin, and so on, we get the data from the sync system and not directly from the site.\u003c/p\u003e\n\n\u003ch4 id=\"ignoring-timing-issues\"\u003eIgnoring Timing Issues\u003c/h4\u003e\n\n\u003cp\u003eLet’s set aside, at least for today, the timing issues. That situation could be improved, but it very much reflects that this is a desktop app with a command that allows you to refresh feeds manually, without having to wait for the next poll.\u003c/p\u003e\n\n\u003ch4 id=\"conditional-get-issues\"\u003eConditional GET Issues\u003c/h4\u003e\n\n\u003cp\u003eFirst, a refresher on how this should work.\u003c/p\u003e\n\n\u003cp\u003eWhen a server returns a Last-Modified header, the client should return that exact same string in follow-up requests in an If-Modified-Since header. The server then looks at the If-Modified-Since header and decides to either return a 200 plus the feed — if it \u003cem\u003ehas\u003c/em\u003e been modified since — or return a 304 Not Modified response and an empty body.\u003c/p\u003e\n\n\u003cp\u003eIt’s the same story with the Etag header. The client should save it and return it in follow-up requests in an If-None-Match header.\u003c/p\u003e\n\n\u003cp\u003eThis is great because it can save a ton of bandwidth, which is great for server and app alike. And NetNewsWire’s been doing this since the early 2000s.\u003c/p\u003e\n\n\u003cp\u003eBut clearly there’s a bug! In some cases, NetNewsWire is not picking up and saving the changed Last-Modified and Etag headers. Sometimes it does, and sometimes it keeps using whatever it already had and ignores the new ones.\u003c/p\u003e\n\n\u003cp\u003eWhat could account for this? Let’s look at the logic.\u003c/p\u003e\n\n\u003ch4 id=\"feed-processing-logic\"\u003eFeed processing logic\u003c/h4\u003e\n\n\u003cp\u003eHere’s what happens when a feed download completes without errors and the content is non-empty:\u003c/p\u003e\n\n\u003cp\u003eFirst we check the hash of the raw feed data against the hash of the raw feed data the last time it actually changed. If those hashes match, then the app stops processing, because the feed hasn’t changed: it’s exactly the same as last time.\u003c/p\u003e\n\n\u003cp\u003eThis is an optimization that deals with the fact that many servers unfortunately don’t support conditional GET. It allows the app to skip feed parsing and updating the database. Saves a bunch of work. Good for battery life.\u003c/p\u003e\n\n\u003cp\u003eIf the hashes don’t match, then processing continues: it parses the feed and then sends the parsed articles to the code that updates the database.\u003c/p\u003e\n\n\u003cp\u003eAfter that it updates and saves the hash of the raw feed data, and finally it stores the conditional GET info — it saves any Last-Modified and Etag header values to send with the next request.\u003c/p\u003e\n\n\u003cp\u003eThis isn’t actually the code, but it’s what the logic looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003edownloadDidComplete(httpResponse, feed, feedData)\n\thash = feedData.md5\n\tif hash == feed.previousHash then return\n\tparsedFeed = parse(feedData)\n\tupdateDatabase(feed, parsedFeed)\n\tfeed.previousHash = hash\n\tfeed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"my-theory\"\u003eMy theory\u003c/h4\u003e\n\n\u003cp\u003eThere’s a great chance you’ve already spotted what I think is the issue: it’s that optimization where we check the hash of the raw feed data and return if it matches the previous hash.\u003c/p\u003e\n\n\u003cp\u003eHere’s what I think has happened in some of the tests: the raw feed data was unchanged, but one or both of the Last-Modified and Etag header values \u003cem\u003edid\u003c/em\u003e change.\u003c/p\u003e\n\n\u003cp\u003eNetNewsWire never picked up the changes to those headers, because that code didn’t run — it had already bailed when it saw that the raw feed data was unchanged.\u003c/p\u003e\n\n\u003cp\u003eThe assumption I made when I wrote this code was that if the raw feed data was unchanged then of course the Last-Modified and Etag header values would be unchanged too, so there was no need to check to see if they were new.\u003c/p\u003e\n\n\u003cp\u003eAnd I think that in real-world situations this is probably true pretty much all the time, and it’s only in tests like this where my assumption wouldn’t be true.\u003c/p\u003e\n\n\u003cp\u003eBut I can’t say that for sure! This is a real bug, and we’ll fix it and add a test or tests to make sure it doesn’t happen again.\u003c/p\u003e\n\n\u003cp\u003eHere’s what the new logic should look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003edownloadDidComplete(httpResponse, feedData, feed)\n\thash = feedData.md5\n\tif hash != feed.previousHash {\n\t\tparsedFeed = parse(feedData)\n\t\tupdateDatabase(feed, parsedFeed)\n\t\tfeed.previousHash = hash\n\t}\n\tfeed.conditionalGetInfo = conditionalGetInfoFromResponse(httpResponse)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith the above logic, conditionalGetInfo gets updated no matter what.\u003c/p\u003e\n\n\u003ch4 id=\"ps-there-could-be-other-bugs\"\u003ePS There could be other bugs\u003c/h4\u003e\n\n\u003cp\u003eMy theory does point to a bug that should get fixed. But is it the only bug? Is it even the bug that causes the issues in these tests?\u003c/p\u003e\n\n\u003cp\u003eThough I’m pretty confident that this is the bug — seems pretty obvious, right? — more investigation and testing is warranted.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
