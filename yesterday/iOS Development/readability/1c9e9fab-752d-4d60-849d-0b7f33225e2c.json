{
  "id": "1c9e9fab-752d-4d60-849d-0b7f33225e2c",
  "title": "Swift Parameterized Testing",
  "link": "https://useyourloaf.com/blog/swift-parameterized-testing/",
  "description": "Apple introduced Swift Testing at WWDC24. One of the interesting features is the ability to pass arguments to a test function. Parameterized Testing The Swift Testing @Test macro has an arguments parameter which accepts a collection of values: @Test(\"Even Value\", arguments: [2, 8, 50]) func even(value: Int) { #expect(value.isMultiple(of: 2)) } Swift Testing calls the test function once for each value in the arguments collection. The Test Navigator shows the results of each of the test runs: If you pass a second argument, Swift Testing generates test cases for all combinations of the two arguments: @Test(\"Product is even\", arguments: [2, 8, 50], [3, 6, 9]) func productEven(value: Int, multiplier: Int) { let product = value * multiplier #expect(product.isMultiple(of: 2)) } The Test Navigator shows nine test results covering all combinations of the input arguments: You’re limited to at most two arguments. If you don’t need every combination you can zip the arguments to pair them: @Test(\"Product is even\", arguments: zip([2, 8, 50], [3, 6, 9])) func productEven(value: Int, multiplier: Int) { let product = value * multiplier #expect(product.isMultiple(of: 2)) } The Test Navigator now shows this test running three times with consecutive pairs of arguments: That all makes for a good demo but how useful is it in practise? Migrating from XCTest I recently migrated some XCTest based unit tests to Swift Testing. I was happy to find examples where I could use parameters to either combine or simplify tests. The parameter based testing works best when you have a collection of input arguments for which you expect the same result. I’ve found this extra convenient when you can organise the input data as a CaseIterable enum that can drive the tests. For example, I like to verify the attributes of each property in my Core Data managed object classes. This protects me from accidentally renaming or changing the type of the property in the Core Data model editor. I have the attributes of each Core Data class listed as enums organised by type. For example, a Country has these String attributes: enum StringAttribute: String, CaseIterable { case capital case name case continent case currency } A test to verify each of these string attributes: private let entityName = \"Country\" private let container: NSPeristentContainer @Test( \"Verify String attributes\", arguments: Country.StringAttribute.allCases) func stringAttributes(_ name: Country.StringAttribute) throws { let entity = try #require( container.managedObjectModel.entitiesByName[entityName]) let attribute = try #require(entity.attributesByName[name.rawValue]) #expect(attribute.type == .string) } I’m yet to find a practical example for when I need all combinations of two arguments though I have some situations where I’ve found zip’ing two arguments useful. Why Bother? I can write the previous test without arguments using a for-loop to iterate over the enum cases. The Swift Testing approach with parameters has some advantages: Each call of the test function with a different argument is an independent test case than can run in parallel. It’s much clearer when a test case fails. You can also rerun just the failing argument from the test navigator by clicking on the red failure icon: Learn More Migrating XCTest to Swift Testing WWDC24 Go further with Swift Testing Swift Parameterized Testing was originally posted 06 Jan 2025 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 06 Jan 2025 10:06:42 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 3382,
  "excerpt": "Swift Testing lets you pass arguments to test functions.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "Apple introduced Swift Testing at WWDC24. One of the interesting features is the ability to pass arguments to a test function. Parameterized Testing The Swift Testing @Test macro has an arguments parameter which accepts a collection of values: @Test(\"Even Value\", arguments: [2, 8, 50]) func even(value: Int) { #expect(value.isMultiple(of: 2)) } Swift Testing calls the test function once for each value in the arguments collection. The Test Navigator shows the results of each of the test runs: If you pass a second argument, Swift Testing generates test cases for all combinations of the two arguments: @Test(\"Product is even\", arguments: [2, 8, 50], [3, 6, 9]) func productEven(value: Int, multiplier: Int) { let product = value * multiplier #expect(product.isMultiple(of: 2)) } The Test Navigator shows nine test results covering all combinations of the input arguments: You’re limited to at most two arguments. If you don’t need every combination you can zip the arguments to pair them: @Test(\"Product is even\", arguments: zip([2, 8, 50], [3, 6, 9])) func productEven(value: Int, multiplier: Int) { let product = value * multiplier #expect(product.isMultiple(of: 2)) } The Test Navigator now shows this test running three times with consecutive pairs of arguments: That all makes for a good demo but how useful is it in practise? Migrating from XCTest I recently migrated some XCTest based unit tests to Swift Testing. I was happy to find examples where I could use parameters to either combine or simplify tests. The parameter based testing works best when you have a collection of input arguments for which you expect the same result. I’ve found this extra convenient when you can organise the input data as a CaseIterable enum that can drive the tests. For example, I like to verify the attributes of each property in my Core Data managed object classes. This protects me from accidentally renaming or changing the type of the property in the Core Data model editor. I have the attributes of each Core Data class listed as enums organised by type. For example, a Country has these String attributes: enum StringAttribute: String, CaseIterable { case capital case name case continent case currency } A test to verify each of these string attributes: private let entityName = \"Country\" private let container: NSPeristentContainer @Test( \"Verify String attributes\", arguments: Country.StringAttribute.allCases) func stringAttributes(_ name: Country.StringAttribute) throws { let entity = try #require( container.managedObjectModel.entitiesByName[entityName]) let attribute = try #require(entity.attributesByName[name.rawValue]) #expect(attribute.type == .string) } I’m yet to find a practical example for when I need all combinations of two arguments though I have some situations where I’ve found zip’ing two arguments useful. Why Bother? I can write the previous test without arguments using a for-loop to iterate over the enum cases. The Swift Testing approach with parameters has some advantages: Each call of the test function with a different argument is an independent test case than can run in parallel. It’s much clearer when a test case fails. You can also rerun just the failing argument from the test navigator by clicking on the red failure icon: Learn More Migrating XCTest to Swift Testing WWDC24 Go further with Swift Testing",
  "image": "https://useyourloaf.com/blog/swift-parameterized-testing/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eApple introduced Swift Testing at WWDC24. One of the interesting features is the ability to pass arguments to a test function.\u003c/p\u003e\n\u003ch3 id=\"parameterized-testing\"\u003eParameterized Testing\u003c/h3\u003e\n\u003cp\u003eThe Swift Testing @Test macro has an arguments parameter which accepts a collection of values:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Even Value\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e50\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eeven\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisMultiple\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eof\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSwift Testing calls the test function once for each value in the arguments collection. The Test Navigator shows the results of each of the test runs:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swift-parameterized-testing/001.png\" alt=\"Test navigator showing value is even test with three passing tests for values 2, 8, and 50\" width=\"250\" height=\"100\" srcset=\"https://useyourloaf.com/blog/swift-parameterized-testing/001@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eIf you pass a second argument, Swift Testing generates test cases for \u003cstrong\u003eall combinations of the two arguments\u003c/strong\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Product is even\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e50\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eproductEven\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emultiplier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eproduct\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003emultiplier\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eproduct\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisMultiple\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eof\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe Test Navigator shows nine test results covering all combinations of the input arguments:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swift-parameterized-testing/002.png\" alt=\"Test navigator showing product is even test with nine passing tests for all combinations of the arguments\" width=\"250\" height=\"245\" srcset=\"https://useyourloaf.com/blog/swift-parameterized-testing/002@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou’re limited to at most two arguments\u003c/strong\u003e. If you don’t need every combination you can \u003cstrong\u003ezip the arguments\u003c/strong\u003e to pair them:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Product is even\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ezip\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e50\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e\u003cspan\u003e]))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eproductEven\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emultiplier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eproduct\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003emultiplier\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eproduct\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisMultiple\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eof\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe Test Navigator now shows this test running three times with consecutive pairs of arguments:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swift-parameterized-testing/003.png\" alt=\"Test navigator showing product is even test with three passing tests for the pairs 2 and 3, 8 and 6, and, 50 and 9\" width=\"250\" height=\"95\" srcset=\"https://useyourloaf.com/blog/swift-parameterized-testing/003@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eThat all makes for a good demo but how useful is it in practise?\u003c/p\u003e\n\u003ch3 id=\"migrating-from-xctest\"\u003eMigrating from XCTest\u003c/h3\u003e\n\u003cp\u003eI recently migrated some XCTest based unit tests to Swift Testing. I was happy to find examples where I could use parameters to either combine or simplify tests.\u003c/p\u003e\n\u003cp\u003eThe parameter based testing works best when you have a collection of input arguments for which you expect the same result. I’ve found this extra convenient when you can organise the input data as a CaseIterable enum that can drive the tests.\u003c/p\u003e\n\u003cp\u003eFor example, I like to verify the attributes of each property in my Core Data managed object classes. This protects me from accidentally renaming or changing the type of the property in the Core Data model editor. I have the attributes of each Core Data class listed as enums organised by type. For example, a \u003ccode\u003eCountry\u003c/code\u003e has these \u003ccode\u003eString\u003c/code\u003e attributes:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eStringAttribute\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eCaseIterable\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003ecapital\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003econtinent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003ecurrency\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eA test to verify each of these string attributes:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eentityName\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Country\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNSPeristentContainer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e\u0026#34;Verify String attributes\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earguments\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCountry\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eStringAttribute\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eallCases\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003estringAttributes\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCountry\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eStringAttribute\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eentity\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emanagedObjectModel\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eentitiesByName\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eentityName\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eattribute\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eentity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eattributesByName\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erawValue\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eattribute\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI’m yet to find a practical example for when I need all combinations of two arguments though I have some situations where I’ve found zip’ing two arguments useful.\u003c/p\u003e\n\u003ch3 id=\"why-bother\"\u003eWhy Bother?\u003c/h3\u003e\n\u003cp\u003eI can write the previous test without arguments using a for-loop to iterate over the enum cases. The Swift Testing approach with parameters has some advantages:\u003c/p\u003e\n\u003cp\u003eEach call of the test function with a different argument is an independent test case than can run in parallel.\nIt’s much clearer when a test case fails. You can also rerun just the failing argument from the test navigator by clicking on the red failure icon:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/swift-parameterized-testing/004.png\" alt=\"Test Navigator showinf five verify string attributes tests, four passing with green ticks and a population test failing with a red cross\" width=\"250\" height=\"145\" srcset=\"https://useyourloaf.com/blog/swift-parameterized-testing/004@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/\"\u003eMigrating XCTest to Swift Testing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2024/10195?time=443\"\u003eWWDC24 Go further with Swift Testing\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-01-06T10:06:42Z",
  "modifiedTime": "2025-01-06T16:21:29Z"
}
