{
  "id": "f6159763-98a4-49ad-af60-618ea07ff450",
  "title": "Approachable Concurrency in Swift Packages",
  "link": "https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/",
  "description": "Xcode 26 ships with Swift 6.2 and enables Approachable Concurrency. How do you adopt it in existing projects and in Swift Packages? What is Approachable Concurrency? In Swift 6.2 Apple is introducing a new more approachable way to use Swift Concurrency. It starts with the assumption that you start by running your app’s code on the main thread and only move work to a background thread when needed. I highly recommend watching the session video WWDC25 Embracing Swift concurrency and/or reading the Swift Evolution proposals to learn more: SE-0461 Run nonisolated async functions on the caller’s actor by default SE-0466 Control default actor isolation inference SE-0470 Global-actor isolated conformances Enabling in Xcode 26 Creating a new project with Xcode 26 enables MainActor default isolation and approachable concurrency by default. For an existing project you opt-in by changing the build settings for a target: Enabling Approachable Concurrency enables a couple of extra upcoming features: The Infer Isolated Conformances setting enables SE-0470 (upcoming feature flag InferIsolatedConformances). The nonIsolated(nonsending) By Default setting enables SE-0461 (upcoming feature flag NonisolatedNonsendingByDefault). The other concurrency features are enabled with Swift 6. Using in a Swift Package You can apply the build settings for approachable concurrency and default actor isolation to one or more targets in your Swift Package. You need to update the swift tools version to 6.2 (first line of Package.swift): // swift-tools-version: 6.2 To set the Default Actor Isolation (SE-0466) for a target, there’s a new swiftSettings option: .target( name: \"MyFeature\", swiftSettings: [ .defaultIsolation(MainActor.self) ] ) To enable approachable concurrency, add the upcoming feature flags for both SE-0461 and SE-0470: .target( name: \"MyFeature\", swiftSettings: [ .defaultIsolation(MainActor.self), .enableUpcomingFeature(\"NonisolatedNonsendingByDefault\"), .enableUpcomingFeature(\"InferIsolatedConformances\") ] ) If you want to apply the settings to all targets, including test targets, add the following to the bottom of your Package.swift file: for target in package.targets { var settings = target.swiftSettings ?? [] settings.append(contentsOf: [ .defaultIsolation(MainActor.self), .enableUpcomingFeature(\"NonisolatedNonsendingByDefault\"), .enableUpcomingFeature(\"InferIsolatedConformances\") ]) target.swiftSettings = settings } Initial Experiences I’m writing this post using Xcode 26 beta 3 and I would say this is still a work-in-progress. One common issue is with protocols like CodingKey which expect to be nonisolated: struct AppSettings: Codable { let name: String private enum CodingKeys: String, CodingKey { case name } ... } That generates a compiler warning: Conformance of ‘AppSettings.CodingKeys’ to protocol ‘CodingKey’ crosses into main actor-isolated code and can cause data races You can workaround it by marking the enum as nonisolated but a permanent fix is on the way. I’ve also seen issues when the generated Bundle.module becomes isolated to @MainActor by default. Learn More WWDC25 Embracing Swift concurrency SE-0461 Run nonisolated async functions on the caller’s actor by default SE-0466 Control default actor isolation inference SE-0470 Global-actor isolated conformances Pitch Amend SE-0466 \u0026 SE-0470 to improve isolation inference Approachable Concurrency in Swift Packages was originally posted 21 Jul 2025 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 21 Jul 2025 10:14:20 +0100",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 3451,
  "excerpt": "How do you enable Approachable Concurrency in Swift Packages?",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "Xcode 26 ships with Swift 6.2 and enables Approachable Concurrency. How do you adopt it in existing projects and in Swift Packages? What is Approachable Concurrency? In Swift 6.2 Apple is introducing a new more approachable way to use Swift Concurrency. It starts with the assumption that you start by running your app’s code on the main thread and only move work to a background thread when needed. I highly recommend watching the session video WWDC25 Embracing Swift concurrency and/or reading the Swift Evolution proposals to learn more: SE-0461 Run nonisolated async functions on the caller’s actor by default SE-0466 Control default actor isolation inference SE-0470 Global-actor isolated conformances Enabling in Xcode 26 Creating a new project with Xcode 26 enables MainActor default isolation and approachable concurrency by default. For an existing project you opt-in by changing the build settings for a target: Enabling Approachable Concurrency enables a couple of extra upcoming features: The Infer Isolated Conformances setting enables SE-0470 (upcoming feature flag InferIsolatedConformances). The nonIsolated(nonsending) By Default setting enables SE-0461 (upcoming feature flag NonisolatedNonsendingByDefault). The other concurrency features are enabled with Swift 6. Using in a Swift Package You can apply the build settings for approachable concurrency and default actor isolation to one or more targets in your Swift Package. You need to update the swift tools version to 6.2 (first line of Package.swift): // swift-tools-version: 6.2 To set the Default Actor Isolation (SE-0466) for a target, there’s a new swiftSettings option: .target( name: \"MyFeature\", swiftSettings: [ .defaultIsolation(MainActor.self) ] ) To enable approachable concurrency, add the upcoming feature flags for both SE-0461 and SE-0470: .target( name: \"MyFeature\", swiftSettings: [ .defaultIsolation(MainActor.self), .enableUpcomingFeature(\"NonisolatedNonsendingByDefault\"), .enableUpcomingFeature(\"InferIsolatedConformances\") ] ) If you want to apply the settings to all targets, including test targets, add the following to the bottom of your Package.swift file: for target in package.targets { var settings = target.swiftSettings ?? [] settings.append(contentsOf: [ .defaultIsolation(MainActor.self), .enableUpcomingFeature(\"NonisolatedNonsendingByDefault\"), .enableUpcomingFeature(\"InferIsolatedConformances\") ]) target.swiftSettings = settings } Initial Experiences I’m writing this post using Xcode 26 beta 3 and I would say this is still a work-in-progress. One common issue is with protocols like CodingKey which expect to be nonisolated: struct AppSettings: Codable { let name: String private enum CodingKeys: String, CodingKey { case name } ... } That generates a compiler warning: Conformance of ‘AppSettings.CodingKeys’ to protocol ‘CodingKey’ crosses into main actor-isolated code and can cause data races You can workaround it by marking the enum as nonisolated but a permanent fix is on the way. I’ve also seen issues when the generated Bundle.module becomes isolated to @MainActor by default. Learn More WWDC25 Embracing Swift concurrency SE-0461 Run nonisolated async functions on the caller’s actor by default SE-0466 Control default actor isolation inference SE-0470 Global-actor isolated conformances Pitch Amend SE-0466 \u0026 SE-0470 to improve isolation inference",
  "image": "https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eXcode 26 ships with Swift 6.2 and enables Approachable Concurrency. How do you adopt it in existing projects and in Swift Packages?\u003c/p\u003e\n\u003ch3 id=\"what-is-approachable-concurrency\"\u003eWhat is Approachable Concurrency?\u003c/h3\u003e\n\u003cp\u003eIn Swift 6.2 Apple is introducing a new \u003cstrong\u003emore approachable\u003c/strong\u003e way to use Swift Concurrency. It starts with the assumption that you start by running your app’s code on the \u003cstrong\u003emain thread\u003c/strong\u003e and only move work to a \u003cstrong\u003ebackground thread\u003c/strong\u003e when needed.\u003c/p\u003e\n\u003cp\u003eI highly recommend watching the session video \u003ca href=\"https://developer.apple.com/videos/play/wwdc2025/268\"\u003eWWDC25 Embracing Swift concurrency\u003c/a\u003e and/or reading the Swift Evolution proposals to learn more:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0461-async-function-isolation.md\"\u003eSE-0461 Run nonisolated async functions on the caller’s actor by default\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0466-control-default-actor-isolation.md\"\u003eSE-0466 Control default actor isolation inference\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0470-isolated-conformances.md\"\u003eSE-0470 Global-actor isolated conformances\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"enabling-in-xcode-26\"\u003eEnabling in Xcode 26\u003c/h3\u003e\n\u003cp\u003eCreating a new project with Xcode 26 enables MainActor default isolation and approachable concurrency by default. For an existing project you opt-in by changing the build settings for a target:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/001.png\" alt=\"Swift compiler concurrency build setting with approachable concurrency yes, default actor isolation MainActor, and strict concurrency complete\" width=\"415\" height=\"100\" srcset=\"https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/001@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eEnabling Approachable Concurrency enables a couple of extra upcoming features:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/002.png\" alt=\"Swift compiler \" width=\"600\" height=\"391\" srcset=\"https://useyourloaf.com/blog/approachable-concurrency-in-swift-packages/002@2x.png 2x\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003cstrong\u003eInfer Isolated Conformances\u003c/strong\u003e setting enables SE-0470 (upcoming feature flag InferIsolatedConformances). The \u003cstrong\u003enonIsolated(nonsending) By Default\u003c/strong\u003e setting enables SE-0461 (upcoming feature flag NonisolatedNonsendingByDefault).\u003c/p\u003e\n\u003cp\u003eThe other concurrency features are enabled with Swift 6.\u003c/p\u003e\n\u003ch3 id=\"using-in-a-swift-package\"\u003eUsing in a Swift Package\u003c/h3\u003e\n\u003cp\u003eYou can apply the build settings for approachable concurrency and default actor isolation to one or more targets in your Swift Package. You need to update the swift tools version to 6.2 (first line of Package.swift):\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e// swift-tools-version: 6.2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo set the \u003cstrong\u003eDefault Actor Isolation\u003c/strong\u003e (SE-0466) for a target, there’s a new swiftSettings option:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;MyFeature\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eswiftSettings\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultIsolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo enable approachable concurrency, add the upcoming feature flags for both SE-0461 and SE-0470:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;MyFeature\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eswiftSettings\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultIsolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenableUpcomingFeature\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;NonisolatedNonsendingByDefault\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenableUpcomingFeature\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;InferIsolatedConformances\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you want to \u003cstrong\u003eapply the settings to all targets\u003c/strong\u003e, including test targets, add the following to the bottom of your Package.swift file:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003epackage\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etargets\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003esettings\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eswiftSettings\u003c/span\u003e \u003cspan\u003e??\u003c/span\u003e \u003cspan\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003esettings\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtentsOf\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefaultIsolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenableUpcomingFeature\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;NonisolatedNonsendingByDefault\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenableUpcomingFeature\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;InferIsolatedConformances\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eswiftSettings\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esettings\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"initial-experiences\"\u003eInitial Experiences\u003c/h3\u003e\n\u003cp\u003eI’m writing this post using Xcode 26 beta 3 and I would say this is still a work-in-progress. One common issue is with protocols like CodingKey which expect to be nonisolated:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAppSettings\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCodable\u003c/span\u003e  \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eCodingKeys\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eCodingKey\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThat generates a compiler warning:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eConformance of ‘AppSettings.CodingKeys’ to protocol ‘CodingKey’ crosses into main actor-isolated code and can cause data races\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eYou can workaround it by marking the enum as nonisolated but a permanent \u003ca href=\"https://forums.swift.org/t/pitch-amend-se-0466-se-0470-to-improve-isolation-inference/79854\"\u003efix \u003c/a\u003e is on the way.\u003c/p\u003e\n\u003cp\u003eI’ve also seen issues when the generated \u003ccode\u003eBundle.module\u003c/code\u003e becomes isolated to @MainActor by default.\u003c/p\u003e\n\u003ch3 id=\"learn-more\"\u003eLearn More\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2025/268\"\u003eWWDC25 Embracing Swift concurrency\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0461-async-function-isolation.md\"\u003eSE-0461 Run nonisolated async functions on the caller’s actor by default\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0466-control-default-actor-isolation.md\"\u003eSE-0466 Control default actor isolation inference\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/swiftlang/swift-evolution/blob/main/proposals/0470-isolated-conformances.md\"\u003eSE-0470 Global-actor isolated conformances\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://forums.swift.org/t/pitch-amend-se-0466-se-0470-to-improve-isolation-inference/79854\"\u003ePitch Amend SE-0466 \u0026amp; SE-0470 to improve isolation inference\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-07-21T10:14:20+01:00",
  "modifiedTime": "2025-07-21T20:54:53+01:00"
}
