{
  "id": "76214fa0-3f49-4ba6-93fb-cd4300716077",
  "title": "How I'm using AI to improve my software engineering productivity (and why it will not steal your job)",
  "link": "https://swiftrocks.com/how-im-using-ai-for-software-engineering",
  "description": "AI has become an important part of my daily software engineering work, so I wanted to write a post sharing how exactly I've been using it in case you're wondering how to use it to improve your productivity as well! Foreword: AI will not steal your software engineering job Before getting to the details of how AI has been helping me to code, I wanted to address the topic of AI replacing software engineers. Recently, my social media feeds have become full of people making predictions about how in X months/years everything in the software engineering industry will be done by AI, via doomsday-style content about how everyone is going to lose their jobs and everything will fall apart. If you look at who's writing these kinds of posts, you'll notice something interesting: they are either executives who have never done any kind of software engineering, or beginners with no industry experience. Honestly, that should tell you everything you need to know about these \"predictions\". But in the interest of being informative, I'll try to explain why they are nonsense. The problem with these \"predictions\" is that the people making them for some reason seem to view software engineering as nothing more than coding and closing tasks on JIRA. You arrive at work, pick a task that is very well defined and requires no clarification whatsoever, code it, close it, pick another task that is once again perfectly defined, and repeat that ad-infimum for the entire duration of your career. But the reality of software engineering is far more complex than that. While there's certainly a good amount of coding, it's extremely rare that the problems a software engineer needs to solve are perfectly defined from the get-go as claimed by the people making these predictions. This means that more often than not the job is not really about coding, but rather figuring out what exactly needs to be coded, by asking yourself questions such as: What problems are we facing right now? What are the current objectives of the company? What is the current state of the company? What is most important for our users? Who will benefit from X problem being solved? What does the codebase looks like today? Are there any patterns or traps I need to be aware of? Are there any political fights going on around me that would affect what I should focus on? What's the current state of the industry? Are there any new tools that can help me solve my problems? The answers to questions like the ones above provide you with context that helps you define how (and when) exactly certain problems should be solved, and is a critical aspect of software engineering even for junior developers. And the interesting part is that the more senior you become, the less coding you do, and the more time you spend answering these types of questions to help your team/company determine which way it should go. This is something I've also written about on my Focus not on the task, but on the problem behind the task blog post. While AI can be quite good at solving very simple and perfectly defined problems, it is exceptionally bad at handling anything that requires taking this level of context into account, which is something that software engineers constantly have to do. This is very easy to confirm if you have doubts about it: Grab any AI agent and project of your choice (or ask the agent to make a new one), and keep asking it to include more features in your project. While it may do relatively well the first time, it is inevitable that the AI will start confusing itself and destroying the codebase on the subsequent requests. This is because AI today doesn't understand context, and as one user on HackerNews wrote, it's like working with a junior developer that has amnesia. Thus, while AI today can be amazing as a coding assistant (which I'll go into more detail further below), the thought of it replacing software engineers is frankly hilarious. One counterargument that some people have is that while this is true today, it doesn't mean that in the future the AI won't be able to understand context and thus be able to do complex tasks. While this is true, what must be noted about this is that an AI capable of understanding context (and gathering it on its own) would be so powerful that it wouldn't just replace software engineers; it would replace all of humanity. If such a thing is achieved then software engineering jobs would be the least of our concerns, so I think it's a sort of weird argument to consider. Our entire lives would change in this scenario. With that out of the way, I'd like to now present my favorite use cases for AI today! Use case 1: Getting simple tasks done quickly One thing that AI is very good as of writing is solving very concrete and straightforward problems. So when I have to do very menial tasks like changing configuration files or writing a simple function that does X and Y, nowadays what I do is simply ask Cursor to do it for me, sit back, and watch the show. Even when taking into account that the AI might not get it 100% correct and that I'll still have to patch the code afterward, this still saves me a massive amount of time overall compared to having me do everything by myself and is definitely my favorite use case of AI today. This is especially true when doing (simple) work on languages that I'm not very familiar with, as the AI in this case is also sparing me from having to do multiple trips to StackOverflow. I still need to do so since the AI will sometimes recommend things that are not correct for my case, but again, even when considering these setbacks, I can get the work done at a much faster pace. It must be noted however that the important keyword here is simple, concrete, and straightforward. As mentioned previously, trying to have the AI solve complex problems that require large amounts of context such as code reviews or designing large features will not work in any meaningful way and is a sure way to waste everyone's time. Use case 2: Understanding complex codebases quickly Another thing that I've found AI to be amazing at is when I'm working on a repository that I'm not familiar with and I need to figure out how certain things are wired together. The way I would do this before AI was to spend hours painstakingly reading through the codebase, but now, with the right questions, it's possible for me to get started in a matter of seconds. Here's a concrete recent example to demonstrate what I mean by this. I was recently attempting to craft a Build Server Protocol that would connect to SourceKit-LSP in order to enable iOS development on my specific non-Xcode conditions. The problem here is that SourceKit-LSP is a very complex project. Even though I know what I have to do in theory, I have no idea what SourceKit-LSP expects me to do in practice. But nowadays, instead of having to spend weeks trying to figure this out by searching keywords on the codebase, I can simply ask Cursor to explain the project to me! Similarly to Use case 1, it's to be expected that the explanation provided by the AI will not be 100% accurate. But once again, even when taking this into consideration, the amount of time these explanations save me is mindblowing. Since Cursor in this case provides shortcuts to the relevant parts of the codebase, I am able to very quickly piece together what I am supposed to do / determine which parts of the explanation are correct and which ones aren't. Use case 3: Searching for things when I don't know what exactly I'm looking for I find that Google tends to provide good results if you know exactly what you're looking for. But if you don't really know what is it that you're trying to find out, you'll have a hard time with it. For example, the other day I was trying to find what the _start function in iOS (the first function called when your app is launched) is, where it's defined, and what it does. But if I go now and search for \"_start function iOS\" on Google, I will not find a straight answer to this question. Google does return somewhat good results (the second search result contains some interesting information about it if you scroll down far enough), but it cannot give me a direct response because I asked the wrong question. I know today that what I should've done is ask it about details of how C programs are linked, but I didn't know this back then, so I couldn't have done that. AI does not have this problem. If you don't know what you're looking for, you can explain your situation to it and it will point you in the right direction: In this example, you can see that ChatGPT immediately pointed out that I asked the wrong question before attempting to explain it! Although the AI's answers won't always be 100% accurate, I find them to be accurate enough to allow me to use Google to find the rest of the information. Just like the previous case, this is not so much about having the AI do everything for me (which it can't), but rather allowing me to save time and get where I want faster. Use case 4: Asking questions that are too specific for Google Even if you know exactly what you're looking for, you may have difficulty using Google if your question is too specific. For example, you cannot search Google on \"how to implement X thing in Swift in my app that is using XYZ frameworks in X iOS version with dependency injection bridging an Obj-C type after the user logged in on my TODO list app using Apple Sign-in from Italy during a rainy day in October\". For cases like this, usually what you need to do is break your problem into multiple, more generic queries, open many tabs that each help you with a specific part of the problem, and then use all of that combined knowledge to come up with the actual answer to your question. AI excels at this. You can be as specific as you want and you'll get a relevant answer. Most coding questions fall into this category, although for these specifically nowadays I prefer using Cursor's code gen features directly as mentioned above. In this case, I could've probably found the answer I was looking for in Google by making a bunch of generic searches about C++ global constructors and good practices, opening a bunch of tabs, and summarizing everything I found. But by asking ChatGPT, I was able to save several hours of my time instead. Use case 5: I want FAST answers It has been getting harder and harder to get fast answers to your questions with Google. Today, it's very unlikely that the answer to a question will lie at the top of a page you've opened. As SEO optimization became more and more important for survival on the web, the amount of stuff you have to endure before getting to the actual content has increased significantly. There will be a lengthy introduction, a pause for sponsors, ten paragraphs about how the question reminds the author about a personal story of how their dog bodyslammed their grandma on Christmas, a call to action for the author's newsletter, some backstory on the question, and only then you'll get to the actual content. I find that there are many cases where this fluff is relevant and worth reading. But there are also many cases when I'm in a hurry and would much rather just get a straight answer to my question. This is also something that I find AI to be quite good at. It generally doesn't try to educate you on things you didn't ask, it just straight up answers your question. By asking follow-up questions regarding one or more things it mentioned in its answer, I can get all of the information I need to learn something new considerably faster than if I had used Google instead. Even though I still need to use Google to double-check if the AI didn't hallucinate particular pieces of information, this ability to quickly gather relevant information saves me an absurd amount of time.",
  "author": "Bruno Rocha",
  "published": "Tue, 15 Apr 2025 11:50:00 GMT+2",
  "source": "https://swiftrocks.com/rss.xml",
  "categories": null,
  "byline": "Bruno Rocha",
  "length": 11823,
  "excerpt": "AI has become an important part of my daily software engineering work. Here's how I used it and why it will not steal your job.",
  "siteName": "SwiftRocks",
  "favicon": "https://swiftrocks.com/images/favicon/favicon_180.png",
  "text": "AI has become an important part of my daily software engineering work, so I wanted to write a post sharing how exactly I've been using it in case you're wondering how to use it to improve your productivity as well! Foreword: AI will not steal your software engineering job Before getting to the details of how AI has been helping me to code, I wanted to address the topic of AI replacing software engineers. Recently, my social media feeds have become full of people making predictions about how in X months/years everything in the software engineering industry will be done by AI, via doomsday-style content about how everyone is going to lose their jobs and everything will fall apart. If you look at who's writing these kinds of posts, you'll notice something interesting: they are either executives who have never done any kind of software engineering, or beginners with no industry experience. Honestly, that should tell you everything you need to know about these \"predictions\". But in the interest of being informative, I'll try to explain why they are nonsense. The problem with these \"predictions\" is that the people making them for some reason seem to view software engineering as nothing more than coding and closing tasks on JIRA. You arrive at work, pick a task that is very well defined and requires no clarification whatsoever, code it, close it, pick another task that is once again perfectly defined, and repeat that ad-infimum for the entire duration of your career. But the reality of software engineering is far more complex than that. While there's certainly a good amount of coding, it's extremely rare that the problems a software engineer needs to solve are perfectly defined from the get-go as claimed by the people making these predictions. This means that more often than not the job is not really about coding, but rather figuring out what exactly needs to be coded, by asking yourself questions such as: What problems are we facing right now? What are the current objectives of the company? What is the current state of the company? What is most important for our users? Who will benefit from X problem being solved? What does the codebase looks like today? Are there any patterns or traps I need to be aware of? Are there any political fights going on around me that would affect what I should focus on? What's the current state of the industry? Are there any new tools that can help me solve my problems? The answers to questions like the ones above provide you with context that helps you define how (and when) exactly certain problems should be solved, and is a critical aspect of software engineering even for junior developers. And the interesting part is that the more senior you become, the less coding you do, and the more time you spend answering these types of questions to help your team/company determine which way it should go. This is something I've also written about on my Focus not on the task, but on the problem behind the task blog post. While AI can be quite good at solving very simple and perfectly defined problems, it is exceptionally bad at handling anything that requires taking this level of context into account, which is something that software engineers constantly have to do. This is very easy to confirm if you have doubts about it: Grab any AI agent and project of your choice (or ask the agent to make a new one), and keep asking it to include more features in your project. While it may do relatively well the first time, it is inevitable that the AI will start confusing itself and destroying the codebase on the subsequent requests. This is because AI today doesn't understand context, and as one user on HackerNews wrote, it's like working with a junior developer that has amnesia. Thus, while AI today can be amazing as a coding assistant (which I'll go into more detail further below), the thought of it replacing software engineers is frankly hilarious. One counterargument that some people have is that while this is true today, it doesn't mean that in the future the AI won't be able to understand context and thus be able to do complex tasks. While this is true, what must be noted about this is that an AI capable of understanding context (and gathering it on its own) would be so powerful that it wouldn't just replace software engineers; it would replace all of humanity. If such a thing is achieved then software engineering jobs would be the least of our concerns, so I think it's a sort of weird argument to consider. Our entire lives would change in this scenario. With that out of the way, I'd like to now present my favorite use cases for AI today! Use case 1: Getting simple tasks done quickly One thing that AI is very good as of writing is solving very concrete and straightforward problems. So when I have to do very menial tasks like changing configuration files or writing a simple function that does X and Y, nowadays what I do is simply ask Cursor to do it for me, sit back, and watch the show. Even when taking into account that the AI might not get it 100% correct and that I'll still have to patch the code afterward, this still saves me a massive amount of time overall compared to having me do everything by myself and is definitely my favorite use case of AI today. This is especially true when doing (simple) work on languages that I'm not very familiar with, as the AI in this case is also sparing me from having to do multiple trips to StackOverflow. I still need to do so since the AI will sometimes recommend things that are not correct for my case, but again, even when considering these setbacks, I can get the work done at a much faster pace. It must be noted however that the important keyword here is simple, concrete, and straightforward. As mentioned previously, trying to have the AI solve complex problems that require large amounts of context such as code reviews or designing large features will not work in any meaningful way and is a sure way to waste everyone's time. Use case 2: Understanding complex codebases quickly Another thing that I've found AI to be amazing at is when I'm working on a repository that I'm not familiar with and I need to figure out how certain things are wired together. The way I would do this before AI was to spend hours painstakingly reading through the codebase, but now, with the right questions, it's possible for me to get started in a matter of seconds. Here's a concrete recent example to demonstrate what I mean by this. I was recently attempting to craft a Build Server Protocol that would connect to SourceKit-LSP in order to enable iOS development on my specific non-Xcode conditions. The problem here is that SourceKit-LSP is a very complex project. Even though I know what I have to do in theory, I have no idea what SourceKit-LSP expects me to do in practice. But nowadays, instead of having to spend weeks trying to figure this out by searching keywords on the codebase, I can simply ask Cursor to explain the project to me! Similarly to Use case 1, it's to be expected that the explanation provided by the AI will not be 100% accurate. But once again, even when taking this into consideration, the amount of time these explanations save me is mindblowing. Since Cursor in this case provides shortcuts to the relevant parts of the codebase, I am able to very quickly piece together what I am supposed to do / determine which parts of the explanation are correct and which ones aren't. Use case 3: Searching for things when I don't know what exactly I'm looking for I find that Google tends to provide good results if you know exactly what you're looking for. But if you don't really know what is it that you're trying to find out, you'll have a hard time with it. For example, the other day I was trying to find what the _start function in iOS (the first function called when your app is launched) is, where it's defined, and what it does. But if I go now and search for \"_start function iOS\" on Google, I will not find a straight answer to this question. Google does return somewhat good results (the second search result contains some interesting information about it if you scroll down far enough), but it cannot give me a direct response because I asked the wrong question. I know today that what I should've done is ask it about details of how C programs are linked, but I didn't know this back then, so I couldn't have done that. AI does not have this problem. If you don't know what you're looking for, you can explain your situation to it and it will point you in the right direction: In this example, you can see that ChatGPT immediately pointed out that I asked the wrong question before attempting to explain it! Although the AI's answers won't always be 100% accurate, I find them to be accurate enough to allow me to use Google to find the rest of the information. Just like the previous case, this is not so much about having the AI do everything for me (which it can't), but rather allowing me to save time and get where I want faster. Use case 4: Asking questions that are too specific for Google Even if you know exactly what you're looking for, you may have difficulty using Google if your question is too specific. For example, you cannot search Google on \"how to implement X thing in Swift in my app that is using XYZ frameworks in X iOS version with dependency injection bridging an Obj-C type after the user logged in on my TODO list app using Apple Sign-in from Italy during a rainy day in October\". For cases like this, usually what you need to do is break your problem into multiple, more generic queries, open many tabs that each help you with a specific part of the problem, and then use all of that combined knowledge to come up with the actual answer to your question. AI excels at this. You can be as specific as you want and you'll get a relevant answer. Most coding questions fall into this category, although for these specifically nowadays I prefer using Cursor's code gen features directly as mentioned above. In this case, I could've probably found the answer I was looking for in Google by making a bunch of generic searches about C++ global constructors and good practices, opening a bunch of tabs, and summarizing everything I found. But by asking ChatGPT, I was able to save several hours of my time instead. Use case 5: I want FAST answers It has been getting harder and harder to get fast answers to your questions with Google. Today, it's very unlikely that the answer to a question will lie at the top of a page you've opened. As SEO optimization became more and more important for survival on the web, the amount of stuff you have to endure before getting to the actual content has increased significantly. There will be a lengthy introduction, a pause for sponsors, ten paragraphs about how the question reminds the author about a personal story of how their dog bodyslammed their grandma on Christmas, a call to action for the author's newsletter, some backstory on the question, and only then you'll get to the actual content. I find that there are many cases where this fluff is relevant and worth reading. But there are also many cases when I'm in a hurry and would much rather just get a straight answer to my question. This is also something that I find AI to be quite good at. It generally doesn't try to educate you on things you didn't ask, it just straight up answers your question. By asking follow-up questions regarding one or more things it mentioned in its answer, I can get all of the information I need to learn something new considerably faster than if I had used Google instead. Even though I still need to use Google to double-check if the AI didn't hallucinate particular pieces of information, this ability to quickly gather relevant information saves me an absurd amount of time.",
  "image": "https://swiftrocks.com/images/thumbs/thumb_dark.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \n  \n\u003cp\u003eAI has become an important part of my daily software engineering work, so I wanted to write a post sharing how exactly I\u0026#39;ve been using it in case you\u0026#39;re wondering how to use it to improve your productivity as well!\u003c/p\u003e\n\u003ch2\u003eForeword: AI will not steal your software engineering job\u003c/h2\u003e\n\u003cp\u003eBefore getting to the details of how AI has been helping me to code, I wanted to address the topic of AI replacing software engineers.\u003c/p\u003e\n\n\u003cp\u003eRecently, my social media feeds have become full of people making predictions about how in X months/years everything in the software engineering industry will be done by AI, via doomsday-style content about how everyone is going to lose their jobs and everything will fall apart.\u003c/p\u003e\n\u003cp\u003eIf you look at who\u0026#39;s writing these kinds of posts, you\u0026#39;ll notice something interesting: they are either executives who have never done any kind of software engineering, or beginners with no industry experience. Honestly, that should tell you everything you need to know about these \u0026#34;predictions\u0026#34;. But in the interest of being informative, I\u0026#39;ll try to explain why they are nonsense.\u003c/p\u003e\n\u003cp\u003eThe problem with these \u0026#34;predictions\u0026#34; is that the people making them for some reason seem to view software engineering as nothing more than coding and closing tasks on JIRA. You arrive at work, pick a task that is very well defined and requires no clarification whatsoever, code it, close it, pick another task that is once again perfectly defined, and repeat that ad-infimum for the entire duration of your career.\u003c/p\u003e\n\u003cp\u003eBut the reality of software engineering is far more complex than that. While there\u0026#39;s certainly a good amount of coding, it\u0026#39;s \u003cb\u003eextremely rare\u003c/b\u003e that the problems a software engineer needs to solve are \u003ci\u003eperfectly defined\u003c/i\u003e from the get-go as claimed by the people making these predictions. This means that more often than not the job is not really about coding, but rather \u003cb\u003efiguring out what exactly needs to be coded\u003c/b\u003e, by asking yourself questions such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat problems are we facing right now?\u003c/li\u003e\n\u003cli\u003eWhat are the current objectives of the company?\u003c/li\u003e\n\u003cli\u003eWhat is the current state of the company?\u003c/li\u003e\n\u003cli\u003eWhat is most important for our users?\u003c/li\u003e\n\u003cli\u003eWho will benefit from X problem being solved?\u003c/li\u003e\n\u003cli\u003eWhat does the codebase looks like today? Are there any patterns or traps I need to be aware of?\u003c/li\u003e\n\u003cli\u003eAre there any political fights going on around me that would affect what I should focus on?\u003c/li\u003e\n\u003cli\u003eWhat\u0026#39;s the current state of the industry? Are there any new tools that can help me solve my problems?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe answers to questions like the ones above provide you with \u003cb\u003econtext\u003c/b\u003e that helps you define how (and when) exactly certain problems should be solved, and is a critical aspect of software engineering even for junior developers. And the interesting part is that the more senior you become, \u003cb\u003ethe less coding you do\u003c/b\u003e, and the more time you spend answering these types of questions to help your team/company determine which way it should go. This is something I\u0026#39;ve also written about on my \u003ci\u003e\u003ca href=\"https://swiftrocks.com/focus-not-on-the-task-but-on-the-problem-behind-the-task\"\u003eFocus not on the task, but on the problem behind the task\u003c/a\u003e\u003c/i\u003e blog post.\u003c/p\u003e\n\u003cp\u003eWhile AI can be quite good at solving very simple and perfectly defined problems, it is \u003cb\u003eexceptionally bad\u003c/b\u003e at handling anything that requires taking this level of context into account, which is something that software engineers constantly have to do. This is very easy to confirm if you have doubts about it: Grab any AI agent and project of your choice (or ask the agent to make a new one), and keep asking it to include more features in your project. While it may do relatively well the first time, it is inevitable that the AI will start confusing itself and destroying the codebase on the subsequent requests. This is because AI today doesn\u0026#39;t understand context, and as one user on HackerNews wrote, it\u0026#39;s like working with a junior developer that has amnesia.\u003c/p\u003e\n\u003cp\u003eThus, while AI today can be amazing as a coding assistant (which I\u0026#39;ll go into more detail further below), the thought of it replacing software engineers is frankly hilarious.\u003c/p\u003e\n\u003cp\u003eOne counterargument that some people have is that while this is true today, it doesn\u0026#39;t mean that in the future the AI won\u0026#39;t be able to understand context and thus be able to do complex tasks. While this is true, what must be noted about this is that an AI capable of understanding context (and gathering it on its own) would be so powerful that it wouldn\u0026#39;t just replace software engineers; it would replace \u003cb\u003eall of humanity\u003c/b\u003e. If such a thing is achieved then software engineering jobs would be the least of our concerns, so I think it\u0026#39;s a sort of weird argument to consider. Our entire lives would change in this scenario.\u003c/p\u003e\n\u003cp\u003eWith that out of the way, I\u0026#39;d like to now present my favorite use cases for AI today!\u003c/p\u003e\n\u003ch2\u003eUse case 1: Getting simple tasks done quickly\u003c/h2\u003e\n\u003cp\u003eOne thing that AI is very good as of writing is solving very concrete and straightforward problems. So when I have to do very menial tasks like changing configuration files or writing a simple function that does X and Y, nowadays what I do is simply ask \u003ca href=\"https://www.cursor.com/\"\u003eCursor\u003c/a\u003e to do it for me, sit back, and watch the show.\u003c/p\u003e\n\u003cp\u003eEven when taking into account that the AI might not get it 100% correct and that I\u0026#39;ll still have to patch the code afterward, this still \u003cb\u003esaves me a massive amount of time\u003c/b\u003e overall compared to having me do everything by myself and is definitely my favorite use case of AI today. This is especially true when doing (simple) work on languages that I\u0026#39;m not very familiar with, as the AI in this case is also sparing me from having to do multiple trips to StackOverflow. I still need to do so since the AI will sometimes recommend things that are not correct for my case, but again, even when considering these setbacks, I can get the work done at a much faster pace.\u003c/p\u003e\n\u003cp\u003eIt must be noted however that the important keyword here is \u003cb\u003esimple, concrete, and straightforward\u003c/b\u003e. As mentioned previously, trying to have the AI solve complex problems that require large amounts of context such as code reviews or designing large features will not work in any meaningful way and is a sure way to waste everyone\u0026#39;s time.\u003c/p\u003e\n\u003ch2\u003eUse case 2: Understanding complex codebases quickly\u003c/h2\u003e\n\u003cp\u003eAnother thing that I\u0026#39;ve found AI to be amazing at is when I\u0026#39;m working on a repository that I\u0026#39;m not familiar with and I need to figure out how certain things are wired together.\u003c/p\u003e\n\u003cp\u003eThe way I would do this before AI was to spend hours painstakingly reading through the codebase, but now, with the right questions, it\u0026#39;s possible for me to get started \u003cb\u003ein a matter of seconds.\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s a concrete recent example to demonstrate what I mean by this. I was recently attempting to craft a Build Server Protocol that would connect to \u003ca href=\"https://github.com/swiftlang/sourcekit-lsp\"\u003eSourceKit-LSP\u003c/a\u003e in order to enable iOS development on my specific non-Xcode conditions.\u003c/p\u003e\n\u003cp\u003eThe problem here is that SourceKit-LSP is a very complex project. Even though I know what I have to do in theory, I have no idea what SourceKit-LSP expects me to do in practice. But nowadays, instead of having to spend weeks trying to figure this out by searching keywords on the codebase, I can simply ask Cursor to explain the project to me!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/4u0M9kM.png\" alt=\"Alt\"/\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/VO60RTY.png\" alt=\"Alt\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eSimilarly to \u003cb\u003eUse case 1\u003c/b\u003e, it\u0026#39;s to be expected that the explanation provided by the AI will not be 100% accurate. But once again, even when taking this into consideration, the amount of time these explanations save me is \u003cb\u003emindblowing\u003c/b\u003e. Since Cursor in this case provides shortcuts to the relevant parts of the codebase, I am able to very quickly piece together what I am supposed to do / determine which parts of the explanation are correct and which ones aren\u0026#39;t.\u003c/p\u003e\n\u003ch2\u003eUse case 3: Searching for things when I don\u0026#39;t know what exactly I\u0026#39;m looking for\u003c/h2\u003e\n\u003cp\u003eI find that Google tends to provide good results if you know \u003cb\u003eexactly\u003c/b\u003e what you\u0026#39;re looking for. But if you don\u0026#39;t really know what is it that you\u0026#39;re trying to find out, you\u0026#39;ll have a hard time with it.\u003c/p\u003e\n\u003cp\u003eFor example, the other day I was trying to find what the \u003ccode\u003e_start\u003c/code\u003e function in iOS (the first function called when your app is launched) is, where it\u0026#39;s defined, and what it does. But if I go now and search for \u0026#34;_start function iOS\u0026#34; on Google, I will not find a straight answer to this question. Google \u003ci\u003edoes\u003c/i\u003e return somewhat good results (the second search result contains some interesting information about it if you scroll down far enough), but it cannot give me a direct response because I asked the wrong question. I know today that what I should\u0026#39;ve done is ask it about details of how C programs are linked, but I didn\u0026#39;t know this back then, so I couldn\u0026#39;t have done that.\u003c/p\u003e\n\u003cp\u003eAI does not have this problem. If you don\u0026#39;t know what you\u0026#39;re looking for, you can explain your situation to it and it will point you in the right direction:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/KuTBOgc.png\" alt=\"Alt\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eIn this example, you can see that ChatGPT immediately pointed out that I asked the wrong question before attempting to explain it!\u003c/p\u003e\n\u003cp\u003eAlthough the AI\u0026#39;s answers won\u0026#39;t always be 100% accurate, I find them to be accurate enough to allow me to use Google to find the rest of the information. Just like the previous case, this is not so much about having the AI do everything for me (which it can\u0026#39;t), but rather allowing me to save time and get where I want faster.\u003c/p\u003e\n\u003ch2\u003eUse case 4: Asking questions that are too specific for Google\u003c/h2\u003e\n\u003cp\u003eEven if you know exactly what you\u0026#39;re looking for, you may have difficulty using Google if your question is too specific. For example, you cannot search Google on \u0026#34;how to implement X thing in Swift in my app that is using XYZ frameworks in X iOS version with dependency injection bridging an Obj-C type after the user logged in on my TODO list app using Apple Sign-in from Italy during a rainy day in October\u0026#34;. For cases like this, usually what you need to do is break your problem into multiple, more generic queries, open many tabs that each help you with a specific part of the problem, and then use all of that combined knowledge to come up with the actual answer to your question.\u003c/p\u003e\n\u003cp\u003eAI excels at this. You can be as specific as you want and you\u0026#39;ll get a relevant answer. Most coding questions fall into this category, although for these specifically nowadays I prefer using Cursor\u0026#39;s code gen features directly as mentioned above.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/Rlbf1Pl.png\" alt=\"Alt\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eIn this case, I could\u0026#39;ve probably found the answer I was looking for in Google by making a bunch of generic searches about C++ global constructors and good practices, opening a bunch of tabs, and summarizing everything I found. But by asking ChatGPT, I was able to save several hours of my time instead.\u003c/p\u003e\n\u003ch2\u003eUse case 5: I want FAST answers\u003c/h2\u003e\n\u003cp\u003eIt has been getting harder and harder to get fast answers to your questions with Google. Today, it\u0026#39;s very unlikely that the answer to a question will lie at the top of a page you\u0026#39;ve opened. As SEO optimization became more and more important for survival on the web, the amount of stuff you have to endure before getting to the actual content has increased significantly. There will be a lengthy introduction, a pause for sponsors, ten paragraphs about how the question reminds the author about a personal story of how their dog bodyslammed their grandma on Christmas, a call to action for the author\u0026#39;s newsletter, some backstory on the question, and \u003cb\u003eonly then\u003c/b\u003e you\u0026#39;ll get to the actual content.\u003c/p\u003e\n\u003cp\u003eI find that there are many cases where this fluff is relevant and worth reading. But there are also many cases when I\u0026#39;m in a hurry and would much rather just get a straight answer to my question.\u003c/p\u003e\n\n\u003cp\u003eThis is also something that I find AI to be quite good at. It generally doesn\u0026#39;t try to educate you on things you didn\u0026#39;t ask, it just straight up answers your question.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://i.imgur.com/SuUcWBm.png\" alt=\"Alt\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eBy asking follow-up questions regarding one or more things it mentioned in its answer, I can get all of the information I need to learn something new considerably faster than if I had used Google instead. Even though I still need to use Google to double-check if the AI didn\u0026#39;t hallucinate particular pieces of information, this ability to quickly gather relevant information saves me an absurd amount of time.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-04-15T11:50:00+02:00",
  "modifiedTime": null
}
