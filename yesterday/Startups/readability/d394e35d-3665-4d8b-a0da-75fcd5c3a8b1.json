{
  "id": "d394e35d-3665-4d8b-a0da-75fcd5c3a8b1",
  "title": "The UCSD p-System, Apple Pascal, and a dream of cross-platform compatibility",
  "link": "https://markbessey.blog/2025/04/14/a-blast-from-the-past/",
  "description": "Article URL: https://markbessey.blog/2025/04/14/a-blast-from-the-past/ Comments URL: https://news.ycombinator.com/item?id=43707805 Points: 21 # Comments: 4",
  "author": "rbanffy",
  "published": "Wed, 16 Apr 2025 17:09:18 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Mark Bessey",
  "length": 5600,
  "excerpt": "The UCSD p-System, Apple Pascal, and a dream of cross-platform compatibility never quite realized I’ve been thinking about the UCSD P-System a lot lately, and I thought I’d write about …",
  "siteName": "markbessey.blog",
  "favicon": "https://s2.wp.com/i/webclip.png",
  "text": "The UCSD p-System, Apple Pascal, and a dream of cross-platform compatibility never quite realized I’ve been thinking about the UCSD P-System a lot lately, and I thought I’d write about it a bit, and about bytecode systems more-generally. And along the way, I hope to write some interesting code. What’s the p-System? Way back in 1974-1978, computer scientists at the University of California, San Diego campus developed a new portable operating system, compiler, and tools to run on both the PDP-11 minicomputers and the increasingly-common microcomputers. They called this UCSD Pascal, and it was available for a wide variety of systems, in just a few years. The secret to its wide portability was that the system sat “on top of” a very small kernel of machine-dependent code, which implemented a “virtual machine” called the “p-machine”, a kind of imaginary CPU specifically designed to be a good target for a Pascal Compiler. Because this was a relatively-small amount of code, it was possible to port the entire operating environment, including the operating system, the compiler, editor, filesystem and other tools, just by implementing the p-machine emulator for a new machine. You could get a version of the p-System for a huge variety of computers. Besides DEC’s PDP-11 and Rainbow, there were versions for the Apple II, the IBM PC (one of 3 OS options for it at the start), for HP’s series 80 and series 9000 workstations, Texas Instruments’ TI-99/4a home computer, CPM machines, various mainframes, and on, and on. Western Digital even created a microprocessor that ran p-machine code as its native machine language. The p-System was not the first portable byte-code interpreter and compiler system – that idea goes very far back, at least to the origins of the Pascal language itself. But it was arguably one of the most-successful early versions of the idea, and served as an inspiration for future portable software systems (including Java’s bytecode, and Infocom’s Z-machine). Where did I first encounter the p-System? In 1986, during my Junior year of High School, I took a Computer Programming class. That was primarily taught in BASIC, because of course it was. After completing that class, I was essentially let loose in the computer lab for a period of “Independent study” (thanks, Mr. Carlson!), and that was where I got to use Pascal for the first time. Apple Pascal, running on the Apple IIe. At that point, I was also using Pascal in my first after-school job, using UCSD Pascal on the HP 80 and 9000 series workstations, and also Turbo Pascal on IBM PC-compatibles (not the p-System, but definitely inspired by it). My “final project” for my Senior year was building a spreadsheet program in Apple Pascal. I managed to get a formula editor, including basic arithmetic functions, the grid display, and printouts all working before I graduated. Unfortunately, that code is lost to time. What am I going to do with the p-System? I have a couple of goals I’m hoping to accomplish here over the next few months: Get Apple Pascal up and running in some kind of emulator on my Mac, so I can experience it again Done, see next blog post Build some tools to transfer files to/from disk images for the emulator These already exist, in various forms, but I really want to make my own, partly for the enjoyment of it, partly to have something simple to do in Rust to build familiarity with the language. Build a p-machine emulator, in Rust and probably a disassembler/assembler, and the rest of the tool chain maybe NOT a Pascal compiler, unless I get ambitious Port the p-machine emulator to something other than the Mac Ideally, something small – like an Arduino or Raspberry Pi Pico Why build new tools for such an old system? Partly because I can, and partly because we’re coming up on the 50th anniversary of the UCSD P-System. Development started around 1974, and UCSD Pascal was first released in 1978. I think it’d be fun to build something new with/for that old system, which was really important to me getting started in my career. And partly because, while there are tools out there, they’re often badly-documented (see link rot lament, below), and they often were built decades ago, at this point, and require compilation with gcc 2.x, for instance. I think it’d be nice to bring back some old system software, using “new” tooling, to hopefully extend the legacy of this system a bit longer. Where can you find out more about the p-System? There is a lot of information available on the Internet, in but it’s scattered everywhere, and a lot of it is suffering link rot these days. One site I found had tantalizing links to a bunch of books, specifications, and historical documents, 80% of which were 404 NOT FOUND. I’m going to add links to other sites to these blog posts as I run across them. Probably the best place to start digging is Hans Otten’s web site, Pascal for Small Machines, which in addition to p-System information, has a bunch of historical information about other versions of Pascal on “small computers”, meaning mini- and micro-computers. I found some very interesting historical information about Apple Pascal and the p-machine at The Digital Antiquarian blog. This is part of a series of articles that goes from Pascal, to the p-System, to Sir-tech software and Wizardry, a roleplaying game for the Apple II which was built with Apple Pascal. The Jefferson Computer Museum has a page about the UCSD p-System, and links to several interesting collections of software.",
  "image": "https://s0.wp.com/i/blank.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003ch2\u003eThe UCSD p-System, Apple Pascal, and a dream of cross-platform compatibility never quite realized\u003c/h2\u003e\n\n\n\n\u003cp\u003eI’ve been thinking about the UCSD P-System a lot lately, and I thought I’d write about it a bit, and about bytecode systems more-generally. And along the way, I hope to write some interesting code.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhat’s the p-System?\u003c/h3\u003e\n\n\n\n\u003cp\u003eWay back in 1974-1978, computer scientists at the University of California, San Diego campus developed a new portable operating system, compiler, and tools to run on both the PDP-11 minicomputers and the increasingly-common microcomputers. They called this \u003cem\u003eUCSD Pascal\u003c/em\u003e, and it was available for a wide variety of systems, in just a few years. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe secret to its wide portability was that the system sat “on top of” a very small kernel of machine-dependent code, which implemented a “virtual machine” called the “p-machine”, a kind of imaginary CPU specifically designed to be a good target for a Pascal Compiler. Because this was a relatively-small amount of code, it was possible to port the entire operating environment, including the operating system, the compiler, editor, filesystem and other tools, just by implementing the p-machine emulator for a new machine.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou could get a version of the p-System for a huge variety of computers. Besides DEC’s PDP-11 and Rainbow, there were versions for the Apple II, the IBM PC (one of 3 OS options for it at the start), for HP’s series 80 and series 9000 workstations, Texas Instruments’ TI-99/4a home computer, CPM machines, various mainframes, and on, and on. Western Digital even created a microprocessor that ran p-machine code as its native machine language.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe p-System was not the first portable byte-code interpreter and compiler system – that idea goes very far back, at least to the origins of the Pascal language itself. But it was arguably one of the most-successful early versions of the idea, and served as an inspiration for future portable software systems (including Java’s bytecode, and Infocom’s Z-machine).\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhere did I first encounter the p-System?\u003c/h3\u003e\n\n\n\n\u003cp\u003eIn 1986, during my Junior year of High School, I took a Computer Programming class. That was primarily taught in BASIC, because of course it was. After completing that class, I was essentially let loose in the computer lab for a period of “Independent study” (thanks, Mr. Carlson!), and that was where I got to use Pascal for the first time. Apple Pascal, running on the Apple IIe. At that point, I was also using Pascal in my first after-school job, using UCSD Pascal on the HP 80 and 9000 series workstations, and also Turbo Pascal on IBM PC-compatibles (not the p-System, but definitely inspired by it).\u003c/p\u003e\n\n\n\n\u003cp\u003eMy “final project” for my Senior year was building a spreadsheet program in Apple Pascal. I managed to get a formula editor, including basic arithmetic functions, the grid display, and printouts all working before I graduated. Unfortunately, that code is lost to time. \u003c/p\u003e\n\n\n\n\u003ch3\u003eWhat am I going to do with the p-System?\u003c/h3\u003e\n\n\n\n\u003cp\u003eI have a couple of goals I’m hoping to accomplish here over the next few months:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eGet Apple Pascal up and running in some kind of emulator on my Mac, so I can experience it again\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eDone, see \u003ca href=\"https://markbessey.blog/2025/04/15/running-apple-pascal-on-a-modern-mac/\"\u003enext blog post\u003c/a\u003e\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eBuild some tools to transfer files to/from disk images for the emulator\n\u003cul\u003e\n\u003cli\u003eThese \u003cem\u003ealready exist\u003c/em\u003e, in various forms, but I really want to make my own, partly for the enjoyment of it, partly to have something simple to do in Rust to build familiarity with the language.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eBuild a p-machine emulator, in Rust\n\u003cul\u003e\n\u003cli\u003eand probably a disassembler/assembler, and the rest of the tool chain\u003c/li\u003e\n\n\n\n\u003cli\u003emaybe NOT a Pascal compiler, unless I get ambitious\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003ePort the p-machine emulator to something other than the Mac\n\u003cul\u003e\n\u003cli\u003eIdeally, something \u003cem\u003esmall\u003c/em\u003e – like an Arduino or Raspberry Pi Pico\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003ch3\u003eWhy build new tools for such an old system?\u003c/h3\u003e\n\n\n\n\u003cp\u003ePartly because I can, and partly because we’re coming up on the 50th anniversary of the UCSD P-System. Development started around 1974, and UCSD Pascal was first released in 1978. I think it’d be fun to build something new with/for that old system, which was really important to me getting started in my career.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd partly because, while there are tools out there, they’re often badly-documented (see link rot lament, below), and they often were built \u003cem\u003edecades ago\u003c/em\u003e, at this point, and require compilation with gcc 2.x, for instance. I think it’d be nice to bring back some old system software, using “new” tooling, to hopefully extend the legacy of this system a bit longer.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhere can you find out more about the p-System?\u003c/h3\u003e\n\n\n\n\u003cp\u003eThere is \u003cem\u003ea lot\u003c/em\u003e of information available on the Internet, in but it’s scattered everywhere, and a lot of it is suffering link rot these days. One site I found had tantalizing links to a bunch of books, specifications, and historical documents, 80% of which were \u003cem\u003e404 NOT FOUND\u003c/em\u003e. I’m going to add links to other sites to these blog posts as I run across them.\u003c/p\u003e\n\n\n\n\u003cp\u003eProbably the best place to \u003cem\u003estart\u003c/em\u003e digging is Hans Otten’s web site, \u003ca href=\"http://pascal.hansotten.com/ucsd-p-system/\"\u003ePascal for Small Machines\u003c/a\u003e, which in addition to p-System information, has a bunch of historical information about other versions of Pascal on “small computers”, meaning mini- and micro-computers.\u003c/p\u003e\n\n\n\n\u003cp\u003eI found some very interesting historical information about Apple Pascal and the p-machine at \u003ca href=\"https://www.filfre.net/2012/03/pascal-and-the-p-machine/\"\u003eThe Digital Antiquarian\u003c/a\u003e blog. This is part of a series of articles that goes from Pascal, to the p-System, to Sir-tech software and \u003cem\u003eWizardry, \u003c/em\u003ea roleplaying game for the Apple II which was built with Apple Pascal.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Jefferson Computer Museum has \u003ca href=\"https://www.threedee.com/jcm/psystem/index.html\"\u003ea page about the UCSD p-System\u003c/a\u003e, and links to several interesting collections of software. \u003c/p\u003e\n\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-04-15T06:29:30Z",
  "modifiedTime": "2025-04-15T07:06:09Z"
}
