{
  "id": "3478ddbc-fc82-409c-8b06-b13f6e5bf4d9",
  "title": "Firecracker Entropy for VM Clones",
  "link": "https://github.com/firecracker-microvm/firecracker/blob/main/docs/snapshotting/random-for-clones.md",
  "description": "Article URL: https://github.com/firecracker-microvm/firecracker/blob/main/docs/snapshotting/random-for-clones.md Comments URL: https://news.ycombinator.com/item?id=43659505 Points: 3 # Comments: 0",
  "author": "transpute",
  "published": "Fri, 11 Apr 2025 22:46:25 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 12914,
  "excerpt": "Secure and fast microVMs for serverless computing. - firecracker-microvm/firecracker",
  "siteName": "GitHub",
  "favicon": "https://github.com/fluidicon.png",
  "text": "Entropy for Clones This document provides a high level perspective on the implications of restoring multiple VM clones from a single snapshot. We start with an overview of the Linux random number generation (RNG) facilities, then go through the potential issues we’ve identified related to cloning state, and finally conclude with a series of recommendations. It’s worth stressing that we aim to prevent stale state being a problem only for the kernel interfaces. Some userspace applications or libraries keep their own equivalent of entropy pools and suffer from the same potential issues after being cloned. There is no generic solution under the current programming model, and all we can do is recommend against their use in pre-snapshot logic. Background The Linux kernel exposes three main RNG interfaces to userspace: the /dev/random and /dev/urandom special devices, and the getrandom syscall, which are described in the random(7) man page. Moreover, Firecracker supports the virtio-rng device which can provide additional entropy to guest VMs. It draws its random bytes from the aws-lc-rs crate which wraps the AWS-LC cryptographic library. Traditionally, /dev/random has been considered a source of “true” randomness, with the downside that reads block when the pool of entropy gets depleted. On the other hand, /dev/urandom doesn’t block, which lead people believe that it provides lower quality results. It turns out the distinction in output quality is actually very hard to make. According to this article, for kernel versions prior to 4.8, both devices draw their output from the same pool, with the exception that /dev/random will block when the system estimates the entropy count has decreased below a certain threshold. The /dev/urandom output is considered secure for virtually all purposes, with the caveat that using it before the system gathers sufficient entropy for initialization may indeed produce low quality random numbers. The getrandom syscall helps with this situation; it uses the /dev/urandom source by default, but will block until it gets properly initialized (the behavior can be altered via configuration flags). Newer kernels (4.8+) have switched to an implementation where /dev/random output comes from a pool called the blocking pool, the output of /dev/urandom is given by a CSPRNG (cryptographically secure pseudorandom number generator), and there’s also an input pool which gathers entropy from various sources available on the system, and is used to feed into or seed the other two components. A very detailed description is available here. The details of this newer implementation are used to make the recommendations present in the document. There are in-kernel interfaces used to obtain random numbers as well, but they are similar to using /dev/urandom (or getrandom with the default source) from userspace. Whenever a VM clone is created based on a snapshot, execution resumes precisely from the previously saved state. Getting random bytes from either /dev/random or /dev/urandom does not lead to identical results for different clones created from the same snapshot because multiple parameters (such as timer data, or output from CPU HWRNG instructions which are present on Ivy Bridge or newer Intel processors and enabled in a Firecracker guest) are mixed with each result. Extra bits are mixed in both when reading random values, and in conjunction with entropy related events such as interrupts. Moreover, the guest kernel will eventually receive fresh entropy from virtio-rng, if attached. There are two questions here: Is the CPU HWRNG output always mixed in when the feature is present (as opposed to only when the CPU HWRNG is trusted)? Is the added noise strong enough to consider the final RNG output sufficiently divergent from all other clones? Both these questions are particularly relevant immediately after resuming a VM from a snapshot. After the VM gets to run for a \"sufficient\" amount of time it should be able to gather some more entropy by itself and its state should be sufficiently divergent that of any other clones. It seems the CPU HWRNG is always added to mix when present. More specifically, page 32 point 1 (at the top of the page) mentions using the CPU HWRNG when present for the entropy pool output function. Page 34 states in case a CPU random number generator is known to the Linux-RNG, data from that hardware RNG is mixed into the entropy pool in a second step. With respect to the initialization of the random pools and DRNG behind /dev/urandom. The discussion regarding DRNG state on page 35 mentions the key part, the counter, and the nonce are XORed with the output of the CPU random number generator if one is present. If it is not present, one high-resolution time stamp obtained with the kernel function random_get_entropy word is XORed with the key part. The CPU HWRNG is also used for the DRNG state transition function (as stated on page 36 point 1), and during the reseed operation (page 37 point 2). The document explicitly mentions when the CPU HWRNG has to be trusted (for example, the bullet points at the end of Section 3.3.2.3). It’s not yet clear whether the noise that gets added for each clone post restore is sufficient to consider their RNG states distinct for security purposes. The conservative approach is to presume the stale state has a significant influence on RNG output, so we should reinitialize both sources based on fresh data after each restore. It would seem that simply writing data to /dev/urandom is enough to muddle the entropy pools, but the bits only get mixed with the input pool. It’s not certain at this point whether such writes have any immediate impact on the blocking pool, and it’s unlikely they cause the CSPRNG to be automatically reseeded. The standard methods of interacting with the kernel RNG sources are documented in the random(4) man page. It states that any writes to either /dev/random or /dev/urandom are mixed with the input entropy pool, but do not increase the current entropy estimation. There is also an ioctl interface which, given the appropriate privileges, can be used to add data to the input entropy pool while also increasing the count, or completely empty all pools. Linux kernels with VMGenID support Linux has support for the Virtual Machine Generation Identifier since 5.18 for ACPI systems. Since 6.10, Linux added support also for systems that use DeviceTree instead of ACPI. The purpose of VMGenID is to notify the guest about time shift events, such as resuming from a snapshot. The device exposes a 16-byte cryptographically random identifier in guest memory. Firecracker implements VMGenID. When resuming a microVM from a snapshot Firecracker writes a new identifier and injects a notification to the guest. Linux, uses this value as new randomness for its CSPRNG. Quoting the random.c implementation of the kernel: /* * Handle a new unique VM ID, which is unique, not secret, so we * don't credit it, but we do immediately force a reseed after so * that it's used by the crng posthaste. */ As a result, values returned by getrandom() and /dev/(u)random are distinct in all VMs started from the same snapshot, after the kernel handles the VMGenID notification. This leaves a race window between resuming vCPUs and Linux CSPRNG getting successfully re-seeded. In Linux 6.8, we extended VMGenID to emit a uevent to user space when it handles the notification. User space can poll this uevent to know when it is safe to use getrandom(), et al. avoiding the race condition. Firecracker supports VMGenID on ARM systems using the DeviceTree binding that was added for the device in Linux 6.10. However, the latest Linux kernel that Firecracker supports is 6.1. As a result, in order to use VMGenID on ARM systems, users need to use a 6.1 kernel with the DeviceTree binding support backported from 6.10. For our CI we backport the relevant changes from 6.10 to 6.1. Consumers of Firecracker that want to use the feature on ARM need to ensure they backport these changes on their guest kernels. Please note that, Firecracker will always enable VMGenID. In kernels where there is no VMGenID driver, the device will not have any effect in the guest. User space considerations Init systems (such as systemd used by AL2 and other distros) might save a random seed file after boot. For systemd, the path is /var/lib/systemd/random-seed. Just to be on the safe side, any such file should be deleted before taking a snapshot, to prevent its reuse for any purposes by the guest. There’s also the /proc/sys/kernel/random/boot_id special file, which gets initialized with a random string at boot time, and is read-only afterwards. All clones restored from the same snapshot will implicitly read the same value from this file. If that’s not desirable, it’s possible to alter the read result via bind mounting another file on top of /proc/sys/kernel/random/boot_id. Recommendations Delete /var/lib/systemd/random-seed, or any equivalent files. If changing the value present in /proc/sys/kernel/random/boot_id is important, bind mount another file on top of it. If microVMs run on machines with IvyBridge or newer Intel processors (which provide RDRAND; in addition, RDSEED is offered starting with Broadwell). Hardware supported reseeding is done on a cadence defined by the Linux Kernel and should be sufficient for most cases. Use virtio-rng. When present, the guest kernel uses the device as an additional source of entropy. On kernels before 5.18, to be as safe as possible, the direct approach is to do the following (before customer code is resumed in the clone): Open one of the special devices files (either /dev/random or /dev/urandom). Take note that RNDCLEARPOOL no longer has any effect on the entropy pool. Issue an RNDADDENTROPY ioctl call (requires CAP_SYS_ADMIN) to mix the provided bytes into the input entropy pool and increase the entropy count. This should also cause the /dev/urandom CSPRNG to be reseeded. The bytes can be generated locally in the guest, or obtained from the host. Issue a RNDRESEEDCRNG ioctl call (4.14, 5.10, (requires CAP_SYS_ADMIN)) that specifically causes the CSPRNG to be reseeded from the input pool. On kernels starting from 5.18 onwards, the CSPRNG will be automatically reseeded when the guest kernel handles the VMGenID notification. To completely avoid the race condition, users should follow the same steps as with kernels \u003c 5.18. On kernels starting from 6.8, users can poll for the VMGenID uevent that the driver sends when the CSPRNG is reseeded after handling the VMGenID notification. Annex 1 contains the source code of a C program which implements the previous three steps. As soon as the guest kernel version switches to 4.19 (or higher), we can rely on the CONFIG_RANDOM_TRUST_CPU kernel option (or the random.trust_cpu=on cmdline parameter) to have the entropy pool automatically refilled using the CPU HWRNG, so step 3 would no longer be necessary. Another way around step 3 is to attach a virtio-rng device. However, we cannot control when the guest kernel will request for random bytes from the device. Annex 1: Source code that clears and reinitializes the entropy pool #include \u003cerrno.h\u003e #include \u003cfcntl.h\u003e #include \u003clinux/random.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e void exit_usage() { printf(\"Usage: ./rerand [\u003chexadecimal_string\u003e]\\n\" \"The length of the string must be a multiple of 8.\\n\"); exit(EXIT_FAILURE); } void exit_perror(const char *msg) { perror(msg); exit(EXIT_FAILURE); } int main(int argc, char ** argv) { if (argc \u003e 2) { exit_usage(); } size_t len = 0; struct rand_pool_info *info = NULL; if (argc == 2) { len = strlen(argv[1]); // We want len to be a multiple of 8 such that we have an easier time // parsing argv[1] into an array of u32s. if (len % 8) { exit_usage(); } info = malloc(sizeof(struct rand_pool_info) + len / 8); if (info == NULL) { exit_perror(\"Could not alloc rand_pool_info struct\"); } // This is measured in bits IIRC. info-\u003eentropy_count = len * 4; info-\u003ebuf_size = len / 8; } int fd = open(\"/dev/urandom\", O_RDWR); if (fd \u003c 0) { exit_perror(\"Unable to open /dev/urandom\"); } if (ioctl(fd, RNDCLEARPOOL) \u003c 0) { exit_perror(\"Error issuing RNDCLEARPOOL operation\"); } if (argc == 1) { exit(EXIT_SUCCESS); } // Add the entropy bytes supplied by the user. char num_buf[9] = {}; size_t pos = 0; while (pos \u003c len) { memcpy(num_buf, \u0026argv[1] + pos, 8); info-\u003ebuf[pos / 8] = strtoul(num_buf, NULL, 16); pos += 8; } if (ioctl(fd, RNDADDENTROPY, info) \u003c 0) { exit_perror(\"Error issuing RNDADDENTROPY operation\"); } }",
  "image": "https://repository-images.githubusercontent.com/107505869/7965503b-5b48-4878-95ed-24d8f8cafef0",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\" aria-labelledby=\"file-name-id-wide file-name-id-mobile\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eEntropy for Clones\u003c/h2\u003e\u003ca id=\"user-content-entropy-for-clones\" aria-label=\"Permalink: Entropy for Clones\" href=\"#entropy-for-clones\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis document provides a high level perspective on the implications of restoring\nmultiple VM clones from a single snapshot. We start with an overview of the\nLinux random number generation (RNG) facilities, then go through the potential\nissues we’ve identified related to cloning state, and finally conclude with a\nseries of recommendations. It’s worth stressing that we aim to prevent stale\nstate being a problem only for the kernel interfaces. Some userspace\napplications or libraries keep their own equivalent of entropy pools and suffer\nfrom the same potential issues after being cloned. There is no generic solution\nunder the current programming model, and all we can do is recommend against\ntheir use in pre-snapshot logic.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eBackground\u003c/h2\u003e\u003ca id=\"user-content-background\" aria-label=\"Permalink: Background\" href=\"#background\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe Linux kernel exposes three main \u003ccode\u003eRNG\u003c/code\u003e interfaces to userspace: the\n\u003ccode\u003e/dev/random\u003c/code\u003e and \u003ccode\u003e/dev/urandom\u003c/code\u003e special devices, and the \u003ccode\u003egetrandom\u003c/code\u003e syscall,\nwhich are described in the \u003ca href=\"http://man7.org/linux/man-pages/man7/random.7.html\" rel=\"nofollow\"\u003erandom(7) man page\u003c/a\u003e. Moreover, Firecracker\nsupports the \u003ca href=\"https://github.com/firecracker-microvm/firecracker/blob/main/docs/entropy.md\"\u003e\u003ccode\u003evirtio-rng\u003c/code\u003e\u003c/a\u003e device which can provide additional\nentropy to guest VMs. It draws its random bytes from the \u003ca href=\"https://docs.rs/aws-lc-rs/latest/aws_lc_rs/index.html\" rel=\"nofollow\"\u003e\u003ccode\u003eaws-lc-rs\u003c/code\u003e\u003c/a\u003e crate\nwhich wraps the \u003ca href=\"https://github.com/aws/aws-lc\"\u003e\u003ccode\u003eAWS-LC\u003c/code\u003e cryptographic library\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eTraditionally, \u003ccode\u003e/dev/random\u003c/code\u003e has been considered a source of “true” randomness,\nwith the downside that reads block when the pool of entropy gets depleted. On\nthe other hand, \u003ccode\u003e/dev/urandom\u003c/code\u003e doesn’t block, which lead people believe that it\nprovides lower quality results.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt turns out the distinction in output quality is actually very hard to make.\nAccording to \u003ca href=\"https://www.2uo.de/myths-about-urandom\" rel=\"nofollow\"\u003ethis article\u003c/a\u003e, for kernel versions prior to 4.8, both devices\ndraw their output from the same pool, with the exception that \u003ccode\u003e/dev/random\u003c/code\u003e will\nblock when the system estimates the entropy count has decreased below a certain\nthreshold. The \u003ccode\u003e/dev/urandom\u003c/code\u003e output is considered secure for virtually all\npurposes, with the caveat that using it before the system gathers sufficient\nentropy for initialization may indeed produce low quality random numbers. The\n\u003ccode\u003egetrandom\u003c/code\u003e syscall helps with this situation; it uses the \u003ccode\u003e/dev/urandom\u003c/code\u003e source\nby default, but will block until it gets properly initialized (the behavior can\nbe altered via configuration flags).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNewer kernels (4.8+) have switched to an implementation where \u003ccode\u003e/dev/random\u003c/code\u003e\noutput comes from a pool called the blocking pool, the output of \u003ccode\u003e/dev/urandom\u003c/code\u003e\nis given by a CSPRNG (cryptographically secure pseudorandom number generator),\nand there’s also an input pool which gathers entropy from various sources\navailable on the system, and is used to feed into or seed the other two\ncomponents. A very detailed description is available \u003ca href=\"https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/Studies/LinuxRNG/LinuxRNG_EN.pdf\" rel=\"nofollow\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe details of this newer implementation are used to make the recommendations\npresent in the document. There are in-kernel interfaces used to obtain random\nnumbers as well, but they are similar to using \u003ccode\u003e/dev/urandom\u003c/code\u003e (or \u003ccode\u003egetrandom\u003c/code\u003e\nwith the default source) from userspace.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWhenever a VM clone is created based on a snapshot, execution resumes precisely\nfrom the previously saved state. Getting random bytes from either \u003ccode\u003e/dev/random\u003c/code\u003e\nor \u003ccode\u003e/dev/urandom\u003c/code\u003e does not lead to identical results for different clones\ncreated from the same snapshot because multiple parameters (such as timer data,\nor output from \u003ccode\u003eCPU HWRNG\u003c/code\u003e instructions which are present on Ivy Bridge or newer\nIntel processors and enabled in a Firecracker guest) are mixed with each result.\nExtra bits are mixed in both when reading random values, and in conjunction with\nentropy related events such as interrupts. Moreover, the guest kernel will\neventually receive fresh entropy from \u003ccode\u003evirtio-rng\u003c/code\u003e, if attached. There are two\nquestions here:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eIs the \u003ccode\u003eCPU HWRNG\u003c/code\u003e output always mixed in when the feature is present (as\nopposed to only when the \u003ccode\u003eCPU HWRNG\u003c/code\u003e is trusted)?\u003c/li\u003e\n\u003cli\u003eIs the added noise strong enough to consider the final RNG output sufficiently\ndivergent from all other clones?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eBoth these questions are particularly relevant immediately after resuming a VM\nfrom a snapshot. After the VM gets to run for a \u0026#34;sufficient\u0026#34; amount of time it\nshould be able to gather some more entropy by itself and its state should be\nsufficiently divergent that of any other clones.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt seems the \u003ccode\u003eCPU HWRNG\u003c/code\u003e is always added to mix when present. More specifically,\n\u003ca href=\"https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/Studies/LinuxRNG/LinuxRNG_EN.pdf\" rel=\"nofollow\"\u003epage 32 point 1 (at the top of the page)\u003c/a\u003e mentions using the \u003ccode\u003eCPU HWRNG\u003c/code\u003e\nwhen present for the entropy pool output function. Page 34 states \u003cem\u003ein case a CPU\nrandom number generator is known to the Linux-RNG, data from that hardware RNG\nis mixed into the entropy pool in a second step\u003c/em\u003e. With respect to the\ninitialization of the random pools and DRNG behind /dev/urandom. The discussion\nregarding DRNG state on page 35 mentions \u003cem\u003ethe key part, the counter, and the\nnonce are XORed with the output of the CPU random number generator if one is\npresent. If it is not present, one high-resolution time stamp obtained with the\nkernel function random_get_entropy word is XORed with the key part\u003c/em\u003e. The\n\u003ccode\u003eCPU HWRNG\u003c/code\u003e is also used for the DRNG state transition function (as stated on\npage 36 point 1), and during the reseed operation (page 37 point 2). The\ndocument explicitly mentions when the \u003ccode\u003eCPU HWRNG\u003c/code\u003e has to be trusted (for\nexample, the bullet points at the end of Section 3.3.2.3).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt’s not yet clear whether the noise that gets added for each clone post restore\nis sufficient to consider their RNG states distinct for security purposes. The\nconservative approach is to presume the stale state has a significant influence\non RNG output, so we should reinitialize both sources based on fresh data after\neach restore. It would seem that simply writing data to \u003ccode\u003e/dev/urandom\u003c/code\u003e is enough\nto muddle the entropy pools, but the bits only get mixed with the input pool.\nIt’s not certain at this point whether such writes have any immediate impact on\nthe blocking pool, and it’s unlikely they cause the \u003ccode\u003eCSPRNG\u003c/code\u003e to be automatically\nreseeded.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe standard methods of interacting with the kernel RNG sources are documented\nin the \u003ca href=\"http://man7.org/linux/man-pages/man4/random.4.html\" rel=\"nofollow\"\u003erandom(4) man page\u003c/a\u003e. It states that any writes to either\n\u003ccode\u003e/dev/random\u003c/code\u003e or \u003ccode\u003e/dev/urandom\u003c/code\u003e are mixed with the input entropy pool, but do\nnot increase the current entropy estimation. There is also an \u003ccode\u003eioctl\u003c/code\u003e interface\nwhich, given the appropriate privileges, can be used to add data to the input\nentropy pool while also increasing the count, or completely empty all pools.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eLinux kernels with VMGenID support\u003c/h3\u003e\u003ca id=\"user-content-linux-kernels-with-vmgenid-support\" aria-label=\"Permalink: Linux kernels with VMGenID support\" href=\"#linux-kernels-with-vmgenid-support\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLinux has support for the\n\u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/hyperv_v2/virtual-machine-generation-identifier\" rel=\"nofollow\"\u003eVirtual Machine Generation Identifier\u003c/a\u003e\nsince 5.18 for ACPI systems. Since 6.10, Linux added support also for systems\nthat use DeviceTree instead of ACPI. The purpose of VMGenID is to notify the\nguest about time shift events, such as resuming from a snapshot. The device\nexposes a 16-byte cryptographically random identifier in guest memory.\nFirecracker implements VMGenID. When resuming a microVM from a snapshot\nFirecracker writes a new identifier and injects a notification to the guest.\nLinux,\n\u003ca href=\"https://elixir.bootlin.com/linux/v5.18.19/source/drivers/virt/vmgenid.c#L77\" rel=\"nofollow\"\u003euses this value\u003c/a\u003e\n\u003ca href=\"https://elixir.bootlin.com/linux/v5.18.19/source/drivers/char/random.c#L908\" rel=\"nofollow\"\u003eas new randomness for its CSPRNG\u003c/a\u003e.\nQuoting the random.c implementation of the kernel:\u003c/p\u003e\n\u003cdiv data-snippet-clipboard-copy-content=\"/*\n * Handle a new unique VM ID, which is unique, not secret, so we\n * don\u0026#39;t credit it, but we do immediately force a reseed after so\n * that it\u0026#39;s used by the crng posthaste.\n */\"\u003e\u003cpre\u003e\u003ccode\u003e/*\n * Handle a new unique VM ID, which is unique, not secret, so we\n * don\u0026#39;t credit it, but we do immediately force a reseed after so\n * that it\u0026#39;s used by the crng posthaste.\n */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eAs a result, values returned by \u003ccode\u003egetrandom()\u003c/code\u003e and \u003ccode\u003e/dev/(u)random\u003c/code\u003e are distinct\nin all VMs started from the same snapshot, \u003cstrong\u003eafter\u003c/strong\u003e the kernel handles the\nVMGenID notification. This leaves a race window between resuming vCPUs and Linux\nCSPRNG getting successfully re-seeded. In Linux 6.8, we\n\u003ca href=\"https://lore.kernel.org/lkml/20230531095119.11202-2-bchalios@amazon.es/\" rel=\"nofollow\"\u003eextended VMGenID\u003c/a\u003e\nto emit a uevent to user space when it handles the notification. User space can\npoll this uevent to know when it is safe to use \u003ccode\u003egetrandom()\u003c/code\u003e, et al. avoiding\nthe race condition.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eFirecracker supports VMGenID on ARM systems using the DeviceTree binding that\nwas added for the device in Linux 6.10. However, the latest Linux kernel that\nFirecracker supports is 6.1. As a result, in order to use VMGenID on ARM\nsystems, users need to use a 6.1 kernel with the DeviceTree binding support\nbackported from 6.10. For our CI we backport the\n\u003ca href=\"https://github.com/torvalds/linux/commit/f0cd69b8cca6a5096463644d6dacc9f991bfa521\"\u003erelevant changes\u003c/a\u003e\nfrom 6.10 to 6.1. Consumers of Firecracker that want to use the feature on ARM\nneed to ensure they backport these changes on their guest kernels.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003ePlease note that, Firecracker will always enable VMGenID. In kernels where there\nis no VMGenID driver, the device will not have any effect in the guest.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUser space considerations\u003c/h3\u003e\u003ca id=\"user-content-user-space-considerations\" aria-label=\"Permalink: User space considerations\" href=\"#user-space-considerations\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eInit systems (such as \u003ccode\u003esystemd\u003c/code\u003e used by AL2 and other distros) might save a\nrandom seed file after boot. For \u003ccode\u003esystemd\u003c/code\u003e, the path is\n\u003ccode\u003e/var/lib/systemd/random-seed\u003c/code\u003e. Just to be on the safe side, any such file\nshould be deleted before taking a snapshot, to prevent its reuse for any\npurposes by the guest. There’s also the \u003ccode\u003e/proc/sys/kernel/random/boot_id\u003c/code\u003e\nspecial file, which gets initialized with a random string at boot time, and is\nread-only afterwards. All clones restored from the same snapshot will implicitly\nread the same value from this file. If that’s not desirable, it’s possible to\nalter the read result via bind mounting another file on top of\n\u003ccode\u003e/proc/sys/kernel/random/boot_id\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eRecommendations\u003c/h2\u003e\u003ca id=\"user-content-recommendations\" aria-label=\"Permalink: Recommendations\" href=\"#recommendations\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eDelete \u003ccode\u003e/var/lib/systemd/random-seed\u003c/code\u003e, or any equivalent files.\u003c/li\u003e\n\u003cli\u003eIf changing the value present in \u003ccode\u003e/proc/sys/kernel/random/boot_id\u003c/code\u003e is\nimportant, bind mount another file on top of it.\u003c/li\u003e\n\u003cli\u003eIf microVMs run on machines with IvyBridge or newer Intel processors (which\nprovide RDRAND; in addition, RDSEED is offered starting with Broadwell).\nHardware supported reseeding is done on a cadence defined by the Linux Kernel\nand should be sufficient for most cases.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003evirtio-rng\u003c/code\u003e. When present, the guest kernel uses the device as an\nadditional source of entropy.\u003c/li\u003e\n\u003cli\u003eOn kernels before 5.18, to be as safe as possible, the direct approach is to\ndo the following (before customer code is resumed in the clone):\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eOpen one of the special devices files (either \u003ccode\u003e/dev/random\u003c/code\u003e or\n\u003ccode\u003e/dev/urandom\u003c/code\u003e). Take note that \u003ccode\u003eRNDCLEARPOOL\u003c/code\u003e no longer\n\u003ca href=\"https://elixir.bootlin.com/linux/v4.14.295/source/drivers/char/random.c#L1351\" rel=\"nofollow\"\u003ehas any effect\u003c/a\u003e on the entropy pool.\u003c/li\u003e\n\u003cli\u003eIssue an \u003ccode\u003eRNDADDENTROPY\u003c/code\u003e ioctl call (requires \u003ccode\u003eCAP_SYS_ADMIN\u003c/code\u003e) to mix the\nprovided bytes into the input entropy pool and increase the entropy count.\nThis should also cause the \u003ccode\u003e/dev/urandom\u003c/code\u003e \u003ccode\u003eCSPRNG\u003c/code\u003e to be reseeded. The\nbytes can be generated locally in the guest, or obtained from the host.\u003c/li\u003e\n\u003cli\u003eIssue a \u003ccode\u003eRNDRESEEDCRNG\u003c/code\u003e ioctl call (\u003ca href=\"https://elixir.bootlin.com/linux/v4.14.295/source/drivers/char/random.c#L1355\" rel=\"nofollow\"\u003e4.14\u003c/a\u003e, \u003ca href=\"https://elixir.bootlin.com/linux/v5.10.147/source/drivers/char/random.c#L1360\" rel=\"nofollow\"\u003e5.10\u003c/a\u003e, (requires\n\u003ccode\u003eCAP_SYS_ADMIN\u003c/code\u003e)) that specifically causes the \u003ccode\u003eCSPRNG\u003c/code\u003e to be reseeded from\nthe input pool.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eOn kernels starting from 5.18 onwards, the CSPRNG will be automatically\nreseeded when the guest kernel handles the VMGenID notification. To completely\navoid the race condition, users should follow the same steps as with kernels\n\u0026lt; 5.18.\u003c/li\u003e\n\u003cli\u003eOn kernels starting from 6.8, users can poll for the VMGenID uevent that the\ndriver sends when the CSPRNG is reseeded after handling the VMGenID\nnotification.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003cstrong\u003eAnnex 1 contains the source code of a C program which implements the previous\nthree steps.\u003c/strong\u003e As soon as the guest kernel version switches to 4.19 (or higher),\nwe can rely on the \u003ccode\u003eCONFIG_RANDOM_TRUST_CPU\u003c/code\u003e kernel option (or the\nrandom.trust_cpu=on cmdline parameter) to have the entropy pool automatically\nrefilled using the \u003ccode\u003eCPU HWRNG\u003c/code\u003e, so step 3 would no longer be necessary. Another\nway around step 3 is to attach a \u003ccode\u003evirtio-rng\u003c/code\u003e device. However, we cannot control\nwhen the guest kernel will request for random bytes from the device.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eAnnex 1: Source code that clears and reinitializes the entropy pool\u003c/h2\u003e\u003ca id=\"user-content-annex-1-source-code-that-clears-and-reinitializes-the-entropy-pool\" aria-label=\"Permalink: Annex 1: Source code that clears and reinitializes the entropy pool\" href=\"#annex-1-source-code-that-clears-and-reinitializes-the-entropy-pool\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"#include \u0026lt;errno.h\u0026gt;\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;linux/random.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;sys/ioctl.h\u0026gt;\n\nvoid exit_usage() {\n    printf(\u0026#34;Usage: ./rerand [\u0026lt;hexadecimal_string\u0026gt;]\\n\u0026#34;\n           \u0026#34;The length of the string must be a multiple of 8.\\n\u0026#34;);\n    exit(EXIT_FAILURE);\n}\n\nvoid exit_perror(const char *msg) {\n    perror(msg);\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char ** argv) {\n    if (argc \u0026gt; 2) {\n        exit_usage();\n    }\n\n    size_t len = 0;\n    struct rand_pool_info *info = NULL;\n\n    if (argc == 2) {\n        len = strlen(argv[1]);\n        // We want len to be a multiple of 8 such that we have an easier time\n        // parsing argv[1] into an array of u32s.\n        if (len % 8) {\n            exit_usage();\n        }\n\n        info = malloc(sizeof(struct rand_pool_info) + len / 8);\n        if (info == NULL) {\n            exit_perror(\u0026#34;Could not alloc rand_pool_info struct\u0026#34;);\n        }\n        // This is measured in bits IIRC.\n        info-\u0026gt;entropy_count = len * 4;\n        info-\u0026gt;buf_size = len / 8;\n    }\n\n    int fd = open(\u0026#34;/dev/urandom\u0026#34;, O_RDWR);\n    if (fd \u0026lt; 0) {\n        exit_perror(\u0026#34;Unable to open /dev/urandom\u0026#34;);\n    }\n\n    if (ioctl(fd, RNDCLEARPOOL) \u0026lt; 0) {\n        exit_perror(\u0026#34;Error issuing RNDCLEARPOOL operation\u0026#34;);\n    }\n\n    if (argc == 1) {\n        exit(EXIT_SUCCESS);\n    }\n\n    // Add the entropy bytes supplied by the user.\n    char num_buf[9] = {};\n    size_t pos = 0;\n\n    while (pos \u0026lt; len) {\n        memcpy(num_buf, \u0026amp;argv[1] + pos, 8);\n        info-\u0026gt;buf[pos / 8] = strtoul(num_buf, NULL, 16);\n        pos += 8;\n    }\n\n    if (ioctl(fd, RNDADDENTROPY, info) \u0026lt; 0) {\n        exit_perror(\u0026#34;Error issuing RNDADDENTROPY operation\u0026#34;);\n    }\n}\"\u003e\u003cpre\u003e#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eerrno.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003efcntl.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003elinux/random.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003estdio.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003estdlib.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003estring.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n#\u003cspan\u003einclude\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003esys/ioctl.h\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eexit_usage\u003c/span\u003e() {\n    \u003cspan\u003eprintf\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eUsage: ./rerand [\u0026lt;hexadecimal_string\u0026gt;]\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\n           \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eThe length of the string must be a multiple of 8.\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e);\n    \u003cspan\u003eexit\u003c/span\u003e(EXIT_FAILURE);\n}\n\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eexit_perror\u003c/span\u003e(\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e *msg) {\n    \u003cspan\u003eperror\u003c/span\u003e(msg);\n    \u003cspan\u003eexit\u003c/span\u003e(EXIT_FAILURE);\n}\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e argc, \u003cspan\u003echar\u003c/span\u003e ** argv) {\n    \u003cspan\u003eif\u003c/span\u003e (argc \u0026gt; \u003cspan\u003e2\u003c/span\u003e) {\n        \u003cspan\u003eexit_usage\u003c/span\u003e();\n    }\n\n    \u003cspan\u003esize_t\u003c/span\u003e len = \u003cspan\u003e0\u003c/span\u003e;\n    \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003erand_pool_info\u003c/span\u003e *info = \u003cspan\u003eNULL\u003c/span\u003e;\n\n    \u003cspan\u003eif\u003c/span\u003e (argc == \u003cspan\u003e2\u003c/span\u003e) {\n        len = \u003cspan\u003estrlen\u003c/span\u003e(argv[\u003cspan\u003e1\u003c/span\u003e]);\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e We want len to be a multiple of 8 such that we have an easier time\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e parsing argv[1] into an array of u32s.\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e (len % \u003cspan\u003e8\u003c/span\u003e) {\n            \u003cspan\u003eexit_usage\u003c/span\u003e();\n        }\n\n        info = \u003cspan\u003emalloc\u003c/span\u003e(\u003cspan\u003esizeof\u003c/span\u003e(\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003erand_pool_info\u003c/span\u003e) + len / \u003cspan\u003e8\u003c/span\u003e);\n        \u003cspan\u003eif\u003c/span\u003e (info == \u003cspan\u003eNULL\u003c/span\u003e) {\n            \u003cspan\u003eexit_perror\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eCould not alloc rand_pool_info struct\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e);\n        }\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e This is measured in bits IIRC.\u003c/span\u003e\n        info-\u0026gt;\u003cspan\u003eentropy_count\u003c/span\u003e = len * \u003cspan\u003e4\u003c/span\u003e;\n        info-\u0026gt;\u003cspan\u003ebuf_size\u003c/span\u003e = len / \u003cspan\u003e8\u003c/span\u003e;\n    }\n\n    \u003cspan\u003eint\u003c/span\u003e fd = \u003cspan\u003eopen\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e/dev/urandom\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, O_RDWR);\n    \u003cspan\u003eif\u003c/span\u003e (fd \u0026lt; \u003cspan\u003e0\u003c/span\u003e) {\n        \u003cspan\u003eexit_perror\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eUnable to open /dev/urandom\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e);\n    }\n\n    \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003eioctl\u003c/span\u003e(fd, RNDCLEARPOOL) \u0026lt; \u003cspan\u003e0\u003c/span\u003e) {\n        \u003cspan\u003eexit_perror\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eError issuing RNDCLEARPOOL operation\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e);\n    }\n\n    \u003cspan\u003eif\u003c/span\u003e (argc == \u003cspan\u003e1\u003c/span\u003e) {\n        \u003cspan\u003eexit\u003c/span\u003e(EXIT_SUCCESS);\n    }\n\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e Add the entropy bytes supplied by the user.\u003c/span\u003e\n    \u003cspan\u003echar\u003c/span\u003e num_buf[\u003cspan\u003e9\u003c/span\u003e] = {};\n    \u003cspan\u003esize_t\u003c/span\u003e pos = \u003cspan\u003e0\u003c/span\u003e;\n\n    \u003cspan\u003ewhile\u003c/span\u003e (pos \u0026lt; len) {\n        \u003cspan\u003ememcpy\u003c/span\u003e(num_buf, \u0026amp;argv[\u003cspan\u003e1\u003c/span\u003e] + pos, \u003cspan\u003e8\u003c/span\u003e);\n        info-\u0026gt;\u003cspan\u003ebuf\u003c/span\u003e[pos / \u003cspan\u003e8\u003c/span\u003e] = \u003cspan\u003estrtoul\u003c/span\u003e(num_buf, \u003cspan\u003eNULL\u003c/span\u003e, \u003cspan\u003e16\u003c/span\u003e);\n        pos += \u003cspan\u003e8\u003c/span\u003e;\n    }\n\n    \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003eioctl\u003c/span\u003e(fd, RNDADDENTROPY, info) \u0026lt; \u003cspan\u003e0\u003c/span\u003e) {\n        \u003cspan\u003eexit_perror\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eError issuing RNDADDENTROPY operation\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e);\n    }\n}\u003c/pre\u003e\u003c/div\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
