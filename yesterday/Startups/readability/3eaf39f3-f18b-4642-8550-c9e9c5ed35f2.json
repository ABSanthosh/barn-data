{
  "id": "3eaf39f3-f18b-4642-8550-c9e9c5ed35f2",
  "title": "Falsehoods programmers believe about null pointers",
  "link": "https://purplesyringa.moe/blog/falsehoods-programmers-believe-about-null-pointers/",
  "description": "Article URL: https://purplesyringa.moe/blog/falsehoods-programmers-believe-about-null-pointers/ Comments URL: https://news.ycombinator.com/item?id=42894220 Points: 6 # Comments: 0",
  "author": "HeliumHydride",
  "published": "Sat, 01 Feb 2025 00:25:43 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 13502,
  "excerpt": "Null pointers look simple on the surface, and that’s why they’re so dangerous. As compiler optimizations, intuitive but incorrect simplifications, and platform-specific quirks have piled on, the odds of making a wrong assumption have increased, leading to the proliferation of bugs and vulnerabilities. This article explores common misconceptions about null pointers held by many programmers, starting with simple fallacies and working our way up to the weirdest cases. Some of them will be news only to beginners, while others may lead experts down the path of meticulous fact-checking. Without further ado, let’s dive in.",
  "siteName": "purplesyringa's blog",
  "favicon": "",
  "text": "January 30, 2025 Reddit Hacker NewsNull pointers look simple on the surface, and that’s why they’re so dangerous. As compiler optimizations, intuitive but incorrect simplifications, and platform-specific quirks have piled on, the odds of making a wrong assumption have increased, leading to the proliferation of bugs and vulnerabilities.This article explores common misconceptions about null pointers held by many programmers, starting with simple fallacies and working our way up to the weirdest cases. Some of them will be news only to beginners, while others may lead experts down the path of meticulous fact-checking. Without further ado, let’s dive in.Dereferencing a null pointer immediately crashes the program.Everyone’s first attempt to dereference a null pointer in C, C++, or Rust results either in STATUS_ACCESS_VIOLATION or a dreaded Segmentation fault (core dumped) message, which gives this misconception some credibility. However, higher-level languages and libraries like Crashpad can handle the error and print a nice message and a backtrace before the crash. This is implemented by installing a vectored exception handler on Windows and a signal handler on Unix-like platforms.Dereferencing a null pointer eventually leads to program termination.While dereferencing a null pointer is a Bad Thing, it is by no means unrecoverable. Vectored exception and signal handlers can resume the program (perhaps from a different code location) instead of bringing the process down. For example, Go translates nil pointer dereferences to panics, which can be caught in user code with recover, and Java translates them to NullPointerException, which can also be caught by user code like any other exception.In both cases, asking for forgiveness (dereferencing a null pointer and then recovering) instead of permission (checking if the pointer is null before dereferencing it) is an optimization. Comparing all pointers with null would slow down execution when the pointer isn’t null, i.e. in the majority of cases. In contrast, signal handling is zero-cost until the signal is generated, which happens exceedingly rarely in well-written programs.Dereferencing a null pointer always causes a signal, an exception, or is otherwise rejected by hardware.Let’s ignore undefined behavior for now and assume that the dereference is not optimized out.Before virtual memory was a thing, almost all memory was accessible. For example, x86 in real mode stored interrupt tables at addresses from 0 to 1024. From the hardware point of view, dereferencing a null pointer is no different from dereferencing other pointers, and as such, it simply accessed memory at address 0.This is still the case on many embedded platforms. Dereferencing a null pointer is still considered UB, so if, for whatever reason, you need to access address 0, there are two major ways to do this:You can write the relevant code in assembly, which does not have UB.If the hardware ignores the topmost bits of the address, you can access 0x80000000 (or similar) from C instead.On modern conventional platforms, dereferencing a null pointer always causes a signal, an exception, or is otherwise rejected by hardware.Linux supports a personality flag called MMAP_PAGE_ZERO for compatibility with programs developed for System V. Running a program under setarch -Z executes it with address 0 to 4096 (or whatever your page size is) mapped to a page of zeroes. Alternatively, you can use mmap to place memory at address 0 by hand. Many years ago, Wine used this trick (among others, like patching LDT) to run DOS applications without DOSBox.This no longer works by default for security reasons. One man’s treasure is another man’s trash: if the kernel accidentally dereferences a null pointer while the memory at address 0 is mapped, it might interpret user-supplied data as a kernel data structure, which facilitates exploits. However, you can still enable this explicitly by running sudo sysctl vm.mmap_min_addr=0.Despite this, there’s a very modern and common platform that still maps memory at address 0. It’s WebAssembly. Isolation within a wasm container is unnecessary, so this does not ease security exploits, and as such, dereferencing a null pointer still works here.Dereferencing a null pointer always triggers “UB”.This one’s tricky. The standard does say this triggers Undefined Behavior, but what this phrase means has significantly changed over time.In ye olden times, the C standard was considered guidelines rather than a ruleset, undefined behavior was closer to implementation-defined behavior than dark magic, and optimizers were stupid enough to make that distinction irrelevant. On a majority of platforms, dereferencing a null pointer compiled and behaved exactly like dereferencing a value at address 0.For all intents and purposes, UB as we understand it today with spooky action at a distance didn’t exist.For example, the HP-UX C compiler had a CLI option to map a page of zeroes at address 0, so that *(int*)NULL would return 0. Certain programs relied on this behavior and had to be patched to run correctly on modern operating systems – or be executed with a personality flag.Now we enter the cursed territory.The null pointer has address 0.The C standard does not require the null pointer to have address 0. The only requirement it imposes is for (void*)x to evaluate to a null pointer, where x is a compile-time constant equal to zero. Such patterns can easily be matched in compile time, so null pointers can have addresses other than 0. Similarly, casting a pointer to a boolean (as in if (p) and !p) is required to produce false for null pointers, not for zero pointers.This is not a hypothetical: some real architectures and C interpreters use non-zero null pointers. fullptr is not really a joke.If you’re wondering, Rust and other modern languages usually don’t support this case.The null pointer has address 0 on modern platforms.On GPU architectures like AMD GCN and NVIDIA Fermi, 0 points to accessible memory. At least on AMD GCN, the null pointer is represented as -1. (I’m not sure if that holds for Fermi, but that would be reasonable.)Since (void*)0 is a null pointer, int x = 0; (void*)x must be a null pointer, too.In int x = 0; (void*)x, x is not a constant expression, so the standard does not require it to produce a null pointer. Runtime integer-to-pointer casts are often no-ops, so adding if (x == 0) x = ACTUAL_NULL_POINTER_ADDRESS; to every cast would be very inefficient, and generating a null pointer conditional on optimizations seeing through runtime values would be unnecessarily inconsistent.Obviously, void *p; memset(\u0026p, 0, sizeof(p)); p is not guaranteed to produce a null pointer either.On platforms where the null pointer has address 0, C objects may not be placed at address 0.A pointer to an object is not a null pointer, even if it has the same address.If you know what pointer provenance is, pointers with the same bitwise representation behaving differently shouldn’t be news to you:int x[1]; int y = 0; int *p = x + 1; // This may evaluate to true if (p == \u0026y) { // But this will be UB even though p and \u0026y are equal *p; } Similarly, objects can be placed at address 0 even though pointers to them will be indistinguishable from NULL in runtime:int tmp = 123; // This can be placed at address 0 int *p = \u0026tmp; // Just a pointer to 0, does not originate from a constant zero int *q = NULL; // A null pointer because it originates from a constant zero // p and q will have the same bitwise representation, but... int x = *p; // produces 123 int y = *q; // UB On platforms where the null pointer has address 0, int x = 0; (void*)x is a null pointer.The result of an integer-to-pointer conversion is implementation-defined. While a null pointer is an obvious candidate, this can also produce an invalid pointer or even a dereferenceable pointer to an object at address 0. Certain compilers encouraged this pattern for accessing memory at address 0 soundly:int *p = (void*)0; // Must produce a NULL pointer int x = *p; // UB int zero = 0; int *q = (void*)zero; // May produce a dereferenceable pointer on some compilers int y = *q; // Not necessarily UB This is mostly a C legacy: most languages don’t differentiate between runtime and compile-time integer-to-pointer casts and will exhibit consistent behavior.On platforms where the null pointer has address 0, int x = 0; (void*)x will compare equal to NULL.In C, pointers to objects are documented to compare as unequal to NULL, even if the object is at address 0. In other words, knowing the addresses of pointers is not enough to compare them. This is one of the rare cases where provenance affects program execution in a way that does not cause UB.The following asserts hold:extern int tmp; // Suppose this is at address 0 int *p = \u0026tmp; assert(p != NULL); // Pointer to object compares unequal to NULL int *q = (void*)(uintptr_t)p; assert(p == q); // Round-tripping produces a possibly invalid, but equal pointer assert(q != NULL); // By transitivity int x = 0; int *r = (void*)x; // This is still round-tripping, lack of data dependency on p is irrelevant assert(r != NULL); As provenance is not accessible in runtime, such comparisons can only be resolved in compile time. So if a pointer to an object might cross an FFI boundary or be passed to complex code, that object can’t be realistically placed at address 0.Even if there is no object at address 0, int x = 0; (void*)x is still allowed to produce a pointer that compares unequal to NULL, as the conversion is implementation-defined.In Rust, objects are not allowed to be placed at address 0 explicitly.On platforms where the null pointer has address 0, null pointers are stored as zeroes.The address of a pointer as revealed by integer casts and the bitwise representation of a pointer don’t have to be equal, much like casting an integer to a float does not retain the bits.Segmented addressing is a common example, but pointer authentication is a more modern instance of this effect. On ARM, the top byte of a pointer can be configured to store a cryptographic signature, which is then verified at dereference. Pointers inside __ptr_auth regions are signed, storing the signature in addition to the address. Apple decided against signing null pointers, as this would make their values unpredictable during compile time. Still, this was a deliberate decision rather than an implication of the standard.CHERI is even weirder. CHERI pointers store 128-bit capabilities in addition to the 64-bit address we’re used to to protect against UAF and OOB accesses. Any pointer with address 0 is considered a null pointer, so there are effectively 2128-ish different null pointers, only one of which is all-zero. (This also means that comparing pointers for equality can yield different results than comparing their binary representations.)If you extend the definition of pointers to include pointers to class members, this gets even more realistic. Pointers to members are, in effect, offsets to fields (at least if we aren’t taking methods into account), and 0 is a valid offset, so (int Class::*)nullptr is usually stored as -1.Null pointers are even more cursed than pointers in general, and provenance already makes pointers quite complicated. Being aware of edge cases like these is valuable to prevent accidentally non-portable code and interpret other people’s code correctly.But if this sounds like an awful lot to keep in mind all the time, you’re missing the point. Tailoring rules and programs to new environments as more platforms emerged and optimizing compilers got smarter is what got us into this situation in the first place.Many people call C a “portable assembler”. This is emphatically not the case. C looks close to hardware, but in reality this language has its own abstract machine and operational semantics. Optimization passes, code-generating backends, and libraries need to speak a platform-independent language to work in tandem, and that language is not “whatever hardware does”. Instead of translating what you’d like the hardware to perform to C literally, treat C as a higher-level language, because it is one.Python does not suffer from horrible memory safety bugs and non-portable behavior not only because it’s an interpreted language, but also because software engineers don’t try to outsmart the compiler or the runtime. Consider applying the same approach to C.Do you need to memset this structure, or will = {0} do the trick?Why are you casting pointers to size_t? Use uintptr_t instead.Why are you even round-tripping through integers? Use void* as an untyped/unaligned pointer type.Instead of crafting branchless code like (void*)((uintptr_t)p * flag) by hand, let the compiler optimize flag ? p : NULL for you.Can you store flags next to the pointer instead of abusing its low bits? If not, can you insert flags with (char*)p + flags instead of (uintptr_t)p | flags?If your spider sense tingles, consult the C standard, then your compiler’s documentation, then ask compiler developers. Don’t assume there are no long-term plans to change the behavior and certainly don’t trust common sense.When all else fails, do the next best thing: document the assumptions. This will make it easier for users to understand the limits of your software, for developers to port your application to a new platform, and for you to debug unexpected problems.Next up: an architecture that stores memory addresses in IEEE-754 floats.",
  "image": "https://purplesyringa.moe/blog/falsehoods-programmers-believe-about-null-pointers/og.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ctime\u003eJanuary 30, 2025\u003c/time\u003e\u003ca href=\"https://www.reddit.com/r/programming/comments/1ieagxg/falsehoods_programmers_believe_about_null_pointers/\"\u003e Reddit\u003c/a\u003e\u003ca href=\"https://news.ycombinator.com/item?id=42886189\"\u003e Hacker News\u003c/a\u003e\u003c/p\u003e\u003cp\u003eNull pointers look simple on the surface, and that’s why they’re so dangerous. As compiler optimizations, intuitive but incorrect simplifications, and platform-specific quirks have piled on, the odds of making a wrong assumption have increased, leading to the proliferation of bugs and vulnerabilities.\u003c/p\u003e\u003cp\u003eThis article explores common misconceptions about null pointers held by many programmers, starting with simple fallacies and working our way up to the weirdest cases. Some of them will be news only to beginners, while others may lead experts down the path of meticulous fact-checking. Without further ado, let’s dive in.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDereferencing a null pointer immediately crashes the program.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eEveryone’s first attempt to dereference a null pointer in C, C++, or Rust results either in \u003ccode\u003eSTATUS_ACCESS_VIOLATION\u003c/code\u003e or a dreaded \u003ccode\u003eSegmentation fault (core dumped)\u003c/code\u003e message, which gives this misconception some credibility. However, higher-level languages and libraries like \u003ca href=\"https://chromium.googlesource.com/crashpad/crashpad\"\u003eCrashpad\u003c/a\u003e can handle the error and print a nice message and a backtrace before the crash. This is implemented by installing a \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling\"\u003evectored exception handler\u003c/a\u003e on Windows and a \u003ca href=\"https://en.wikipedia.org/wiki/C_signal_handling\"\u003esignal handler\u003c/a\u003e on Unix-like platforms.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDereferencing a null pointer eventually leads to program termination.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWhile dereferencing a null pointer is a Bad Thing, it is by no means unrecoverable. Vectored exception and signal handlers can resume the program (perhaps from a different code location) instead of bringing the process down. For example, Go translates nil pointer dereferences to panics, which can be caught in user code with \u003ca href=\"https://go.dev/blog/defer-panic-and-recover\"\u003erecover\u003c/a\u003e, and Java translates them to \u003ccode\u003eNullPointerException\u003c/code\u003e, which can also be caught by user code like any other exception.\u003c/p\u003e\u003cp\u003eIn both cases, asking for forgiveness (dereferencing a null pointer and then recovering) instead of permission (checking if the pointer is null before dereferencing it) is an optimization. Comparing all pointers with null would slow down execution when the pointer \u003cem\u003eisn’t\u003c/em\u003e null, i.e. in the majority of cases. In contrast, signal handling is zero-cost until the signal is generated, which happens exceedingly rarely in well-written programs.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDereferencing a null pointer always causes a signal, an exception, or is otherwise rejected by hardware.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLet’s ignore undefined behavior for now and assume that the dereference is not optimized out.\u003c/p\u003e\u003cp\u003eBefore virtual memory was a thing, almost all memory was accessible. For example, x86 in real mode stored interrupt tables at addresses from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e1024\u003c/code\u003e. From the hardware point of view, dereferencing a null pointer is no different from dereferencing other pointers, and as such, it simply accessed memory at address \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThis is still the case on many embedded platforms. Dereferencing a null pointer is still considered UB, so if, for whatever reason, you need to access address \u003ccode\u003e0\u003c/code\u003e, there are two major ways to do this:\u003c/p\u003e\u003col\u003e\u003cli\u003eYou can write the relevant code in assembly, which does not have UB.\u003c/li\u003e\u003cli\u003eIf the hardware ignores the topmost bits of the address, you can access \u003ccode\u003e0x80000000\u003c/code\u003e (or similar) from C instead.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cstrong\u003eOn modern conventional platforms, dereferencing a null pointer always causes a signal, an exception, or is otherwise rejected by hardware.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eLinux supports a \u003ca href=\"https://man7.org/linux/man-pages/man2/personality.2.html\"\u003epersonality flag\u003c/a\u003e called \u003ccode\u003eMMAP_PAGE_ZERO\u003c/code\u003e for compatibility with programs developed for System V. Running a program under \u003ccode\u003esetarch -Z\u003c/code\u003e executes it with address \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003e4096\u003c/code\u003e (or whatever your page size is) mapped to a page of zeroes. Alternatively, you can use \u003ccode\u003emmap\u003c/code\u003e to place memory at address \u003ccode\u003e0\u003c/code\u003e by hand. Many years ago, Wine used this trick (among others, like patching LDT) to run DOS applications without DOSBox.\u003c/p\u003e\u003cp\u003eThis no longer works by default for security reasons. One man’s treasure is another man’s trash: if the kernel accidentally dereferences a null pointer while the memory at address \u003ccode\u003e0\u003c/code\u003e is mapped, it might interpret user-supplied data as a kernel data structure, which facilitates exploits. However, you can still enable this explicitly by running \u003ccode\u003esudo sysctl vm.mmap_min_addr=0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eDespite this, there’s a very modern and common platform that still maps memory at address \u003ccode\u003e0\u003c/code\u003e. It’s WebAssembly. Isolation within a wasm container is unnecessary, so this does not ease security exploits, and as such, dereferencing a null pointer still works here.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDereferencing a null pointer always triggers “UB”.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis one’s tricky. The standard does say this triggers Undefined Behavior, but what this phrase \u003cem\u003emeans\u003c/em\u003e has significantly changed over time.\u003c/p\u003e\u003cp\u003eIn ye olden times, the C standard was considered guidelines rather than a ruleset, \u003cem\u003eundefined behavior\u003c/em\u003e was closer to \u003cem\u003eimplementation-defined behavior\u003c/em\u003e than dark magic, and optimizers were stupid enough to make that distinction irrelevant. On a majority of platforms, dereferencing a null pointer compiled and behaved exactly like dereferencing a value at address \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFor all intents and purposes, UB as we understand it today with spooky action at a distance didn’t exist.\u003c/p\u003e\u003cp\u003eFor example, the \u003ca href=\"https://stackoverflow.com/questions/58843458/hp-ux-cc-uses-a-default-setting-to-allow-null-dereferences-is-that-possible-in\"\u003eHP-UX C compiler\u003c/a\u003e had a CLI option to map a page of zeroes at address \u003ccode\u003e0\u003c/code\u003e, so that \u003ccode\u003e*(int*)NULL\u003c/code\u003e would return \u003ccode\u003e0\u003c/code\u003e. Certain programs relied on this behavior and had to be patched to run correctly on modern operating systems – or be executed with a personality flag.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eNow we enter the cursed territory.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe null pointer has address \u003ccode\u003e0\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe C standard does not require the null pointer to have address \u003ccode\u003e0\u003c/code\u003e. The only requirement it imposes is for \u003ccode\u003e(void*)x\u003c/code\u003e to evaluate to a null pointer, where \u003ccode\u003ex\u003c/code\u003e is \u003cem\u003ea compile-time constant equal to zero\u003c/em\u003e. Such patterns can easily be matched in compile time, so null pointers can have addresses other than \u003ccode\u003e0\u003c/code\u003e. Similarly, casting a pointer to a boolean (as in \u003ccode\u003eif (p)\u003c/code\u003e and \u003ccode\u003e!p\u003c/code\u003e) is required to produce \u003ccode\u003efalse\u003c/code\u003e for null pointers, not for zero pointers.\u003c/p\u003e\u003cp\u003eThis is not a hypothetical: \u003ca href=\"https://c-faq.com/null/machexamp.html\"\u003esome real architectures\u003c/a\u003e and C interpreters use non-zero null pointers. \u003ccode\u003efullptr\u003c/code\u003e is not really a joke.\u003c/p\u003e\u003cp\u003eIf you’re wondering, Rust and other modern languages usually don’t support this case.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eThe null pointer has address \u003ccode\u003e0\u003c/code\u003e on modern platforms.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eOn GPU architectures like \u003ca href=\"https://reviews.llvm.org/D26196\"\u003eAMD GCN\u003c/a\u003e and \u003ca href=\"https://what.thedailywtf.com/topic/8661/sometimes-checking-for-null-pointers-is-a-mistake-nvidia-cuda/13\"\u003eNVIDIA Fermi\u003c/a\u003e, \u003ccode\u003e0\u003c/code\u003e points to accessible memory. At least on AMD GCN, the null pointer is represented as \u003ccode\u003e-1\u003c/code\u003e. (I’m not sure if that holds for Fermi, but that would be reasonable.)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSince \u003ccode\u003e(void*)0\u003c/code\u003e is a null pointer, \u003ccode\u003eint x = 0; (void*)x\u003c/code\u003e must be a null pointer, too.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIn \u003ccode\u003eint x = 0; (void*)x\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e is not a constant expression, so the standard does not require it to produce a null pointer. Runtime integer-to-pointer casts are often no-ops, so adding \u003ccode\u003eif (x == 0) x = ACTUAL_NULL_POINTER_ADDRESS;\u003c/code\u003e to every cast would be very inefficient, and generating a null pointer conditional on optimizations seeing through runtime values would be unnecessarily inconsistent.\u003c/p\u003e\u003cp\u003eObviously, \u003ccode\u003evoid *p; memset(\u0026amp;p, 0, sizeof(p)); p\u003c/code\u003e is not guaranteed to produce a null pointer either.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOn platforms where the null pointer has address \u003ccode\u003e0\u003c/code\u003e, C objects may not be placed at address \u003ccode\u003e0\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eA pointer to an object is not a null pointer, even if it has the same address.\u003c/p\u003e\u003cp\u003eIf you know what pointer provenance is, pointers with the same bitwise representation behaving differently shouldn’t be news to you:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eint\u003c/span\u003e x[\u003cspan\u003e1\u003c/span\u003e];\n\u003cspan\u003eint\u003c/span\u003e y = \u003cspan\u003e0\u003c/span\u003e;\n\u003cspan\u003eint\u003c/span\u003e *p = x + \u003cspan\u003e1\u003c/span\u003e;\n\u003cspan\u003e// This may evaluate to true\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e (p == \u0026amp;y) {\n    \u003cspan\u003e// But this will be UB even though p and \u0026amp;y are equal\u003c/span\u003e\n    *p;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSimilarly, objects can be placed at address \u003ccode\u003e0\u003c/code\u003e even though pointers to them will be indistinguishable from \u003ccode\u003eNULL\u003c/code\u003e in runtime:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eint\u003c/span\u003e tmp = \u003cspan\u003e123\u003c/span\u003e; \u003cspan\u003e// This can be placed at address 0\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e *p = \u0026amp;tmp; \u003cspan\u003e// Just a pointer to 0, does not originate from a constant zero\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e *q = \u003cspan\u003eNULL\u003c/span\u003e; \u003cspan\u003e// A null pointer because it originates from a constant zero\u003c/span\u003e\n\u003cspan\u003e// p and q will have the same bitwise representation, but...\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e x = *p; \u003cspan\u003e// produces 123\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e y = *q; \u003cspan\u003e// UB\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eOn platforms where the null pointer has address \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eint x = 0; (void*)x\u003c/code\u003e is a null pointer.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe result of an integer-to-pointer conversion is implementation-defined. While a null pointer is an obvious candidate, this can also produce an invalid pointer or even a dereferenceable pointer to an object at address \u003ccode\u003e0\u003c/code\u003e. Certain compilers \u003ca href=\"https://c-faq.com/.xx/q5.19.html\"\u003eencouraged\u003c/a\u003e this pattern for accessing memory at address \u003ccode\u003e0\u003c/code\u003e soundly:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eint\u003c/span\u003e *p = (\u003cspan\u003evoid\u003c/span\u003e*)\u003cspan\u003e0\u003c/span\u003e; \u003cspan\u003e// Must produce a NULL pointer\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e x = *p; \u003cspan\u003e// UB\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e zero = \u003cspan\u003e0\u003c/span\u003e;\n\u003cspan\u003eint\u003c/span\u003e *q = (\u003cspan\u003evoid\u003c/span\u003e*)zero; \u003cspan\u003e// May produce a dereferenceable pointer on some compilers\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e y = *q; \u003cspan\u003e// Not necessarily UB\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is mostly a C legacy: most languages don’t differentiate between runtime and compile-time integer-to-pointer casts and will exhibit consistent behavior.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOn platforms where the null pointer has address \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eint x = 0; (void*)x\u003c/code\u003e will compare equal to \u003ccode\u003eNULL\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIn C, pointers to objects are documented to compare as unequal to \u003ccode\u003eNULL\u003c/code\u003e, even if the object is at address \u003ccode\u003e0\u003c/code\u003e. In other words, knowing the addresses of pointers is not enough to compare them. This is one of the rare cases where provenance affects program execution in a way that does not cause UB.\u003c/p\u003e\u003cp\u003eThe following asserts hold:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eextern\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e tmp; \u003cspan\u003e// Suppose this is at address 0\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e *p = \u0026amp;tmp;\nassert(p != \u003cspan\u003eNULL\u003c/span\u003e); \u003cspan\u003e// Pointer to object compares unequal to NULL\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e *q = (\u003cspan\u003evoid\u003c/span\u003e*)(\u003cspan\u003euintptr_t\u003c/span\u003e)p;\nassert(p == q); \u003cspan\u003e// Round-tripping produces a possibly invalid, but equal pointer\u003c/span\u003e\nassert(q != \u003cspan\u003eNULL\u003c/span\u003e); \u003cspan\u003e// By transitivity\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e x = \u003cspan\u003e0\u003c/span\u003e;\n\u003cspan\u003eint\u003c/span\u003e *r = (\u003cspan\u003evoid\u003c/span\u003e*)x; \u003cspan\u003e// This is still round-tripping, lack of data dependency on p is irrelevant\u003c/span\u003e\nassert(r != \u003cspan\u003eNULL\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs provenance is not accessible in runtime, such comparisons can only be resolved in compile time. So if a pointer to an object might cross an FFI boundary or be passed to complex code, that object can’t be realistically placed at address \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eEven if there is no object at address \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eint x = 0; (void*)x\u003c/code\u003e is still allowed to produce a pointer that compares unequal to \u003ccode\u003eNULL\u003c/code\u003e, as the conversion is implementation-defined.\u003c/p\u003e\u003cp\u003eIn Rust, objects are not allowed to be placed at address \u003ccode\u003e0\u003c/code\u003e explicitly.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOn platforms where the null pointer has address \u003ccode\u003e0\u003c/code\u003e, null pointers are stored as zeroes.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe address of a pointer as revealed by integer casts and the bitwise representation of a pointer don’t have to be equal, much like casting an integer to a float does not retain the bits.\u003c/p\u003e\u003cp\u003eSegmented addressing is a common example, but pointer authentication is a more modern instance of this effect. On ARM, the top byte of a pointer can be configured to store a cryptographic signature, which is then verified at dereference. Pointers inside \u003ca href=\"https://github.com/swiftlang/llvm-project/blob/65e6c0eccdc1b63a0598b735dabaccf0d575a6b4/clang/docs/PointerAuthentication.rst#ptrauth-qualifier\"\u003e__ptr_auth\u003c/a\u003e regions are signed, storing the signature in addition to the address. Apple decided against signing null pointers, as this would make their values unpredictable during compile time. Still, this was a deliberate decision rather than an implication of the standard.\u003c/p\u003e\u003cp\u003eCHERI is even weirder. CHERI pointers store \u003ceq\u003e\u003cmath\u003e\u003cmn\u003e128\u003c/mn\u003e\u003c/math\u003e\u003c/eq\u003e-bit capabilities in addition to the \u003ceq\u003e\u003cmath\u003e\u003cmn\u003e64\u003c/mn\u003e\u003c/math\u003e\u003c/eq\u003e-bit address we’re used to to protect against UAF and OOB accesses. Any pointer with address \u003ccode\u003e0\u003c/code\u003e is considered a null pointer, so there are effectively \u003ceq\u003e\u003cmath\u003e\u003cmsup\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmn\u003e128\u003c/mn\u003e\u003c/msup\u003e\u003c/math\u003e\u003c/eq\u003e-ish different null pointers, only one of which is all-zero. (This also means that comparing pointers for equality can yield different results than comparing their binary representations.)\u003c/p\u003e\u003cp\u003eIf you extend the definition of pointers to include pointers to class members, this gets even more realistic. Pointers to members are, in effect, offsets to fields (at least if we aren’t taking methods into account), and \u003ccode\u003e0\u003c/code\u003e is a valid offset, so \u003ccode\u003e(int Class::*)nullptr\u003c/code\u003e is usually stored as \u003ccode\u003e-1\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNull pointers are even more cursed than pointers in general, and provenance already makes pointers quite complicated. Being aware of edge cases like these is valuable to prevent accidentally non-portable code and interpret other people’s code correctly.\u003c/p\u003e\u003cp\u003eBut if this sounds like an awful lot to keep in mind all the time, you’re missing the point. Tailoring rules and programs to new environments as more platforms emerged and optimizing compilers got smarter is what got us into this situation in the first place.\u003c/p\u003e\u003cp\u003eMany people call C a “portable assembler”. This is emphatically not the case. C \u003cem\u003elooks\u003c/em\u003e close to hardware, but in reality this language has its own abstract machine and operational semantics. Optimization passes, code-generating backends, and libraries need to speak a platform-independent language to work in tandem, and that language is not “whatever hardware does”. Instead of translating what you’d like the hardware to perform to C literally, treat C as a higher-level language, because it \u003cem\u003eis\u003c/em\u003e one.\u003c/p\u003e\u003cp\u003ePython does not suffer from horrible memory safety bugs and non-portable behavior not only because it’s an interpreted language, but also because software engineers don’t try to outsmart the compiler or the runtime. Consider applying the same approach to C.\u003c/p\u003e\u003cul\u003e\u003cli\u003eDo you \u003cem\u003eneed\u003c/em\u003e to \u003ccode\u003ememset\u003c/code\u003e this structure, or will \u003ccode\u003e= {0}\u003c/code\u003e do the trick?\u003c/li\u003e\u003cli\u003eWhy are you casting pointers to \u003ccode\u003esize_t\u003c/code\u003e? Use \u003ccode\u003euintptr_t\u003c/code\u003e instead.\u003c/li\u003e\u003cli\u003eWhy are you even round-tripping through integers? Use \u003ccode\u003evoid*\u003c/code\u003e as an untyped/unaligned pointer type.\u003c/li\u003e\u003cli\u003eInstead of crafting branchless code like \u003ccode\u003e(void*)((uintptr_t)p * flag)\u003c/code\u003e by hand, let the compiler optimize \u003ccode\u003eflag ? p : NULL\u003c/code\u003e for you.\u003c/li\u003e\u003cli\u003eCan you store flags next to the pointer instead of abusing its low bits? If not, can you insert flags with \u003ccode\u003e(char*)p + flags\u003c/code\u003e instead of \u003ccode\u003e(uintptr_t)p | flags\u003c/code\u003e?\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIf your spider sense tingles, consult the C standard, then your compiler’s documentation, then ask compiler developers. Don’t assume there are no long-term plans to change the behavior and certainly don’t trust common sense.\u003c/p\u003e\u003cp\u003eWhen all else fails, do the next best thing: document the assumptions. This will make it easier for users to understand the limits of your software, for developers to port your application to a new platform, and for you to debug unexpected problems.\u003c/p\u003e\u003cp\u003e\u003cem\u003eNext up: an architecture that stores memory addresses in IEEE-754 floats.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
