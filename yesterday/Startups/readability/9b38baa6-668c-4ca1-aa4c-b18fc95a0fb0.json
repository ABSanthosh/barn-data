{
  "id": "9b38baa6-668c-4ca1-aa4c-b18fc95a0fb0",
  "title": "Embedding Lua in Sqleibniz with Rust",
  "link": "https://xnacly.me/posts/2024/embed-lua-in-rust/",
  "description": "Article URL: https://xnacly.me/posts/2024/embed-lua-in-rust/ Comments URL: https://news.ycombinator.com/item?id=42456707 Points: 6 # Comments: 0",
  "author": "xnacly",
  "published": "Wed, 18 Dec 2024 23:33:14 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 14801,
  "excerpt": "Improving the SQL DX one blog article at a time",
  "siteName": "",
  "favicon": "",
  "text": "I am currently writing a analysis tool for Sql: sqleibniz, specifically for the sqlite dialect.The goal is to perform static analysis for sql input, including: syntax checks, checks if tables, columns and functions exist. Combining this with an embedded sqlite runtime and the ability to assert conditions in this runtime, creates a really great dev experience for sql.Furthermore, I want to be able to show the user high quality error messages with context, explainations and the ability to mute certain diagnostics.After completing the static analysis part of the project, I plan on writing a lsp server for sql, so stay tuned for that.Lua as scriptable configuration \u0026 extending sqleibniz with hooksI want to get the most out of sqleibniz, for me this includes the ability for configuration while providing sensible defaults.Before the changes layed out in this post, sqleibniz was configured via a leibniz.toml file: 1# this is an example file, consult: https://toml.io/en/ for syntax help and 2# src/rules.rs::Config for all available options 3[disabled] 4 # see sqleibniz --help for all available rules 5 rules = [ 6 # by default, sqleibniz specific errors are disabled: 7 \"NoContent\", # source file is empty 8 \"NoStatements\", # source file contains no statements 9 \"Unimplemented\", # construct is not implemented yet 10 \"BadSqleibnizInstruction\", # source file contains a bad sqleibniz instruction 11 12 # ignoring sqlite specific diagnostics: 13 # \"UnknownKeyword\", # an unknown keyword was encountered 14 # \"UnterminatedString\", # a not closed string was found 15 # \"UnknownCharacter\", # an unknown character was found 16 # \"InvalidNumericLiteral\", # an invalid numeric literal was found 17 # \"InvalidBlob\", # an invalid blob literal was found (either bad hex data or incorrect syntax) 18 # \"Syntax\", # a structure with incorrect syntax was found 19 # \"Semicolon\", # a semicolon is missing 20 ] TipA rule refers to a group of diagnostics, as their comments document. Sqleibniz groups diagnostics according to these rules. This enables omitting a singular or multiple diagnostics, alternatively to the configuration file, sqleibniz accepts the -D (short for disable) cli flag, followed the be rule to disable (the list of available rules can be found with sqleibniz --help). For instance, disabling all non sqlite diagnostics:1$ sqleibniz \\ 2 -Dno-statements \\ 3 -Dno-content \\ 4 -Dunimplemented \\ 5 -Dbad-sqleibniz-instruction Sqleibniz prints the rules it currently ignores: 1$ sqleibniz \\ 2 -Dno-statements \\ 3 -Dno-content \\ 4 -Dunimplemented \\ 5 -Dbad-sqleibniz-instruction 6warn: Ignoring the following diagnostics, as specified: 7 -\u003e NoStatements 8 -\u003e NoContent 9 -\u003e Unimplemented 10 -\u003e BadSqleibnizInstruction Why switch from toml to lua when cleary toml already allows us to have all the configuration we need? The answer is scripting. I want to enable users to write their own plugins/addons/hooks for whatever usecase anyone could have.My idea is to provide an array of hooks in lua, each one with a name, a node type to run the callback for and a callback that, once run, gets the context of the node. Node refers to an element in the abstract syntax tree generated by sqleibniz. leibniz.lua already contains the configuration from before, extended with two examplary hooks: 1-- this is an example configuration, consult: https://www.lua.org/manual/5.4/ 2-- or https://learnxinyminutes.com/docs/lua/ for syntax help and 3-- src/rules.rs::Config for all available options 4leibniz = { 5 disabled_rules = { 6 -- ignore sqleibniz specific diagnostics: 7 \"NoContent\", -- source file is empty 8 \"NoStatements\", -- source file contains no statements 9 \"Unimplemented\", -- construct is not implemented yet 10 \"BadSqleibnizInstruction\", -- source file contains a bad sqleibniz instruction 11 12 -- ignore sqlite specific diagnostics: 13 14 -- \"UnknownKeyword\", -- an unknown keyword was encountered 15 -- \"UnterminatedString\", -- a not closed string was found 16 -- \"UnknownCharacter\", -- an unknown character was found 17 -- \"InvalidNumericLiteral\", -- an invalid numeric literal was found 18 -- \"InvalidBlob\", -- an invalid blob literal was found (either bad hex data or incorrect syntax) 19 -- \"Syntax\", -- a structure with incorrect syntax was found 20 -- \"Semicolon\", -- a semicolon is missing 21 }, 22 -- sqleibniz allows for writing custom rules with lua 23 hooks = { 24 { 25 -- summarises the hooks content 26 name = \"idents should be lowercase\", 27 -- instructs sqleibniz which node to execute the `hook` for 28 node = \"literal\", 29 -- sqleibniz calls the hook function once it encounters a node name 30 -- matching the hook.node content 31 -- 32 -- The `node` argument holds the following fields: 33 -- 34 --``` 35 -- node: { 36 -- kind: string, 37 -- content: string, 38 -- children: node[], 39 -- } 40 --``` 41 -- 42 hook = function(node) 43 if node.kind == \"ident\" then 44 if string.match(node.content, \"%u\") then 45 -- returing an error passes the diagnostic to sqleibniz, 46 -- thus a pretty message with the name of the hook, the 47 -- node it occurs and the message passed to error() is 48 -- generated 49 error(\"All idents should be lowercase\") 50 end 51 end 52 end 53 }, 54 { 55 name = \"idents shouldn't be longer than 12 characters\", 56 node = \"literal\", 57 hook = function(node) 58 local max_size = 12 59 if node.kind == \"ident\" then 60 if string.len(node.content) \u003e= max_size then 61 error(\"idents shouldn't be longer than \" .. max_size .. \" characters\") 62 end 63 end 64 end 65 } 66 } 67} Since no one uses sqleibniz yet and I have no semantic versioning in place, I do not care about breaking backwards compatibility and just made the change, small projects ROCK!Rust to Lua, Lua to RustSince the lua configuration is only useful when accessed inside the rust application, I created an equivalent data structure, containg both the disabled rules and the hooks.1pub struct Config { 2 pub disabled_rules: Vec\u003cRule\u003e, 3 pub hooks: Option\u003cVec\u003cHook\u003e\u003e, 4} I use the mlua package, because it has serde support and a lot of examples, even though I no longer use this feature.1mlua = { version = \"0.10.2\", features = [\"lua54\", \"vendored\"] } The vendored-feature allows me to not care about dependency managment regarding lua:vendored: build static Lua(JIT) library from sources during mlua compilation using lua-src or luajit-src cratesmlua uses the FromLua and IntoLua traits for converting rust types to lua types and vice versa.1// from mlua/src/traits.rs 2 3/// Trait for types convertible from [`Value`]. 4pub trait FromLua: Sized { 5 /// Performs the conversion. 6 fn from_lua(value: Value, lua: \u0026Lua) -\u003e Result\u003cSelf\u003e; 7} mlua implements these traits for all primitive types and some ADT, while the serde-feature enables the serialization and deserialization of structures annotated with serde::Deserialize and serde::Serialize. The only issue I found with the above, is the ability to deserialize lua functions (mlua::Function). Serde does not support these, thus I implemented FromLua and IntoLua for my types on my own, taking serde out of the equation: 1impl FromLua for Config { 2 fn from_lua(value: mlua::Value, lua: \u0026mlua::Lua) -\u003e mlua::Result\u003cSelf\u003e { 3 let table: Table = lua.unpack(value)?; 4 let disabled_rules: Vec\u003cRule\u003e = table.get(\"disabled_rules\").unwrap_or_else(|_| vec![]); 5 let hooks: Option\u003cVec\u003cHook\u003e\u003e = table.get(\"hooks\").ok(); 6 Ok(Self { 7 disabled_rules, 8 hooks, 9 }) 10 } 11} Since the context (lua) is passed into the conversion, we can unpack the value to convert, because we want to work directly on the mlua::Value type.Implementing FromLua for Config requires sqleibniz::types::config::Rule and sqleibniz::types::config::Hook to implement FromLua too: 1pub enum Rule { 2 NoContent, 3 NoStatements, 4 Unimplemented, 5 UnknownKeyword, 6 BadSqleibnizInstruction, 7 UnterminatedString, 8 UnknownCharacter, 9 InvalidNumericLiteral, 10 InvalidBlob, 11 Syntax, 12 Semicolon, 13} 14 15impl mlua::FromLua for Rule { 16 fn from_lua(value: mlua::Value, lua: \u0026mlua::Lua) -\u003e mlua::Result\u003cSelf\u003e { 17 let value: String = lua.unpack(value)?; 18 Ok(match value.as_str() { 19 \"NoContent\" =\u003e Self::NoContent, 20 \"NoStatements\" =\u003e Self::NoStatements, 21 \"Unimplemented\" =\u003e Self::Unimplemented, 22 \"UnterminatedString\" =\u003e Self::UnterminatedString, 23 \"UnknownCharacter\" =\u003e Self::UnknownCharacter, 24 \"InvalidNumericLiteral\" =\u003e Self::InvalidNumericLiteral, 25 \"InvalidBlob\" =\u003e Self::InvalidBlob, 26 \"Syntax\" =\u003e Self::Syntax, 27 \"Semicolon\" =\u003e Self::Semicolon, 28 \"BadSqleibnizInstruction\" =\u003e Self::BadSqleibnizInstruction, 29 \"UnknownKeyword\" =\u003e Self::UnknownKeyword, 30 _ =\u003e { 31 return Err(mlua::Error::FromLuaConversionError { 32 from: \"string\", 33 to: \"sqleibniz::rules::Rule\".into(), 34 message: Some(\"Unknown rule name\".into()), 35 }) 36 } 37 }) 38 } 39} The same for HookContext, but a lot shorter: 1pub struct Hook { 2 pub name: String, 3 /// node is optional, because omitting it executes the hook for every encountered node 4 pub node: Option\u003cString\u003e, 5 pub hook: Option\u003cFunction\u003e, 6} 7 8impl mlua::FromLua for Hook { 9 fn from_lua(value: mlua::Value, lua: \u0026mlua::Lua) -\u003e mlua::Result\u003cSelf\u003e { 10 let table: Table = lua.unpack(value)?; 11 let name = table.get(\"name\")?; 12 let node = table.get(\"node\").ok(); 13 let hook: Option\u003cFunction\u003e = table.get(\"hook\").ok(); 14 Ok(Self { name, node, hook }) 15 } 16} Calling Lua functions from RustSince we now have the ability to convert a lua value to a mlua::Function, we can call said function and provide the context it needs as its argument(s):1impl Hook { 2 pub fn exec(\u0026self, arg: HookContext) -\u003e mlua::Result\u003c()\u003e { 3 if let Some(hook) = \u0026self.hook { 4 hook.call(arg)? 5 } 6 Ok(()) 7 } 8} The sqleibniz::types::ctx::HookContext represents the context I want every hook to have, specifically: 1pub struct HookContext { 2 /// [Self::kind] will be the name of the node for most nodes, except nodes 3 /// that hold different kinds, such as Literal, which can be an Ident, a 4 /// String, a Number, etc. 5 pub kind: String, 6 /// [Self::content] holds the textual representation of a nodes contents if 7 /// it is [crates::parser::nodes::Literal]. 8 pub content: Option\u003cString\u003e, 9 pub children: Vec\u003cHookContext\u003e, 10} Due to us passing this structure to Hook::exec and therefore to mlua::Function::call it has to implement the IntoLua trait:1impl IntoLua for HookContext { 2 fn into_lua(self, lua: \u0026mlua::Lua) -\u003e mlua::Result\u003cmlua::Value\u003e { 3 let table = lua.create_table()?; 4 table.set(\"kind\", self.kind)?; 5 table.set(\"text\", self.content.unwrap_or_else(|| String::new()))?; 6 table.set(\"children\", self.children)?; 7 lua.pack(table) 8 } 9} Putting it all togetherInside of the lua scripting context, we now are able to access all of these fields: 1leibniz = { 2 hooks = { 3 { 4 name = \"hook test\", 5 hook = function(node) 6 print(node.kind .. \" \" .. node.text .. \" \" .. #node.children) 7 end 8 } 9 } 10} Executing this hook with the HookContext ends in the expected result: literal this_is_an_ident 0.The following shows the full example I use for sqleibniz: 1fn configuration(lua: \u0026mlua::Lua, file_name: \u0026str) -\u003e Result\u003cConfig, String\u003e { 2 let conf_str = fs::read_to_string(file_name) 3 .map_err(|err| format!(\"Failed to read configuration file '{}': {}\", file_name, err))?; 4 5 // load the lua configuration string, execute it 6 lua.load(conf_str) 7 .set_name(file_name) 8 .exec() 9 .map_err(|err| format!(\"{}: {}\", file_name, err))?; 10 let globals = lua.globals(); 11 12 let raw_conf = globals 13 .get::\u003cmlua::Value\u003e(\"leibniz\") 14 .map_err(|err| format!(\"{}: {}\", file_name, err))?; 15 // if the leibniz table does not exist, mlua does not return an Err, we 16 // have to check for this case 17 if raw_conf.is_nil() { 18 return Err(format!( 19 \"{}: leibniz table is missing from configuration\", 20 file_name 21 )); 22 } 23 24 let conf: Config = lua 25 // calls mlua::FromLua(conf) 26 .unpack(raw_conf) 27 .map_err(|err| format!(\"{}: {}\", file_name, err))?; 28 Ok(conf) 29} 30 31fn main() { 32 let mut config = Config { 33 disabled_rules: vec![], 34 hooks: None, 35 }; 36 37 // lua defined here because it would be dropped at the end of configuration(), in the 38 // future this will probably need to be moved one scope up to life long enough for analysis 39 let lua = mlua::Lua::new(); 40 match configuration(\u0026lua, \u0026args.config) { 41 Ok(conf) =\u003e config = conf, 42 Err(err) =\u003e { 43 error::warn(\u0026err.to_string()); 44 } 45 } 46 47 if let Some(hooks) = \u0026config.hooks { 48 let ctx = types::ctx::HookContext { 49 kind: \"literal\".into(), 50 content: Some(\"this_is_an_ident\".into()), 51 children: vec![], 52 }; 53 54 for hook in hooks { 55 let _ = hook.exec(ctx.clone()); 56 } 57 } 58} If the configuration has invalid syntax or the leibniz table is missing, a warning is omitted and sqleibniz falls back to the default empty configuration:1warn: leibniz.lua: syntax error: [string \"leibniz.lua\"]:6: '}' expected (to close '{' at line 4) near 'bled_rules' 2warn: leibniz.lua: leibniz table is missing from configuration",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cblockquote\u003e\u003cp\u003eI am currently writing a analysis tool for Sql:\n\u003ca href=\"https://github.com/xnacly/sqleibniz\"\u003e\u003ccode\u003esqleibniz\u003c/code\u003e\u003c/a\u003e, specifically for the\nsqlite dialect.\u003c/p\u003e\u003cp\u003eThe goal is to perform static analysis for sql input, including: syntax\nchecks, checks if tables, columns and functions exist. Combining this with an\nembedded sqlite runtime and the ability to assert conditions in this runtime,\ncreates a really great dev experience for sql.\u003c/p\u003e\u003cp\u003eFurthermore, I want to be able to show the user high quality error messages\nwith context, explainations and the ability to mute certain diagnostics.\u003c/p\u003e\u003cp\u003eAfter completing the static analysis part of the project, I plan on writing a\nlsp server for sql, so stay tuned for that.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"lua-as-scriptable-configuration--extending-sqleibniz-with-hooks\"\u003eLua as scriptable configuration \u0026amp; extending sqleibniz with hooks\u003c/h2\u003e\u003cp\u003eI want to get the most out of sqleibniz, for me this includes the ability for\nconfiguration while providing sensible defaults.\u003c/p\u003e\u003cp\u003eBefore the changes layed out in this post, sqleibniz was configured via a\n\u003ccode\u003eleibniz.toml\u003c/code\u003e file:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"toml\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e# this is an example file, consult: https://toml.io/en/ for syntax help and\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e# src/rules.rs::Config for all available options\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e[disabled]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e# see sqleibniz --help for all available rules\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    rules = [\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# by default, sqleibniz specific errors are disabled:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;NoContent\u0026#34;\u003c/span\u003e, \u003cspan\u003e# source file is empty\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;NoStatements\u0026#34;\u003c/span\u003e, \u003cspan\u003e# source file contains no statements\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;Unimplemented\u0026#34;\u003c/span\u003e, \u003cspan\u003e# construct is not implemented yet\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;BadSqleibnizInstruction\u0026#34;\u003c/span\u003e, \u003cspan\u003e# source file contains a bad sqleibniz instruction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# ignoring sqlite specific diagnostics:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;UnknownKeyword\u0026#34;, # an unknown keyword was encountered\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;UnterminatedString\u0026#34;, # a not closed string was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;UnknownCharacter\u0026#34;, # an unknown character was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;InvalidNumericLiteral\u0026#34;, # an invalid numeric literal was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;InvalidBlob\u0026#34;, # an invalid blob literal was found (either bad hex data or incorrect syntax)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e18\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;Syntax\u0026#34;, # a structure with incorrect syntax was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e19\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# \u0026#34;Semicolon\u0026#34;, # a semicolon is missing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e    ]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"callout\"\u003e\u003ch3\u003eTip\u003c/h3\u003e\u003cp\u003eA \u003ccode\u003erule\u003c/code\u003e refers to a group of diagnostics, as their comments document.\nSqleibniz groups diagnostics according to these rules. This enables omitting a\nsingular or multiple diagnostics, alternatively to the configuration file,\nsqleibniz accepts the \u003ccode\u003e-D\u003c/code\u003e (short for disable) cli flag, followed the be rule\nto disable (the list of available rules can be found with \u003ccode\u003esqleibniz --help\u003c/code\u003e).\nFor instance, disabling all non sqlite diagnostics:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e$ sqleibniz \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e    -Dno-statements \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e    -Dno-content \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e    -Dunimplemented \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e    -Dbad-sqleibniz-instruction\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSqleibniz prints the rules it currently ignores:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e$ sqleibniz \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    -Dno-statements \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e    -Dno-content \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e    -Dunimplemented \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    -Dbad-sqleibniz-instruction\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003ewarn: Ignoring the following diagnostics, as specified:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e -\u0026gt; NoStatements\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e -\u0026gt; NoContent\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e -\u0026gt; Unimplemented\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e -\u0026gt; BadSqleibnizInstruction\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eWhy switch from toml to lua when cleary toml already allows us to have all the\nconfiguration we need? The answer is scripting. I want to enable users to write\ntheir own plugins/addons/hooks for whatever usecase anyone could have.\u003c/p\u003e\u003cp\u003eMy idea is to provide an array of hooks in lua, each one with a name, a node\ntype to run the callback for and a callback that, once run, gets the context of\nthe node. Node refers to an element in the abstract syntax tree generated by\nsqleibniz. \u003ccode\u003eleibniz.lua\u003c/code\u003e already contains the configuration from before,\nextended with two examplary hooks:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"lua\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e-- this is an example configuration, consult: https://www.lua.org/manual/5.4/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e-- or https://learnxinyminutes.com/docs/lua/ for syntax help and\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e-- src/rules.rs::Config for all available options\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003eleibniz \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    disabled_rules \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- ignore sqleibniz specific diagnostics:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;NoContent\u0026#34;\u003c/span\u003e,               \u003cspan\u003e-- source file is empty\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;NoStatements\u0026#34;\u003c/span\u003e,            \u003cspan\u003e-- source file contains no statements\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;Unimplemented\u0026#34;\u003c/span\u003e,           \u003cspan\u003e-- construct is not implemented yet\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e\u0026#34;BadSqleibnizInstruction\u0026#34;\u003c/span\u003e, \u003cspan\u003e-- source file contains a bad sqleibniz instruction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- ignore sqlite specific diagnostics:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;UnknownKeyword\u0026#34;, -- an unknown keyword was encountered\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;UnterminatedString\u0026#34;, -- a not closed string was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;UnknownCharacter\u0026#34;, -- an unknown character was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;InvalidNumericLiteral\u0026#34;, -- an invalid numeric literal was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e18\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;InvalidBlob\u0026#34;, -- an invalid blob literal was found (either bad hex data or incorrect syntax)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e19\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;Syntax\u0026#34;, -- a structure with incorrect syntax was found\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e-- \u0026#34;Semicolon\u0026#34;, -- a semicolon is missing\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e21\u003c/span\u003e\u003cspan\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e22\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e-- sqleibniz allows for writing custom rules with lua\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e23\u003c/span\u003e\u003cspan\u003e    hooks \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e        {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e25\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e-- summarises the hooks content\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e26\u003c/span\u003e\u003cspan\u003e            name \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;idents should be lowercase\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e27\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e-- instructs sqleibniz which node to execute the `hook` for\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e28\u003c/span\u003e\u003cspan\u003e            node \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;literal\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e29\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e-- sqleibniz calls the hook function once it encounters a node name\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e30\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e-- matching the hook.node content\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e31\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e-- The `node` argument holds the following fields:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e33\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e34\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--```\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--    node: {\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e36\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--     kind: string,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e37\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--     content: string,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e38\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--     children: node[],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e39\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--    }\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--```\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e41\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e--\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e            hook \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e(node)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e43\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003eif\u003c/span\u003e node.kind \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;ident\u0026#34;\u003c/span\u003e \u003cspan\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e44\u003c/span\u003e\u003cspan\u003e                    \u003cspan\u003eif\u003c/span\u003e string.match(node.content, \u003cspan\u003e\u0026#34;%u\u0026#34;\u003c/span\u003e) \u003cspan\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e45\u003c/span\u003e\u003cspan\u003e                        \u003cspan\u003e-- returing an error passes the diagnostic to sqleibniz,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e46\u003c/span\u003e\u003cspan\u003e                        \u003cspan\u003e-- thus a pretty message with the name of the hook, the\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e                        \u003cspan\u003e-- node it occurs and the message passed to error() is\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e48\u003c/span\u003e\u003cspan\u003e                        \u003cspan\u003e-- generated\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e49\u003c/span\u003e\u003cspan\u003e                        error(\u003cspan\u003e\u0026#34;All idents should be lowercase\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e50\u003c/span\u003e\u003cspan\u003e                    \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e51\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e52\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e53\u003c/span\u003e\u003cspan\u003e        },\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e54\u003c/span\u003e\u003cspan\u003e        {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e55\u003c/span\u003e\u003cspan\u003e            name \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;idents shouldn\u0026#39;t be longer than 12 characters\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e56\u003c/span\u003e\u003cspan\u003e            node \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;literal\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e57\u003c/span\u003e\u003cspan\u003e            hook \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e(node)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e58\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003elocal\u003c/span\u003e max_size \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e12\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e59\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003eif\u003c/span\u003e node.kind \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;ident\u0026#34;\u003c/span\u003e \u003cspan\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e60\u003c/span\u003e\u003cspan\u003e                    \u003cspan\u003eif\u003c/span\u003e string.len(node.content) \u003cspan\u003e\u0026gt;=\u003c/span\u003e max_size \u003cspan\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e61\u003c/span\u003e\u003cspan\u003e                        error(\u003cspan\u003e\u0026#34;idents shouldn\u0026#39;t be longer than \u0026#34;\u003c/span\u003e \u003cspan\u003e..\u003c/span\u003e max_size \u003cspan\u003e..\u003c/span\u003e \u003cspan\u003e\u0026#34; characters\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e62\u003c/span\u003e\u003cspan\u003e                    \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e63\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e64\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e65\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e66\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e67\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSince no one uses sqleibniz yet and I have no semantic versioning in place, I\ndo not care about breaking backwards compatibility and just made the change,\nsmall projects ROCK!\u003c/p\u003e\u003ch2 id=\"rust-to-lua-lua-to-rust\"\u003eRust to Lua, Lua to Rust\u003c/h2\u003e\u003cp\u003eSince the lua configuration is only useful when accessed inside the rust\napplication, I created an equivalent data structure, containg both the disabled\nrules and the hooks.\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eConfig\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e disabled_rules: \u003cspan\u003eVec\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eRule\u003cspan\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e hooks: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVec\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eHook\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp\u003eI use the \u003ca href=\"https://crates.io/crates/mlua\"\u003e\u003ccode\u003emlua\u003c/code\u003e\u003c/a\u003e package, because it has\nserde support and a lot of examples, even though I no longer use this\nfeature.\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"toml\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003emlua = { version = \u003cspan\u003e\u0026#34;0.10.2\u0026#34;\u003c/span\u003e, features = [\u003cspan\u003e\u0026#34;lua54\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;vendored\u0026#34;\u003c/span\u003e] }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe \u003ccode\u003evendored\u003c/code\u003e-feature allows me to not care about dependency managment regarding lua:\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ccode\u003evendored\u003c/code\u003e: build static Lua(JIT) library from sources during mlua compilation using lua-src or luajit-src crates\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\u003cp\u003emlua uses the \u003ccode\u003eFromLua\u003c/code\u003e and \u003ccode\u003eIntoLua\u003c/code\u003e traits for converting rust types to lua\ntypes and vice versa.\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e// from mlua/src/traits.rs\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e/// Trait for types convertible from [`Value`].\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003etrait\u003c/span\u003e FromLua: \u003cspan\u003eSized\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e/// Performs the conversion.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e6\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003efrom_lua\u003c/span\u003e(value: \u003cspan\u003eValue\u003c/span\u003e, lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003eLua\u003c/span\u003e) -\u0026gt; \u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eSelf\u003cspan\u003e\u0026gt;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e7\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003emlua implements these traits for all primitive types and some ADT, while the\n\u003ccode\u003eserde\u003c/code\u003e-feature enables the serialization and deserialization of structures\nannotated with \u003ccode\u003eserde::Deserialize\u003c/code\u003e and \u003ccode\u003eserde::Serialize\u003c/code\u003e. The only issue I\nfound with the above, is the ability to deserialize lua functions\n(\u003ccode\u003emlua::Function\u003c/code\u003e). Serde does not support these, thus I implemented \u003ccode\u003eFromLua\u003c/code\u003e\nand \u003ccode\u003eIntoLua\u003c/code\u003e for my types on my own, taking serde out of the equation:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimpl\u003c/span\u003e FromLua \u003cspan\u003efor\u003c/span\u003e Config {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003efrom_lua\u003c/span\u003e(value: \u003cspan\u003emlua\u003c/span\u003e::Value, lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emlua\u003c/span\u003e::Lua) -\u0026gt; \u003cspan\u003emlua\u003c/span\u003e::\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eSelf\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e table: \u003cspan\u003eTable\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e lua.unpack(value)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e disabled_rules: \u003cspan\u003eVec\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eRule\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e table.get(\u003cspan\u003e\u0026#34;disabled_rules\u0026#34;\u003c/span\u003e).unwrap_or_else(\u003cspan\u003e|\u003c/span\u003e_\u003cspan\u003e|\u003c/span\u003e vec![]);\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e hooks: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVec\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eHook\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e table.get(\u003cspan\u003e\u0026#34;hooks\u0026#34;\u003c/span\u003e).ok();\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eOk\u003c/span\u003e(Self {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e            disabled_rules,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e            hooks,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e        })\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp\u003eSince the context (\u003ccode\u003elua\u003c/code\u003e) is passed into the conversion, we can unpack the\nvalue to convert, because we want to work directly on the \u003ccode\u003emlua::Value\u003c/code\u003e type.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eImplementing \u003ccode\u003eFromLua\u003c/code\u003e for \u003ccode\u003eConfig\u003c/code\u003e requires \u003ccode\u003esqleibniz::types::config::Rule\u003c/code\u003e\nand \u003ccode\u003esqleibniz::types::config::Hook\u003c/code\u003e to implement \u003ccode\u003eFromLua\u003c/code\u003e too:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eRule\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    NoContent,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e    NoStatements,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e    Unimplemented,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    UnknownKeyword,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e    BadSqleibnizInstruction,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e    UnterminatedString,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e    UnknownCharacter,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e    InvalidNumericLiteral,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e    InvalidBlob,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e    Syntax,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e    Semicolon,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimpl\u003c/span\u003e mlua::FromLua \u003cspan\u003efor\u003c/span\u003e Rule {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003efrom_lua\u003c/span\u003e(value: \u003cspan\u003emlua\u003c/span\u003e::Value, lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emlua\u003c/span\u003e::Lua) -\u0026gt; \u003cspan\u003emlua\u003c/span\u003e::\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eSelf\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e value: \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e lua.unpack(value)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e18\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eOk\u003c/span\u003e(\u003cspan\u003ematch\u003c/span\u003e value.as_str() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e19\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;NoContent\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::NoContent,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;NoStatements\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::NoStatements,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e21\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;Unimplemented\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::Unimplemented,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e22\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;UnterminatedString\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::UnterminatedString,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e23\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;UnknownCharacter\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::UnknownCharacter,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;InvalidNumericLiteral\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::InvalidNumericLiteral,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e25\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;InvalidBlob\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::InvalidBlob,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e26\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;Syntax\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::Syntax,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e27\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;Semicolon\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::Semicolon,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e28\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;BadSqleibnizInstruction\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::BadSqleibnizInstruction,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e29\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;UnknownKeyword\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e Self::UnknownKeyword,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e30\u003c/span\u003e\u003cspan\u003e            _ \u003cspan\u003e=\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e31\u003c/span\u003e\u003cspan\u003e                \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eErr\u003c/span\u003e(mlua::Error::FromLuaConversionError {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e                    from: \u003cspan\u003e\u0026#34;string\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e33\u003c/span\u003e\u003cspan\u003e                    to: \u003cspan\u003e\u0026#34;sqleibniz::rules::Rule\u0026#34;\u003c/span\u003e.into(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e34\u003c/span\u003e\u003cspan\u003e                    message: \u003cspan\u003eSome\u003c/span\u003e(\u003cspan\u003e\u0026#34;Unknown rule name\u0026#34;\u003c/span\u003e.into()),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e                })\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e36\u003c/span\u003e\u003cspan\u003e            }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e37\u003c/span\u003e\u003cspan\u003e        })\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e38\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e39\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe same for \u003ccode\u003eHookContext\u003c/code\u003e, but a lot shorter:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eHook\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e name: \u003cspan\u003eString\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e/// node is optional, because omitting it executes the hook for every encountered node\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003epub\u003c/span\u003e node: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e hook: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eFunction\u003cspan\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimpl\u003c/span\u003e mlua::FromLua \u003cspan\u003efor\u003c/span\u003e Hook {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003efrom_lua\u003c/span\u003e(value: \u003cspan\u003emlua\u003c/span\u003e::Value, lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emlua\u003c/span\u003e::Lua) -\u0026gt; \u003cspan\u003emlua\u003c/span\u003e::\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eSelf\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e table: \u003cspan\u003eTable\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e lua.unpack(value)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e name \u003cspan\u003e=\u003c/span\u003e table.get(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e node \u003cspan\u003e=\u003c/span\u003e table.get(\u003cspan\u003e\u0026#34;node\u0026#34;\u003c/span\u003e).ok();\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e hook: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eFunction\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e table.get(\u003cspan\u003e\u0026#34;hook\u0026#34;\u003c/span\u003e).ok();\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eOk\u003c/span\u003e(Self { name, node, hook })\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"calling-lua-functions-from-rust\"\u003eCalling Lua functions from Rust\u003c/h2\u003e\u003cp\u003eSince we now have the ability to convert a lua value to a \u003ccode\u003emlua::Function\u003c/code\u003e, we\ncan call said function and provide the context it needs as its argument(s):\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimpl\u003c/span\u003e Hook {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eexec\u003c/span\u003e(\u003cspan\u003e\u0026amp;\u003c/span\u003eself, arg: \u003cspan\u003eHookContext\u003c/span\u003e) -\u0026gt; \u003cspan\u003emlua\u003c/span\u003e::\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e()\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eSome\u003c/span\u003e(hook) \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003eself.hook {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e            hook.call(arg)\u003cspan\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e6\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eOk\u003c/span\u003e(())\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e7\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe \u003ccode\u003esqleibniz::types::ctx::HookContext\u003c/code\u003e represents the context I want every hook to have, specifically:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eHookContext\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e/// [Self::kind] will be the name of the node for most nodes, except nodes\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e/// that hold different kinds, such as Literal, which can be an Ident, a\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e/// String, a Number, etc.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003epub\u003c/span\u003e kind: \u003cspan\u003eString\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e/// [Self::content] holds the textual representation of a nodes contents if\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e/// it is [crates::parser::nodes::Literal].\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003epub\u003c/span\u003e content: \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003epub\u003c/span\u003e children: \u003cspan\u003eVec\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eHookContext\u003cspan\u003e\u0026gt;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDue to us passing this structure to \u003ccode\u003eHook::exec\u003c/code\u003e and therefore to\n\u003ccode\u003emlua::Function::call\u003c/code\u003e it has to implement the \u003ccode\u003eIntoLua\u003c/code\u003e trait:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimpl\u003c/span\u003e IntoLua \u003cspan\u003efor\u003c/span\u003e HookContext {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003einto_lua\u003c/span\u003e(self, lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emlua\u003c/span\u003e::Lua) -\u0026gt; \u003cspan\u003emlua\u003c/span\u003e::\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003emlua::Value\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e table \u003cspan\u003e=\u003c/span\u003e lua.create_table()\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e        table.set(\u003cspan\u003e\u0026#34;kind\u0026#34;\u003c/span\u003e, self.kind)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e        table.set(\u003cspan\u003e\u0026#34;text\u0026#34;\u003c/span\u003e, self.content.unwrap_or_else(\u003cspan\u003e||\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e::new()))\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e6\u003c/span\u003e\u003cspan\u003e        table.set(\u003cspan\u003e\u0026#34;children\u0026#34;\u003c/span\u003e, self.children)\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e7\u003c/span\u003e\u003cspan\u003e        lua.pack(table)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e9\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"putting-it-all-together\"\u003ePutting it all together\u003c/h2\u003e\u003cp\u003eInside of the lua scripting context, we now are able to access all of these fields:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"lua\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003eleibniz \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    hooks \u003cspan\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e        {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e            name \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;hook test\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e            hook \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e(node)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e                print(node.kind \u003cspan\u003e..\u003c/span\u003e \u003cspan\u003e\u0026#34; \u0026#34;\u003c/span\u003e \u003cspan\u003e..\u003c/span\u003e node.text \u003cspan\u003e..\u003c/span\u003e \u003cspan\u003e\u0026#34; \u0026#34;\u003c/span\u003e \u003cspan\u003e..\u003c/span\u003e \u003cspan\u003e#\u003c/span\u003enode.children)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003eend\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eExecuting this hook with the \u003ccode\u003eHookContext\u003c/code\u003e ends in the\nexpected result: \u003ccode\u003eliteral this_is_an_ident 0\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe following shows the full example I use for sqleibniz:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e\u003cspan\u003e 1\u003c/span\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003econfiguration\u003c/span\u003e(lua: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emlua\u003c/span\u003e::Lua, file_name: \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e) -\u0026gt; \u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eConfig, \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e conf_str \u003cspan\u003e=\u003c/span\u003e fs::read_to_string(file_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 3\u003c/span\u003e\u003cspan\u003e        .map_err(\u003cspan\u003e|\u003c/span\u003eerr\u003cspan\u003e|\u003c/span\u003e format!(\u003cspan\u003e\u0026#34;Failed to read configuration file \u0026#39;\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e\u0026#39;: \u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e, file_name, err))\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 4\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 5\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e// load the lua configuration string, execute it\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 6\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    lua.load(conf_str)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 7\u003c/span\u003e\u003cspan\u003e        .set_name(file_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e        .exec()\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e 9\u003c/span\u003e\u003cspan\u003e        .map_err(\u003cspan\u003e|\u003c/span\u003eerr\u003cspan\u003e|\u003c/span\u003e format!(\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e, file_name, err))\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e globals \u003cspan\u003e=\u003c/span\u003e lua.globals();\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e11\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e raw_conf \u003cspan\u003e=\u003c/span\u003e globals\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e13\u003c/span\u003e\u003cspan\u003e        .get::\u003cspan\u003e\u0026lt;\u003c/span\u003emlua::Value\u003cspan\u003e\u0026gt;\u003c/span\u003e(\u003cspan\u003e\u0026#34;leibniz\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e14\u003c/span\u003e\u003cspan\u003e        .map_err(\u003cspan\u003e|\u003c/span\u003eerr\u003cspan\u003e|\u003c/span\u003e format!(\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e, file_name, err))\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e15\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e// if the leibniz table does not exist, mlua does not return an Err, we\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e16\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// have to check for this case\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003eif\u003c/span\u003e raw_conf.is_nil() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e18\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eErr\u003c/span\u003e(format!(\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e19\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e: leibniz table is missing from configuration\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e            file_name\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e21\u003c/span\u003e\u003cspan\u003e        ));\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e22\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e23\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e conf: \u003cspan\u003eConfig\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e lua\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e25\u003c/span\u003e\u003cspan\u003e         \u003cspan\u003e// calls mlua::FromLua(conf)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e26\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e        .unpack(raw_conf)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e27\u003c/span\u003e\u003cspan\u003e        .map_err(\u003cspan\u003e|\u003c/span\u003eerr\u003cspan\u003e|\u003c/span\u003e format!(\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e, file_name, err))\u003cspan\u003e?\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e28\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eOk\u003c/span\u003e(conf)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e29\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e30\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e31\u003c/span\u003e\u003cspan\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emut\u003c/span\u003e config \u003cspan\u003e=\u003c/span\u003e Config {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e33\u003c/span\u003e\u003cspan\u003e        disabled_rules: \u003cspan\u003evec\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e[],\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e34\u003c/span\u003e\u003cspan\u003e        hooks: \u003cspan\u003eNone\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e35\u003c/span\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e36\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e37\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003e// lua defined here because it would be dropped at the end of configuration(), in the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e38\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003e// future this will probably need to be moved one scope up to life long enough for analysis\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e39\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e    \u003cspan\u003elet\u003c/span\u003e lua \u003cspan\u003e=\u003c/span\u003e mlua::Lua::new();\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003ematch\u003c/span\u003e configuration(\u003cspan\u003e\u0026amp;\u003c/span\u003elua, \u003cspan\u003e\u0026amp;\u003c/span\u003eargs.config) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e41\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eOk\u003c/span\u003e(conf) \u003cspan\u003e=\u0026gt;\u003c/span\u003e config \u003cspan\u003e=\u003c/span\u003e conf,\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eErr\u003c/span\u003e(err) \u003cspan\u003e=\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e43\u003c/span\u003e\u003cspan\u003e            error::warn(\u003cspan\u003e\u0026amp;\u003c/span\u003eerr.to_string());\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e44\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e45\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e46\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e47\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eSome\u003c/span\u003e(hooks) \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003econfig.hooks {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e48\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003elet\u003c/span\u003e ctx \u003cspan\u003e=\u003c/span\u003e types::ctx::HookContext {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e49\u003c/span\u003e\u003cspan\u003e            kind: \u003cspan\u003e\u0026#34;literal\u0026#34;\u003c/span\u003e.into(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e50\u003c/span\u003e\u003cspan\u003e            content: \u003cspan\u003eSome\u003c/span\u003e(\u003cspan\u003e\u0026#34;this_is_an_ident\u0026#34;\u003c/span\u003e.into()),\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e51\u003c/span\u003e\u003cspan\u003e            children: \u003cspan\u003evec\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e[],\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e52\u003c/span\u003e\u003cspan\u003e        };\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e53\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e54\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003efor\u003c/span\u003e hook \u003cspan\u003ein\u003c/span\u003e hooks {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e55\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003elet\u003c/span\u003e _ \u003cspan\u003e=\u003c/span\u003e hook.exec(ctx.clone());\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e56\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e57\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e58\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf the configuration has invalid syntax or the \u003ccode\u003eleibniz\u003c/code\u003e table is missing, a\nwarning is omitted and sqleibniz falls back to the default empty configuration:\u003c/p\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e\u003cspan\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003ewarn: leibniz.lua: syntax error: [string \u0026#34;leibniz.lua\u0026#34;]:6: \u0026#39;}\u0026#39; expected (to close \u0026#39;{\u0026#39; at line 4) near \u0026#39;bled_rules\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003ewarn: leibniz.lua: leibniz table is missing from configuration\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2024-12-16T11:12:45+01:00",
  "modifiedTime": null
}
