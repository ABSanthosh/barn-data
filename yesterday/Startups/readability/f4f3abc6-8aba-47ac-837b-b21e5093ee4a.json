{
  "id": "f4f3abc6-8aba-47ac-837b-b21e5093ee4a",
  "title": "You could have invented Fenwick trees",
  "link": "https://www.cambridge.org/core/journals/journal-of-functional-programming/article/you-could-have-invented-fenwick-trees/B4628279D4E54229CED97249E96F721D",
  "description": "Article URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/you-could-have-invented-fenwick-trees/B4628279D4E54229CED97249E96F721D Comments URL: https://news.ycombinator.com/item?id=42818248 Points: 3 # Comments: 0",
  "author": "matt_d",
  "published": "Sat, 25 Jan 2025 00:23:34 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "BRENT YORGEY (a1)",
  "length": 42753,
  "excerpt": "You could have invented Fenwick trees - Volume 35",
  "siteName": "Cambridge Core",
  "favicon": "",
  "text": "1 Introduction Suppose we have a sequence of n integers $a_1, a_2, \\ldots, a_n$ and want to be able to perform arbitrary interleavings of the following two operations, as illustrated in Figure 1 : Fig. 1 Update and range query operations. • Update the value at any given indexFootnote 1 i by adding some value v. • Find the sum of all values in any given range $[i,\\ j]$ , that is, $a_i + a_{i+1} + \\ldots + a_j$ . We call this operation a range query. Note that update is phrased in terms of adding some value v to the existing value; we can also set a given index to a new value v by adding $v - u$ , where u is the old value. If we simply store the integers in a mutable array, then we can update in constant time, but range queries require time linear in the size of the range, since we must iterate through the entire range $[i,\\ j]$ to add up the values. In order to improve the running time of range queries, we could try to cache (at least some of) the range sums. However, this must be done with care, since the cached sums must be kept up to date when updating the value at an index. For example, a straightforward approach would be to use an array P where $P_i$ stores the prefix sum $a_1 + \\ldots + a_i$ ; P can be precomputed in linear time via a scan. Now range queries are fast: we can obtain $a_i + \\ldots + a_j$ in constant time by computing $P_j - P_{i-1}$ (for convenience we set $P_0 = 0$ so this works even when $i=1$ ). Unfortunately, it is update that now takes linear time, since changing $a_i$ requires updating $P_j$ for every $j {\\geqslant} i$ . Is it possible to design a data structure that allows both operations to run in sublinear time? (You may wish to pause and think about it before reading the next paragraph!) This is not just academic: the problem was originally considered in the context of arithmetic coding (Rissanen \u0026 Langdon, Reference Rissanen and Langdon1979; Bird \u0026 Gibbons, Reference Bird and Gibbons2002), a family of techniques for turning messages into sequences of bits for storage or transmission. In order to minimize the bits required, one generally wants to assign shorter bit sequences to more frequent characters, and vice versa; this leads to the need to maintain a dynamic table of character frequencies. We update the table every time a new character is processed and query the table for cumulative frequencies in order to subdivide a unit interval into consecutive segments proportional to the frequency of each character (Ryabko, Reference Ryabko1989; Fenwick, Reference Fenwick1994). So, can we get both operations to run in sublinear time? The answer, of course, is yes. One simple technique is to divide the sequence into $\\sqrt n$ buckets, each of size $\\sqrt n$ , and create an additional array of size $\\sqrt n$ to cache the sum of each bucket. Updates still run in O(1), since we simply have to update the value at the given index and the corresponding bucket sum. Range queries now run in $O(\\sqrt n)$ time: to find the sum $a_i + \\ldots + a_j$ , we manually add the values from $a_i$ to the end of its bucket, and from $a_j$ to the beginning of its bucket; for all the buckets in between we can just look up their sum. We can make range queries even faster, at the cost of making updates slightly slower, by introducing additional levels of caching. For example, we can divide the sequence into $\\sqrt[3] n$ “big buckets” and then further subdivide each big bucket into $\\sqrt[3] n$ “small buckets”, with each small bucket holding $\\sqrt[3] n$ values. The sum of each bucket is cached; now each update requires modifying three values, and range queries run in $O(\\sqrt[3] n)$ time. In the limit, we end up with a binary divide-and-conquer approach to caching range sums, with both update and range query taking $O(\\lg n)$ time. In particular, we can make a balanced binary tree where the leaves store the sequence itself, and every internal node stores the sum of its children. (This will be a familiar idea to many functional programmers; for example, finger trees (Hinze \u0026 Paterson, Reference Hinze and Paterson2006; Apfelmus, Reference Apfelmus2009) use a similar sort of caching scheme.) The resulting data structure is popularly known as a segment tree,Footnote 2 presumably because each internal node ultimately caches the sum of a (contiguous) segment of the underlying sequence. Figure 2 shows a segment tree built on a sample array of length $n=16$ (for simplicity, we will assume that n is a power of two, although it is easy to generalize to situations where it is not). Each leaf of the tree corresponds to an array entry; each internal node is drawn with a grey bar showing the segment of the underlying array of which it is the sum. Let’s see how we can use a segment tree to implement the two required operations so that they run in logarithmic time. • To update the value at index i, we also need to update any cached range sums which include it. These are exactly the nodes along the path from the leaf at index i to the root of the tree; there are $O(\\lg n)$ such nodes. Figure 3 illustrates this update process for the example segment tree from Figure 2; updating the entry at index 5 requires modifying only the shaded nodes along the path from the root to the updated entry. • To perform a range query, we descend through the tree while keeping track of the range covered by the current node. - If the range of the current node is wholly contained within the query range, return the value of the current node. - If the range of the current node is disjoint from the query range, return 0. - Otherwise, recursively query both children and return the sum of the results. Figure 4 illustrates the process of computing the sum of the range $[4 \\ldots 11]$ . Blue nodes are the ones we recurse through; green nodes are those whose range is wholly contained in the query range and are returned without recursing further; grey nodes are disjoint from the query range and return zero. The final result in this example is the sum of values at the green nodes, $1 + 1 + 5 + -2 = 5$ (it is easily verified that this is in fact the sum of values in the range $[4 \\ldots 11]$ ). Fig. 3 Updating a segment tree. Fig. 4 Performing a range query on a segment tree. On this small example tree, it may seem that we visit a significant fraction of the total nodes, but in general, we visit no more than about $4 \\lg n$ . Figure 5 makes this more clear. Only one blue node in the entire tree can have two blue children, and hence, each level of the tree can contain at most two blue nodes and two non-blue nodes. We essentially perform two binary searches, one to find each endpoint of the query range. Fig. 5 Performing a range query on a larger segment tree. Segment trees are a very nice solution to the problem: as we will see in Section 2, they fit well in a functional language; they also lend themselves to powerful generalizations such as lazily propagated range updates and persistent update history via shared immutable structure (Reference IvanovIvanov, 2011b ). Fenwick trees, or binary indexed trees (Fenwick, Reference Fenwick1994; Reference IvanovIvanov, 2011a ), are an alternative solution to the problem. What they lack in generality, they make up for with an extremely small memory footprint—they require literally nothing more than an array storing the values in the tree—and a blazing fast implementation. In other words, they are perfect for applications such as low-level coding/decoding routines where we don’t need any of the advanced features that segment trees offer, and want to squeeze out every last bit of performance. Figure 6 shows a typical implementation of Fenwick trees in Java. As you can see, the implementation is incredibly concise and consists mostly of some small loops doing just a few arithmetic and bit operations per iteration. It is not at all clear what this code is doing, or how it works! Upon closer inspection, the range, get, and set functions are straightforward, but the other functions are a puzzle. We can see that both the prefix and update functions call another function LSB, which for some reason performs a bitwise logical AND of an integer and its negation. In fact, LSB(x) computes the least significant bit of x, that is, it returns the smallest $2^k$ such that the kth bit of x is a one. However, it is not obvious how the implementation of LSB works, nor how and why least significant bits are being used to compute updates and prefix sums. Fig. 6 Implementing Fenwick trees with bit tricks. Our goal is not to write elegant functional code for this—already solved!—problem. Rather, our goal will be to use a functional domain-specific language for bit strings, along with equational reasoning, to derive and explain this baffling imperative code from first principles—a demonstration of the power of functional thinking and equational reasoning to understand code written even in other, non-functional languages. After developing more intuition for segment trees (Section 2), we will see how Fenwick trees can be viewed as a variant on segment trees (Section 3). We will then take a detour into two’s complement binary encoding, develop a suitable DSL for bit manipulations, and explain the implementation of the LSB function (Section 4). Armed with the DSL, we will then derive functions for converting back and forth between Fenwick trees and standard binary trees (Section 5). Finally, we will be able to derive functions for moving within a Fenwick tree by converting to binary tree indices, doing the obvious operations to effect the desired motion within the binary tree, and then converting back. Fusing away the conversions via equational reasoning will finally reveal the hidden LSB function, as expected (Section 6). This paper was produced from a literate Haskell document; the source is available from GitHub, at https://github.com/byorgey/fenwick/blob/master/Fenwick.lhs. 2 Segment trees Figure 7 exhibits a simple implementation of a segment tree in Haskell, using some utilities for working with index ranges shown in Figure 8. We store a segment tree as a recursive algebraic data type and implement update and rq using code that directly corresponds to the recursive descriptions given in the previous section; get and set can then also be implemented in terms of them. It is not hard to generalize this code to work for segment trees storing values from either an arbitrary commutative monoid if we don’t need the set operation—or from an arbitrary Abelian group (i.e. commutative monoid with inverses) if we do need set—but we keep things simple since the generalization doesn’t add anything to our story. Fig. 7 Simple segment tree implementation in Haskell. Although this implementation is simple and relatively straightforward to understand, compared to simply storing the sequence of values in an array, it incurs a good deal of overhead. We can be more clever in our use of space by storing all the nodes of a segment tree in an array, using the standard left-to-right breadth-first indexing scheme illustrated in Figure 9 (for example, this scheme, or something like it, is commonly used to implement binary heaps). The root has label 1; every time we descend one level we append an extra bit: 0 when we descend to the left child and 1 when we descend to the right. Thus, the index of each node expressed in binary records the sequence of left-right choices along the path to that node from the root. Going from a node to its children is as simple as doing a left bit shift and optionally adding 1; going from a node to its parent is a right bit shift. This defines a bijection from the positive natural numbers to the nodes of an infinite binary tree. If we label the segment tree array with $s_1 \\ldots s_{2n-1}$ , then $s_1$ stores the sum of all the $a_i$ , $s_2$ stores the sum of the first half of the $a_i$ , $s_3$ stores the sum of the second half, and so on. $a_1 \\ldots a_n$ themselves are stored as $s_n \\ldots s_{2n-1}$ . Fig. 9 Indexing a binary tree. The important point is that since descending recursively through the tree corresponds to simple operations on indices, all the algorithms we have discussed can be straightforwardly transformed into code that works with a (mutable) array: for example, instead of storing a reference to the current subtree, we store an integer index; every time we want to descend to the left or right, we simply double the current index or double and add one, and so on. Working with tree nodes stored in an array presents an additional opportunity: rather than being forced to start at the root and recurse downwards, we can start at a particular index of interest and move up the tree instead. So how do we get from segment trees to Fenwick trees? We start with an innocuous-seeming observation: not all the values stored in a segment tree are necessary. Of course, all the non-leaf nodes are “unnecessary” in the sense that they represent cached range sums which could easily be recomputed from the original sequence. That’s the whole point: caching these “redundant” sums trades off space for time, allowing us to perform arbitrary updates and range queries quickly, at the cost of doubling the required storage space. But that’s not what I mean! In fact, there is a different set of values we can forget about, but in such a way that we still retain the logarithmic running time for updates and range queries. Which values, you ask? Simple: just forget the data stored in every node which is a right child. Figure 10 shows the same example tree we have been using, but with the data deleted from every right child. Note that “every right child” includes both leaves and internal nodes: we forget the data associated to every node which is the right child of its parent. We will refer to the nodes with discarded data as inactive and the remaining nodes (that is, left children and the root) as active. We also say that a tree with all its right children inactivated in this way has been thinned. Fig. 10 Inactivating all right children in a segment tree. Updating a thinned segment tree is easy: just update the same nodes as before, ignoring any updates to inactive nodes. But how do we answer range queries? It’s not too hard to see that there is enough information remaining to reconstruct the information that was discarded (you might like to try convincing yourself of this: can you deduce what values must go in the greyed-out nodes in Figure 10, without peeking at any previous figures?). However, in and of itself, this observation does not give us a nice algorithm for computing range sums. It turns out the key is to think about prefix sums. As we saw in the introduction and the implementation of range in Figure 6, if we can compute the prefix sum $P_k = a_1 + \\ldots + a_k$ for any k, then we can compute the range sum $a_i + \\ldots + a_j$ as $P_j - P_{i-1}$ . Theorem 1 Given a thinned segment tree, the sum of any prefix of the original array (and hence also any range sum) can be computed, in logarithmic time, using only the values of active nodes. Proof Surprisingly, in the special case of prefix queries, the original range query algorithm described in Section 1 and implemented in Figure 7 works unchanged! That is to say, the base case in which the range of the current node is wholly contained within the query range—and we thus return the value of the current node—will only ever happen at active nodes. First, the root itself is active, and hence, querying the full range will work. Next, consider the case where we are at a node and recurse on both children. The left child is always active, so we only need to consider the case where we recurse to the right. It is impossible that the range of the right child will be wholly contained in the query range: since the query range is always a prefix of the form $[1,\\ j]$ , if the right child’s range is wholly contained in $[1,\\ j]$ then the left child’s range must be as well—which means that the parent node’s range (which is the union of its children’s ranges) would also be wholly contained in the query range. But in that case we would simply return the parent’s value without recursing into the right child. Thus, when we do recurse into a right child, we might end up returning 0, or we might recurse further into both grandchildren, but in any case we will never try to look at the value of the right child itself. Figure 11 illustrates performing a prefix query on a segment tree. Notice that visited right children are only ever blue or grey; the only green nodes are left children. Fig. 11 Performing a prefix query on a segment tree. 3 Fenwick trees How should we actually store a thinned segment tree in memory? If we stare at Figure 10 again, one strategy suggests itself: simply take every active node and “slide” it down and to the right until it lands in an empty slot in the underlying array, as illustrated in Figure 12. This sets up a one-to-one correspondence between active nodes and indices in the range $1 \\ldots n$ . Another way to understand this indexing scheme is to use a postorder traversal of the tree, skipping over inactive nodes and giving consecutive indices to active nodes encountered during the traversal. We can also visualize the result by drawing the tree in a “right-leaning” style (Figure 13), vertically aligning each active node with the array slot where it is stored. Fig. 12 Sliding active values down a thinned segment tree. Fig. 13 Right-leaning drawing of a thinned segment tree, vertically aligning nodes with their storage location. This method of storing the active nodes from a thinned segment tree in an array is precisely a Fenwick tree. I will also sometimes refer to it as a Fenwick array, when I want to particularly emphasize the underlying array data structure. Although it is certainly a clever use of space, the big question is how to implement the update and range query operations. Our implementations of these operations for segment trees worked by recursively descending through the tree, either directly if the tree is stored as a recursive data structure, or using simple operations on indices if the tree is stored in an array. However, when storing the active nodes of a thinned tree in a Fenwick array, it is not a priori obvious what operations on array indices will correspond to moving around the tree. In order to attack this problem, we first take a detour through a domain-specific language for two’s complement binary values. 4 Two’s complement binary The bit tricks usually employed to implement Fenwick trees rely on a two’s complement representation of binary numbers, which allow positive and negative numbers to be represented in a uniform way; for example, a value consisting of all 1 bits represents $-1$ . We therefore turn now to developing a domain-specific language, embedded in Haskell, for manipulating two’s complement binary representations. First, we define a type of bits, with functions for inversion, logical conjunction, and logical disjunction: Next, we must define bit strings, i.e. sequences of bits. Rather than fix a specific bit width, it will be much more elegant to work with infinite bit strings.Footnote 3 It is tempting to use standard Haskell lists to represent potentially infinite bit strings, but this leads to a number of problems. For example, equality of infinite lists is not decidable, and there is no way in general to convert from an infinite list of bits back to an Integer—how would we know when to stop? In fact, these practical problems stem from a more fundamental one: infinite lists of bits are actually a bad representation for two’s complement bit strings, because of “junk”, that is, infinite lists of bits which do not correspond to values in our intended semantic domain. For example, cycle [I,O] is an infinite list which alternates between I and O forever, but it does not represent a valid two’s complement encoding of an integer. Even worse are non-periodic lists, such as the one with I at every prime index and O everywhere else. In fact, the bit strings we want are the eventually constant ones, that is, strings which eventually settle down to an infinite tail of all zeros (which represent nonnegative integers) or all ones (which represent negative integers). Every such string has a finite representation, so directly encoding eventually constant bit strings in Haskell not only gets rid of the junk but also leads to elegant, terminating algorithms for working with them. Rep b represents an infinite sequence of bit b, whereas Snoc bs b represents the bit string bs followed by a final bit b. We use Snoc, rather than Cons, to match the way we usually write bit strings, with the least significant bit last. Note also the use of a strictness annotation on the Bits field of Snoc; this is to rule out infinite lists of bits using only Snoc, such as bs=Snoc (Snoc bs O) I. In other words, the only way to make a non-bottom value of type Bits is to have a finite sequence of Snoc finally terminated by Rep. Although we have eliminated junk values, one remaining problem is that there can be multiple distinct representations of the same value. For example, Snoc (Rep O) O and Rep O both represent the infinite bit string containing all zeros. However, we can solve this with a carefully constructed bidirectional pattern synonym (Pickering et al., Reference Pickering, Érdi, Peyton Jones and Eisenberg2016). Matching with the pattern ${({bs}\\mathrel{:\\!.}{b})}$ uses a view pattern (Erwig \u0026 Jones, Reference Erwig and Jones2001) to potentially expand a Rep one step into a Snoc, so that we can pretend Bits values are always constructed with ${(\\mathrel{:\\!.})}$ . Conversely, constructing a Bits with ${(\\mathrel{:\\!.})}$ will do nothing if we happen to snoc an identical bit b onto an existing ${{Rep}\\;{b}}$ . This ensures that as long as we stick to using ${(\\mathrel{:\\!.})}$ and never directly use Snoc, Bits values will always be normalized so that the terminal ${{Rep}\\;{b}}$ is immediately followed by a different bit. Finally, we mark the pattern ${(\\mathrel{:\\!.})}$ as COMPLETE on its own, since matching on ${(\\mathrel{:\\!.})}$ is indeed sufficient to handle every possible input of type Bits. However, in order to obtain terminating algorithms we will often include one or more special cases for Rep. Let’s begin with some functions for converting Bits to and from Integer and for displaying Bits (intended only for testing). Let’s try it out, using QuickCheck (Claessen \u0026 Hughes, Reference Claessen and Hughes2000) to verify our conversion functions: We can now begin implementing some basic operations on Bits. First, incrementing and decrementing can be implemented recursively as follows: The least significant bit, or LSB, of a sequence of bits can be defined as follows: Note that we add a special case for ${{Rep}\\;{O}}$ to ensure that lsb is total. Technically, ${{Rep}\\;{O}}$ does not have a least significant bit, so defining ${{lsb}\\;({Rep}\\;{O})\\mathrel{=}{Rep}\\;{O}}$ seems sensible. Bitwise logical conjunction can be defined straightforwardly. Note that we only need two cases; if the finite parts of the inputs have different lengths, matching with ${(\\mathrel{:\\!.})}$ will automatically expand the shorter one to match the longer one. Bitwise inversion is likewise straightforward. The above functions follow familiar patterns. We could easily generalize to eventually constant streams over an arbitrary element type and then implement in terms of a generic zipWith and inv in terms of map. However, for the present purpose we do not need the extra generality. We implement addition with the usual carry-propagation algorithm, along with some special cases for Rep. It is not too hard to convince ourselves that this definition of addition is terminating and yields correct results; but we can also be fairly confident by just trying it with QuickCheck: Finally, the following definition of negation is probably familiar to anyone who has studied two’s complement arithmetic; I leave it as an exercise for the interested reader to prove that ${{x}\\oplus{neg}\\;{x}\\equiv {Rep}\\;{O}}$ for all ${{x}\\mathbin{::}{Bits}}$ . We now have the tools to resolve the first mystery of the Fenwick tree implementation. Theorem 4.1 For all ${{x}\\mathbin{::}{Bits}}$ , Proof. By induction on x. • First, if ${{x}\\mathrel{=}{Rep}\\;{O}}$ , it is an easy calculation to verify that . • Likewise, if ${{x}\\mathrel{=}{Rep}\\;{I}}$ , both ${{lsb}\\;{x}}$ and reduce to ${{Rep}\\;{O}\\mathrel{:\\!.}{I}}$ . • If ${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{O}}$ , then ${{lsb}\\;{x}\\mathrel{=}{lsb}\\;({xs}\\mathrel{:\\!.}{O})\\mathrel{=}{lsb}\\;{xs}\\mathrel{:\\!.}{O}}$ by definition, whereas • Next, if ${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{I}}$ , then ${{lsb}\\;({xs}\\mathrel{:\\!.}{I})\\mathrel{=}{Rep}\\;{O}\\mathrel{:\\!.}{I}}$ by definition, whereas For the last equality, we need a lemma that , which should be intuitively clear and can easily be proved by induction as well. Finally, in order to express the index conversion functions we will develop in the next section, we need a few more things in our DSL. First, some functions to set and clear individual bits and to test whether particular bits are set: The only other things we will need are left and right shift, and a generic while combinator that iterates a given function, returning the first iterate for which a predicate is false. 5 Index conversion Before deriving our index conversion functions, we must deal with one slightly awkward fact. In a traditional binary tree indexing scheme, as shown in Figure 9, the root has index 1, every left child is twice its parent, and every right child is one more than twice its parent. Recall that in a thinned segment tree, the root node and every left child are active, with all right children being inactive. This makes the root an awkward special case—all active nodes have an even index, except the root, which has index 1. This makes it more difficult to check whether we are at an active node—it is not enough to simply look at the least significant bit. One easy way to fix this is simply to give the root index 2 and then proceed to label the rest of the nodes using the same scheme—every left child is twice its parent, and every right child is one more than twice its parent. This results in the indexing shown in Figure 14, as if we had just taken the left subtree of the tree rooted at 1, and ignored the right subtree. Of course, this means about half the possible indices are omitted—but that’s not a problem, since we will only use these indices as an intermediate step which will eventually get fused away. Fig. 14 Indexing a binary tree with 2 at the root. Figure 15 shows a binary tree where nodes have been numbered in two different ways: the left side of each node shows the node’s binary tree index (with the root having index 2). The right side of each node shows its index in the Fenwick array, if it has one (inactive nodes simply have their right half greyed out). The table underneath shows the mapping from Fenwick array indices (top row) to binary tree indices (bottom row). As a larger example, Figure 16 shows the same thing on a binary tree one level deeper. Fig. 15 Binary tree labelled with both binary and Fenwick indexing. Fig. 16 Binary tree labelled with both binary and Fenwick indexing. Our goal is to come up with a way to calculate the binary index for a given Fenwick index or vice versa. Staring at the table in Figure 16, a few patterns stand out. Of course, all the numbers in the bottom row are even, which is precisely because the binary tree is numbered in such a way that all active nodes have an even index. Second, we can see the even numbers $32, 34 \\ldots 46$ , in order, in all the odd positions. These are exactly the leaves of the tree, and indeed, every other node in the Fenwick array will be a leaf from the original tree. Alternating with these, in the even positions, are the numbers $16\\;\\; 8\\;\\; 18\\;\\; 4 \\ldots$ , which correspond to all the non-leaf nodes; but these are exactly the sequence of binary indices from the bottom row of the table in Figure 15—since the internal nodes in a tree of height 4 themselves constitute a tree of height 3, with the nodes occurring in the same order. These observations lead to the recurrence shown in Figure 17 for the sequence $b_n$ of binary indices for the nodes stored in a Fenwick array of length $2^n$ : $b_0$ is just the singleton sequence [2], and otherwise $b_n$ is the even numbers $2^{n+1}, 2^{n+1} + 2, \\ldots, 2^{n+1} + 2^n - 2$ interleaved with $b_{n-1}$ . Fig. 17 Recurrence for sequence of binary tree indices in a Fenwick array. We can check that this does in fact reproduce the observed sequence for $n = 4$ : Let ${{s}\\text{ ! }{k}}$ denote the kth item in the list s (counting from 1), as defined in Figure 18. The same figure also lists two easy lemmas about the interaction between indexing and interleaving, namely ${({xs}{\\curlyvee}{ys})\\text{ ! }(\\mathrm{2}\\cdot{j})\\mathrel{=}{ys}\\text{ ! }{j}}$ and ${({xs}{\\curlyvee}{ys})\\text{ ! }(\\mathrm{2}\\cdot{j}\\mathbin{-}\\mathrm{1})\\mathrel{=}{xs}\\text{ ! }{j}}$ (as long as xs and ys have equal lengths). With these in hand, we can define the Fenwick to binary index conversion function as \\[ {{f2b}\\;{n}\\;{k}\\mathrel{=}{b}\\;{n}\\text{ ! }{k}}. \\] Of course, since $b_n$ is of length $2^n$ , this function is only defined on the range $[1, 2^n]$ . Fig. 18 Indexing and interleaving. We can now simplify the definition of f2b as follows. First of all, for even inputs, we have And for odd inputs, Thus, we have \\[ {{f2b}\\;{n}\\;{k}} = \\begin{cases} {{f2b}\\;({n}\\mathbin{-}\\mathrm{1})\\;({k}\\mathbin{/}\\mathrm{2})} \u0026 k \\text{ even} \\\\ 2^{n+1} + k - 1 \u0026 k \\text{ odd} \\end{cases} \\] Note that when $n = 0,$ we must have $k = 1$ , and hence, ${{f2b}\\;\\mathrm{0}\\;\\mathrm{1}} = 2^0 + 1 - 1 = 1$ , as required, so this definition is valid for all $n {\\geqslant} 0$ . Now factor k uniquely as $2^a \\cdot b$ where b is odd. Then by induction we can see that \\[ {{f2b}\\;{n}\\;(\\mathrm{2}^ {{a}}\\cdot{b})\\mathrel{=}{f2b}\\;({n}\\mathbin{-}{a})\\;{b}} = 2^{n-a+1} + b - 1. \\] So, in other words, computing f2b consists of repeatedly dividing by 2 (i.e. right bit shifts) as long as the input is even and then finally decrementing and adding a power of 2. However, knowing what power of 2 to add at the end depends on knowing how many times we shifted. A better way to think of it is to add $2^{n+1}$ at the beginning, and then let it be shifted along with everything else. Thus, we have the following definition of f2b’ using our Bits DSL. Defining ${{shift}\\;{n}\\mathrel{=}{while}\\;{even}\\;{shr}\\mathbin{\\circ}{set}\\;{n}}$ separately will make some of our proofs more compact later. For example, we can verify that this produces identical results to ${{f2b}\\;\\mathrm{4}}$ on the range $[1, 2^4]$ (for convenience, we define ${({f}\\mathbin{===}{g})\\;{k}\\mathrel{=}{f}\\;{k}\\equiv {g}\\;{k}}$ ): We now turn to deriving ${{b2f}\\;{n}}$ , which converts back from binary to Fenwick indices. ${{b2f}\\;{n}}$ should be a left inverse to ${{f2b}\\;{n}}$ , that is, for any $k \\in [1, 2^n]$ we should have ${{b2f}\\;{n}\\;({f2b}\\;{n}\\;{k})\\equiv {k}}$ . If k is an input to ${{f2b}}$ , we have $k = 2^a \\cdot b {\\leqslant} 2^n$ , and so $b-1 \u003c 2^{n-a}$ . Hence, given the output ${{f2b}\\;{n}\\;{k}} = m = 2^{n-a+1} + b - 1$ , the highest bit of m is $2^{n-a+1}$ , and the rest of the bits represent $b-1$ . So, in general, given some m which is the output of ${{f2b}\\;{n}}$ , we can write it uniquely as $m = 2^c + d$ where $d \u003c 2^{c-1}$ ; then \\[ {{b2f}\\;{n}\\;(\\mathrm{2}^ {{c}}\\mathbin{+}{d})\\mathrel{=}\\mathrm{2}^ {{n}\\mathbin{-}{c}\\mathbin{+}\\mathrm{1}}\\cdot({d}\\mathbin{+}\\mathrm{1})}. \\] In other words, given the input $2^c + d$ , we subtract off the highest bit $2^c$ , increment, then left shift $n-c+1$ times. Again, though, there is a simpler way: we can increment first (note since $d \u003c 2^{c-1}$ , incrementing cannot disturb the bit at $2^c$ ), then left shift enough times to bring the leftmost bit into position $n+1$ , and finally remove it. That is: Verifying: 6 Deriving Fenwick operations We can now finally derive the required operations on Fenwick array indices for moving through the tree, by starting with operations on a binary indexed tree and conjugating by conversion to and from Fenwick indices. First, in order to fuse away the resulting conversion, we will need a few lemmas. Lemma 6.1 (shr-inc-dec). For all ${{bs}\\mathbin{::}{Bits}}$ which are odd (that is, end with I), • ${({shr}\\mathbin{\\circ}{dec})\\;{bs}\\mathrel{=}{shr}\\;{bs}}$ • ${({shr}\\mathbin{\\circ}{inc})\\;{bs}\\mathrel{=}({inc}\\mathbin{\\circ}{shr})\\;{bs}}$ Proof Both are immediate by definition. Lemma 6.2 (while-inc-dec). The following both hold for all Bits values: • ${{inc}\\mathbin{\\circ}{while}\\;{odd}\\;{shr}\\mathrel{=}{while}\\;{even}\\;{shr}\\mathbin{\\circ}{inc}}$ • ${{dec}\\mathbin{\\circ}{while}\\;{even}\\;{shr}\\mathrel{=}{while}\\;{odd}\\;{shr}\\mathbin{\\circ}{dec}}$ Proof. Easy proof by induction on Bits. For example, for the inc case, the functions on both sides discard consecutive 1 bits and then flip the first 0 bit to a 1. Finally, we will need a lemma about shifting zero bits in and out of the right side of a value. Lemma 6.3 (shl-shr). For all $0 \u003c x \u003c 2^{n+2}$ , \\[ {({while}\\;(not\\mathbin{\\circ}{test}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{shl}\\mathbin{\\circ}{while}\\;{even}\\;{shr})\\;{x}\\mathrel{=}{while}\\;(not\\mathbin{\\circ}{test}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{shl}\\;{x}}. \\] Proof Intuitively, this says that if we first shift out all the zero bits and then left shift until bit $n+1$ is set, we could get the same result by forgetting about the right shifts entirely; shifting out zero bits and then shifting them back in should be the identity. Formally, the proof is by induction on x. If ${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{I}}$ is odd, the equality is immediate since ${{while}\\;{even}\\;{shr}\\;{x}\\mathrel{=}{x}}$ . Otherwise, if ${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{O}}$ , on the left-hand side the O is immediately discarded by shr, whereas on the right-hand side ${{xs}\\mathrel{:\\!.}{O}\\mathrel{=}{shl}\\;{xs}}$ , and the extra shl can be absorbed into the while since ${{xs}} \u003c 2^{n+1}$ . What remains is simply the induction hypothesis. With these lemmas under our belt, let’s see how to move around a Fenwick array in order to implement update and query; we’ll begin with update. When implementing the update operation, we need to start at a leaf and follow the path up to the root, updating all the active nodes along the way. In fact, for any given leaf, its closest active parent is precisely the node stored in the slot that used to correspond to that leaf (see Figure 13). So to update index i, we just need to start at index i in the Fenwick array, and then repeatedly find the closest active parent, updating as we go. Recall that the imperative code for update works this way, apparently finding the closest active parent at each step by adding the LSB of the current index: Let’s see how to derive this behavior. To find the closest active parent of a node under a binary indexing scheme, we first move up to the immediate parent (by dividing the index by two, i.e. performing a right bit shift); then continue moving up to the next immediate parent as long as the current node is a right child (i.e. has an odd index). This yields the definition: This is why we used the slightly strange indexing scheme with the root having index 2—otherwise this definition would not work for any node whose active parent is the root! Now, to derive the corresponding operation on Fenwick indices, we conjugate by conversion to and from Fenwick indices and compute as follows. To make the computation easier to read, the portion being rewritten is underlined at each step. In the final step, since the input x satisfies $x {\\leqslant} 2^n$ , we have ${{inc}\\mathbin{\\circ}{shift}\\;({n}\\mathbin{+}\\mathrm{1})} \u003c 2^{n+2}$ , so Lemma 6.3 applies. Reading from right to left, the pipeline we have just computed performs the following steps: 1. Set bit $n+1$ 2. Shift out consecutive zeros until finding the least significant 1 bit 3. Increment 4. Shift zeros back in to bring the most significant bit back to position $n+1$ , then clear it. Intuitively, this does look a lot like adding the LSB! In general, to find the LSB, one must shift through consecutive 0 bits until finding the first 1; the question is how to keep track of how many 0 bits were shifted on the way. The lsb function itself keeps track via the recursion stack; after finding the first 1 bit, the recursion stack unwinds and re-snocs all the 0 bits recursed through on the way. The above pipeline represents an alternative approach: set bit $n+1$ as a “sentinel” to keep track of how much we have shifted; right shift until the first 1 is literally in the ones place, at which point we increment; and then shift all the 0 bits back in by doing left shifts until the sentinel bit gets back to the $n+1$ place. One example of this process is illustrated in Figure 19. Of course, this only works for values that are sufficiently small that the sentinel bit will not be disturbed throughout the operation. Fig. 19 Adding LSB with a sentinel bit + shifts. To make this more formal, we begin by defining a helper function atLSB, which does an operation “at the LSB”, that is, it shifts out 0 bits until finding a 1, applies the given function, then restores the 0 bits. Lemma 6.4 (add-lsb). For all ${{x}\\mathbin{::}{Bits}}$ , ${{x}\\mathbin{+}{lsb}\\;{x}\\mathrel{=}{atLSB}\\;{inc}\\;{x}}$ and ${{x}\\mathbin{-}{lsb}\\;{x}\\mathrel{=}{atLSB}\\;{dec}\\;{x}}$ . Proof Straightforward induction on x. We can formally relate the “shifting with a sentinel” scheme to the use of atLSB, with the following (admittedly rather technical) lemma:Lemma 6.5 (sentinel). Let $n {\\geqslant} 1$ and let ${{f}\\mathbin{::}{Bits}\\to {Bits}}$ be a function such that 1. ${({f}\\mathbin{\\circ}{set}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{x}\\mathrel{=}({set}\\;({n}\\mathbin{+}\\mathrm{1})\\mathbin{\\circ}{f})\\;{x}}$ for any $0 \u003c x \u003c 2^n$ , and 2. ${{f}\\;{x}} \u003c 2^{n+1}$ for any $0 \u003c x \u003c 2^n + 2^{n-1}$ . Then for all $0 \u003c x \u003c 2^n$ , \\[ {({unshift}\\;({n}\\mathbin{+}\\mathrm{1})\\mathbin{\\circ}{f}\\mathbin{\\circ}{shift}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{x}\\mathrel{=}{atLSB}\\;{f}\\;{x}}. \\] The proof is rather tedious and not all that illuminating, so we omit it (an extended version including a full proof may be found on the author’s website, at http://ozark.hendrix.edu/ yorgey/pub/Fenwick-ext.pdf). However, we do note that both inc and dec fit the criteria for f: incrementing or decrementing some $0 \u003c x \u003c 2^n$ cannot affect the $(n+1)$ st bit as long as $n {\\geqslant} 1$ , and the result of incrementing or decrementing a number less than $2^n + 2^{n-1}$ will be a number less than $2^{n+1}$ . We can now put all the pieces together show that adding the LSB at each step is the correct way to implement update. Theorem 6.6 Adding the LSB is the correct way to move up a Fenwick-indexed tree to the nearest active parent, that is, \\[ {{activeParentFenwick}\\mathrel{=}{b2f'}\\;{n}\\mathbin{\\circ}{activeParentBinary}\\mathbin{\\circ}{f2b'}\\;{n}\\mathrel{=}\\lambda {x}\\to {x}\\mathbin{+}{lsb}\\;{x}} \\] everywhere on the range $[1, 2^n)$ . (We exclude $2^n$ since it corresponds to the root of the tree under a Fenwick indexing scheme.) Proof We can carry out a similar process to derive an implementation for prefix query (which supposedly involves subtracting the LSB). Again, if we want to compute the sum of [1, j], we can start at index j in the Fenwick array, which stores the sum of the unique segment ending at j. If the node at index j stores the segment [i,j], we next need to find the unique node storing a segment that ends at $i-1$ . We can do this repeatedly, adding up segments as we go. Staring at Figure 20 for inspiration, we can see that what we want to do is find the left sibling of our closest inactive parent, that is, we go up until finding the first ancestor which is a right child, then go to its left sibling. Under a binary indexing scheme, this can be implemented simply as: Fig. 20 Moving up a segment tree to find successive prefix segments. Theorem 6.7 Subtracting the LSB is the correct way to move up a Fenwick-indexed tree to the active node covering the segment previous to the current one, that is, \\[ {{prevSegmentFenwick}\\mathrel{=}{b2f'}\\;{n}\\mathbin{\\circ}{prevSegmentBinary}\\mathbin{\\circ}{f2b'}\\;{n}\\mathrel{=}\\lambda {x}\\to {x}\\mathbin{-}{lsb}\\;{x}} \\] everywhere on the range $[1, 2^n)$ . Proof 7 Conclusion Historically, to my knowledge, Fenwick trees were not actually developed as an optimization of segment trees as presented here. This has merely been a fictional—but hopefully illuminating—alternate history of ideas, highlighting the power of functional thinking, domain-specific languages, and equational reasoning to explore relationships between different structures and algorithms. As future work, it would be interesting to explore some of the mentioned generalizations of segment trees, to see whether one can derive Fenwick-like structures that support additional operations.",
  "image": "https://static.cambridge.org/covers/JFP_0_0_0/journal_of functional programming.jpg?send-full-size-image=true",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv data-magellan-destination=\"s1\" id=\"s1\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e1\u003c/span\u003e Introduction\u003c/h2\u003e\n\u003cp\u003e Suppose we have a sequence of \u003cem\u003en\u003c/em\u003e integers \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline1.png?pub-status=live\" width=\"89\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline1.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline1.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_1, a_2, \\ldots, a_n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and want to be able to perform arbitrary interleavings of the following two operations, as illustrated in Figure \u003ca href=\"#f1\"\u003e1\u003c/a\u003e :\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f1\" id=\"f1\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig1.png?pub-status=live\" width=\"1535\" height=\"1239\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig1.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig1.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 1\u003c/span\u003e Update and range query operations.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e \n\u003cem\u003eUpdate\u003c/em\u003e the value at any given index\u003ca href=\"#fn1\"\u003e\u003cspan\u003eFootnote \u003c/span\u003e\n\u003csup\u003e1\u003c/sup\u003e\n\u003c/a\u003e \u003cem\u003ei\u003c/em\u003e by adding some value \u003cem\u003ev\u003c/em\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e Find the sum of all values in any given range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline2.png?pub-status=live\" width=\"31\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline2.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline2.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[i,\\ j]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, that is, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline3.png?pub-status=live\" width=\"130\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline3.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline3.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i + a_{i+1} + \\ldots + a_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. We call this operation a \u003cem\u003erange query\u003c/em\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e Note that update is phrased in terms of \u003cem\u003eadding\u003c/em\u003e some value \u003cem\u003ev\u003c/em\u003e to the existing value; we can also \u003cem\u003eset\u003c/em\u003e a given index to a new value \u003cem\u003ev\u003c/em\u003e by adding \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline4.png?pub-status=live\" width=\"35\" height=\"7\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline4.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline4.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$v - u$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, where \u003cem\u003eu\u003c/em\u003e is the old value.\u003c/p\u003e\n\u003cp\u003e If we simply store the integers in a mutable array, then we can update in constant time, but range queries require time linear in the size of the range, since we must iterate through the entire range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline5.png?pub-status=live\" width=\"30\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline5.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline5.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[i,\\ j]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e to add up the values.\u003c/p\u003e\n\u003cp\u003e In order to improve the running time of range queries, we could try to cache (at least some of) the range sums. However, this must be done with care, since the cached sums must be kept up to date when updating the value at an index. For example, a straightforward approach would be to use an array \u003cem\u003eP\u003c/em\u003e where \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline6.png?pub-status=live\" width=\"15\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline6.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline6.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e stores the prefix sum \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline7.png?pub-status=live\" width=\"86\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline7.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline7.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_1 + \\ldots + a_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e; \u003cem\u003eP\u003c/em\u003e can be precomputed in linear time via a scan. Now range queries are fast: we can obtain \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline8.png?pub-status=live\" width=\"84\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline8.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline8.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i + \\ldots + a_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e in constant time by computing \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9.png?pub-status=live\" width=\"61\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_j - P_{i-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e (for convenience we set \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline10.png?pub-status=live\" width=\"46\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline10.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline10.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_0 = 0$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e so this works even when \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline11.png?pub-status=live\" width=\"31\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline11.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline11.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$i=1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e). Unfortunately, it is update that now takes linear time, since changing \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline12.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline12.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline12.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e requires updating \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline13.png?pub-status=live\" width=\"15\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline13.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline13.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e for every \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline14.png?pub-status=live\" width=\"26\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline14.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline14.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$j {\\geqslant} i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cp\u003e Is it possible to design a data structure that allows \u003cem\u003eboth\u003c/em\u003e operations to run in sublinear time? (You may wish to pause and think about it before reading the next paragraph!) This is not just academic: the problem was originally considered in the context of \u003cem\u003earithmetic coding\u003c/em\u003e (Rissanen \u0026amp; Langdon, \u003ca href=\"#ref11\"\u003e\u003cspan\u003eReference Rissanen and Langdon\u003c/span\u003e1979\u003c/a\u003e; Bird \u0026amp; Gibbons, \u003ca href=\"#ref2\"\u003e\u003cspan\u003eReference Bird and Gibbons\u003c/span\u003e2002\u003c/a\u003e), a family of techniques for turning messages into sequences of bits for storage or transmission. In order to minimize the bits required, one generally wants to assign shorter bit sequences to more frequent characters, and vice versa; this leads to the need to maintain a dynamic table of character frequencies. We \u003cem\u003eupdate\u003c/em\u003e the table every time a new character is processed and \u003cem\u003equery\u003c/em\u003e the table for cumulative frequencies in order to subdivide a unit interval into consecutive segments proportional to the frequency of each character (Ryabko, \u003ca href=\"#ref12\"\u003e\u003cspan\u003eReference Ryabko\u003c/span\u003e1989\u003c/a\u003e; Fenwick, \u003ca href=\"#ref5\"\u003e\u003cspan\u003eReference Fenwick\u003c/span\u003e1994\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003e So, can we get both operations to run in sublinear time? The answer, of course, is yes. One simple technique is to divide the sequence into \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline15.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline15.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline15.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e buckets, each of size \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline16.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline16.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline16.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and create an additional array of size \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline17.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline17.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline17.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e to cache the sum of each bucket. Updates still run in \u003cem\u003eO\u003c/em\u003e(1), since we simply have to update the value at the given index and the corresponding bucket sum. Range queries now run in \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline18.png?pub-status=live\" width=\"45\" height=\"18\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline18.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline18.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$O(\\sqrt n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e time: to find the sum \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline19.png?pub-status=live\" width=\"83\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline19.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline19.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i + \\ldots + a_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, we manually add the values from \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline20.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline20.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline20.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e to the end of its bucket, and from \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline21.png?pub-status=live\" width=\"12\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline21.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline21.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e to the beginning of its bucket; for all the buckets in between we can just look up their sum.\u003c/p\u003e\n\u003cp\u003e We can make range queries even faster, at the cost of making updates slightly slower, by introducing additional levels of caching. For example, we can divide the sequence into \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline22.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline22.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline22.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt[3] n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e “big buckets” and then further subdivide each big bucket into \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline23.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline23.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline23.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt[3] n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e “small buckets”, with each small bucket holding \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline24.png?pub-status=live\" width=\"23\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline24.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline24.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$\\sqrt[3] n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e values. The sum of each bucket is cached; now each update requires modifying three values, and range queries run in \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline25.png?pub-status=live\" width=\"45\" height=\"18\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline25.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline25.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$O(\\sqrt[3] n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e time.\u003c/p\u003e\n\u003cp\u003e In the limit, we end up with a binary divide-and-conquer approach to caching range sums, with both update and range query taking \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline26.png?pub-status=live\" width=\"47\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline26.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline26.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$O(\\lg n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e time. In particular, we can make a balanced binary tree where the leaves store the sequence itself, and every internal node stores the sum of its children. (This will be a familiar idea to many functional programmers; for example, finger trees (Hinze \u0026amp; Paterson, \u003ca href=\"#ref7\"\u003e\u003cspan\u003eReference Hinze and Paterson\u003c/span\u003e2006\u003c/a\u003e; Apfelmus, \u003ca href=\"#ref1\"\u003e\u003cspan\u003eReference Apfelmus\u003c/span\u003e2009\u003c/a\u003e) use a similar sort of caching scheme.) The resulting data structure is popularly known as a \u003cem\u003esegment tree\u003c/em\u003e,\u003ca href=\"#fn2\"\u003e\u003cspan\u003eFootnote \u003c/span\u003e\n\u003csup\u003e2\u003c/sup\u003e\n\u003c/a\u003e presumably because each internal node ultimately caches the sum of a (contiguous) \u003cem\u003esegment\u003c/em\u003e of the underlying sequence. Figure \u003ca href=\"#f2\"\u003e2\u003c/a\u003e shows a segment tree built on a sample array of length \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline27.png?pub-status=live\" width=\"43\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline27.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline27.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n=16$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e (for simplicity, we will assume that \u003cem\u003en\u003c/em\u003e is a power of two, although it is easy to generalize to situations where it is not). Each leaf of the tree corresponds to an array entry; each internal node is drawn with a grey bar showing the segment of the underlying array of which it is the sum.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f2\" id=\"f2\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig2.png?pub-status=live\" width=\"2255\" height=\"1072\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig2.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig2.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Let’s see how we can use a segment tree to implement the two required operations so that they run in logarithmic time.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e To update the value at index \u003cem\u003ei\u003c/em\u003e, we also need to update any cached range sums which include it. These are exactly the nodes along the path from the leaf at index \u003cem\u003ei\u003c/em\u003e to the root of the tree; there are \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline28.png?pub-status=live\" width=\"47\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline28.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline28.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$O(\\lg n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e such nodes. Figure \u003ca href=\"#f3\"\u003e3\u003c/a\u003e illustrates this update process for the example segment tree from Figure \u003ca href=\"#f2\"\u003e2\u003c/a\u003e; updating the entry at index 5 requires modifying only the shaded nodes along the path from the root to the updated entry.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e To perform a range query, we descend through the tree while keeping track of the range covered by the current node.\u003c/p\u003e\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e-\u003c/span\u003e If the range of the current node is wholly contained within the query range, return the value of the current node.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e-\u003c/span\u003e If the range of the current node is disjoint from the query range, return 0.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e-\u003c/span\u003e Otherwise, recursively query both children and return the sum of the results.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e Figure \u003ca href=\"#f4\"\u003e4\u003c/a\u003e illustrates the process of computing the sum of the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline29.png?pub-status=live\" width=\"60\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline29.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline29.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[4 \\ldots 11]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Blue nodes are the ones we recurse through; green nodes are those whose range is wholly contained in the query range and are returned without recursing further; grey nodes are disjoint from the query range and return zero. The final result in this example is the sum of values at the green nodes, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline30.png?pub-status=live\" width=\"131\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline30.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline30.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$1 + 1 + 5 + -2 = 5$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e (it is easily verified that this is in fact the sum of values in the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline31.png?pub-status=live\" width=\"60\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline31.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline31.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[4 \\ldots 11]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e).\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f3\" id=\"f3\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig3.png?pub-status=live\" width=\"2255\" height=\"1072\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig3.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig3.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 3\u003c/span\u003e Updating a segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"f4\" id=\"f4\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig4.png?pub-status=live\" width=\"2256\" height=\"1160\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig4.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig4.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 4\u003c/span\u003e Performing a range query on a segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e On this small example tree, it may seem that we visit a significant fraction of the total nodes, but in general, we visit no more than about \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline32.png?pub-status=live\" width=\"36\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline32.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline32.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$4 \\lg n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Figure \u003ca href=\"#f5\"\u003e5\u003c/a\u003e makes this more clear. Only one blue node in the entire tree can have two blue children, and hence, each level of the tree can contain at most two blue nodes and two non-blue nodes. We essentially perform two binary searches, one to find each endpoint of the query range.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f5\" id=\"f5\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig5.png?pub-status=live\" width=\"3694\" height=\"670\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig5.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig5.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 5\u003c/span\u003e Performing a range query on a larger segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e Segment trees are a very nice solution to the problem: as we will see in Section \u003ca href=\"#s2\"\u003e2\u003c/a\u003e, they fit well in a functional language; they also lend themselves to powerful generalizations such as lazily propagated range updates and persistent update history via shared immutable structure (\u003ca href=\"#ref9\"\u003e\u003cspan\u003eReference Ivanov\u003c/span\u003eIvanov, 2011\u003cem\u003eb\u003c/em\u003e\n\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003e \n\u003cem\u003eFenwick trees\u003c/em\u003e, or \u003cem\u003ebinary indexed trees\u003c/em\u003e (Fenwick, \u003ca href=\"#ref5\"\u003e\u003cspan\u003eReference Fenwick\u003c/span\u003e1994\u003c/a\u003e; \u003ca href=\"#ref8\"\u003e\u003cspan\u003eReference Ivanov\u003c/span\u003eIvanov, 2011\u003cem\u003ea\u003c/em\u003e\n\u003c/a\u003e), are an alternative solution to the problem. What they lack in generality, they make up for with an extremely small memory footprint—they require literally nothing more than an array storing the values in the tree—and a blazing fast implementation. In other words, they are perfect for applications such as low-level coding/decoding routines where we don’t need any of the advanced features that segment trees offer, and want to squeeze out every last bit of performance.\u003c/p\u003e\n\u003cp\u003e Figure \u003ca href=\"#f6\"\u003e6\u003c/a\u003e shows a typical implementation of Fenwick trees in Java. As you can see, the implementation is incredibly concise and consists mostly of some small loops doing just a few arithmetic and bit operations per iteration. It is not at all clear what this code is doing, or how it works! Upon closer inspection, the \u003cspan\u003erange\u003c/span\u003e, \u003cspan\u003eget\u003c/span\u003e, and \u003cspan\u003eset\u003c/span\u003e functions are straightforward, but the other functions are a puzzle. We can see that both the \u003cspan\u003eprefix\u003c/span\u003e and \u003cspan\u003eupdate\u003c/span\u003e functions call another function \u003cspan\u003eLSB\u003c/span\u003e, which for some reason performs a bitwise logical AND of an integer and its negation. In fact, \u003cspan\u003eLSB(x)\u003c/span\u003e computes the \u003cem\u003eleast significant bit\u003c/em\u003e of \u003cem\u003ex\u003c/em\u003e, that is, it returns the smallest \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline33.png?pub-status=live\" width=\"14\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline33.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline33.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^k$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e such that the \u003cem\u003ek\u003c/em\u003eth bit of \u003cem\u003ex\u003c/em\u003e is a one. However, it is not obvious how the implementation of \u003cspan\u003eLSB\u003c/span\u003e works, nor how and why least significant bits are being used to compute updates and prefix sums.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f6\" id=\"f6\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig6.png?pub-status=live\" width=\"2659\" height=\"1580\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig6.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig6.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 6\u003c/span\u003e Implementing Fenwick trees with bit tricks.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e Our goal is \u003cem\u003enot\u003c/em\u003e to write elegant functional code for this—already solved!—problem. Rather, our goal will be to use a functional domain-specific language for bit strings, along with equational reasoning, to \u003cem\u003ederive\u003c/em\u003e and \u003cem\u003eexplain\u003c/em\u003e this baffling imperative code from first principles—a demonstration of the power of functional thinking and equational reasoning to understand code written even in other, non-functional languages. After developing more intuition for segment trees (Section \u003ca href=\"#s2\"\u003e2\u003c/a\u003e), we will see how Fenwick trees can be viewed as a variant on segment trees (Section \u003ca href=\"#s3\"\u003e3\u003c/a\u003e). We will then take a detour into two’s complement binary encoding, develop a suitable DSL for bit manipulations, and explain the implementation of the \u003cspan\u003eLSB\u003c/span\u003e function (Section \u003ca href=\"#s4\"\u003e4\u003c/a\u003e). Armed with the DSL, we will then derive functions for converting back and forth between Fenwick trees and standard binary trees (Section \u003ca href=\"#s5\"\u003e5\u003c/a\u003e). Finally, we will be able to derive functions for moving within a Fenwick tree by converting to binary tree indices, doing the obvious operations to effect the desired motion within the binary tree, and then converting back. Fusing away the conversions via equational reasoning will finally reveal the hidden LSB function, as expected (Section \u003ca href=\"#s6\"\u003e6\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003e This paper was produced from a literate Haskell document; the source is available from GitHub, at \u003ca href=\"https://github.com/byorgey/fenwick/blob/master/Fenwick.lhs\"\u003ehttps://github.com/byorgey/fenwick/blob/master/Fenwick.lhs\u003c/a\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s2\" id=\"s2\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e2\u003c/span\u003e Segment trees\u003c/h2\u003e\n\u003cp\u003e Figure \u003ca href=\"#f7\"\u003e7\u003c/a\u003e exhibits a simple implementation of a segment tree in Haskell, using some utilities for working with index ranges shown in Figure \u003ca href=\"#f8\"\u003e8\u003c/a\u003e. We store a segment tree as a recursive algebraic data type and implement \u003cem\u003eupdate\u003c/em\u003e and \u003cem\u003erq\u003c/em\u003e using code that directly corresponds to the recursive descriptions given in the previous section; \u003cem\u003eget\u003c/em\u003e and \u003cem\u003eset\u003c/em\u003e can then also be implemented in terms of them. It is not hard to generalize this code to work for segment trees storing values from either an arbitrary commutative monoid if we don’t need the \u003cem\u003eset\u003c/em\u003e operation—or from an arbitrary Abelian group (i.e. commutative monoid with inverses) if we do need \u003cem\u003eset\u003c/em\u003e—but we keep things simple since the generalization doesn’t add anything to our story.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f7\" id=\"f7\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig7.png?pub-status=live\" width=\"2337\" height=\"2308\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig7.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig7.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 7\u003c/span\u003e Simple segment tree implementation in Haskell.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"f8\" id=\"f8\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig8.png?pub-status=live\" width=\"2968\" height=\"1204\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig8.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig8.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Although this implementation is simple and relatively straightforward to understand, compared to simply storing the sequence of values in an array, it incurs a good deal of overhead. We can be more clever in our use of space by storing all the nodes of a segment tree in an array, using the standard left-to-right breadth-first indexing scheme illustrated in Figure \u003ca href=\"#f9\"\u003e9\u003c/a\u003e (for example, this scheme, or something like it, is commonly used to implement binary heaps). The root has label 1; every time we descend one level we append an extra bit: 0 when we descend to the left child and 1 when we descend to the right. Thus, the index of each node expressed in binary records the sequence of left-right choices along the path to that node from the root. Going from a node to its children is as simple as doing a left bit shift and optionally adding 1; going from a node to its parent is a right bit shift. This defines a bijection from the positive natural numbers to the nodes of an infinite binary tree. If we label the segment tree array with \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline34.png?pub-status=live\" width=\"73\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline34.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline34.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$s_1 \\ldots s_{2n-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, then \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline35.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline35.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline35.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$s_1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e stores the sum of all the \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline36.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline36.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline36.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline37.png?pub-status=live\" width=\"13\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline37.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline37.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$s_2$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e stores the sum of the first half of the \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline38.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline38.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline38.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline39.png?pub-status=live\" width=\"12\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline39.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline39.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$s_3$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e stores the sum of the second half, and so on. \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline40.png?pub-status=live\" width=\"56\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline40.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline40.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_1 \\ldots a_n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e themselves are stored as \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline41.png?pub-status=live\" width=\"72\" height=\"10\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline41.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline41.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$s_n \\ldots s_{2n-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f9\" id=\"f9\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig9.png?pub-status=live\" width=\"2131\" height=\"997\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig9.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig9.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 9\u003c/span\u003e Indexing a binary tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e The important point is that since descending recursively through the tree corresponds to simple operations on indices, all the algorithms we have discussed can be straightforwardly transformed into code that works with a (mutable) array: for example, instead of storing a reference to the current subtree, we store an integer index; every time we want to descend to the left or right, we simply double the current index or double and add one, and so on. Working with tree nodes stored in an array presents an additional opportunity: rather than being forced to start at the root and recurse downwards, we can start at a particular index of interest and move \u003cem\u003eup\u003c/em\u003e the tree instead.\u003c/p\u003e\n\u003cp\u003e So how do we get from segment trees to Fenwick trees? We start with an innocuous-seeming observation: \u003cem\u003enot all the values stored in a segment tree are necessary\u003c/em\u003e. Of course, all the non-leaf nodes are “unnecessary” in the sense that they represent cached range sums which could easily be recomputed from the original sequence. That’s the whole point: caching these “redundant” sums trades off space for time, allowing us to perform arbitrary updates and range queries quickly, at the cost of doubling the required storage space.\u003c/p\u003e\n\u003cp\u003e But that’s not what I mean! In fact, there is a different set of values we can forget about, but in such a way that we still retain the logarithmic running time for updates and range queries. Which values, you ask? Simple: just forget the data stored in \u003cem\u003eevery node which is a right child\u003c/em\u003e. Figure \u003ca href=\"#f10\"\u003e10\u003c/a\u003e shows the same example tree we have been using, but with the data deleted from every right child. Note that “every right child” includes both leaves and internal nodes: we forget the data associated to \u003cem\u003eevery\u003c/em\u003e node which is the right child of its parent. We will refer to the nodes with discarded data as \u003cem\u003einactive\u003c/em\u003e and the remaining nodes (that is, left children and the root) as \u003cem\u003eactive\u003c/em\u003e. We also say that a tree with all its right children inactivated in this way has been \u003cem\u003ethinned\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f10\" id=\"f10\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig10.png?pub-status=live\" width=\"2131\" height=\"1012\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig10.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig10.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 10\u003c/span\u003e Inactivating all right children in a segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e Updating a thinned segment tree is easy: just update the same nodes as before, ignoring any updates to inactive nodes. But how do we answer range queries? It’s not too hard to see that there is enough information remaining to reconstruct the information that was discarded (you might like to try convincing yourself of this: can you deduce what values must go in the greyed-out nodes in Figure \u003ca href=\"#f10\"\u003e10\u003c/a\u003e, without peeking at any previous figures?). However, in and of itself, this observation does not give us a nice algorithm for computing range sums.\u003c/p\u003e\n\u003cp\u003e It turns out the key is to think about \u003cem\u003eprefix sums\u003c/em\u003e. As we saw in the introduction and the implementation of \u003cspan\u003erange\u003c/span\u003e in Figure \u003ca href=\"#f6\"\u003e6\u003c/a\u003e, if we can compute the prefix sum \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline42.png?pub-status=live\" width=\"125\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline42.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline42.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_k = a_1 + \\ldots + a_k$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e for any \u003cem\u003ek\u003c/em\u003e, then we can compute the range sum \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline43.png?pub-status=live\" width=\"83\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline43.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline43.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$a_i + \\ldots + a_j$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e as \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline44.png?pub-status=live\" width=\"62\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline44.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline44.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$P_j - P_{i-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTheorem 1\u003c/span\u003e Given a thinned segment tree, the sum of any prefix of the original array (and hence also any range sum) can be computed, in logarithmic time, using only the values of active nodes.\u003c/p\u003e\n\n\u003cp\u003e\u003cspan\u003eProof\u003c/span\u003e Surprisingly, in the special case of prefix queries, the original range query algorithm described in Section \u003ca href=\"#s1\"\u003e1\u003c/a\u003e and implemented in Figure \u003ca href=\"#f7\"\u003e7\u003c/a\u003e works unchanged! That is to say, the base case in which the range of the current node is wholly contained within the query range—and we thus return the value of the current node—will only ever happen at active nodes.\u003c/p\u003e\n\n\u003cp\u003e First, the root itself is active, and hence, querying the full range will work. Next, consider the case where we are at a node and recurse on both children. The left child is always active, so we only need to consider the case where we recurse to the right. It is impossible that the range of the right child will be wholly contained in the query range: since the query range is always a prefix of the form \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline45.png?pub-status=live\" width=\"34\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline45.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline45.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1,\\ j]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, if the right child’s range is wholly contained in \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline46.png?pub-status=live\" width=\"35\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline46.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline46.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1,\\ j]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e then the left child’s range must be as well—which means that the parent node’s range (which is the union of its children’s ranges) would also be wholly contained in the query range. But in that case we would simply return the parent’s value without recursing into the right child. Thus, when we do recurse into a right child, we might end up returning 0, or we might recurse further into both grandchildren, but in any case we will never try to look at the value of the right child itself.\u003c/p\u003e\n\u003cp\u003e Figure \u003ca href=\"#f11\"\u003e11\u003c/a\u003e illustrates performing a prefix query on a segment tree. Notice that visited right children are only ever blue or grey; the only green nodes are left children.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f11\" id=\"f11\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig11.png?pub-status=live\" width=\"2136\" height=\"1096\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig11.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig11.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 11\u003c/span\u003e Performing a prefix query on a segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s3\" id=\"s3\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e3\u003c/span\u003e Fenwick trees\u003c/h2\u003e\n\u003cp\u003e How should we actually store a thinned segment tree in memory? If we stare at Figure \u003ca href=\"#f10\"\u003e10\u003c/a\u003e again, one strategy suggests itself: simply take every active node and “slide” it down and to the right until it lands in an empty slot in the underlying array, as illustrated in Figure \u003ca href=\"#f12\"\u003e12\u003c/a\u003e. This sets up a one-to-one correspondence between active nodes and indices in the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline47.png?pub-status=live\" width=\"42\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline47.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline47.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$1 \\ldots n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Another way to understand this indexing scheme is to use a postorder traversal of the tree, skipping over inactive nodes and giving consecutive indices to active nodes encountered during the traversal. We can also visualize the result by drawing the tree in a “right-leaning” style (Figure \u003ca href=\"#f13\"\u003e13\u003c/a\u003e), vertically aligning each active node with the array slot where it is stored.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f12\" id=\"f12\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig12.png?pub-status=live\" width=\"2132\" height=\"1461\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig12.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig12.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 12\u003c/span\u003e Sliding active values down a thinned segment tree.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"f13\" id=\"f13\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig13.png?pub-status=live\" width=\"2131\" height=\"1012\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig13.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig13.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 13\u003c/span\u003e Right-leaning drawing of a thinned segment tree, vertically aligning nodes with their storage location.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e This method of storing the active nodes from a thinned segment tree in an array is precisely a \u003cem\u003eFenwick tree\u003c/em\u003e. I will also sometimes refer to it as a \u003cem\u003eFenwick array\u003c/em\u003e, when I want to particularly emphasize the underlying array data structure. Although it is certainly a clever use of space, the big question is how to implement the update and range query operations. Our implementations of these operations for segment trees worked by recursively descending through the tree, either directly if the tree is stored as a recursive data structure, or using simple operations on indices if the tree is stored in an array. However, when storing the active nodes of a thinned tree in a Fenwick array, it is not \u003cem\u003ea priori\u003c/em\u003e obvious what operations on array indices will correspond to moving around the tree. In order to attack this problem, we first take a detour through a domain-specific language for two’s complement binary values.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s4\" id=\"s4\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e4\u003c/span\u003e Two’s complement binary\u003c/h2\u003e\n\u003cp\u003e The bit tricks usually employed to implement Fenwick trees rely on a \u003cem\u003etwo’s complement\u003c/em\u003e representation of binary numbers, which allow positive and negative numbers to be represented in a uniform way; for example, a value consisting of all 1 bits represents \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline48.png?pub-status=live\" width=\"19\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline48.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline48.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$-1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. We therefore turn now to developing a domain-specific language, embedded in Haskell, for manipulating two’s complement binary representations.\u003c/p\u003e\n\u003cp\u003e First, we define a type of bits, with functions for inversion, logical conjunction, and logical disjunction:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9001\" id=\"dispU9001\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9001.png?pub-status=live\" width=\"504\" height=\"271\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9001.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9001.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Next, we must define bit strings, i.e. sequences of bits. Rather than fix a specific bit width, it will be much more elegant to work with \u003cem\u003einfinite\u003c/em\u003e bit strings.\u003ca href=\"#fn3\"\u003e\u003cspan\u003eFootnote \u003c/span\u003e\n\u003csup\u003e3\u003c/sup\u003e\n\u003c/a\u003e It is tempting to use standard Haskell lists to represent potentially infinite bit strings, but this leads to a number of problems. For example, equality of infinite lists is not decidable, and there is no way in general to convert from an infinite list of bits back to an \u003cem\u003eInteger\u003c/em\u003e—how would we know when to stop? In fact, these practical problems stem from a more fundamental one: infinite lists of bits are actually a bad representation for two’s complement bit strings, because of “junk”, that is, infinite lists of bits which do not correspond to values in our intended semantic domain. For example, \u003cem\u003ecycle\u003c/em\u003e [\u003cem\u003eI\u003c/em\u003e,\u003cem\u003eO\u003c/em\u003e] is an infinite list which alternates between \u003cem\u003eI\u003c/em\u003e and \u003cem\u003eO\u003c/em\u003e forever, but it does not represent a valid two’s complement encoding of an integer. Even worse are non-periodic lists, such as the one with \u003cem\u003eI\u003c/em\u003e at every prime index and \u003cem\u003eO\u003c/em\u003e everywhere else.\u003c/p\u003e\n\u003cp\u003e In fact, the bit strings we want are the \u003cem\u003eeventually constant\u003c/em\u003e ones, that is, strings which eventually settle down to an infinite tail of all zeros (which represent nonnegative integers) or all ones (which represent negative integers). Every such string has a finite representation, so directly encoding eventually constant bit strings in Haskell not only gets rid of the junk but also leads to elegant, terminating algorithms for working with them.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9002\" id=\"dispU9002\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9002.png?pub-status=live\" width=\"301\" height=\"110\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9002.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9002.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e \n\u003cem\u003eRep b\u003c/em\u003e represents an infinite sequence of bit \u003cem\u003eb\u003c/em\u003e, whereas \u003cem\u003eSnoc bs b\u003c/em\u003e represents the bit string \u003cem\u003ebs\u003c/em\u003e followed by a final bit \u003cem\u003eb\u003c/em\u003e. We use \u003cem\u003eSnoc\u003c/em\u003e, rather than \u003cem\u003eCons\u003c/em\u003e, to match the way we usually write bit strings, with the least significant bit last. Note also the use of a \u003cem\u003estrictness annotation\u003c/em\u003e on the \u003cem\u003eBits\u003c/em\u003e field of \u003cem\u003eSnoc\u003c/em\u003e; this is to rule out infinite lists of bits using only \u003cem\u003eSnoc\u003c/em\u003e, such as \u003cem\u003ebs\u003c/em\u003e=\u003cem\u003eSnoc\u003c/em\u003e (\u003cem\u003eSnoc bs O\u003c/em\u003e) \u003cem\u003eI\u003c/em\u003e. In other words, the only way to make a non-bottom value of type \u003cem\u003eBits\u003c/em\u003e is to have a finite sequence of \u003cem\u003eSnoc\u003c/em\u003e finally terminated by \u003cem\u003eRep\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e Although we have eliminated junk values, one remaining problem is that there can be multiple distinct representations of the same value. For example, \u003cem\u003eSnoc\u003c/em\u003e (\u003cem\u003eRep O\u003c/em\u003e) \u003cem\u003eO\u003c/em\u003e and \u003cem\u003eRep O\u003c/em\u003e both represent the infinite bit string containing all zeros. However, we can solve this with a carefully constructed \u003cem\u003ebidirectional pattern synonym\u003c/em\u003e (Pickering \u003cem\u003eet al\u003c/em\u003e., \u003ca href=\"#ref10\"\u003e\u003cspan\u003eReference Pickering, Érdi, Peyton Jones and Eisenberg\u003c/span\u003e2016\u003c/a\u003e).\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9003\" id=\"dispU9003\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9003.png?pub-status=live\" width=\"432\" height=\"291\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9003.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9003.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Matching with the pattern \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline50.png?pub-status=live\" width=\"49\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline50.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline50.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({bs}\\mathrel{:\\!.}{b})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e uses a \u003cem\u003eview pattern\u003c/em\u003e (Erwig \u0026amp; Jones, \u003ca href=\"#ref4\"\u003e\u003cspan\u003eReference Erwig and Jones\u003c/span\u003e2001\u003c/a\u003e) to potentially expand a \u003cem\u003eRep\u003c/em\u003e one step into a \u003cem\u003eSnoc\u003c/em\u003e, so that we can pretend \u003cem\u003eBits\u003c/em\u003e values are always constructed with \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline51.png?pub-status=live\" width=\"19\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline51.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline51.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Conversely, constructing a \u003cem\u003eBits\u003c/em\u003e with \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline52.png?pub-status=live\" width=\"20\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline52.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline52.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e will do nothing if we happen to snoc an identical bit \u003cem\u003eb\u003c/em\u003e onto an existing \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline53.png?pub-status=live\" width=\"38\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline53.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline53.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{Rep}\\;{b}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. This ensures that as long as we stick to using \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline54.png?pub-status=live\" width=\"20\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline54.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline54.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and never directly use \u003cem\u003eSnoc\u003c/em\u003e, \u003cem\u003eBits\u003c/em\u003e values will always be \u003cem\u003enormalized\u003c/em\u003e so that the terminal \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline55.png?pub-status=live\" width=\"38\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline55.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline55.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{Rep}\\;{b}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is immediately followed by a different bit. Finally, we mark the pattern \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline56.png?pub-status=live\" width=\"20\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline56.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline56.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e as \u003cspan\u003eCOMPLETE\u003c/span\u003e on its own, since matching on \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline57.png?pub-status=live\" width=\"19\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline57.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline57.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is indeed sufficient to handle every possible input of type \u003cem\u003eBits\u003c/em\u003e. However, in order to obtain terminating algorithms we will often include one or more special cases for \u003cem\u003eRep\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e Let’s begin with some functions for converting \u003cem\u003eBits\u003c/em\u003e to and from \u003cem\u003eInteger\u003c/em\u003e and for displaying \u003cem\u003eBits\u003c/em\u003e (intended only for testing).\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9004\" id=\"dispU9004\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9004.png?pub-status=live\" width=\"579\" height=\"516\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9004.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9004.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Let’s try it out, using QuickCheck (Claessen \u0026amp; Hughes, \u003ca href=\"#ref3\"\u003e\u003cspan\u003eReference Claessen and Hughes\u003c/span\u003e2000\u003c/a\u003e) to verify our conversion functions:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9005\" id=\"dispU9005\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9005.png?pub-status=live\" width=\"675\" height=\"385\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9005.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9005.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e We can now begin implementing some basic operations on \u003cem\u003eBits\u003c/em\u003e. First, incrementing and decrementing can be implemented recursively as follows:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9006\" id=\"dispU9006\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9006.png?pub-status=live\" width=\"317\" height=\"243\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9006.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9006.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e The \u003cem\u003eleast significant bit\u003c/em\u003e, or LSB, of a sequence of bits can be defined as follows:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9007\" id=\"dispU9007\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9007.png?pub-status=live\" width=\"282\" height=\"120\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9007.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9007.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Note that we add a special case for \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline58.png?pub-status=live\" width=\"42\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline58.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline58.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{Rep}\\;{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e to ensure that \u003cem\u003elsb\u003c/em\u003e is total. Technically, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline59.png?pub-status=live\" width=\"42\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline59.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline59.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{Rep}\\;{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e does not have a least significant bit, so defining \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline60.png?pub-status=live\" width=\"136\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline60.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline60.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{lsb}\\;({Rep}\\;{O})\\mathrel{=}{Rep}\\;{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e seems sensible.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9008\" id=\"dispU9008\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9008.png?pub-status=live\" width=\"337\" height=\"253\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9008.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9008.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Bitwise logical conjunction can be defined straightforwardly. Note that we only need two cases; if the finite parts of the inputs have different lengths, matching with \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline61.png?pub-status=live\" width=\"19\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline61.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline61.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${(\\mathrel{:\\!.})}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e will automatically expand the shorter one to match the longer one.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9009\" id=\"dispU9009\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9009.png?pub-status=live\" width=\"431\" height=\"107\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9009.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9009.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Bitwise inversion is likewise straightforward.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9010\" id=\"dispU9010\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9010.png?pub-status=live\" width=\"270\" height=\"89\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9010.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9010.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e The above functions follow familiar patterns. We could easily generalize to eventually constant streams over an arbitrary element type and then implement \u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9001.png?pub-status=live\" width=\"26\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9001.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9001.png\"/\u003e in terms of a generic \u003cem\u003ezipWith\u003c/em\u003e and \u003cem\u003einv\u003c/em\u003e in terms of \u003cem\u003emap\u003c/em\u003e. However, for the present purpose we do not need the extra generality.\u003c/p\u003e\n\u003cp\u003e We implement addition with the usual carry-propagation algorithm, along with some special cases for \u003cem\u003eRep\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9011\" id=\"dispU9011\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9011.png?pub-status=live\" width=\"441\" height=\"190\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9011.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9011.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e It is not too hard to convince ourselves that this definition of addition is terminating and yields correct results; but we can also be fairly confident by just trying it with QuickCheck:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9012\" id=\"dispU9012\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9012.png?pub-status=live\" width=\"871\" height=\"78\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9012.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9012.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Finally, the following definition of negation is probably familiar to anyone who has studied two’s complement arithmetic; I leave it as an exercise for the interested reader to prove that \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline62.png?pub-status=live\" width=\"124\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline62.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline62.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\oplus{neg}\\;{x}\\equiv {Rep}\\;{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e for all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline63.png?pub-status=live\" width=\"51\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline63.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline63.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathbin{::}{Bits}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9013\" id=\"dispU9013\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9013.png?pub-status=live\" width=\"274\" height=\"86\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9013.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9013.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e We now have the tools to resolve the first mystery of the Fenwick tree implementation.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTheorem 4.1\u003c/span\u003e For all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline64.png?pub-status=live\" width=\"51\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline64.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline64.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathbin{::}{Bits}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e,\u003c/p\u003e\n\n\u003cdiv data-magellan-destination=\"dispU9014\" id=\"dispU9014\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9014.png?pub-status=live\" width=\"187\" height=\"31\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9014.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9014.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e \n\u003cstrong\u003eProof.\u003c/strong\u003e By induction on \u003cem\u003ex\u003c/em\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e First, if \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline65.png?pub-status=live\" width=\"69\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline65.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline65.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{Rep}\\;{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, it is an easy calculation to verify that \u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9002.png?pub-status=live\" width=\"159\" height=\"19\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9002.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9002.png\"/\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e Likewise, if \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline66.png?pub-status=live\" width=\"64\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline66.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline66.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{Rep}\\;{I}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, both \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline67.png?pub-status=live\" width=\"30\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline67.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline67.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{lsb}\\;{x}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and \u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9003.png?pub-status=live\" width=\"58\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9003.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9003.png\"/\u003e reduce to \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline68.png?pub-status=live\" width=\"65\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline68.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline68.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{Rep}\\;{O}\\mathrel{:\\!.}{I}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e If \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline69.png?pub-status=live\" width=\"69\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline69.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline69.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, then \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline70.png?pub-status=live\" width=\"208\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline70.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline70.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{lsb}\\;{x}\\mathrel{=}{lsb}\\;({xs}\\mathrel{:\\!.}{O})\\mathrel{=}{lsb}\\;{xs}\\mathrel{:\\!.}{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e by definition, whereas\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9015\" id=\"dispU9015\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9015.png?pub-status=live\" width=\"615\" height=\"342\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9015.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9015.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e Next, if \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline71.png?pub-status=live\" width=\"64\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline71.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline71.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{I}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, then \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline72.png?pub-status=live\" width=\"153\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline72.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline72.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{lsb}\\;({xs}\\mathrel{:\\!.}{I})\\mathrel{=}{Rep}\\;{O}\\mathrel{:\\!.}{I}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e by definition, whereas\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv data-magellan-destination=\"dispU9016\" id=\"dispU9016\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9016.png?pub-status=live\" width=\"769\" height=\"341\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9016.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9016.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e For the last equality, we need a lemma that \u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9004.png?pub-status=live\" width=\"123\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9004.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline9004.png\"/\u003e, which should be intuitively clear and can easily be proved by induction as well.\u003c/p\u003e\n\u003cp\u003e Finally, in order to express the index conversion functions we will develop in the next section, we need a few more things in our DSL. First, some functions to set and clear individual bits and to test whether particular bits are set:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9017\" id=\"dispU9017\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9017.png?pub-status=live\" width=\"408\" height=\"409\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9017.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9017.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e The only other things we will need are left and right shift, and a generic \u003cem\u003ewhile\u003c/em\u003e combinator that iterates a given function, returning the first iterate for which a predicate is false.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9018\" id=\"dispU9018\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9018.png?pub-status=live\" width=\"424\" height=\"268\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9018.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9018.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s5\" id=\"s5\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e5\u003c/span\u003e Index conversion\u003c/h2\u003e\n\u003cp\u003e Before deriving our index conversion functions, we must deal with one slightly awkward fact. In a traditional binary tree indexing scheme, as shown in Figure \u003ca href=\"#f9\"\u003e9\u003c/a\u003e, the root has index 1, every left child is twice its parent, and every right child is one more than twice its parent. Recall that in a thinned segment tree, the root node and every left child are active, with all right children being inactive. This makes the root an awkward special case—all active nodes have an even index, \u003cem\u003eexcept\u003c/em\u003e the root, which has index 1. This makes it more difficult to check whether we are at an active node—it is not enough to simply look at the least significant bit.\u003c/p\u003e\n\u003cp\u003e One easy way to fix this is simply to give the root index 2 and then proceed to label the rest of the nodes using the same scheme—every left child is twice its parent, and every right child is one more than twice its parent. This results in the indexing shown in Figure \u003ca href=\"#f14\"\u003e14\u003c/a\u003e, as if we had just taken the left subtree of the tree rooted at 1, and ignored the right subtree. Of course, this means about half the possible indices are omitted—but that’s not a problem, since we will only use these indices as an intermediate step which will eventually get fused away.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f14\" id=\"f14\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig14.png?pub-status=live\" width=\"2131\" height=\"997\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig14.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig14.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 14\u003c/span\u003e Indexing a binary tree with 2 at the root.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e Figure \u003ca href=\"#f15\"\u003e15\u003c/a\u003e shows a binary tree where nodes have been numbered in two different ways: the left side of each node shows the node’s binary tree index (with the root having index 2). The right side of each node shows its index in the Fenwick array, if it has one (inactive nodes simply have their right half greyed out). The table underneath shows the mapping from Fenwick array indices (top row) to binary tree indices (bottom row). As a larger example, Figure \u003ca href=\"#f16\"\u003e16\u003c/a\u003e shows the same thing on a binary tree one level deeper.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f15\" id=\"f15\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig15.png?pub-status=live\" width=\"3134\" height=\"1941\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig15.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig15.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 15\u003c/span\u003e Binary tree labelled with both binary and Fenwick indexing.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"f16\" id=\"f16\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig16.png?pub-status=live\" width=\"3654\" height=\"1535\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig16.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig16.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 16\u003c/span\u003e Binary tree labelled with both binary and Fenwick indexing.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e Our goal is to come up with a way to calculate the binary index for a given Fenwick index or vice versa. Staring at the table in Figure \u003ca href=\"#f16\"\u003e16\u003c/a\u003e, a few patterns stand out. Of course, all the numbers in the bottom row are even, which is precisely because the binary tree is numbered in such a way that all active nodes have an even index. Second, we can see the even numbers \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline73.png?pub-status=live\" width=\"83\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline73.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline73.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$32, 34 \\ldots 46$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, in order, in all the odd positions. These are exactly the leaves of the tree, and indeed, every other node in the Fenwick array will be a leaf from the original tree. Alternating with these, in the even positions, are the numbers \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline74.png?pub-status=live\" width=\"91\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline74.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline74.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$16\\;\\; 8\\;\\; 18\\;\\; 4 \\ldots$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, which correspond to all the non-leaf nodes; but these are exactly the sequence of binary indices from the bottom row of the table in Figure \u003ca href=\"#f15\"\u003e15\u003c/a\u003e—since the internal nodes in a tree of height 4 themselves constitute a tree of height 3, with the nodes occurring in the same order.\u003c/p\u003e\n\u003cp\u003e These observations lead to the recurrence shown in Figure \u003ca href=\"#f17\"\u003e17\u003c/a\u003e for the sequence \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline75.png?pub-status=live\" width=\"14\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline75.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline75.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b_n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e of binary indices for the nodes stored in a Fenwick array of length \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline76.png?pub-status=live\" width=\"14\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline76.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline76.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e: \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline77.png?pub-status=live\" width=\"14\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline77.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline77.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b_0$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is just the singleton sequence [2], and otherwise \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline78.png?pub-status=live\" width=\"14\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline78.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline78.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b_n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is the even numbers \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline79.png?pub-status=live\" width=\"224\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline79.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline79.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^{n+1}, 2^{n+1} + 2, \\ldots, 2^{n+1} + 2^n - 2$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e interleaved with \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline80.png?pub-status=live\" width=\"28\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline80.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline80.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b_{n-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f17\" id=\"f17\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig17.png?pub-status=live\" width=\"1753\" height=\"729\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig17.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig17.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 17\u003c/span\u003e Recurrence for sequence of binary tree indices in a Fenwick array.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e We can check that this does in fact reproduce the observed sequence for \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline81.png?pub-status=live\" width=\"35\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline81.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline81.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n = 4$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9019\" id=\"dispU9019\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9019.png?pub-status=live\" width=\"576\" height=\"78\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9019.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9019.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Let \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline82.png?pub-status=live\" width=\"31\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline82.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline82.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{s}\\text{ ! }{k}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e denote the \u003cem\u003ek\u003c/em\u003eth item in the list \u003cem\u003es\u003c/em\u003e (counting from 1), as defined in Figure \u003ca href=\"#f18\"\u003e18\u003c/a\u003e. The same figure also lists two easy lemmas about the interaction between indexing and interleaving, namely \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline83.png?pub-status=live\" width=\"152\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline83.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline83.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({xs}{\\curlyvee}{ys})\\text{ ! }(\\mathrm{2}\\cdot{j})\\mathrel{=}{ys}\\text{ ! }{j}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline84.png?pub-status=live\" width=\"181\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline84.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline84.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({xs}{\\curlyvee}{ys})\\text{ ! }(\\mathrm{2}\\cdot{j}\\mathbin{-}\\mathrm{1})\\mathrel{=}{xs}\\text{ ! }{j}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e (as long as \u003cem\u003exs\u003c/em\u003e and \u003cem\u003eys\u003c/em\u003e have equal lengths). With these in hand, we can define the Fenwick to binary index conversion function as \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU1.png?pub-status=live\" width=\"115\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU1.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU1.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{f2b}\\;{n}\\;{k}\\mathrel{=}{b}\\;{n}\\text{ ! }{k}}. \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e Of course, since \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline85.png?pub-status=live\" width=\"14\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline85.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline85.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b_n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is of length \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline86.png?pub-status=live\" width=\"14\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline86.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline86.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, this function is only defined on the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline87.png?pub-status=live\" width=\"40\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline87.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline87.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1, 2^n]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f18\" id=\"f18\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig18.png?pub-status=live\" width=\"406\" height=\"276\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig18.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig18.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 18\u003c/span\u003e Indexing and interleaving.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e We can now simplify the definition of \u003cem\u003ef2b\u003c/em\u003e as follows. First of all, for even inputs, we have\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9020\" id=\"dispU9020\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9020.png?pub-status=live\" width=\"572\" height=\"321\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9020.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9020.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e And for odd inputs,\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9021\" id=\"dispU9021\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9021.png?pub-status=live\" width=\"659\" height=\"343\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9021.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9021.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Thus, we have \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU2.png?pub-status=live\" width=\"261\" height=\"51\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU2.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU2.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{f2b}\\;{n}\\;{k}} = \\begin{cases} {{f2b}\\;({n}\\mathbin{-}\\mathrm{1})\\;({k}\\mathbin{/}\\mathrm{2})} \u0026amp; k \\text{ even} \\\\ 2^{n+1} + k - 1 \u0026amp; k \\text{ odd} \\end{cases} \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e Note that when \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline88.png?pub-status=live\" width=\"40\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline88.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline88.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n = 0,$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e we must have \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline89.png?pub-status=live\" width=\"34\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline89.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline89.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$k = 1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and hence, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline90.png?pub-status=live\" width=\"167\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline90.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline90.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}\\;\\mathrm{0}\\;\\mathrm{1}} = 2^0 + 1 - 1 = 1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, as required, so this definition is valid for all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline91.png?pub-status=live\" width=\"29\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline91.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline91.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n {\\geqslant} 0$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Now factor \u003cem\u003ek\u003c/em\u003e uniquely as \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline92.png?pub-status=live\" width=\"34\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline92.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline92.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^a \\cdot b$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e where \u003cem\u003eb\u003c/em\u003e is odd. Then by induction we can see that \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU3.png?pub-status=live\" width=\"316\" height=\"18\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU3.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU3.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{f2b}\\;{n}\\;(\\mathrm{2}^ {{a}}\\cdot{b})\\mathrel{=}{f2b}\\;({n}\\mathbin{-}{a})\\;{b}} = 2^{n-a+1} + b - 1. \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e So, in other words, computing \u003cem\u003ef2b\u003c/em\u003e consists of repeatedly dividing by 2 (i.e. right bit shifts) as long as the input is even and then finally decrementing and adding a power of 2. However, knowing what power of 2 to add at the end depends on knowing how many times we shifted. A better way to think of it is to add \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline93.png?pub-status=live\" width=\"28\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline93.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline93.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^{n+1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e at the \u003cem\u003ebeginning\u003c/em\u003e, and then let it be shifted along with everything else. Thus, we have the following definition of \u003cem\u003ef2b’\u003c/em\u003e using our \u003cem\u003eBits\u003c/em\u003e DSL. Defining \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline94.png?pub-status=live\" width=\"201\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline94.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline94.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{shift}\\;{n}\\mathrel{=}{while}\\;{even}\\;{shr}\\mathbin{\\circ}{set}\\;{n}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e separately will make some of our proofs more compact later.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9022\" id=\"dispU9022\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9022.png?pub-status=live\" width=\"312\" height=\"134\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9022.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9022.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e For example, we can verify that this produces identical results to \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline95.png?pub-status=live\" width=\"38\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline95.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline95.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}\\;\\mathrm{4}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e on the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline96.png?pub-status=live\" width=\"41\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline96.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline96.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1, 2^4]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e (for convenience, we define \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline97.png?pub-status=live\" width=\"163\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline97.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline97.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({f}\\mathbin{===}{g})\\;{k}\\mathrel{=}{f}\\;{k}\\equiv {g}\\;{k}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e):\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9023\" id=\"dispU9023\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9023.png?pub-status=live\" width=\"738\" height=\"80\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9023.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9023.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e We now turn to deriving \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline98.png?pub-status=live\" width=\"36\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline98.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline98.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{b2f}\\;{n}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, which converts back from binary to Fenwick indices. \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline99.png?pub-status=live\" width=\"35\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline99.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline99.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{b2f}\\;{n}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e should be a left inverse to \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline100.png?pub-status=live\" width=\"39\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline100.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline100.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}\\;{n}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, that is, for any \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline101.png?pub-status=live\" width=\"66\" height=\"15\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline101.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline101.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$k \\in [1, 2^n]$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e we should have \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline102.png?pub-status=live\" width=\"126\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline102.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline102.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{b2f}\\;{n}\\;({f2b}\\;{n}\\;{k})\\equiv {k}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. If \u003cem\u003ek\u003c/em\u003e is an input to \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline103.png?pub-status=live\" width=\"27\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline103.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline103.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, we have \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline104.png?pub-status=live\" width=\"89\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline104.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline104.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$k = 2^a \\cdot b {\\leqslant} 2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and so \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline105.png?pub-status=live\" width=\"84\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline105.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline105.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b-1 \u0026lt; 2^{n-a}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Hence, given the output \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline106.png?pub-status=live\" width=\"200\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline106.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline106.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}\\;{n}\\;{k}} = m = 2^{n-a+1} + b - 1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, the highest bit of \u003cem\u003em\u003c/em\u003e is \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline107.png?pub-status=live\" width=\"43\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline107.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline107.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^{n-a+1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and the rest of the bits represent \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline108.png?pub-status=live\" width=\"35\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline108.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline108.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$b-1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. So, in general, given some \u003cem\u003em\u003c/em\u003e which is the output of \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline109.png?pub-status=live\" width=\"38\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline109.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline109.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f2b}\\;{n}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, we can write it uniquely as \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline110.png?pub-status=live\" width=\"75\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline110.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline110.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$m = 2^c + d$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e where \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline111.png?pub-status=live\" width=\"55\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline111.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline111.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$d \u0026lt; 2^{c-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e; then \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU4.png?pub-status=live\" width=\"219\" height=\"18\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU4.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU4.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{b2f}\\;{n}\\;(\\mathrm{2}^ {{c}}\\mathbin{+}{d})\\mathrel{=}\\mathrm{2}^ {{n}\\mathbin{-}{c}\\mathbin{+}\\mathrm{1}}\\cdot({d}\\mathbin{+}\\mathrm{1})}. \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e In other words, given the input \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline112.png?pub-status=live\" width=\"43\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline112.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline112.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^c + d$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, we subtract off the highest bit \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline113.png?pub-status=live\" width=\"13\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline113.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline113.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^c$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, increment, then left shift \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline114.png?pub-status=live\" width=\"62\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline114.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline114.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n-c+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e times. Again, though, there is a simpler way: we can increment first (note since \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline115.png?pub-status=live\" width=\"55\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline115.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline115.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$d \u0026lt; 2^{c-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, incrementing cannot disturb the bit at \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline116.png?pub-status=live\" width=\"13\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline116.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline116.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^c$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e), then left shift enough times to bring the leftmost bit into position \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline117.png?pub-status=live\" width=\"34\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline117.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline117.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and finally remove it. That is:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9024\" id=\"dispU9024\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9024.png?pub-status=live\" width=\"485\" height=\"137\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9024.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9024.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Verifying:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9025\" id=\"dispU9025\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9025.png?pub-status=live\" width=\"817\" height=\"79\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9025.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9025.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s6\" id=\"s6\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e6\u003c/span\u003e Deriving Fenwick operations\u003c/h2\u003e\n\u003cp\u003e We can now finally derive the required operations on Fenwick array indices for moving through the tree, by starting with operations on a binary indexed tree and conjugating by conversion to and from Fenwick indices. First, in order to fuse away the resulting conversion, we will need a few lemmas.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"lem6_1\" id=\"lem6_1\"\u003e\n\n\u003cp\u003e\u003cspan\u003eLemma 6.1\u003c/span\u003e (shr-inc-dec). For all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline118.png?pub-status=live\" width=\"58\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline118.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline118.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{bs}\\mathbin{::}{Bits}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e which are odd (that is, end with I),\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline119.png?pub-status=live\" width=\"147\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline119.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline119.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({shr}\\mathbin{\\circ}{dec})\\;{bs}\\mathrel{=}{shr}\\;{bs}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline120.png?pub-status=live\" width=\"191\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline120.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline120.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({shr}\\mathbin{\\circ}{inc})\\;{bs}\\mathrel{=}({inc}\\mathbin{\\circ}{shr})\\;{bs}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e\u003cspan\u003eProof\u003c/span\u003e Both are immediate by definition.\u003c/p\u003e\n\n\u003cdiv data-magellan-destination=\"lem6_2\" id=\"lem6_2\"\u003e\n\n\u003cp\u003e\u003cspan\u003eLemma 6.2\u003c/span\u003e (while-inc-dec). \u003cem\u003eThe following both hold for all Bits values:\u003c/em\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline121.png?pub-status=live\" width=\"274\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline121.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline121.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{inc}\\mathbin{\\circ}{while}\\;{odd}\\;{shr}\\mathrel{=}{while}\\;{even}\\;{shr}\\mathbin{\\circ}{inc}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e•\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline122.png?pub-status=live\" width=\"280\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline122.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline122.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{dec}\\mathbin{\\circ}{while}\\;{even}\\;{shr}\\mathrel{=}{while}\\;{odd}\\;{shr}\\mathbin{\\circ}{dec}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e \n\u003cstrong\u003eProof.\u003c/strong\u003e Easy proof by induction on \u003cem\u003eBits\u003c/em\u003e. For example, for the \u003cem\u003einc\u003c/em\u003e case, the functions on both sides discard consecutive 1 bits and then flip the first 0 bit to a 1.\u003c/p\u003e\n\u003cp\u003e Finally, we will need a lemma about shifting zero bits in and out of the right side of a value.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"lem6_3\" id=\"lem6_3\"\u003e\n\n\u003cp\u003e\u003cspan\u003eLemma 6.3\u003c/span\u003e (shl-shr). For all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline123.png?pub-status=live\" width=\"83\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline123.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline123.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$0 \u0026lt; x \u0026lt; 2^{n+2}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU5.png?pub-status=live\" width=\"531\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU5.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU5.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {({while}\\;(not\\mathbin{\\circ}{test}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{shl}\\mathbin{\\circ}{while}\\;{even}\\;{shr})\\;{x}\\mathrel{=}{while}\\;(not\\mathbin{\\circ}{test}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{shl}\\;{x}}. \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e\u003cspan\u003eProof\u003c/span\u003e Intuitively, this says that if we first shift out all the zero bits and then left shift until bit \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline124.png?pub-status=live\" width=\"35\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline124.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline124.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is set, we could get the same result by forgetting about the right shifts entirely; shifting out zero bits and then shifting them back in should be the identity.\u003c/p\u003e\n\n\u003cp\u003e Formally, the proof is by induction on \u003cem\u003ex\u003c/em\u003e. If \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline125.png?pub-status=live\" width=\"64\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline125.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline125.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{I}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e is odd, the equality is immediate since \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline126.png?pub-status=live\" width=\"133\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline126.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline126.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{while}\\;{even}\\;{shr}\\;{x}\\mathrel{=}{x}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. Otherwise, if \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline127.png?pub-status=live\" width=\"69\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline127.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline127.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathrel{=}{xs}\\mathrel{:\\!.}{O}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, on the left-hand side the \u003cem\u003eO\u003c/em\u003e is immediately discarded by \u003cem\u003eshr\u003c/em\u003e, whereas on the right-hand side \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline128.png?pub-status=live\" width=\"99\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline128.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline128.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{xs}\\mathrel{:\\!.}{O}\\mathrel{=}{shl}\\;{xs}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and the extra \u003cem\u003eshl\u003c/em\u003e can be absorbed into the \u003cem\u003ewhile\u003c/em\u003e since \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline129.png?pub-status=live\" width=\"62\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline129.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline129.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{xs}} \u0026lt; 2^{n+1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. What remains is simply the induction hypothesis.\u003c/p\u003e\n\u003cp\u003e With these lemmas under our belt, let’s see how to move around a Fenwick array in order to implement \u003cem\u003eupdate\u003c/em\u003e and \u003cem\u003equery\u003c/em\u003e; we’ll begin with \u003cem\u003eupdate\u003c/em\u003e. When implementing the \u003cem\u003eupdate\u003c/em\u003e operation, we need to start at a leaf and follow the path up to the root, updating all the active nodes along the way. In fact, for any given leaf, its closest active parent is precisely the node stored in the slot that used to correspond to that leaf (see Figure \u003ca href=\"#f13\"\u003e13\u003c/a\u003e). So to update index \u003cem\u003ei\u003c/em\u003e, we just need to start at index \u003cem\u003ei\u003c/em\u003e in the Fenwick array, and then repeatedly find the closest active parent, updating as we go. Recall that the imperative code for \u003cem\u003eupdate\u003c/em\u003e works this way, apparently finding the closest active parent at each step by adding the LSB of the current index:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9026\" id=\"dispU9026\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9026.png?pub-status=live\" width=\"538\" height=\"95\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9026.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9026.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Let’s see how to derive this behavior.\u003c/p\u003e\n\u003cp\u003e To find the closest active parent of a node under a binary indexing scheme, we first move up to the immediate parent (by dividing the index by two, i.e. performing a right bit shift); then continue moving up to the next immediate parent as long as the current node is a right child (i.e. has an odd index). This yields the definition:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9027\" id=\"dispU9027\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9027.png?pub-status=live\" width=\"417\" height=\"77\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9027.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9027.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e This is why we used the slightly strange indexing scheme with the root having index 2—otherwise this definition would not work for any node whose active parent is the root!\u003c/p\u003e\n\u003cp\u003e Now, to derive the corresponding operation on Fenwick indices, we conjugate by conversion to and from Fenwick indices and compute as follows. To make the computation easier to read, the portion being rewritten is underlined at each step.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9028\" id=\"dispU9028\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9028.png?pub-status=live\" width=\"876\" height=\"481\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9028.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9028.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e In the final step, since the input \u003cem\u003ex\u003c/em\u003e satisfies \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline130.png?pub-status=live\" width=\"36\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline130.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline130.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$x {\\leqslant} 2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, we have \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline131.png?pub-status=live\" width=\"162\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline131.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline131.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{inc}\\mathbin{\\circ}{shift}\\;({n}\\mathbin{+}\\mathrm{1})} \u0026lt; 2^{n+2}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, so Lemma 6.3 applies.\u003c/p\u003e\n\u003cp\u003e Reading from right to left, the pipeline we have just computed performs the following steps:\u003c/p\u003e\n\u003cp\u003e 1. Set bit \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline132.png?pub-status=live\" width=\"35\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline132.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline132.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\u003cp\u003e 2. Shift out consecutive zeros until finding the least significant 1 bit\u003c/p\u003e\n\u003cp\u003e 3. Increment\u003c/p\u003e\n\u003cp\u003e 4. Shift zeros back in to bring the most significant bit back to position \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline133.png?pub-status=live\" width=\"34\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline133.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline133.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, then clear it.\u003c/p\u003e\n\u003cp\u003e Intuitively, this does look a lot like adding the LSB! In general, to find the LSB, one must shift through consecutive 0 bits until finding the first 1; the question is how to keep track of how many 0 bits were shifted on the way. The \u003cem\u003elsb\u003c/em\u003e function itself keeps track via the recursion stack; after finding the first 1 bit, the recursion stack unwinds and re-snocs all the 0 bits recursed through on the way. The above pipeline represents an alternative approach: set bit \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline134.png?pub-status=live\" width=\"35\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline134.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline134.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e as a “sentinel” to keep track of how much we have shifted; right shift until the first 1 is literally in the ones place, at which point we increment; and then shift all the 0 bits back in by doing left shifts until the sentinel bit gets back to the \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline135.png?pub-status=live\" width=\"34\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline135.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline135.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n+1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e place. One example of this process is illustrated in Figure \u003ca href=\"#f19\"\u003e19\u003c/a\u003e. Of course, this only works for values that are sufficiently small that the sentinel bit will not be disturbed throughout the operation.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f19\" id=\"f19\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig19.png?pub-status=live\" width=\"814\" height=\"1280\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig19.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig19.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 19\u003c/span\u003e Adding LSB with a sentinel bit + shifts.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e To make this more formal, we begin by defining a helper function \u003cem\u003eatLSB\u003c/em\u003e, which does an operation “at the LSB”, that is, it shifts out 0 bits until finding a 1, applies the given function, then restores the 0 bits.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9029\" id=\"dispU9029\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9029.png?pub-status=live\" width=\"370\" height=\"128\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9029.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9029.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cspan\u003eLemma 6.4\u003c/span\u003e (add-lsb). For all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline136.png?pub-status=live\" width=\"51\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline136.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline136.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathbin{::}{Bits}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline137.png?pub-status=live\" width=\"152\" height=\"12\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline137.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline137.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathbin{+}{lsb}\\;{x}\\mathrel{=}{atLSB}\\;{inc}\\;{x}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline138.png?pub-status=live\" width=\"156\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline138.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline138.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{x}\\mathbin{-}{lsb}\\;{x}\\mathrel{=}{atLSB}\\;{dec}\\;{x}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cspan\u003eProof\u003c/span\u003e Straightforward induction on \u003cem\u003ex\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e We can formally relate the “shifting with a sentinel” scheme to the use of \u003cem\u003eatLSB\u003c/em\u003e, with the following (admittedly rather technical) lemma:\u003c/p\u003e\u003cp\u003e\u003cspan\u003eLemma 6.5\u003c/span\u003e (sentinel). Let \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline139.png?pub-status=live\" width=\"28\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline139.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline139.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n {\\geqslant} 1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e and let \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline140.png?pub-status=live\" width=\"104\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline140.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline140.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f}\\mathbin{::}{Bits}\\to {Bits}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e be a function such that\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e1.\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline141.png?pub-status=live\" width=\"246\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline141.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline141.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${({f}\\mathbin{\\circ}{set}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{x}\\mathrel{=}({set}\\;({n}\\mathbin{+}\\mathrm{1})\\mathbin{\\circ}{f})\\;{x}}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e for any \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline142.png?pub-status=live\" width=\"69\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline142.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline142.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$0 \u0026lt; x \u0026lt; 2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\u003cp\u003e\u003cspan\u003e2.\u003c/span\u003e \n\u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline143.png?pub-status=live\" width=\"69\" height=\"16\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline143.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline143.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n${{f}\\;{x}} \u0026lt; 2^{n+1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e for any \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline144.png?pub-status=live\" width=\"117\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline144.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline144.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$0 \u0026lt; x \u0026lt; 2^n + 2^{n-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e Then for all \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline145.png?pub-status=live\" width=\"68\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline145.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline145.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$0 \u0026lt; x \u0026lt; 2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU6.png?pub-status=live\" width=\"319\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU6.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU6.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {({unshift}\\;({n}\\mathbin{+}\\mathrm{1})\\mathbin{\\circ}{f}\\mathbin{\\circ}{shift}\\;({n}\\mathbin{+}\\mathrm{1}))\\;{x}\\mathrel{=}{atLSB}\\;{f}\\;{x}}. \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\n\n\u003cp\u003e The proof is rather tedious and not all that illuminating, so we omit it\u003c/p\u003e\n\u003cp\u003e (an extended version including a full proof may be found on the author’s website, at \u003ca href=\"http://ozark.hendrix.edu/\"\u003ehttp://ozark.hendrix.edu/\u003c/a\u003e yorgey/pub/Fenwick-ext.pdf). However, we do note that both \u003cem\u003einc\u003c/em\u003e and \u003cem\u003edec\u003c/em\u003e fit the criteria for \u003cem\u003ef\u003c/em\u003e: incrementing or decrementing some \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline146.png?pub-status=live\" width=\"69\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline146.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline146.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$0 \u0026lt; x \u0026lt; 2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e cannot affect the \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline147.png?pub-status=live\" width=\"46\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline147.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline147.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$(n+1)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003est bit as long as \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline148.png?pub-status=live\" width=\"29\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline148.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline148.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$n {\\geqslant} 1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e, and the result of incrementing or decrementing a number less than \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline149.png?pub-status=live\" width=\"62\" height=\"14\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline149.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline149.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^n + 2^{n-1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e will be a number less than \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline150.png?pub-status=live\" width=\"28\" height=\"13\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline150.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline150.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^{n+1}$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. We can now put all the pieces together show that adding the LSB at each step is the correct way to implement \u003cem\u003eupdate\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"the6_6\" id=\"the6_6\"\u003e\n\n\u003cp\u003e\u003cspan\u003eTheorem 6.6\u003c/span\u003e Adding the LSB is the correct way to move up a Fenwick-indexed tree to the nearest active parent, that is, \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU7.png?pub-status=live\" width=\"520\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU7.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU7.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{activeParentFenwick}\\mathrel{=}{b2f\u0026#39;}\\;{n}\\mathbin{\\circ}{activeParentBinary}\\mathbin{\\circ}{f2b\u0026#39;}\\;{n}\\mathrel{=}\\lambda {x}\\to {x}\\mathbin{+}{lsb}\\;{x}} \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e everywhere on the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline151.png?pub-status=live\" width=\"40\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline151.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline151.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1, 2^n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. (We exclude \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline152.png?pub-status=live\" width=\"14\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline152.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline152.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$2^n$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e since it corresponds to the root of the tree under a Fenwick indexing scheme.)\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e \u003cstrong\u003eProof\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"dispU9030\" id=\"dispU9030\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9030.png?pub-status=live\" width=\"631\" height=\"268\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9030.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9030.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e We can carry out a similar process to derive an implementation for prefix query (which supposedly involves \u003cem\u003esubtracting\u003c/em\u003e the LSB). Again, if we want to compute the sum of [1, \u003cem\u003ej\u003c/em\u003e], we can start at index \u003cem\u003ej\u003c/em\u003e in the Fenwick array, which stores the sum of the unique segment ending at \u003cem\u003ej\u003c/em\u003e. If the node at index \u003cem\u003ej\u003c/em\u003e stores the segment [\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e], we next need to find the unique node storing a segment that ends at \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline153.png?pub-status=live\" width=\"31\" height=\"11\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline153.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline153.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$i-1$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e. We can do this repeatedly, adding up segments as we go.\u003c/p\u003e\n\u003cp\u003e Staring at Figure \u003ca href=\"#f20\"\u003e20\u003c/a\u003e for inspiration, we can see that what we want to do is find the \u003cem\u003eleft sibling\u003c/em\u003e of our \u003cem\u003eclosest inactive parent\u003c/em\u003e, that is, we go up until finding the first ancestor which is a right child, then go to its left sibling. Under a binary indexing scheme, this can be implemented simply as:\u003c/p\u003e\n\u003cdiv data-magellan-destination=\"f20\" id=\"f20\"\u003e\n\n\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig20.png?pub-status=live\" width=\"2136\" height=\"1096\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig20.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_fig20.png\"/\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cspan\u003eFig. 20\u003c/span\u003e Moving up a segment tree to find successive prefix segments.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"dispU9031\" id=\"dispU9031\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9031.png?pub-status=live\" width=\"447\" height=\"75\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9031.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9031.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"the6_7\" id=\"the6_7\"\u003e\n\n\u003cp\u003e\u003cspan\u003eTheorem 6.7\u003c/span\u003e Subtracting the LSB is the correct way to move up a Fenwick-indexed tree to the active node covering the segment previous to the current one, that is, \u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU8.png?pub-status=live\" width=\"524\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU8.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU8.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n\\[ {{prevSegmentFenwick}\\mathrel{=}{b2f\u0026#39;}\\;{n}\\mathbin{\\circ}{prevSegmentBinary}\\mathbin{\\circ}{f2b\u0026#39;}\\;{n}\\mathrel{=}\\lambda {x}\\to {x}\\mathbin{-}{lsb}\\;{x}} \\]\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/p\u003e\u003cp\u003e everywhere on the range \u003cspan data-mathjax-status=\"alt-graphic\"\u003e\n\u003cspan\u003e\n\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline154.png?pub-status=live\" width=\"41\" height=\"17\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline154.png\" data-zoomable=\"false\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_inline154.png\"/\u003e\n\u003cspan data-mathjax-type=\"texmath\"\u003e\u003cspan\u003e\n$[1, 2^n)$\n\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\n\u003c/span\u003e.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cdiv data-magellan-destination=\"prf5\" id=\"prf5\"\u003e\n\n\u003cp\u003e\u003cspan\u003eProof\u003c/span\u003e \n\u003c/p\u003e\u003cdiv data-magellan-destination=\"dispU9032\" id=\"dispU9032\"\u003e\n\u003cp\u003e\u003cimg data-src=\"https://static.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9032.png?pub-status=live\" width=\"788\" height=\"539\" data-original-image=\"/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9032.png\" data-zoomable=\"true\" src=\"https://www.cambridge.org/binary/version/id/urn:cambridge.org:id:binary:20250116174732089-0720:S0956796824000169:S0956796824000169_eqnU9032.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003c/div\u003e\n\n\u003c/div\u003e\n\u003cdiv data-magellan-destination=\"s7\" id=\"s7\"\u003e\n\n\u003ch2\u003e\u003cspan\u003e7\u003c/span\u003e Conclusion\u003c/h2\u003e\n\u003cp\u003e Historically, to my knowledge, Fenwick trees were not actually developed as an optimization of segment trees as presented here. This has merely been a fictional—but hopefully illuminating—alternate history of ideas, highlighting the power of functional thinking, domain-specific languages, and equational reasoning to explore relationships between different structures and algorithms. As future work, it would be interesting to explore some of the mentioned generalizations of segment trees, to see whether one can derive Fenwick-like structures that support additional operations.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "45 min read",
  "publishedTime": null,
  "modifiedTime": null
}
