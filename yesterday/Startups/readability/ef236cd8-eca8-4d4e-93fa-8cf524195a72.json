{
  "id": "ef236cd8-eca8-4d4e-93fa-8cf524195a72",
  "title": "SRAM Has No Chill: Exploiting Power Domain Separation to Steal On-Chip Secrets",
  "link": "https://cacm.acm.org/research-highlights/sram-has-no-chill-exploiting-power-domain-separation-to-steal-on-chip-secrets/",
  "description": "Article URL: https://cacm.acm.org/research-highlights/sram-has-no-chill-exploiting-power-domain-separation-to-steal-on-chip-secrets/ Comments URL: https://news.ycombinator.com/item?id=44689402 Points: 12 # Comments: 1",
  "author": "zdw",
  "published": "Fri, 25 Jul 2025 22:47:52 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "David Roman",
  "length": 41541,
  "excerpt": "An increasingly connected world makes us dependent on computing devices that handle a wide range of security- and privacy-critical operations. We use smartphones and watches to manage bank transactions and store biometric information. On the industrial and government side, embedded devices monitor remote system operations and feed data critical to industrial processes and national defense. Physical access to these devices leads to a wide range of security exploits, including impersonation, proprietary software cloning, and infiltration and exploitation of industrial and defense infrastructures.",
  "siteName": "Communications of the ACM",
  "favicon": "https://cacm.acm.org/wp-content/uploads/2023/11/cropped-cropped-cacm_favicon-1.png?w=192",
  "text": "1 IntroductionAn increasingly connected world makes us dependent on computing devices that handle a wide range of security- and privacy-critical operations. We use smartphones and watches to manage bank transactions and store biometric information. On the industrial and government side, embedded devices monitor remote system operations and feed data critical to industrial processes and national defense. Physical access to these devices leads to a wide range of security exploits, including impersonation, proprietary software cloning, and infiltration and exploitation of industrial and defense infrastructures.A standard approach to prevent data theft from a system’s non-volatile memory (NVM) is to enforce full-disk encryption methods, such as BitLocker and VeraCrypt. These encryption methods protect data using a password or PIN so that even if a device is lost or stolen, NVM remains inaccessible to an attacker. Disk encryption changed the attackers’ focus on other types of memories, such as DRAM. Halderman et al. show how an attacker gains access to a disk encryption key by cold booting a system and dumping its main memory.10 In this attack, the authors use low temperature (–50∘C) to ‘freeze’ the data in DRAM cells so that even if the memory is out of power for a short time, it retains its logic states. Once ‘frozen’, an attacker physically removes and inserts the victim DRAM in another machine to run forensics on the dumped memory image. While this attack is practical for larger devices where DRAM is removable (for example, laptops), it poses a few technical challenges for mobile and other embedded devices. In an embedded device, memory chips and processors are soldered on the pc boards (PCBs), making it difficult to remove them from a system. FROST17 overcomes this challenge by allowing device reset to factory default—preserving DRAM’s content while the device boots from another media.To defend devices from cold boot attacks, researchers have proposed numerous methods where sensitive code and data remain encrypted in on-chip memory; decryption occurs only in the on-chip memories such as caches.16,26 Since systems-on-a-chip (SoCs) already contain large enough on-chip storage to hold keys and cryptographic states, executing software on the memory requires no additional hardware. For example, TRESOR uses x86 debug registers to store sensitive AES states without leaking security-critical information to off-chip memory.16 Researchers extend this idea to ARM devices, where the CPU fetches the encrypted software and data to the on-chip memories before decryption and execution.6,7,8,9,23,26 These works advocate fully on-chip execution for cryptographic operations because attacking a processor’s internal memory is expensive and demands sophisticated attack methods, such as decapsulation. This article evaluates the security of on-chip computation schemes, specifically under the cold boot attack model and empirically shows that these methods are secure from the traditional cold boot attack.10On-chip memories, primarily SRAM, are integrated directly into the processor die, offering greater security against physical attacks (for example, probing attacks11,26) compared to off-chip memories. Research shows that SRAM can partially retain data for a few milliseconds under extremely low temperatures (below –110∘C).1 However, achieving such temperatures poses significant challenges, risks damaging components such as the battery, and requires specialized equipment. Additionally, exploiting SRAM in embedded devices typically necessitates a physical power disconnect, which far exceeds SRAM’s brief data retention time.This article introduces Volt Boot, a method for executing physical memory disclosure attacks on on-chip SRAM memories by exploiting SoCs’ power domain separation. These domains operate at specific voltages, managed by components such as PMICs, capacitors, and inductors, to balance performance and power efficiency. We demonstrate that traditional cold-boot-style attacks, which leverage low-temperature-induced data retention, are ineffective on embedded SRAM (§Section 3). We uncover a new attack vector that exploits power domain separation of modern SoCs and show that such architectural design choices can be weaponized for leaking fully on-chip security-critical information(§Section 4). Using three commercially available Cortex-A profile devices, we demonstrate the attack by retrieving data from caches (§Section 6.1), CPU registers (§Section 6.2), and iRAMs (§Section 6.3). Provided that an application runs from internal memory (for example, cache) undisturbed by operating system’s background process, we retrieve memory image with 100% accuracy. Finally, we analyze the trade-offs involved in potential countermeasures (§Section 7)2 BackgroundOn-chip SRAM: Static random access memory (SRAM) is the building block of temporary on-chip storage, such as caches, iRAM, registers, translation lookaside buffers (TLBs), and branch target buffers (BTBs), making them one of the most common type of memory in modern computing devices. Figure 1 illustrates a typical SRAM cell, which is composed of two inverters in a positive feedback configuration to store one bit of data. Transistors N1 and N2 provide access to the data bit (Q) and its complement (∼Q), respectively. Unless a processor executes a read/write command, Word Line remains de-asserted with data stored in the cross-coupled structure formed by inverters. Figure 1.  Schematic diagram of a typical SRAM cell.Unlike other types of memory, direct access (that is, direct software read/write) to many types of on-chip SRAM (for example, instruction cache) is uncommon in typical processors. However, most architectures provide access to these internal memories through various methods to debug low-level memory errors; ARM provides co-processor instructions in ARMv8 architecture, while RISC-V processors22 allow memory-mapped access. For a more concrete example, the Cortex-A72 processor offers access to 15 distinct internal RAMs—including caches, TLBs, and BTBs—via its cp15 co-processor interface.Fully on-chip computation: Storing plain-text security-critical information in a DRAM is unsafe, motivating both industry and academic research to push for safer off-chip memory management schemes. Since Intel’s 6th generation, all subsequent processors are able to obfuscate data in the DDR3 and DDR4 DRAMs using session keys and pseudo-random numbers.15,25 For devices without inline encryption, researchers propose fully SoC-bound computations where sensitive information never leaves a chip’s physical boundary.In most cases, it is unnecessary to encrypt and decrypt every memory-bound transaction as software can store intermediate states in on-chip memories as plain text. This idea inspired numerous on-chip computation methods. Sentry7 and Copker9 uses iRAMs and caches as temporary memory to avoid exposing secrets to DRAM. Cache-assisted secure execution (CaSe) extends this idea by adding Trust-Zone support to a partially locked cache. The processor fetches encrypted software from main memory and stores it in a locked cache as plain text. From this point, the plain-text data/code remains in the cache for the duration of execution. Similarly, TRESOR,16 PRIME,8 and Security Through Amnesia23 use on-chip registers (for example, debug) to implement cryptographic algorithms on-chip. These methods essentially emulate a microcontroller’s behavior in an application processor and reduce the attack surface to the border of the chip itself. Given no plain-text data is released off-chip, these methods provide strong security against the most sophisticated physical memory disclosure attacks, for example, cold boot.Power domain separation. SoCs integrate numerous circuit blocks, each exhibiting unique analog characteristics. To meet stringent performance and power efficiency requirements, these blocks are divided into separate voltage domains. The power management unit (PMU) within the SoC dynamically manages the voltage levels for these domains at runtime, tailoring them to the workload of each domain.In modern, complex SoCs, dozens of off-chip supply pins connect to various power domains, enabling precise control over analog circuit behavior. This setup mitigates challenges such as ground bounce, power-supply noise, and per-pin current limitations. We broadly categorize the power-supply domains of an SoC into three main areas, as illustrated in Figure 2:Core power domain: The processing elements are in this domain. For example, the ARM cluster in a multi-core SoC draws power from the core supply voltage domain. Apart from computing elements such as CPU extensions and GPUs, this domain supplies power to L1 caches and their associated control circuitry.Memory power domain: This domain supplies power to the memories and their associated peripherals. Most SoCs manage main memory, non-volatile memory (for example, Flash), and L2/L3 caches with this power domain.I/O power domain: Power for the I/O controllers and external peripherals is drawn from this domain. Figure 2.  A simplified block diagram of an SoC’s power domains. The PMIC is an external component that maintains a specific voltage level at each power-domain supply pin.SoC designers subdivide power domains into smaller logical blocks that allow fine-grain control of the different components within an SoC. For example, some processors allow powering down individual cache components in its L1 memory domain through software.3 The domains are separated using power gating to balance energy consumption and performance of independent blocks at startup and runtime.3 Cold Booting On-Chip SRAM Is IneffectiveIn the absence of refresh, a DRAM cell’s data-retention time depends on the time it takes for capacitors to leak enough charge to alter the digital value sensed. Temperature affects DRAM cell discharge rate; lower temperatures increase data retention time. Reducing the temperature of a memory device keeps the data in the memory for a short period even if the power is turned off, which is the fundamental idea behind the cold boot attack.10 Both DRAM and SRAM partially retain their data across power cycles for a short time when the temperature is reduced below a certain level1,2,10 due to their intrinsic capacitance (although DRAM has much longer retention time). We discuss the technical hurdles that prevent a cold boot attack on SRAM as follows:SRAM’s placement: On-chip SRAMs are tightly coupled with processing cores and are built into the processor die itself. Such placement of SRAM makes it inaccessible given the traditional physical attacker threat model. The embedded nature of SRAMs complicates the cooling process as well because an attacker needs to freeze the entire device. Cold booting this memory requires extreme low temperature and risks bricking of the system.Short retention time: We cannot launch a cold boot attack on embedded memories by resetting a device through software because a system easily prevents such attempts by purging residual memories as part of a core’s power down sequence.5 Disconnecting the power from a device is the only reliable way to prevent the system from executing any residual memory-purging routines.An abrupt power disconnect from a device while executing critical security operations ensures target information remains in SRAM. To power cycle an embedded device, we must manually disconnect its power supply (for example, the battery). As the literature suggests, SRAM retains information for only a few milliseconds—even under extremely cold conditions, which is insufficient to execute a reboot by manually disconnecting power from a device.17Effect of low temperature: Typically, systems turn off when the operating temperature crosses a certain threshold set by the manufacturers. Executing a cold boot attack on SRAM requires extremely low temperature (below –110∘),1 which is far beyond the operating limit of most devices. We reproduced a similar attack as FROST17 in cache memory (SRAM, as opposed to the DRAM targeted in the original attack) of a Raspberry Pi 4 (a quad-core cortex-A72 device) to study cold temperature data retention of its embedded SRAM.3 We load bare-metal software to populate both the d-cache and i-cache of each core and extract the cached data in a binary image. Then the device undergoes static cooling in a TestEquity thermal chamber for an hour to stabilize the core temperature. We power cycle the device for a few milliseconds and extract the cache data to compare it to previously stored binaries. Table 1 lists the mean mismatch between post-reboot retrieved cache and pre-stored binary for each core at different temperatures. The information retrieval errors indicate almost no data retention even at –40∘C. Note SRAMs boot up into random states where approximately 50% of the bits are 1s.Table 1.  Errors in d-cache data after a cold boot attack execution in a BCM2711 SoC. We compute a mean error for each core at different temperatures. The fractional Hamming distance between cache content after power cycle and cache’s startup state is ∼ 0.10, indicating no data retention. Temperature 0 ∘ C – 5 ∘ C – 40 ∘ C Recommended Min.SoC’s hard limitError50.14%50.06%50.39%4 Volt BootVolt Boot is an attack that exploits an SoC’s power domain separation to induce cross-power-cycle data retention in embedded SRAM. In this section, we show circuit design choices made for power and performance reasons lead to a new cold-boot-style attack, but with increased precision and fewer requirements than traditional low-temperature-based data retention attacks.4.1 Threat model.Our threat model is based on the cold boot attack10 where an attacker has physical access to a device. The most significant modifications to the original cold boot threat model are the location and type of the memory. Our target is SRAM embedded within the core of a device, which prevents direct access to the memory contents without damaging the chip. Then the attacker boots the victim device from a media, for example, boot ROM or USB, to dump the uninitialized volatile memory image. This threat model is consistent with the threat model presented in the FROST,17 Sentry,7 and CaSE26 systems. These papers consider an adversary capable of capturing a device (that is, lost or stolen) that is protected against memory disclosure attacks using a lock screen and off-chip memory encryption.Our threat model extends to headless embedded devices that collect, store, and transfer sensitive information in an unsupervised environment. Note that a number of system-protection methods exist where devices are permanently locked from programming or software updates. The behavior of such devices resembles an application-specific IC (ASIC), and we consider these systems out of the scope of our threat model.4.2 Inducing data retention.SoCs need external pins to supply specific voltage to optimize performance and efficiently use energy under fluctuating loads. Usually, a PMIC supplies power to each domain in a particular order to bring up the board from reset. Figure 3 illustrates how a typical PMIC is used to drive an SoC. Generally, LDOs supply power to the domains where voltage fluctuation is limited, whereas domains with high load fluctuation (and dynamic voltage and frequency scaling) use switching regulators to save energy from heat loss. When a power domain of an SoC draws a large current under the demand of software/hardware, the parasitic inductance of the board and the package drop the voltage at the supply lines; this is called droop. To counter droop, the supply voltage pins are extended out of the SoC to connect capacitors so that they ‘absorb’ the current surge, keeping supply voltage closer to nominal. Regardless of the type of regulator used in a power domain, the pins connected to the PMIC require passive components to filter out noise generated during load fluctuation. Figure 3.  Typical power supply system. The LC combination supply lines are for switching regulators, whereas the decoupling capacitor filters out noise during fluctuating load driven by LDOs.Each power domain is power-gated to allow independent control at startup and run-time. Our observation is that if we externally maintain a steady voltage to the pin that supplies power to a target memory domain, it retains SRAM data—even while the rest of the system undergoes a power cycle. We maintain the domain voltage level from an external voltage probe while disconnecting the main supply line to the PMIC. That is, Volt Boot artificially creates SRAM data retention across a power cycle using a voltage probe in a PCB’s test pad or bare passive component’s lead that is connected to a target memory domain.As discussed in Section Section 3, cold booting is an impractical way of attacking on-chip SRAM. Even if it is possible to retain information across power cycles, the extracted data is erroneous because SRAM’s charge leakage follows a normal distribution, and so some cells will lose their data even for a short power disconnect.19 Note that SRAM cells are bistable, which makes it harder to look for keys using the algorithm proposed in the original cold boot attack.10 Since our attack involves no other physical variables (for example, temperature) and memory discharge rate, manufacturing technology node is irrelevant.4.3 Attack enablers.While power domain separation serves as the basis for our attack, a combined effect of multiple aspects and attributes of a system enables Volt Boot. We identify each attack enablers as follows:Ubiquity of SRAM: SRAM is available in every computing device, ranging from resource-constrained microcontrollers to server-class processors. We can induce artificial SRAM state retention in any SoC that has separate SRAM and compute core power domains.Internal RAMs store data in plain-text: As mentioned in Section Section 2, cryptography application developers consider on-chip memories safer compared to external memories. As a result, unlike external DRAMs, scrambling or encrypting SRAM’s data is uncommon in commodity processors. Thus, access to data residing in on-chip SRAM guarantees a plain-text version of the information, even if external memories implement scrambling or encryption.Domain-specific exposed power-supply pins: As discussed, performance, energy efficiency, and die area reduction are the primary reasons to expose domain-specific voltage pins out of an SoC; some of these pins are connected to the embedded SRAM. By construction, data remains error-free in SRAM as long as its supply voltage remains above its data-retention voltage. Note, this voltage is well below the nominal supply voltage of the power domain the cells are connoted to. The power domain separation through power-gating methods and dedicated pins exposed from the SoCs let us shut down the entire system while the small portion that holds sensitive data ‘alive.’No default RAM reset hardware: SRAM stays at an uninitialized state after booting-up because of two main reasons: First, some SRAMs are large (\u003e1MB) compared to the other on-chip resources, and resetting such large memory by iterating over the entire address (usually line by line for caches) space reduces boot speed significantly. Second, SRAM’s startup state has numerous security applications, such as PUF21 and TRNG.12 Note that cleaning and invalidating a cache at the boot phase does not erase the contents; these operations set the invalid bits to prevent a cache hit, but the data remains unchanged. The co-processor interface still allows reading out the cache contents from a proper exception level (EL3 for ARM devices). Therefore, initializing cache lines using a software interface is currently the only means to reset the power-on state of L1 caches, which needs the execution of DC ZVA instructions for every line.3,4 The purpose of this instruction is to allow initializing a large block of memory in the cache for a particular data structure without writing zeros in the external memories. Note cleaning/invalidation instructions apply to both instruction and data caches, but resetting instructions are exclusive to d-caches.5 Attack EvaluationAn SoC’s domain-separated power management architecture allows us to supply voltage to a target memory through exposed pins and keep part of the chip active (that is, retaining state) while the rest of the system resets. The actual method used to access embedded SRAM varies depending on the targeted SoC, but devices’ power-supply methods are very similar at a high level. We evaluate Volt Boot using ARM devices from different vendors, and to explore the generality of the attack, we choose devices that span a broad range of applications. For example, Raspberry Pis represents a wide array of systems, ranging from embedded devices common in IoT applications to systems capable of running a full-fledged operating system. To expand the targeted memory types, we include an SoC designed for multimedia applications, because it contains large memory-mapped SRAM (that is, iRAM). Table 2 lists the specification of the evaluation platforms. The SoCs in these systems draw power from three different power-management devices, and we observe similar circuit design choices for the off-chip passive components (see Figure 3).Table 2.  Evaluation platforms and SoCs. System on ChipCPU coreBoardSRAMManufacturerBCM2711Quad-core Cortex-A72Raspberry pi 4 Model BL1I: 48KB, L1D: 32KB, L2: 1MBBroadcomBCM2837Quad-core Cortex-A53Raspberry pi 3 Model BL1I: 32KB, L1D: 32KB, L2: 512KBi.MX535Cortex-A8i.MX53 Evaluation boardL1I:32KB, L1D: 32KB, L2: 256KB, iRAM: 128KBNXPWe use a bench power supply with a current-driving capability of more than 3A to ensure stable voltage delivery to the target power domain of the SoC. Although attaching a probe at the same voltage level typically draws only a few milliamps, a sudden disconnection of the compute core supply line from the PMIC causes a momentary current surge in the target power domain. This surge can lead to a voltage drop below the SRAM’s data-retention threshold (§Section 2), resulting in errors in the extracted data. Consequently, a power supply capable of providing sufficient current is crucial, especially when the target memory domain also powers the CPU core(s).5.1 Attack execution steps.In this section, we discuss how to execute an attack on SoCs (see Figure 4 for summary).Identifying target domains and their associated pins: To target a device, the first step is identifying the pins supplying power to the SRAM. Directly locating these pins on an SoC is often impractical due to advanced packaging, such as BGA. However, exact pins are not necessary, as supply pins connect to nearby passive components (for example, decoupling capacitors) or test pads, typically near the PMIC. Their layout generally follows a standard pattern (see Figure 3). For our evaluation platforms, Table 3 lists the test points and pin names, with visual representations in Figure 5.Attaching a voltage probe: We measure the nominal voltage at the target pin(s) and connect an external power supply at the same level. The power source must provide sufficient current to maintain the voltage when the device’s main power is off, preventing data loss. For example, a Raspberry Pi 4 draws 400–600mA through test pad TP15 with an 800mV probe, depending on workload. When the main supply is disconnected, the cores draw power from the probe, which keeps the voltage constant even during high momentary current demand. After a few microseconds, current drops to 8mA, and the memory remains in retention state indefinitely.Power cycling and booting the system: Once the external probe is in place, we disconnect the device from the main power source while our voltage probe keeps the target SRAM in its data retention state.Systems vary in boot-up methods after power down—some require user data erasure to boot from alternative media, while others boot internally without external media. We emulate this by booting Raspberry Pis from USB storage and use a post-reboot data-extraction program to:(A)Reduce contamination on the SRAM’s retained data during boot-up by avoiding storing data to it (either explicitly or implicitly).(B)Exfiltrate data from the SRAM to other memory (for example, Flash, DRAM, or a debugger) for post-processing.The cache extraction software uses CP15 instructions to read cache data into general-purpose registers. For out-of-order processors, data (DSB SY) and instruction (ISB) synchronization barriers must follow cache access instructions, such as the Cortex-A72’s SYS #0, c15, c4, #0, \u003cxt\u003e for RAMINDEX operations. Data is then transferred from CPU registers to DRAM via standard load/store instructions.For iRAM, we dump data directly using the debug interface. On the i.MX535 (Cortex-A8), which boots without external firmware, we connect a JTAG probe to automate iRAM reading process.Analyzing the memory contents: The attacker must tailor post-processing strategies based on the target SRAM and their objectives. Volt Boot reads memory without errors, but noise in the extracted data can arise from the dynamic behavior of the software (in cache) during an attack. For instance, extracting cryptographic keys from cache memory with precision depends heavily on the workload of the processing core and the influence of background processes. Figure 4.  Executing Volt Boot attack.Table 3.  Volt Boot evaluation platforms, test pads, and their nominal voltages. BoardsPCB Test Pads to ProbeNominal VoltageTarget MemoriesPower DomainsRaspberry Pi 3PP581.2VL1D, L1I, registersCore (VDD_CORE)Raspberry Pi 4TP150.8VL1D, L1I, registersCore (VDD_CORE)i.MX53SH131.3ViRAMMemory (VDDAL1) Figure 5.  Pictures of our evaluation platforms (a) Raspberry Pi 4, (b) Raspberry Pi 3, and (c) i.MX535, showing the test points we attach our voltage probe to.5.2 Attacker accessible memory area.At startup, the CPU uses part of the embedded SRAM before even an attacker has access to those memories. What percentage of memory is available after SoC boot-up depends on the target memory type of an SoC. To find the accessible proportion of the SRAM, we execute bare-metal software that populates a target memory with predefined patterns. The bare-metal setup allows us to calculate the effect of the CPU’s boot phase on internal memories, avoiding dynamic behavior, such as cache eviction. Once the software loads the data/instruction in the target memory, we execute the steps discussed above.Our experiments on the L1 caches of the BCM2711 and BCM2837 show no clobbering during the initial boot phase, consistent with the fact that L1 caches in these SoCs are software-enabled. This allows an attacker to avoid activating the cache, thereby accessing its full contents.In contrast, these Broadcom devices feature a built-in video core that shares the L2 cache with the ARM CPU cores. During startup, the video core uses pre-compiled binaries for system initialization, overwriting L2 cache contents and preventing any post-reboot data recovery.The i.MX535 has similar behavior for caches, but boot ROM uses part of the iRAM as scratchpad memory before initializing the DRAM controllers. That is, the CPU resets part of iRAM before allowing any debug connection or software execution. Such a boot method is standard among Cortex-M devices; they clobber 2KB SRAM (main memory) at the boot phase.14,24 Our experiments show that approximately 95% of an i.MX535’s iRAM is exposed to Volt Boot.6 Attack Execution in Different SRAMA successful cold boot attack depends on several factors, including temperature and the intrinsic data-retention time of SRAM, which is largely determined by its manufacturing technology. To execute the attack, the attacker must abruptly power off the device to avoid memory corruption or defensive data-wiping mechanisms.Next, the attacker reduces the device’s temperature, as lower temperatures significantly enhance the accuracy of the extracted data within a fixed period of power loss. Following this, the victim device needs to be rebooted.In commercial devices, the most common method of abrupt power-off is physically removing the battery or disconnecting the power supply. However, such operations typically take several hundred milliseconds—far exceeding the data retention limits of SRAM under standard conditions.1Volt Boot is a non-invasive memory-disclosure attack that uses for voltage-induced cross-power-cycle data retention for SRAM. The ultimate result of such data retention resembles a cold-boot-style attack with higher accuracy—without exposing a device to very low temperatures. Volt Boot exploits power-domain separation in modern SoCs, eliminating variables such as data-retention time and temperature. We execute three example attacks using the devices listed in Table 2. Our proof-of-concept attacks empirically demonstrate the vulnerability of computation methods that store secrets as plain-text in caches, registers, and iRAMs.6.1 Attacking caches.Attacking caches with bare-metal software: In this scenario, we evaluate how Volt Boot targets a device running bare-metal software, emulating typical embedded systems designed for specialized tasks such as monitoring and data collection. We develop a bare-metal program that enables the caches and executes NOP instructions across all four cores, allowing us to accurately measure the extent of software extracted by Volt Boot. To maintain precise control over the execution environment, we implement the software in aarch64 assembly.We perform the attack on Raspberry Pi devices and compare the cache content to the ground truth machine code. Figure 6 shows the cached content post-attack, with 100% data retention accuracy across all cores of both devices. Figure 6.  Snapshots of i-cache after attacking bare-metal software in (a) BCM2711 and (b) BCM2837 SoCs. Uninitialized cache cells power on into random state, but when we execute Volt Boot attack, instructions stay in the i-cache across power cycles.Attacking caches with an OS: We demonstrate how Volt Boot extracts data from a user application running on a general-purpose system—the Linux kernel. The application stores a specific pattern (0xAA) in a large data structure and reads it back. During execution, we perform the attack steps outlined in Section Section 5.1 and visualize the post-attack d-cache snapshots in Figure 7. The d-cache correctly contains the expected pattern (that is, 0xAA). Additionally, we analyze the i-cache and confirm that all instructions for our application are present, matching the ground truth machine code and occupying consecutive address spaces. Figure 7.  Snapshots of the caches after executing Volt Boot on a system running a general application. We generate the cache images from one way of each type of cache.To quantify the effect of a cache’s dynamic behavior on a Linux-based system, we write a microbenchmark with variable array size; the benchmark loads the array from the Flash to DRAM (and d-cache). We run the benchmark in a standard Raspberry Pi OS running on a Raspberry Pi 4.20 This SoC has a 32KB two-way set-associative data cache. We vary the number of 8-byte elements in the array by increasing the size of the array in each set of experiments. The size of the array varies from 12.5% (4KB) of the cache size to full-cache size (32KB); by extension, the number of elements in the array varies from 512 to 2,048. We repeat Volt Boot attack on each array size three times and calculate an average number of elements retrieved for each array size (that is, a total of 12 experiments for four different array sizes). We launch one benchmark process per core, which allows us to analyze how L1 cache’s (per core) dynamic behavior affects Volt Boot’s data retrieval accuracy. At the time of the attack, the victim system concurrently runs four processes in the four different cores of the Cortex-A72 CPU. In each experiment, our post-processing script compares the array elements with the retrieved cache image of each core. Note that other processes (and the kernel) evict cache lines, therefore, an element of the array can be in both ways of the cache in a modified state. We consider an element of the array present in the d-cache only when the entire 8-byte array element is present in the cache. Table 4 lists the results of the L1 data cache data-extraction experiment. A 4KB array contains 512 array elements and Volt Boot retrieves all the elements. Volt Boot retrieves approximately 90% of the array elements when the array size is close to the cache size. That is, when the data size approaches the total cache size, information retrieval accuracy decreases. The kernel’s background processes introduce errors in the data extraction by evicting cache lines when the size of a data structure is comparable to the cache size. Note that in the case of on-chip crypto, which uses cache locking (for example, CaSE26), Volt Boot retrieves the entire binary of plain-text software since neither the kernel nor other processes can evict secret-holding cache lines.Table 4.  Extracted data from d-cache of a BCM2711 SoC using Volt Boot attack. The size of the d-cache in this SoC is 32KB, which is divided into two ways, W0 and W1.    W 0 W 1 W 0 ∪ W 1 % data extracted4KBCore 0373.0309.0512.0100.00%Core 1338.7341.0512.0100.00%Core 2354.7340.7512.0100.00%Core 3363.0318.0512.0100.00%8KBCore 0591.0633.01,024.0100.00%Core 1580.7659.71,023.799.97%Core 2564.7656.71,024.0100.00%Core 3581.0656.71,024.0100.00%16KBCore 01,177.31,067.32,048.0100.00%Core 11,155.01,097.32,048.0100.00%Core 21,179.71,084.72,045.099.85%Core 31,114.31,139.02,048.0100.00%32KBCore 01,956.71,990.73,747.391.49%Core 11,980.31,970.73,753.091.63%Core 21,984.01,977.33759.391.78%Core 31,878.01,815.33,509.085.67%6.2 Attacking registers.Modern SoCs contain different types of CPU registers that are not part of a typical boot sequence, for example, ARM cores use vector registers \u003cv0...v31\u003e to process SIMD and floating-point instructions. These registers are relatively large (128-bit) and byte-addressable, making them suitable for storing security-sensitive states (for example, key schedules) of cryptographic algorithms, such as AES. Given our threat model, we investigate whether these registers are vulnerable to Volt Boot.We develop a bare-metal program in aarch64 assembly that initializes the vector registers with distinct patterns, such as 0xFF and 0xAA. Post-attack analysis on the BCM2711 and BCM2837 reveals that these vector registers completely retain their states during the execution of the Volt Boot attack. Consequently, any on-chip cryptographic program relying on these registers to conceal secrets is vulnerable to Volt Boot.6.3 Attacking iRAM.iRAMs (also known as OCRAM) are on-chip memories that an SoC uses as temporary storage for different applications, such as boot firmware and multimedia streaming. We study the vulnerability of these memories to Volt Boot attack using a multimedia SoC, the i.MX535,18 which contains 128KB of iRAM. This memory block is in the L1 power domain, which draws current through VDDAL1 pin of the SoC. Unlike the BCM2711 and the BCM2837, the i.MX535’s ARM core itself draws power through a different pin, VCCGP. The i.MX535 boots from internal ROM, and attacking this SoC does not require any external boot media (for example, Flash). That is, this device essentially behaves as a microcontroller at startup. For automation, we attach a JTAG reader to read/write to the iRAM directly and store four copies of a 512×512 (128KB) bitmap image to quantify the accuracy of data extraction through Volt Boot attack.As detailed in Section Section 5.2, the entire iRAM cannot be retrieved because the internal boot firmware partially overwrites it before handing control to external software. The overall extraction error is 2.7%. To identify the source, we compute the Hamming distance between the image binary and the extracted iRAM binary at 512-bit granularity (Figure 8). Errors are clustered near the beginning and end of the iRAM, with the largest range between 0xF800083C and 0xF80018CC, consistent with other i.MX535 devices. Figure 8.  Hamming distance between image and post-attack binary.7 CountermeasuresTo assess potential countermeasures, we break down the Volt Boot attack into two broad phases: (a) inducing SRAM data retention across power cycles, and (b) accessing the unmodified SRAM contents after the system reboots. Mitigating the attack requires disrupting at least one of these critical steps. This section outlines potential countermeasures, targeting both phases: the first three approaches address data retention, while the last two focus on preventing access to retained data.Eliminating power domain separation: The decision to separate circuit blocks into power domains involves numerous levels of hardware design stack, ranging from device manufacturing to architecture. Eliminating power domain separation is not a practical countermeasure due to performance, efficiency, and implementation concerns.Purging residual memory: A straightforward way to avoid on-chip data retention in the caches and other SRAMs is to erase the memory as part of the processor’s power-down sequence. Such a software/hardware-driven approach is not a practical solution to defend against Volt Boot because an abrupt power disconnect from a live device stops all operations immediately.Resetting SRAM at startup: Even if an attacker successfully retains the memory states after a power cycle, it becomes useless if there is no feasible method to extract the retained information after a reboot. Resetting the memory using hardware such as MBIST prevent this attack.Our experiments across various devices reveal that hardware SRAM resets during boot are uncommon. Most boot with undefined SRAM states, persisting until overwritten by software. While armv8.A allows L2 cache resets via the nL2RST pin, this does not apply to L1 caches. Furthermore, the CPU does not benefit from resetting the data and instruction RAMs because the cache operation is dependent on the status of tag RAMs (for example, L1D-tag and L1I-tag) not the data RAMs (for example, L1D-data and L1I-Data). Data RAMs can only be reset via ISA-provided software zero-ization, which is not available for all internal RAMs. A simpler alternative is toggling SRAM power at reset, but this hardware-based solution is impractical for existing SoCs due to required hardware modifications.TrustZone support: ARM TrustZones (TZ) is a hardware-backed memory isolation technique available in most Cortex-A profile processors. Enforcing TZ support prevents unauthorized access (from non-secure state) to memory locations marked secure. An attempt to access a secure line from a non-secure state triggers a hardware exception. The secure data remains inaccessible to an attacker across power cycles when TZ is enforced because the only way to read secure memory content is to change the security attribute of the memory location; such reset erases the memory content.Mandated authenticated boot: Volt Boot needs to boot the system with an exploitable system image. Signing the system with an OEM’s signature and burning the hash of the image in the fuses prevents an attacker from booting a device from another media. Note that all devices do not have mandated authenticated boot functionality as it complicates post-deployment firmware updates for simpler embedded devices. Additionally, some processors boot from an internal boot ROM and use the internal RAM as a scratchpad, providing direct access to on-chip memory. This design is based on the assumption that on-chip SRAM does not retain any data across power cycles.8 ConclusionThe last two decades of hardware security research have seen a rampant increase in proof-of-concept and real-world attacks targeting off-chip memories designs. Recent efforts to mitigate these attack surfaces primarily turn to on-chip computation—that is, Cache as RAM—as their deeply embedded nature renders all previous classes of attacks (for example, cold boot) obsolete. However, these systems’ reliance on power-domain separation enables a new class of attacks: Volt Boot.In this paper, we show that current on-chip SRAM is indeed resilient against conventional temperature “freezing”-based attacks. However, we show the effectiveness of a voltage-based attack that snapshots SRAM, without exposing an SoC to low temperature, effectively enabling the indefinite retention of SRAM data while software changes. Compared to previous-generation cold-boot attacks against standalone SRAM, Volt Boot achieves error-free data exfiltration on devices spanning three distinct microarchitectures—defeating the paradigm of on-chip computation as a viable defense against secret extraction.9 AcknowledgmentsThe project depicted is sponsored by the Defense Advanced Research Projects Agency (DARPA). The content of the information does not necessarily reflect the position or the policy of the government, and no official endorsement should be inferred.Previously PublishedThe original version of this paper was published in Proceedings of the 27th ACM Intern. Conf. on Architectural Support for Programming Languages and Operating Systems, 2022.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv lang=\"en\"\u003e\u003csection id=\"sec1\"\u003e\u003ch2\u003e\u003cspan\u003e1 \u003c/span\u003eIntroduction\u003c/h2\u003e\u003cp id=\"p-1\"\u003eAn increasingly connected world makes us dependent on computing devices that handle a wide range of security- and privacy-critical operations. We use smartphones and watches to manage bank transactions and store biometric information. On the industrial and government side, embedded devices monitor remote system operations and feed data critical to industrial processes and national defense. Physical access to these devices leads to a wide range of security exploits, including impersonation, proprietary software cloning, and infiltration and exploitation of industrial and defense infrastructures.\u003c/p\u003e\u003cp id=\"p-2\"\u003eA standard approach to prevent data theft from a system’s non-volatile memory (NVM) is to enforce full-disk encryption methods, such as BitLocker and VeraCrypt. These encryption methods protect data using a password or PIN so that even if a device is lost or stolen, NVM remains inaccessible to an attacker. Disk encryption changed the attackers’ focus on other types of memories, such as DRAM. Halderman \u003ci\u003eet al.\u003c/i\u003e show how an attacker gains access to a disk encryption key by \u003ci\u003ecold booting\u003c/i\u003e a system and dumping its main memory.\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e In this attack, the authors use low temperature (\u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmo\u003e–\u003c/mo\u003e\u003cmsup\u003e\u003cmn\u003e50\u003c/mn\u003e\u003cmo\u003e∘\u003c/mo\u003e\u003c/msup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e) to ‘freeze’ the data in DRAM cells so that even if the memory is \u003ci\u003eout of power\u003c/i\u003e for a short time, it retains its logic states. Once ‘frozen’, an attacker physically removes and inserts the victim DRAM in another machine to run forensics on the dumped memory image. While this attack is practical for larger devices where DRAM is removable (for example, laptops), it poses a few technical challenges for mobile and other embedded devices. In an embedded device, memory chips and processors are soldered on the pc boards (PCBs), making it difficult to remove them from a system. \u003ci\u003eFROST\u003c/i\u003e\u003ca href=\"#B17\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B17\"\u003e\u003csup\u003e17\u003c/sup\u003e\u003c/a\u003e overcomes this challenge by allowing device reset to factory default—preserving DRAM’s content while the device boots from another media.\u003c/p\u003e\u003cp id=\"p-3\"\u003eTo defend devices from cold boot attacks, researchers have proposed numerous methods where sensitive code and data remain encrypted in on-chip memory; decryption occurs only in the on-chip memories such as caches.\u003ca href=\"#B16\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B16\"\u003e\u003csup\u003e16\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B26\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B26\"\u003e\u003csup\u003e26\u003c/sup\u003e\u003c/a\u003e Since systems-on-a-chip (SoCs) already contain large enough on-chip storage to hold keys and cryptographic states, executing software on the memory requires no additional hardware. For example, \u003ci\u003eTRESOR\u003c/i\u003e uses x86 debug registers to store sensitive AES states without leaking security-critical information to off-chip memory.\u003ca href=\"#B16\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B16\"\u003e\u003csup\u003e16\u003c/sup\u003e\u003c/a\u003e Researchers extend this idea to ARM devices, where the CPU fetches the encrypted software and data to the on-chip memories before decryption and execution.\u003ca href=\"#B6\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B6\"\u003e\u003csup\u003e6\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B7\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B7\"\u003e\u003csup\u003e7\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B8\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B8\"\u003e\u003csup\u003e8\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B9\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B9\"\u003e\u003csup\u003e9\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B23\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B23\"\u003e\u003csup\u003e23\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B26\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B26\"\u003e\u003csup\u003e26\u003c/sup\u003e\u003c/a\u003e These works advocate fully on-chip execution for cryptographic operations because attacking a processor’s internal memory is expensive and demands sophisticated attack methods, such as decapsulation. This article evaluates the security of on-chip computation schemes, specifically under the cold boot attack model and empirically shows that these methods are secure from the traditional cold boot attack.\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"p-4\"\u003eOn-chip memories, primarily SRAM, are integrated directly into the processor die, offering greater security against physical attacks (for example, probing attacks\u003ca href=\"#B11\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B11\"\u003e\u003csup\u003e11\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B26\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B26\"\u003e\u003csup\u003e26\u003c/sup\u003e\u003c/a\u003e) compared to off-chip memories. Research shows that SRAM can partially retain data for a few milliseconds under extremely low temperatures (below \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmo\u003e–\u003c/mo\u003e\u003cmsup\u003e\u003cmn\u003e110\u003c/mn\u003e\u003cmo\u003e∘\u003c/mo\u003e\u003c/msup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003c/math\u003e\u003c/span\u003e).\u003ca href=\"#B1\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B1\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e However, achieving such temperatures poses significant challenges, risks damaging components such as the battery, and requires specialized equipment. Additionally, exploiting SRAM in embedded devices typically necessitates a physical power disconnect, which far exceeds SRAM’s brief data retention time.\u003c/p\u003e\u003cp id=\"p-5\"\u003eThis article introduces \u003ci\u003eVolt Boot\u003c/i\u003e, a method for executing physical memory disclosure attacks on on-chip SRAM memories by exploiting SoCs’ power domain separation. These domains operate at specific voltages, managed by components such as PMICs, capacitors, and inductors, to balance performance and power efficiency. We demonstrate that traditional cold-boot-style attacks, which leverage low-temperature-induced data retention, are ineffective on embedded SRAM (§\u003ca href=\"#sec3\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec3\"\u003eSection 3\u003c/a\u003e). We uncover a new attack vector that exploits \u003ci\u003epower domain separation\u003c/i\u003e of modern SoCs and show that such \u003ci\u003earchitectural design choices can be weaponized\u003c/i\u003e for leaking fully on-chip security-critical information(§\u003ca href=\"#sec4\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec4\"\u003eSection 4\u003c/a\u003e). Using \u003ci\u003ethree\u003c/i\u003e commercially available Cortex-A profile devices, we demonstrate the attack by retrieving data from caches (§\u003ca href=\"#sec12\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec12\"\u003eSection 6.1\u003c/a\u003e), CPU registers (§\u003ca href=\"#sec13\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec13\"\u003eSection 6.2\u003c/a\u003e), and iRAMs (§\u003ca href=\"#sec14\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec14\"\u003eSection 6.3\u003c/a\u003e). Provided that an application runs from internal memory (for example, cache) undisturbed by operating system’s background process, we retrieve memory image with \u003cb\u003e100% accuracy\u003c/b\u003e. Finally, we analyze the trade-offs involved in potential countermeasures (§\u003ca href=\"#sec15\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec15\"\u003eSection 7\u003c/a\u003e)\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec2\"\u003e\u003ch2\u003e\u003cspan\u003e2 \u003c/span\u003eBackground\u003c/h2\u003e\u003cp id=\"p-6\"\u003e\u003cb\u003eOn-chip SRAM:\u003c/b\u003e Static random access memory (SRAM) is the building block of temporary on-chip storage, such as caches, iRAM, registers, translation lookaside buffers (TLBs), and branch target buffers (BTBs), making them one of the most common type of memory in modern computing devices. Figure \u003ca href=\"#F1\" data-jats-ref-type=\"fig\" data-jats-rid=\"F1\"\u003e1\u003c/a\u003e illustrates a typical SRAM cell, which is composed of two inverters in a positive feedback configuration to store one bit of data. Transistors N1 and N2 provide access to the data bit (Q) and its complement (\u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmo\u003e∼\u003c/mo\u003e\u003c/math\u003e\u003c/span\u003eQ), respectively. Unless a processor executes a read/write command, \u003ci\u003eWord Line\u003c/i\u003e remains de-asserted with data stored in the cross-coupled structure formed by inverters.\u003c/p\u003e\u003cfigure id=\"F1\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig01.jpg\" data-type=\"image\" data-caption=\"Figure 1. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig01.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 1. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig01.jpg\" alt=\"\" data-image-id=\"F1\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 1. \u003c/span\u003e \u003cspan\u003eSchematic diagram of a typical SRAM cell.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"p-8\"\u003eUnlike other types of memory, \u003ci\u003edirect access\u003c/i\u003e (that is, direct software read/write) to many types of on-chip SRAM (for example, instruction cache) is uncommon in typical processors. However, most architectures provide access to these internal memories through various methods to debug low-level memory errors; ARM provides co-processor instructions in ARMv8 architecture, while RISC-V processors\u003ca href=\"#B22\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B22\"\u003e\u003csup\u003e22\u003c/sup\u003e\u003c/a\u003e allow memory-mapped access. For a more concrete example, the Cortex-A72 processor offers access to 15 distinct internal RAMs—including caches, TLBs, and BTBs—via its \u003ccode\u003ecp15\u003c/code\u003e co-processor interface.\u003c/p\u003e\u003cp id=\"p-9\"\u003e\u003cb\u003eFully on-chip computation:\u003c/b\u003e Storing plain-text security-critical information in a DRAM is unsafe, motivating both industry and academic research to push for safer off-chip memory management schemes. Since Intel’s 6\u003csup\u003eth\u003c/sup\u003e generation, all subsequent processors are able to obfuscate data in the DDR3 and DDR4 DRAMs using session keys and pseudo-random numbers.\u003ca href=\"#B15\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B15\"\u003e\u003csup\u003e15\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B25\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B25\"\u003e\u003csup\u003e25\u003c/sup\u003e\u003c/a\u003e For devices without inline encryption, researchers propose fully SoC-bound computations where sensitive information never leaves a chip’s physical boundary.\u003c/p\u003e\u003cp id=\"p-10\"\u003eIn most cases, it is unnecessary to encrypt and decrypt every memory-bound transaction as software can store intermediate states in on-chip memories as plain text. This idea inspired numerous on-chip computation methods. Sentry\u003ca href=\"#B7\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B7\"\u003e\u003csup\u003e7\u003c/sup\u003e\u003c/a\u003e and Copker\u003ca href=\"#B9\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B9\"\u003e\u003csup\u003e9\u003c/sup\u003e\u003c/a\u003e uses iRAMs and caches as temporary memory to avoid exposing secrets to DRAM. \u003ci\u003eCache-assisted secure execution (CaSe)\u003c/i\u003e extends this idea by adding Trust-Zone support to a partially locked cache. The processor fetches encrypted software from main memory and stores it in a locked cache as plain text. From this point, the plain-text data/code remains in the cache for the duration of execution. Similarly, TRESOR,\u003ca href=\"#B16\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B16\"\u003e\u003csup\u003e16\u003c/sup\u003e\u003c/a\u003e PRIME,\u003ca href=\"#B8\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B8\"\u003e\u003csup\u003e8\u003c/sup\u003e\u003c/a\u003e and Security Through Amnesia\u003ca href=\"#B23\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B23\"\u003e\u003csup\u003e23\u003c/sup\u003e\u003c/a\u003e use on-chip registers (for example, debug) to implement cryptographic algorithms on-chip. These methods essentially emulate a microcontroller’s behavior in an application processor and reduce the attack surface to the border of the chip itself. Given no plain-text data is released off-chip, these methods provide strong security against the most sophisticated physical memory disclosure attacks, for example\u003ci\u003e,\u003c/i\u003e cold boot.\u003c/p\u003e\u003cp id=\"p-11\"\u003e\u003cb\u003ePower domain separation.\u003c/b\u003e SoCs integrate numerous circuit blocks, each exhibiting unique analog characteristics. To meet stringent performance and power efficiency requirements, these blocks are divided into separate voltage domains. The power management unit (PMU) within the SoC dynamically manages the voltage levels for these domains at runtime, tailoring them to the workload of each domain.\u003c/p\u003e\u003cp id=\"p-12\"\u003eIn modern, complex SoCs, dozens of off-chip supply pins connect to various power domains, enabling precise control over analog circuit behavior. This setup mitigates challenges such as ground bounce, power-supply noise, and per-pin current limitations. We broadly categorize the power-supply domains of an SoC into three main areas, as illustrated in Figure \u003ca href=\"#F2\" data-jats-ref-type=\"fig\" data-jats-rid=\"F2\"\u003e2\u003c/a\u003e:\u003c/p\u003e\u003cul data-jats-list-type=\"bullet\"\u003e\u003cli\u003e\u003cp id=\"p-13\"\u003e\u003cb\u003eCore power domain:\u003c/b\u003e The processing elements are in this domain. For example, the ARM cluster in a multi-core SoC draws power from the core supply voltage domain. Apart from computing elements such as CPU extensions and GPUs, this domain supplies power to L1 caches and their associated control circuitry.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp id=\"p-14\"\u003e\u003cb\u003eMemory power domain:\u003c/b\u003e This domain supplies power to the memories and their associated peripherals. Most SoCs manage main memory, non-volatile memory (for example, Flash), and L2/L3 caches with this power domain.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp id=\"p-15\"\u003e\u003cb\u003eI/O power domain:\u003c/b\u003e Power for the I/O controllers and external peripherals is drawn from this domain.\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cfigure id=\"F2\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig02.jpg\" data-type=\"image\" data-caption=\"Figure 2. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig02.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 2. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig02.jpg\" alt=\"\" data-image-id=\"F2\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 2. \u003c/span\u003e \u003cspan\u003eA simplified block diagram of an SoC’s power domains. The PMIC is an external component that maintains a specific voltage level at each power-domain supply pin.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"p-17\"\u003eSoC designers subdivide power domains into smaller logical blocks that allow fine-grain control of the different components within an SoC. For example, some processors allow powering down individual cache components in its \u003ccode\u003eL1\u003c/code\u003e memory domain through software.\u003ca href=\"#B3\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B3\"\u003e\u003csup\u003e3\u003c/sup\u003e\u003c/a\u003e The domains are separated using power gating to balance energy consumption and performance of independent blocks at startup and runtime.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec3\"\u003e\u003ch2\u003e\u003cspan\u003e3 \u003c/span\u003eCold Booting On-Chip SRAM Is Ineffective\u003c/h2\u003e\u003cp id=\"p-18\"\u003eIn the absence of refresh, a DRAM cell’s data-retention time depends on the time it takes for capacitors to leak enough charge to alter the digital value sensed. Temperature affects DRAM cell discharge rate; lower temperatures increase data retention time. Reducing the temperature of a memory device keeps the data in the memory for a short period even if the power is turned off, which is the fundamental idea behind the cold boot attack.\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e Both DRAM and SRAM partially retain their data across power cycles for a short time when the temperature is reduced below a certain level\u003ca href=\"#B1\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B1\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B2\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B2\"\u003e\u003csup\u003e2\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e due to their intrinsic capacitance (although DRAM has much longer retention time). We discuss the technical hurdles that prevent a cold boot attack on SRAM as follows:\u003c/p\u003e\u003cp id=\"p-19\"\u003e\u003cb\u003eSRAM’s placement:\u003c/b\u003e On-chip SRAMs are tightly coupled with processing cores and are built into the processor die itself. Such placement of SRAM makes it inaccessible given the traditional physical attacker threat model. The \u003ci\u003eembedded nature\u003c/i\u003e of SRAMs complicates the cooling process as well because an attacker needs to freeze the entire device. \u003ci\u003eCold booting\u003c/i\u003e this memory requires extreme low temperature and risks bricking of the system.\u003c/p\u003e\u003cp id=\"p-20\"\u003e\u003cb\u003eShort retention time:\u003c/b\u003e We cannot launch a cold boot attack on embedded memories by resetting a device through software because a system easily prevents such attempts by purging residual memories as part of a core’s power down sequence.\u003ca href=\"#B5\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B5\"\u003e\u003csup\u003e5\u003c/sup\u003e\u003c/a\u003e Disconnecting the power from a device is the only reliable way to prevent the system from executing any residual memory-purging routines.\u003c/p\u003e\u003cp id=\"p-21\"\u003eAn abrupt power disconnect from a device while executing critical security operations ensures target information remains in SRAM. To power cycle an embedded device, we must manually disconnect its power supply (for example, the battery). As the literature suggests, SRAM retains information for only a few milliseconds—even under extremely cold conditions, which is insufficient to execute a reboot by manually disconnecting power from a device.\u003ca href=\"#B17\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B17\"\u003e\u003csup\u003e17\u003c/sup\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"p-22\"\u003e\u003cb\u003eEffect of low temperature:\u003c/b\u003e Typically, systems turn off when the operating temperature crosses a certain threshold set by the manufacturers. Executing a cold boot attack on SRAM requires extremely low temperature (below \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmo\u003e–\u003c/mo\u003e\u003cmsup\u003e\u003cmn\u003e110\u003c/mn\u003e\u003cmo\u003e∘\u003c/mo\u003e\u003c/msup\u003e\u003c/math\u003e\u003c/span\u003e),\u003ca href=\"#B1\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B1\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e which is far beyond the operating limit of most devices. We reproduced a similar attack as FROST\u003ca href=\"#B17\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B17\"\u003e\u003csup\u003e17\u003c/sup\u003e\u003c/a\u003e in cache memory (SRAM, as opposed to the DRAM targeted in the original attack) of a Raspberry Pi 4 (a quad-core cortex-A72 device) to study cold temperature data retention of its embedded SRAM.\u003ca href=\"#B3\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B3\"\u003e\u003csup\u003e3\u003c/sup\u003e\u003c/a\u003e We load bare-metal software to populate both the d-cache and i-cache of each core and extract the cached data in a binary image. Then the device undergoes static cooling in a TestEquity thermal chamber for an hour to stabilize the core temperature. We power cycle the device for a few milliseconds and extract the cache data to compare it to previously stored binaries. Table \u003ca href=\"#T1\" data-jats-ref-type=\"table\" data-jats-rid=\"T1\"\u003e1\u003c/a\u003e lists the \u003ci\u003emean\u003c/i\u003e mismatch between post-reboot retrieved cache and pre-stored binary for each core at different temperatures. The information retrieval errors indicate almost no data retention even at \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmo\u003e–\u003c/mo\u003e\u003cmsup\u003e\u003cmn\u003e40\u003c/mn\u003e\u003cmo\u003e∘\u003c/mo\u003e\u003c/msup\u003e\u003cmi\u003eC\u003c/mi\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e. Note SRAMs boot up into random states where approximately 50% of the bits are 1s.\u003c/p\u003e\u003cfigure id=\"T1\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003cspan\u003eTable 1. \u003c/span\u003e \u003cspan\u003eErrors in d-cache data after a cold boot attack execution in a BCM2711 SoC. We compute a mean error for each core at different temperatures. The fractional Hamming distance between cache content after power cycle and cache’s startup state is ∼ 0.10, indicating no data retention.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003ctable data-jats-frame=\"hsides\" data-jats-rules=\"rows\"\u003e\u003ccolgroup\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003c/colgroup\u003e\u003cthead\u003e\u003ctr\u003e\u003cth rowspan=\"2\"\u003eTemperature\u003c/th\u003e\u003cth\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmsup\u003e \u003cmn\u003e0\u003c/mn\u003e \u003cmo\u003e∘\u003c/mo\u003e \u003c/msup\u003e \u003cmi\u003eC\u003c/mi\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003cth rowspan=\"2\"\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmo\u003e–\u003c/mo\u003e \u003cmsup\u003e \u003cmn\u003e5\u003c/mn\u003e \u003cmo\u003e∘\u003c/mo\u003e \u003c/msup\u003e \u003cmi\u003eC\u003c/mi\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmo\u003e–\u003c/mo\u003e \u003cmsup\u003e \u003cmn\u003e40\u003c/mn\u003e \u003cmo\u003e∘\u003c/mo\u003e \u003c/msup\u003e \u003cmi\u003eC\u003c/mi\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003c/tr\u003e\u003ctr\u003e\u003cth\u003eRecommended Min.\u003c/th\u003e\u003cth\u003eSoC’s hard limit\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cb\u003eError\u003c/b\u003e\u003c/td\u003e\u003ctd\u003e50.14%\u003c/td\u003e\u003ctd\u003e50.06%\u003c/td\u003e\u003ctd\u003e50.39%\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003c/figure\u003e\u003c/section\u003e\u003csection id=\"sec4\"\u003e\u003ch2\u003e\u003cspan\u003e4 \u003c/span\u003eVolt Boot\u003c/h2\u003e\u003cp id=\"p-24\"\u003eVolt Boot is an attack that exploits an SoC’s power domain separation to induce cross-power-cycle data retention in embedded SRAM. In this section, we show circuit design choices made for power and performance reasons lead to a new cold-boot-style attack, but with increased precision and fewer requirements than traditional low-temperature-based data retention attacks.\u003c/p\u003e\u003csection id=\"sec5\"\u003e\u003ch3\u003e\u003cspan\u003e4.1 \u003c/span\u003eThreat model.\u003c/h3\u003e\u003cp id=\"p-25\"\u003eOur threat model is based on the cold boot attack\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e where an attacker has physical access to a device. The most significant modifications to the original cold boot threat model are the location and type of the memory. Our target is SRAM embedded within the core of a device, which prevents direct access to the memory contents without damaging the chip. Then the attacker boots the victim device from a media, for example, boot ROM or USB, to dump the uninitialized volatile memory image. This threat model is consistent with the threat model presented in the FROST,\u003ca href=\"#B17\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B17\"\u003e\u003csup\u003e17\u003c/sup\u003e\u003c/a\u003e Sentry,\u003ca href=\"#B7\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B7\"\u003e\u003csup\u003e7\u003c/sup\u003e\u003c/a\u003e and CaSE\u003ca href=\"#B26\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B26\"\u003e\u003csup\u003e26\u003c/sup\u003e\u003c/a\u003e systems. These papers consider an adversary capable of capturing a device (that is, lost or stolen) that is protected against memory disclosure attacks using a lock screen and off-chip memory encryption.\u003c/p\u003e\u003cp id=\"p-26\"\u003eOur threat model extends to headless embedded devices that collect, store, and transfer sensitive information in an unsupervised environment. Note that a number of system-protection methods exist where devices are permanently locked from programming or software updates. The behavior of such devices resembles an application-specific IC (ASIC), and we consider these systems out of the scope of our threat model.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec6\"\u003e\u003ch3\u003e\u003cspan\u003e4.2 \u003c/span\u003eInducing data retention.\u003c/h3\u003e\u003cp id=\"p-27\"\u003eSoCs need external pins to supply specific voltage to optimize performance and efficiently use energy under fluctuating loads. Usually, a PMIC supplies power to each domain in a particular order to bring up the board from reset. Figure \u003ca href=\"#F3\" data-jats-ref-type=\"fig\" data-jats-rid=\"F3\"\u003e3\u003c/a\u003e illustrates how a typical PMIC is used to drive an SoC. Generally, LDOs supply power to the domains where voltage fluctuation is limited, whereas domains with high load fluctuation (and dynamic voltage and frequency scaling) use switching regulators to save energy from heat loss. When a power domain of an SoC draws a large current under the demand of software/hardware, the parasitic inductance of the board and the package drop the voltage at the supply lines; this is called droop. To counter droop, the supply voltage pins are extended out of the SoC to connect capacitors so that they ‘absorb’ the current surge, keeping supply voltage closer to nominal. Regardless of the type of regulator used in a power domain, the pins connected to the PMIC require passive components to filter out noise generated during load fluctuation.\u003c/p\u003e\u003cfigure id=\"F3\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig03.jpg\" data-type=\"image\" data-caption=\"Figure 3. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig03.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 3. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig03.jpg\" alt=\"\" data-image-id=\"F3\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 3. \u003c/span\u003e \u003cspan\u003eTypical power supply system. The LC combination supply lines are for switching regulators, whereas the decoupling capacitor filters out noise during fluctuating load driven by LDOs.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"p-29\"\u003eEach power domain is power-gated to allow independent control at startup and run-time. Our observation is that if we externally maintain a steady voltage to the pin that supplies power to a target memory domain, it retains SRAM data—even while the rest of the system undergoes a power cycle. We maintain the domain voltage level from an external voltage probe while disconnecting the main supply line to the PMIC. That is, Volt Boot artificially creates SRAM data retention across a power cycle using a voltage probe in a PCB’s test pad or bare passive component’s lead that is connected to a target memory domain.\u003c/p\u003e\u003cp id=\"p-30\"\u003eAs discussed in Section \u003ca href=\"#sec3\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec3\"\u003eSection 3\u003c/a\u003e, cold booting is an impractical way of attacking on-chip SRAM. Even if it is possible to retain information across power cycles, the extracted data is erroneous because SRAM’s charge leakage follows a normal distribution, and so some cells will lose their data even for a short power disconnect.\u003ca href=\"#B19\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B19\"\u003e\u003csup\u003e19\u003c/sup\u003e\u003c/a\u003e Note that SRAM cells are bistable, which makes it harder to look for keys using the algorithm proposed in the original cold boot attack.\u003ca href=\"#B10\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B10\"\u003e\u003csup\u003e10\u003c/sup\u003e\u003c/a\u003e Since our attack involves no other physical variables (for example, temperature) and memory discharge rate, manufacturing technology node is irrelevant.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec7\"\u003e\u003ch3\u003e\u003cspan\u003e4.3 \u003c/span\u003eAttack enablers.\u003c/h3\u003e\u003cp id=\"p-31\"\u003eWhile power domain separation serves as the basis for our attack, a combined effect of multiple aspects and attributes of a system enables Volt Boot. We identify each attack enablers as follows:\u003c/p\u003e\u003cp id=\"p-32\"\u003e\u003cb\u003eUbiquity of SRAM:\u003c/b\u003e SRAM is available in every computing device, ranging from resource-constrained microcontrollers to server-class processors. We can induce artificial SRAM state retention in any SoC that has separate SRAM and compute core power domains.\u003c/p\u003e\u003cp id=\"p-33\"\u003e\u003cb\u003eInternal RAMs store data in plain-text:\u003c/b\u003e As mentioned in Section \u003ca href=\"#sec2\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec2\"\u003eSection 2\u003c/a\u003e, cryptography application developers consider on-chip memories safer compared to external memories. As a result, unlike external DRAMs, scrambling or encrypting SRAM’s data is uncommon in commodity processors. Thus, access to data residing in on-chip SRAM guarantees a plain-text version of the information, even if external memories implement scrambling or encryption.\u003c/p\u003e\u003cp id=\"p-34\"\u003e\u003cb\u003eDomain-specific exposed power-supply pins:\u003c/b\u003e As discussed, performance, energy efficiency, and die area reduction are the primary reasons to expose domain-specific voltage pins out of an SoC; some of these pins are connected to the embedded SRAM. By construction, data remains error-free in SRAM as long as its supply voltage remains above its data-retention voltage. Note, this voltage is well below the nominal supply voltage of the power domain the cells are connoted to. The power domain separation through power-gating methods and dedicated pins exposed from the SoCs let us shut down the entire system while the small portion that holds sensitive data ‘alive.’\u003c/p\u003e\u003cp id=\"p-35\"\u003e\u003cb\u003eNo default RAM reset hardware:\u003c/b\u003e SRAM stays at an uninitialized state after booting-up because of two main reasons: First, some SRAMs are large (\u0026gt;1MB) compared to the other on-chip resources, and resetting such large memory by iterating over the entire address (usually line by line for caches) space reduces boot speed significantly. Second, SRAM’s startup state has numerous security applications, such as PUF\u003ca href=\"#B21\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B21\"\u003e\u003csup\u003e21\u003c/sup\u003e\u003c/a\u003e and TRNG.\u003ca href=\"#B12\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B12\"\u003e\u003csup\u003e12\u003c/sup\u003e\u003c/a\u003e Note that cleaning and invalidating a cache at the boot phase does not erase the contents; these operations set the invalid bits to prevent a cache hit, but the data remains unchanged. The co-processor interface still allows reading out the cache contents from a proper exception level (\u003ccode\u003eEL3\u003c/code\u003e for ARM devices). Therefore, initializing cache lines using a software interface is currently the only means to reset the power-on state of L1 caches, which needs the execution of \u003ccode\u003eDC ZVA\u003c/code\u003e instructions for every line.\u003ca href=\"#B3\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B3\"\u003e\u003csup\u003e3\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B4\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B4\"\u003e\u003csup\u003e4\u003c/sup\u003e\u003c/a\u003e The purpose of this instruction is to allow initializing a large block of memory in the cache for a particular data structure without writing zeros in the external memories. Note cleaning/invalidation instructions apply to both instruction and data caches, but \u003ci\u003eresetting instructions\u003c/i\u003e are exclusive to d-caches.\u003c/p\u003e\u003c/section\u003e\u003c/section\u003e\u003csection id=\"sec8\"\u003e\u003ch2\u003e\u003cspan\u003e5 \u003c/span\u003eAttack Evaluation\u003c/h2\u003e\u003cp id=\"p-36\"\u003eAn SoC’s domain-separated power management architecture allows us to supply voltage to a target memory through exposed pins and keep part of the chip active (that is, retaining state) while the rest of the system resets. The actual method used to access embedded SRAM varies depending on the targeted SoC, but devices’ power-supply methods are very similar at a high level. We evaluate Volt Boot using ARM devices from different vendors, and to explore the generality of the attack, we choose devices that span a broad range of applications. For example, Raspberry Pis represents a wide array of systems, ranging from embedded devices common in IoT applications to systems capable of running a full-fledged operating system. To expand the targeted memory types, we include an SoC designed for multimedia applications, because it contains large memory-mapped SRAM (that is, iRAM). Table \u003ca href=\"#T2\" data-jats-ref-type=\"table\" data-jats-rid=\"T2\"\u003e2\u003c/a\u003e lists the specification of the evaluation platforms. The SoCs in these systems draw power from three different power-management devices, and we observe similar circuit design choices for the off-chip passive components (see Figure \u003ca href=\"#F3\" data-jats-ref-type=\"fig\" data-jats-rid=\"F3\"\u003e3\u003c/a\u003e).\u003c/p\u003e\u003cfigure id=\"T2\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003cspan\u003eTable 2. \u003c/span\u003e \u003cspan\u003eEvaluation platforms and SoCs.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003ctable data-jats-frame=\"hsides\" data-jats-rules=\"rows\"\u003e\u003ccolgroup\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003c/colgroup\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eSystem on Chip\u003c/th\u003e\u003cth\u003eCPU core\u003c/th\u003e\u003cth\u003eBoard\u003c/th\u003e\u003cth\u003eSRAM\u003c/th\u003e\u003cth\u003eManufacturer\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cb\u003eBCM2711\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eQuad-core Cortex-A72\u003c/td\u003e\u003ctd\u003eRaspberry pi 4 Model B\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eL1I: 48KB, L1D: 32KB, L2: 1MB\u003c/code\u003e\u003c/td\u003e\u003ctd rowspan=\"2\"\u003eBroadcom\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cb\u003eBCM2837\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eQuad-core Cortex-A53\u003c/td\u003e\u003ctd\u003eRaspberry pi 3 Model B\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eL1I: 32KB, L1D: 32KB, L2: 512KB\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cb\u003ei.MX535\u003c/b\u003e\u003c/td\u003e\u003ctd\u003eCortex-A8\u003c/td\u003e\u003ctd\u003ei.MX53 Evaluation board\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eL1I:32KB, L1D: 32KB, L2: 256KB, iRAM: 128KB\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNXP\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003c/figure\u003e\u003cp id=\"p-38\"\u003eWe use a bench power supply with a current-driving capability of more than 3A to ensure stable voltage delivery to the target power domain of the SoC. Although attaching a probe at the same voltage level typically draws only a few milliamps, a sudden disconnection of the compute core supply line from the PMIC causes a momentary current surge in the target power domain. This surge can lead to a voltage drop below the SRAM’s data-retention threshold (§\u003ca href=\"#sec2\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec2\"\u003eSection 2\u003c/a\u003e), resulting in errors in the extracted data. Consequently, a power supply capable of providing sufficient current is crucial, especially when the target memory domain also powers the CPU core(s).\u003c/p\u003e\u003csection id=\"sec9\"\u003e\u003ch3\u003e\u003cspan\u003e5.1 \u003c/span\u003eAttack execution steps.\u003c/h3\u003e\u003cp id=\"p-39\"\u003eIn this section, we discuss how to execute an attack on SoCs (see Figure \u003ca href=\"#F4\" data-jats-ref-type=\"fig\" data-jats-rid=\"F4\"\u003e4\u003c/a\u003e for summary).\u003c/p\u003e\u003cul data-jats-list-type=\"bullet\"\u003e\u003cli\u003e\u003cp id=\"p-40\"\u003e\u003cb\u003eIdentifying target domains and their associated pins:\u003c/b\u003e To target a device, the first step is identifying the pins supplying power to the SRAM. Directly locating these pins on an SoC is often impractical due to advanced packaging, such as BGA. However, exact pins are not necessary, as supply pins connect to nearby passive components (for example, decoupling capacitors) or test pads, typically near the PMIC. Their layout generally follows a standard pattern (see Figure \u003ca href=\"#F3\" data-jats-ref-type=\"fig\" data-jats-rid=\"F3\"\u003e3\u003c/a\u003e). For our evaluation platforms, Table \u003ca href=\"#T3\" data-jats-ref-type=\"table\" data-jats-rid=\"T3\"\u003e3\u003c/a\u003e lists the test points and pin names, with visual representations in Figure \u003ca href=\"#F5\" data-jats-ref-type=\"fig\" data-jats-rid=\"F5\"\u003e5\u003c/a\u003e.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp id=\"p-41\"\u003e\u003cb\u003eAttaching a voltage probe:\u003c/b\u003e We measure the nominal voltage at the target pin(s) and connect an external power supply at the same level. The power source must provide sufficient current to maintain the voltage when the device’s main power is off, preventing data loss. For example, a Raspberry Pi 4 draws 400–600mA through test pad \u003ccode\u003eTP15\u003c/code\u003e with an 800mV probe, depending on workload. When the main supply is disconnected, the cores draw power from the probe, which keeps the voltage constant even during high momentary current demand. After a few microseconds, current drops to 8mA, and the memory remains in retention state indefinitely.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp id=\"p-42\"\u003e\u003cb\u003ePower cycling and booting the system:\u003c/b\u003e Once the external probe is in place, we disconnect the device from the main power source while our voltage probe keeps the target SRAM in its data retention state.\u003c/p\u003e\u003cp id=\"p-43\"\u003eSystems vary in boot-up methods after power down—some require user data erasure to boot from alternative media, while others boot internally without external media. We emulate this by booting Raspberry Pis from USB storage and use a post-reboot data-extraction program to:\u003c/p\u003e\u003cul data-jats-list-type=\"simple\"\u003e\u003cli\u003e\u003cp\u003e(A)\u003c/p\u003e\u003cp id=\"p-44\"\u003eReduce contamination on the SRAM’s retained data during boot-up by avoiding storing data to it (either explicitly or implicitly).\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e(B)\u003c/p\u003e\u003cp id=\"p-45\"\u003eExfiltrate data from the SRAM to other memory (for example, Flash, DRAM, or a debugger) for post-processing.\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"p-46\"\u003eThe cache extraction software uses \u003ccode\u003eCP15\u003c/code\u003e instructions to read cache data into general-purpose registers. For out-of-order processors, data (\u003ccode\u003eDSB SY\u003c/code\u003e) and instruction (\u003ccode\u003eISB\u003c/code\u003e) synchronization barriers must follow cache access instructions, such as the Cortex-A72’s \u003ccode\u003eSYS #0, c15, c4, #0, \u0026lt;xt\u0026gt;\u003c/code\u003e for RAMINDEX operations. Data is then transferred from CPU registers to DRAM via standard load/store instructions.\u003c/p\u003e\u003cp id=\"p-47\"\u003eFor iRAM, we dump data directly using the debug interface. On the i.MX535 (Cortex-A8), which boots without external firmware, we connect a \u003ccode\u003eJTAG\u003c/code\u003e probe to automate iRAM reading process.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp id=\"p-48\"\u003e\u003cb\u003eAnalyzing the memory contents:\u003c/b\u003e The attacker must tailor post-processing strategies based on the target SRAM and their objectives. Volt Boot reads memory without errors, but noise in the extracted data can arise from the dynamic behavior of the software (in cache) during an attack. For instance, extracting cryptographic keys from cache memory with precision depends heavily on the workload of the processing core and the influence of background processes.\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cfigure id=\"F4\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig04.jpg\" data-type=\"image\" data-caption=\"Figure 4. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig04.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 4. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig04.jpg\" alt=\"\" data-image-id=\"F4\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 4. \u003c/span\u003e \u003cspan\u003eExecuting \u003ci\u003eVolt Boot\u003c/i\u003e attack.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure id=\"T3\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003cspan\u003eTable 3. \u003c/span\u003e \u003cspan\u003eVolt Boot evaluation platforms, test pads, and their nominal voltages.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003ctable data-jats-frame=\"hsides\" data-jats-rules=\"rows\"\u003e\u003ccolgroup\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003c/colgroup\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cp id=\"p-51\"\u003eBoards\u003c/p\u003e\u003c/th\u003e\u003cth\u003e\u003cp id=\"p-52\"\u003ePCB Test Pads to Probe\u003c/p\u003e\u003c/th\u003e\u003cth\u003e\u003cp id=\"p-53\"\u003eNominal Voltage\u003c/p\u003e\u003c/th\u003e\u003cth\u003e\u003cp id=\"p-54\"\u003eTarget Memories\u003c/p\u003e\u003c/th\u003e\u003cth\u003e\u003cp id=\"p-55\"\u003ePower Domains\u003c/p\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cp id=\"p-56\"\u003eRaspberry Pi 3\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-57\"\u003e\u003ccode\u003ePP58\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-58\"\u003e1.2V\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-59\"\u003eL1D, L1I, registers\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-60\"\u003eCore (\u003ci\u003eVDD_CORE\u003c/i\u003e)\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cp id=\"p-61\"\u003eRaspberry Pi 4\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-62\"\u003e\u003ccode\u003eTP15\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-63\"\u003e0.8V\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-64\"\u003eL1D, L1I, registers\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-65\"\u003eCore (\u003ci\u003eVDD_CORE\u003c/i\u003e)\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cp id=\"p-66\"\u003ei.MX53\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-67\"\u003e\u003ccode\u003eSH13\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-68\"\u003e1.3V\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-69\"\u003eiRAM\u003c/p\u003e\u003c/td\u003e\u003ctd\u003e\u003cp id=\"p-70\"\u003eMemory (\u003ci\u003eVDDAL\u003c/i\u003e1)\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003c/figure\u003e\u003cfigure id=\"F5\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig05.jpg\" data-type=\"image\" data-caption=\"Figure 5. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig05.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 5. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig05.jpg\" alt=\"\" data-image-id=\"F5\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 5. \u003c/span\u003e \u003cspan\u003ePictures of our evaluation platforms (a) Raspberry Pi 4, (b) Raspberry Pi 3, and (c) i.MX535, showing the test points we attach our voltage probe to.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003c/section\u003e\u003csection id=\"sec10\"\u003e\u003ch3\u003e\u003cspan\u003e5.2 \u003c/span\u003eAttacker accessible memory area.\u003c/h3\u003e\u003cp id=\"p-72\"\u003eAt startup, the CPU uses part of the embedded SRAM before even an attacker has access to those memories. What percentage of memory is available after SoC boot-up depends on the target memory type of an SoC. To find the accessible proportion of the SRAM, we execute bare-metal software that populates a target memory with predefined patterns. The bare-metal setup allows us to calculate the effect of the CPU’s boot phase on internal memories, avoiding dynamic behavior, such as cache eviction. Once the software loads the data/instruction in the target memory, we execute the steps discussed above.\u003c/p\u003e\u003cp id=\"p-73\"\u003eOur experiments on the L1 caches of the BCM2711 and BCM2837 show no clobbering during the initial boot phase, consistent with the fact that L1 caches in these SoCs are software-enabled. This allows an attacker to avoid activating the cache, thereby accessing its full contents.\u003c/p\u003e\u003cp id=\"p-74\"\u003eIn contrast, these Broadcom devices feature a built-in video core that shares the L2 cache with the ARM CPU cores. During startup, the video core uses pre-compiled binaries for system initialization, overwriting L2 cache contents and preventing any post-reboot data recovery.\u003c/p\u003e\u003cp id=\"p-75\"\u003eThe i.MX535 has similar behavior for caches, but boot ROM uses part of the iRAM as scratchpad memory before initializing the DRAM controllers. That is, the CPU resets part of iRAM before allowing any debug connection or software execution. Such a boot method is standard among Cortex-M devices; they clobber \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmi\u003eK\u003c/mi\u003e\u003cmi\u003eB\u003c/mi\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e SRAM (main memory) at the boot phase.\u003ca href=\"#B14\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B14\"\u003e\u003csup\u003e14\u003c/sup\u003e\u003c/a\u003e\u003csup\u003e,\u003c/sup\u003e\u003ca href=\"#B24\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B24\"\u003e\u003csup\u003e24\u003c/sup\u003e\u003c/a\u003e Our experiments show that approximately 95% of an i.MX535’s iRAM is exposed to Volt Boot.\u003c/p\u003e\u003c/section\u003e\u003c/section\u003e\u003csection id=\"sec11\"\u003e\u003ch2\u003e\u003cspan\u003e6 \u003c/span\u003eAttack Execution in Different SRAM\u003c/h2\u003e\u003cp id=\"p-76\"\u003eA successful cold boot attack depends on several factors, including temperature and the intrinsic data-retention time of SRAM, which is largely determined by its manufacturing technology. To execute the attack, the attacker must abruptly power off the device to avoid memory corruption or defensive data-wiping mechanisms.\u003c/p\u003e\u003cp id=\"p-77\"\u003eNext, the attacker reduces the device’s temperature, as lower temperatures significantly enhance the accuracy of the extracted data within a fixed period of power loss. Following this, the victim device needs to be rebooted.\u003c/p\u003e\u003cp id=\"p-78\"\u003eIn commercial devices, the most common method of abrupt power-off is physically removing the battery or disconnecting the power supply. However, such operations typically take several hundred milliseconds—far exceeding the data retention limits of SRAM under standard conditions.\u003ca href=\"#B1\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B1\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"p-79\"\u003eVolt Boot is a non-invasive memory-disclosure attack that uses for voltage-induced cross-power-cycle data retention for SRAM. The ultimate result of such data retention resembles a cold-boot-style attack with higher accuracy—without exposing a device to very low temperatures. Volt Boot exploits power-domain separation in modern SoCs, eliminating variables such as data-retention time and temperature. We execute three example attacks using the devices listed in Table \u003ca href=\"#T2\" data-jats-ref-type=\"table\" data-jats-rid=\"T2\"\u003e2\u003c/a\u003e. Our proof-of-concept attacks empirically demonstrate the vulnerability of computation methods that store secrets as plain-text in caches, registers, and iRAMs.\u003c/p\u003e\u003csection id=\"sec12\"\u003e\u003ch3\u003e\u003cspan\u003e6.1 \u003c/span\u003eAttacking caches.\u003c/h3\u003e\u003cp id=\"p-80\"\u003e\u003cb\u003eAttacking caches with bare-metal software:\u003c/b\u003e In this scenario, we evaluate how Volt Boot targets a device running bare-metal software, emulating typical embedded systems designed for specialized tasks such as monitoring and data collection. We develop a bare-metal program that enables the caches and executes \u003ccode\u003eNOP\u003c/code\u003e instructions across all four cores, allowing us to accurately measure the extent of software extracted by Volt Boot. To maintain precise control over the execution environment, we implement the software in \u003ccode\u003eaarch64\u003c/code\u003e assembly.\u003c/p\u003e\u003cp id=\"p-81\"\u003eWe perform the attack on Raspberry Pi devices and compare the cache content to the ground truth machine code. Figure \u003ca href=\"#F6\" data-jats-ref-type=\"fig\" data-jats-rid=\"F6\"\u003e6\u003c/a\u003e shows the cached content post-attack, with 100% data retention accuracy across all cores of both devices.\u003c/p\u003e\u003cfigure id=\"F6\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig06.jpg\" data-type=\"image\" data-caption=\"Figure 6. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig06.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 6. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig06.jpg\" alt=\"\" data-image-id=\"F6\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 6. \u003c/span\u003e \u003cspan\u003eSnapshots of i-cache after attacking bare-metal software in (a) BCM2711 and (b) BCM2837 SoCs. Uninitialized cache cells power on into random state, but when we execute Volt Boot attack, instructions stay in the i-cache across power cycles.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"p-83\"\u003e\u003cb\u003eAttacking caches with an OS:\u003c/b\u003e We demonstrate how Volt Boot extracts data from a user application running on a general-purpose system—the Linux kernel. The application stores a specific pattern (\u003ccode\u003e0xAA\u003c/code\u003e) in a large data structure and reads it back. During execution, we perform the attack steps outlined in Section \u003ca href=\"#sec9\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec9\"\u003eSection 5.1\u003c/a\u003e and visualize the post-attack d-cache snapshots in Figure \u003ca href=\"#F7\" data-jats-ref-type=\"fig\" data-jats-rid=\"F7\"\u003e7\u003c/a\u003e. The d-cache correctly contains the expected pattern (that is, \u003ccode\u003e0xAA\u003c/code\u003e). Additionally, we analyze the i-cache and confirm that all instructions for our application are present, matching the ground truth machine code and occupying consecutive address spaces.\u003c/p\u003e\u003cfigure id=\"F7\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig07.jpg\" data-type=\"image\" data-caption=\"Figure 7. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig07.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 7. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig07.jpg\" alt=\"\" data-image-id=\"F7\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 7. \u003c/span\u003e \u003cspan\u003eSnapshots of the caches after executing Volt Boot on a system running a general application. We generate the cache images from one way of each type of cache.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"p-85\"\u003eTo quantify the effect of a cache’s dynamic behavior on a Linux-based system, we write a microbenchmark with variable array size; the benchmark loads the array from the Flash to DRAM (and d-cache). We run the benchmark in a standard Raspberry Pi OS running on a Raspberry Pi 4.\u003ca href=\"#B20\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B20\"\u003e\u003csup\u003e20\u003c/sup\u003e\u003c/a\u003e This SoC has a 32KB two-way set-associative data cache. We vary the number of 8-byte elements in the array by increasing the size of the array in each set of experiments. The size of the array varies from 12.5% (4KB) of the cache size to full-cache size (32KB); by extension, the number of elements in the array varies from 512 to 2,048. We repeat Volt Boot attack on each array size three times and calculate an average number of elements retrieved for each array size (that is, a total of 12 experiments for four different array sizes). We launch one benchmark process per core, which allows us to analyze how L1 cache’s (per core) dynamic behavior affects Volt Boot’s data retrieval accuracy. At the time of the attack, the victim system concurrently runs four processes in the four different cores of the Cortex-A72 CPU. In each experiment, our post-processing script compares the array elements with the retrieved cache image of each core. Note that other processes (and the kernel) evict cache lines, therefore, an element of the array can be in both ways of the cache in a modified state. We consider an element of the array present in the d-cache only when the entire 8-byte array element is present in the cache. Table \u003ca href=\"#T4\" data-jats-ref-type=\"table\" data-jats-rid=\"T4\"\u003e4\u003c/a\u003e lists the results of the L1 data cache data-extraction experiment. A 4KB array contains 512 array elements and Volt Boot retrieves all the elements. Volt Boot retrieves approximately 90% of the array elements when the array size is close to the cache size. That is, when the data size approaches the total cache size, information retrieval accuracy decreases. The kernel’s background processes introduce errors in the data extraction by evicting cache lines when the size of a data structure is comparable to the cache size. Note that in the case of on-chip crypto, which uses cache locking (for example, \u003ci\u003eCaSE\u003c/i\u003e\u003ca href=\"#B26\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B26\"\u003e\u003csup\u003e26\u003c/sup\u003e\u003c/a\u003e), Volt Boot retrieves the entire binary of plain-text software since neither the kernel nor other processes can evict secret-holding cache lines.\u003c/p\u003e\u003cfigure id=\"T4\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003cspan\u003eTable 4. \u003c/span\u003e \u003cspan\u003eExtracted data from d-cache of a BCM2711 SoC using Volt Boot attack. The size of the d-cache in this SoC is 32KB, which is divided into two ways, \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmi\u003eW\u003c/mi\u003e\u003cmn\u003e0\u003c/mn\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e and \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmi\u003eW\u003c/mi\u003e\u003cmn\u003e1\u003c/mn\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e.\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003ctable data-jats-frame=\"hsides\" data-jats-rules=\"rows\"\u003e\u003ccolgroup\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003ccol/\u003e \u003c/colgroup\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e \u003c/th\u003e\u003cth\u003e \u003c/th\u003e\u003cth\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmi\u003eW\u003c/mi\u003e \u003cmn\u003e0\u003c/mn\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmi\u003eW\u003c/mi\u003e \u003cmn\u003e1\u003c/mn\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003cth\u003e\u003cspan\u003e \u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e \u003cmrow\u003e \u003cmi\u003eW\u003c/mi\u003e \u003cmn\u003e0\u003c/mn\u003e \u003cmo\u003e∪\u003c/mo\u003e \u003cmi\u003eW\u003c/mi\u003e \u003cmn\u003e1\u003c/mn\u003e \u003c/mrow\u003e \u003c/math\u003e \u003c/span\u003e\u003c/th\u003e\u003cth\u003e% data extracted\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd rowspan=\"4\"\u003e4KB\u003c/td\u003e\u003ctd\u003eCore 0\u003c/td\u003e\u003ctd\u003e373.0\u003c/td\u003e\u003ctd\u003e309.0\u003c/td\u003e\u003ctd\u003e512.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 1\u003c/td\u003e\u003ctd\u003e338.7\u003c/td\u003e\u003ctd\u003e341.0\u003c/td\u003e\u003ctd\u003e512.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 2\u003c/td\u003e\u003ctd\u003e354.7\u003c/td\u003e\u003ctd\u003e340.7\u003c/td\u003e\u003ctd\u003e512.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 3\u003c/td\u003e\u003ctd\u003e363.0\u003c/td\u003e\u003ctd\u003e318.0\u003c/td\u003e\u003ctd\u003e512.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd rowspan=\"4\"\u003e8KB\u003c/td\u003e\u003ctd\u003eCore 0\u003c/td\u003e\u003ctd\u003e591.0\u003c/td\u003e\u003ctd\u003e633.0\u003c/td\u003e\u003ctd\u003e1,024.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 1\u003c/td\u003e\u003ctd\u003e580.7\u003c/td\u003e\u003ctd\u003e659.7\u003c/td\u003e\u003ctd\u003e1,023.7\u003c/td\u003e\u003ctd\u003e99.97%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 2\u003c/td\u003e\u003ctd\u003e564.7\u003c/td\u003e\u003ctd\u003e656.7\u003c/td\u003e\u003ctd\u003e1,024.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 3\u003c/td\u003e\u003ctd\u003e581.0\u003c/td\u003e\u003ctd\u003e656.7\u003c/td\u003e\u003ctd\u003e1,024.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd rowspan=\"4\"\u003e16KB\u003c/td\u003e\u003ctd\u003eCore 0\u003c/td\u003e\u003ctd\u003e1,177.3\u003c/td\u003e\u003ctd\u003e1,067.3\u003c/td\u003e\u003ctd\u003e2,048.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 1\u003c/td\u003e\u003ctd\u003e1,155.0\u003c/td\u003e\u003ctd\u003e1,097.3\u003c/td\u003e\u003ctd\u003e2,048.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 2\u003c/td\u003e\u003ctd\u003e1,179.7\u003c/td\u003e\u003ctd\u003e1,084.7\u003c/td\u003e\u003ctd\u003e2,045.0\u003c/td\u003e\u003ctd\u003e99.85%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 3\u003c/td\u003e\u003ctd\u003e1,114.3\u003c/td\u003e\u003ctd\u003e1,139.0\u003c/td\u003e\u003ctd\u003e2,048.0\u003c/td\u003e\u003ctd\u003e100.00%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd rowspan=\"4\"\u003e32KB\u003c/td\u003e\u003ctd\u003eCore 0\u003c/td\u003e\u003ctd\u003e1,956.7\u003c/td\u003e\u003ctd\u003e1,990.7\u003c/td\u003e\u003ctd\u003e3,747.3\u003c/td\u003e\u003ctd\u003e91.49%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 1\u003c/td\u003e\u003ctd\u003e1,980.3\u003c/td\u003e\u003ctd\u003e1,970.7\u003c/td\u003e\u003ctd\u003e3,753.0\u003c/td\u003e\u003ctd\u003e91.63%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 2\u003c/td\u003e\u003ctd\u003e1,984.0\u003c/td\u003e\u003ctd\u003e1,977.3\u003c/td\u003e\u003ctd\u003e3759.3\u003c/td\u003e\u003ctd\u003e91.78%\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCore 3\u003c/td\u003e\u003ctd\u003e1,878.0\u003c/td\u003e\u003ctd\u003e1,815.3\u003c/td\u003e\u003ctd\u003e3,509.0\u003c/td\u003e\u003ctd\u003e85.67%\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003c/figure\u003e\u003c/section\u003e\u003csection id=\"sec13\"\u003e\u003ch3\u003e\u003cspan\u003e6.2 \u003c/span\u003eAttacking registers.\u003c/h3\u003e\u003cp id=\"p-87\"\u003eModern SoCs contain different types of CPU registers that are not part of a typical boot sequence, for example, ARM cores use vector registers \u003ccode\u003e\u0026lt;v0...v31\u0026gt;\u003c/code\u003e to process SIMD and floating-point instructions. These registers are relatively large (128-bit) and byte-addressable, making them suitable for storing security-sensitive states (for example, key schedules) of cryptographic algorithms, such as AES. Given our threat model, we investigate whether these registers are vulnerable to Volt Boot.\u003c/p\u003e\u003cp id=\"p-88\"\u003eWe develop a bare-metal program in \u003ccode\u003eaarch64\u003c/code\u003e assembly that initializes the vector registers with distinct patterns, such as 0xFF and 0xAA. Post-attack analysis on the BCM2711 and BCM2837 reveals that these vector registers completely retain their states during the execution of the Volt Boot attack. Consequently, any on-chip cryptographic program relying on these registers to conceal secrets is vulnerable to Volt Boot.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec14\"\u003e\u003ch3\u003e\u003cspan\u003e6.3 \u003c/span\u003eAttacking iRAM.\u003c/h3\u003e\u003cp id=\"p-89\"\u003eiRAMs (also known as OCRAM) are on-chip memories that an SoC uses as temporary storage for different applications, such as boot firmware and multimedia streaming. We study the vulnerability of these memories to Volt Boot attack using a multimedia SoC, the i.MX535,\u003ca href=\"#B18\" data-jats-ref-type=\"bibr\" data-jats-rid=\"B18\"\u003e\u003csup\u003e18\u003c/sup\u003e\u003c/a\u003e which contains 128KB of iRAM. This memory block is in the L1 power domain, which draws current through \u003ccode\u003eVDDAL1\u003c/code\u003e pin of the SoC. Unlike the BCM2711 and the BCM2837, the i.MX535’s ARM core itself draws power through a different pin, \u003ccode\u003eVCCGP\u003c/code\u003e. The i.MX535 boots from internal ROM, and attacking this SoC does not require any external boot media (for example, Flash). That is, this device essentially behaves as a microcontroller at startup. For automation, we attach a JTAG reader to read/write to the iRAM directly and store four copies of a \u003cspan\u003e\u003cmath xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"inline\"\u003e\u003cmrow\u003e\u003cmn\u003e512\u003c/mn\u003e\u003cmo\u003e×\u003c/mo\u003e\u003cmn\u003e512\u003c/mn\u003e\u003c/mrow\u003e\u003c/math\u003e\u003c/span\u003e (128KB) bitmap image to quantify the accuracy of data extraction through Volt Boot attack.\u003c/p\u003e\u003cp id=\"p-90\"\u003eAs detailed in Section \u003ca href=\"#sec10\" data-jats-ref-type=\"sec\" data-jats-rid=\"sec10\"\u003eSection 5.2\u003c/a\u003e, the entire iRAM cannot be retrieved because the internal boot firmware partially overwrites it before handing control to external software. The overall extraction error is 2.7%. To identify the source, we compute the Hamming distance between the image binary and the extracted iRAM binary at 512-bit granularity (Figure \u003ca href=\"#F8\" data-jats-ref-type=\"fig\" data-jats-rid=\"F8\"\u003e8\u003c/a\u003e). Errors are clustered near the beginning and end of the iRAM, with the largest range between 0xF800083C and 0xF80018CC, consistent with other i.MX535 devices.\u003c/p\u003e\u003cfigure id=\"F8\" data-jats-position=\"float\"\u003e\u003cp\u003e\u003ca data-fslightbox=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig08.jpg\" data-type=\"image\" data-caption=\"Figure 8. \" href=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig08.jpg\"\u003e\n\t\t\t\t\u003cimg decoding=\"async\" title=\"Figure 8. \" src=\"https://cacm.acm.org/wp-content/uploads/2025/06/3725845_fig08.jpg\" alt=\"\" data-image-id=\"F8\" data-image-type=\"figure\"/\u003e\n\t\t\t\u003c/a\u003e\n\t\t\u003c/p\u003e\u003cfigcaption\u003e\u003cspan\u003eFigure 8. \u003c/span\u003e \u003cspan\u003eHamming distance between image and post-attack binary.\u003c/span\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003c/section\u003e\u003c/section\u003e\u003csection id=\"sec15\"\u003e\u003ch2\u003e\u003cspan\u003e7 \u003c/span\u003eCountermeasures\u003c/h2\u003e\u003cp id=\"p-92\"\u003eTo assess potential countermeasures, we break down the \u003ci\u003eVolt Boot\u003c/i\u003e attack into two broad phases: (a) inducing SRAM data retention across power cycles, and (b) accessing the unmodified SRAM contents after the system reboots. Mitigating the attack requires disrupting at least one of these critical steps. This section outlines potential countermeasures, targeting both phases: the first three approaches address data retention, while the last two focus on preventing access to retained data.\u003c/p\u003e\u003cp id=\"p-93\"\u003e\u003cb\u003eEliminating power domain separation:\u003c/b\u003e The decision to separate circuit blocks into power domains involves numerous levels of hardware design stack, ranging from device manufacturing to architecture. Eliminating power domain separation is not a practical countermeasure due to performance, efficiency, and implementation concerns.\u003c/p\u003e\u003cp id=\"p-94\"\u003e\u003cb\u003ePurging residual memory:\u003c/b\u003e A straightforward way to avoid on-chip data retention in the caches and other SRAMs is to \u003ci\u003eerase\u003c/i\u003e the memory as part of the processor’s power-down sequence. Such a software/hardware-driven approach is not a practical solution to defend against Volt Boot because an abrupt power disconnect from a live device stops all operations immediately.\u003c/p\u003e\u003cp id=\"p-95\"\u003e\u003cb\u003eResetting SRAM at startup:\u003c/b\u003e Even if an attacker successfully retains the memory states after a power cycle, it becomes useless if there is no feasible method to extract the retained information after a reboot. Resetting the memory using hardware such as \u003ci\u003eMBIST\u003c/i\u003e prevent this attack.\u003c/p\u003e\u003cp id=\"p-96\"\u003eOur experiments across various devices reveal that hardware SRAM resets during boot are uncommon. Most boot with undefined SRAM states, persisting until overwritten by software. While \u003ccode\u003earmv8.A\u003c/code\u003e allows L2 cache resets via the \u003ccode\u003enL2RST\u003c/code\u003e pin, this does not apply to L1 caches. Furthermore, the CPU does not benefit from resetting the data and instruction RAMs because the cache operation is dependent on the status of tag RAMs (for example, L1D-tag and L1I-tag) not the data RAMs (for example, L1D-data and L1I-Data). Data RAMs can only be reset via ISA-provided software \u003ci\u003ezero-ization\u003c/i\u003e, which is not available for all internal RAMs. A simpler alternative is toggling SRAM power at reset, but this hardware-based solution is impractical for existing SoCs due to required hardware modifications.\u003c/p\u003e\u003cp id=\"p-97\"\u003e\u003cb\u003eTrustZone support:\u003c/b\u003e ARM TrustZones (TZ) is a hardware-backed memory isolation technique available in most Cortex-A profile processors. Enforcing TZ support prevents unauthorized access (from non-secure state) to memory locations marked secure. An attempt to access a secure line from a non-secure state triggers a hardware exception. The secure data remains inaccessible to an attacker across power cycles when TZ is enforced because the only way to read secure memory content is to change the security attribute of the memory location; such reset erases the memory content.\u003c/p\u003e\u003cp id=\"p-98\"\u003e\u003cb\u003eMandated authenticated boot:\u003c/b\u003e Volt Boot needs to boot the system with an exploitable system image. Signing the system with an OEM’s signature and burning the hash of the image in the fuses prevents an attacker from booting a device from another media. Note that all devices do not have mandated authenticated boot functionality as it complicates post-deployment firmware updates for simpler embedded devices. Additionally, some processors boot from an internal boot ROM and use the internal RAM as a scratchpad, providing direct access to on-chip memory. This design is based on the assumption that on-chip SRAM does not retain any data across power cycles.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec16\"\u003e\u003ch2\u003e\u003cspan\u003e8 \u003c/span\u003eConclusion\u003c/h2\u003e\u003cp id=\"p-99\"\u003eThe last two decades of hardware security research have seen a rampant increase in proof-of-concept \u003ci\u003eand\u003c/i\u003e real-world attacks targeting \u003ci\u003eoff-chip memories\u003c/i\u003e designs. Recent efforts to mitigate these attack surfaces primarily turn to \u003ci\u003eon-chip\u003c/i\u003e computation—that is, \u003ci\u003eCache as RAM\u003c/i\u003e—as their deeply embedded nature renders all previous classes of attacks (for example, cold boot) obsolete. However, these systems’ reliance on \u003ci\u003epower-domain separation\u003c/i\u003e enables a new class of attacks: Volt Boot.\u003c/p\u003e\u003cp id=\"p-100\"\u003eIn this paper, we show that current on-chip SRAM is indeed resilient against conventional temperature “freezing”-based attacks. However, we show the effectiveness of a voltage-based attack that snapshots SRAM, without exposing an SoC to low temperature, effectively enabling the indefinite retention of SRAM data while software changes. Compared to previous-generation cold-boot attacks against standalone SRAM, Volt Boot achieves \u003ci\u003eerror-free\u003c/i\u003e data exfiltration on devices spanning three distinct microarchitectures—defeating the paradigm of on-chip computation as a viable defense against secret extraction.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec17\"\u003e\u003ch2\u003e\u003cspan\u003e9 \u003c/span\u003eAcknowledgments\u003c/h2\u003e\u003cp id=\"p-101\"\u003eThe project depicted is sponsored by the Defense Advanced Research Projects Agency (DARPA). The content of the information does not necessarily reflect the position or the policy of the government, and no official endorsement should be inferred.\u003c/p\u003e\u003c/section\u003e\u003csection id=\"sec18\"\u003e\u003ch2\u003ePreviously Published\u003c/h2\u003e\u003cp id=\"p-102\"\u003eThe original version of this paper was published in \u003ci\u003eProceedings of the 27th ACM Intern. Conf. on Architectural Support for Programming Languages and Operating Systems\u003c/i\u003e, 2022.\u003c/p\u003e\u003c/section\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "43 min read",
  "publishedTime": "2025-07-24T15:57:03Z",
  "modifiedTime": null
}
