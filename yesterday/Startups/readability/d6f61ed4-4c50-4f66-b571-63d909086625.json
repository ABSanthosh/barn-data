{
  "id": "d6f61ed4-4c50-4f66-b571-63d909086625",
  "title": "The Two Factions of C++",
  "link": "https://herecomesthemoon.net/2024/11/two-factions-of-cpp/",
  "description": "Article URL: https://herecomesthemoon.net/2024/11/two-factions-of-cpp/ Comments URL: https://news.ycombinator.com/item?id=42231489 Points: 36 # Comments: 19",
  "author": "cyclopeanutopia",
  "published": "Sun, 24 Nov 2024 23:21:36 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Mond",
  "length": 10679,
  "excerpt": "The dream of a single dialect-free C++ has probably been dead for many years, anyway.",
  "siteName": "MOND←TECH MAGAZINE",
  "favicon": "",
  "text": "Zero Ranger. Toggle original/dithered image There seems to be a lot of fighting and arguing over the future of C++. On Reddit and a certain orange website, definitely, but also surely at the official C++ standard committee meetings. You don’t need to look very far. The Absolute State (of C++) It looks like we’re in the following situation: C++’s Evolution Working Group (EWG) just achieved consensus on adopting P3466 R0 - (Re)affirm design principles for future C++ evolution: This means no ABI breaks, retain link compatibility with C and previous C++. It also means no ‘viral annotations’ (no lifetime annotations, for example).1 It heavily doubles down on a set of incompatible goals, ie. no ABI break and the zero-overhead-principle.2 Whether this is good or bad, it is a (literal) doubling down on the current trajectory of the C++ language. In the meantime: The US government wants people to stop using C++: The CISA The NSA The White House, apparently. No, really. Various branches of the US government have released papers, reports, recommendation to warn the industry against usage of memory-unsafe languages. All sorts of big tech players are adopting Rust: Microsoft is apparently rewriting core-libraries in Rust. Google seems to be committing to Rust, and in fact started working on a bidirectional C++/Rust interop tool. AWS is using Rust. etc. Speaking of big tech, did you notice that Herb Sutter is leaving Microsoft, and that it seems like MSVC is slow to implement C++23 features, and asking the community for prioritization. The infamous Prague ABI-vote happened (tl;dr: “C++23 will not break ABI, it’s unclear if it ever will.”), Google supposedly significantly lowered its participation in the C++ development process, and instead started to work on their own C++ successor language. They even have a summary outlining all of the issues they had trying to improve C++.3 Stories of people trying their best to participate in the C++-standard committee process across multiple years, only to be chewed up and spit out are widely known and shared throughout the community. (A feature landing in C first doesn’t help either.) Modules are still not implemented. Are we modules yet? ‘Safety Profiles’ are still in a weird state with no existing implementation, trying to retrofit some amount of safety onto existing C++ code while minimizing changes to existing code. Sean Baxter himself took a stance against profiles, and described C++ as “underspecified”. I don’t know about you, but if I were to look at all of this as an outsider, it sure would look as if C++ is basically falling apart, and as if a vast amount of people lost faith in the ability of C++’s committee to somehow stay on top of this.4 Two Cultures People seem to be looking for other solutions. Say, Google. Google evidently lost faith in ’the process’ ever since the ABI-vote. This isn’t a loss of faith in the language itself, Google has one of the largest C++ codebases in the world, and it has served them incredibly well. It’s a loss of faith in the language’s ability to evolve as pressure mounts from different angles (potential government regulations, competing languages, a desire for better performance and safety guarantees from key players, etc.). So what’s the problem? Why doesn’t C++ just…change? Well, figuring that out is easy. Just look at what Herb Sutter said in his paper on profiles: “We must minimize the need to change existing code. For adoption in existing code, decades of experience has consistently shown that most customers with large code bases cannot and will not change even 1% of their lines of code in order to satisfy strictness rules, not even for safety reasons unless regulatory requirements compel them to do so.” – Herb Sutter Cool. Is anyone surprised by this? I don’t think so. Now, let’s contrast this with Chandler Carruth’s biography on the WG21 member page: I led the design of C++ tooling and automated refactoring systems built on top of Clang and now part of the Clang project. […] Within Google, I led the effort to scale the automated Clang-based refactoring tools up to our entire codebase, over 100 million lines of C++ code. We can analyze and apply refactorings across the entire codebase in 20 minutes. Oh. Do you see it? (Yes you do, I highlighted it.) It’s “automated migration tooling”. Except it’s not just that, automated migration tooling is just the peak, the single brightly glowing example. We’re basically seeing a conflict between two starkly different camps of C++-users: Nimble, modern, highly capable tech corporations that understand that their code is an asset. (This isn’t strictly big tech. Any sane greenfield C++ startup will also fall into this category.) Everyone else. Every ancient corporation where people are still fighting over how to indent their code, and some young engineer is begging management to allow him to set up a linter. One of these groups will be capable of handling a migration somewhat gracefully, and it’s the group that is capable of building their C++ stack from versioned source, not the group that still uses ancient pre-built libraries from 1998. In practice, of course, this is a gradient. I can only imagine how much sweat, tears, bills and blood must’ve flown to turn big tech codebases from terrifying balls of mud into semi-manageable, buildable, linted, properly versioned, slightly-less-terrifying balls of mud. With the bias of hindsight, it’s easy to think of all of this as inevitable: There was a clear disconnect between the needs of corporations such as Google (who use highly modern C++, have automated tooling and testing, and modern infrastructure), and the (very strong) desire for backwards compatibility. To go out on a limb, the notion of a single, dialect-free and unified C++ seems like it’s been dead for years.5 We have, at the very least, two major flavors of C++: Any remotely modern C++. Probably at least C++17. uniqe_ptr, constexpr, lambdas, optional. Everything can be built from versioned source using some sort of dedicated, clean and unified build process that’s at least slightly more sophisticated than raw CMake, and sort of looks like it just works if you squint a little. Some sort of static analyzers, formatter, linter. Any sort of agreement that keeping a codebase clean and modern is worthwhile. Anything that’s not that. Any C++ that’s been sitting in ancient, dusted-up servers of a medium-sized bank. Any C++ that relies on some utterly ancient chunk of compiled code, whose source has been lost, and whose original authors are unreachable. Any C++ that sits deployed on pet-type servers, to the point that spinning it up anywhere else would take an engineer a full month just to figure out all of the implicit dependencies, configs, and environment variables. Any codebase which is primarily classified as a cost-center. You’ll notice that the main difference isn’t about C++ itself at all. The difference is tooling and the ability to build from versioned source in any clean, well-defined manner. Ideally, even the ability to deploy without needing to remember that one flag or environment variable the previous guy usually set to keep everything from imploding. A lot of people will tell you that tooling isn’t the responsibility of the C++ standard committee, and they are right. Tooling isn’t the responsibility of the C++ standard committee, because the C++ standard committee abdicates any responsibility for it (it focuses on specifications for the C++ language, not on concrete implementations). This is by design, and it’s hard to blame them considering the legacy baggage. C++ is a standard unifying different implementations. That said, if there’s one thing which Go got right, it’s that tooling matters. C++, in comparison, is from a prehistoric age before linters were invented. C++ has no unified build system, it has nothing even close to a unified package management system, it is incredibly hard to parse and analyze (this is terrible for tooling), and is fighting a horrifying uphill battle against Hyrum’s Law for every change that needs to be made. There’s a massive, growing rift between those two factions, and I honestly don’t see it closing anytime soon. The C++ committee seems pretty committed (committeed, if you will) to maintaining backwards compatibility, no matter the cost. Consequences This is why profiles are the way they are: Safety Profiles are not intended to solve the problems of modern, tech-savvy C++ corporations. They’re intended to bring improvements without requiring any changes to old code. Likewise, modules. You’re intended to be able to “just” import a header file as a module, and there should not be any sort of backwards compatibility issues. Of course, everyone loves features which can just be dropped-in and bring improvements without requiring any changes to old code. But it’s pretty clear that these features are designed (first and foremost) with the goal of ’legacy C++’ in mind. Any feature that would require a migration from legacy C++ is a non-starter for the C++ committee since, as Herb Sutter said, you essentially cannot expect people to migrate. This is something which I try to keep in mind when I look at C++ papers: There’s two large audiences here. One is that of modern C++, the other is that of legacy C++. These two camps disagree fiercely, and many papers are written with the needs of one specific group in mind. The C++-committee is trying to keep this rift from widening. That’s, presumably, why anything in the direction of Safe C++ by Sean Baxter is a non-starter for them. This is a radical, sweeping change that could create a fundamentally new way of writing C++. Of course, there’s also the question of whether specific C++ standard committee members are just being very, very stubborn, and grasping at straws to prevent an evolution which they personally aesthetically disagree with. Far be it from to accuse anyone, but it wouldn’t be the first time I heard that the C++ committee applied double standards such as: “We expect a full, working implementation across several working compilers from you if you’d like to see this proposal approved, but we’re still happy to commit to certain vast projects (eg. modules, profiles) that have no functioning proof of concept implementation.” If this were the case (I genuinely cannot say) then I really wouldn’t know for how much longer C++ could continue going down that road without a much more dramatic split. And all of that that is not even getting into the massive can of worms and problems that’d be caused by breaking ABI compatibility.",
  "image": "https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/dithers/not-bad-at-all-header_dithered.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003carticle\u003e\n\u003cdiv id=\"content\"\u003e\u003cdiv\u003e\n\u003cfigure data-imgstate=\"dither\"\u003e\n\u003cimg alt=\"Zero Ranger.\" data-dither=\"/2024/11/two-factions-of-cpp/images/dithers/not-bad-at-all_dithered.png\" data-original=\"https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/not-bad-at-all_hu130da105ae916814d5129db49a9c3717_341311_800x800_fit_q90_h2_box_3.webp\" loading=\"lazy\" src=\"https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/dithers/not-bad-at-all_dithered.png\"/\u003e\n\u003cdiv\u003e\n\u003cfigcaption\u003e\n\u003cspan\u003e Zero Ranger. \u003c/span\u003e\n\u003csvg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n\u003crect height=\"24.28\" width=\"24.28\" x=\"13.51\" y=\"13.58\"\u003e\u003c/rect\u003e\n\u003crect height=\"24.28\" width=\"24.28\" x=\"37.93\" y=\"37.86\"\u003e\u003c/rect\u003e\n\u003crect height=\"24.28\" width=\"24.28\" x=\"62.21\" y=\"13.58\"\u003e\u003c/rect\u003e\n\u003crect height=\"24.28\" width=\"24.28\" x=\"13.51\" y=\"62.14\"\u003e\u003c/rect\u003e\n\u003crect height=\"24.28\" width=\"24.28\" x=\"62.21\" y=\"62.14\"\u003e\u003c/rect\u003e\n\u003c/svg\u003e\n\u003cp\u003e\u003cspan\u003e\n             Toggle original/dithered image\n          \u003c/span\u003e\n\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/div\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003cp\u003eThere seems to be a lot of fighting and arguing over the future of C++.\u003c/p\u003e\n\u003cp\u003eOn Reddit and a certain orange website, definitely, but also surely at the official C++ standard committee meetings. You don’t need to look very far.\u003c/p\u003e\n\u003ch2 id=\"the-absolute-state-of-c\"\u003eThe Absolute State (of C++)\u003c/h2\u003e\n\u003cp\u003eIt looks like we’re in the following situation:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC++’s Evolution Working Group (EWG) just \u003ca href=\"https://github.com/cplusplus/papers/issues/2121#issuecomment-2494153010\" target=\"_blank\"\u003eachieved consensus\u003c/a\u003e on adopting \u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf\" target=\"_blank\"\u003eP3466 R0 - (Re)affirm design principles for future C++ evolution\u003c/a\u003e:\n\u003cul\u003e\n\u003cli\u003eThis means no ABI breaks, retain link compatibility with C and previous C++.\u003c/li\u003e\n\u003cli\u003eIt also means no ‘viral annotations’ (no lifetime annotations, for example).\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003eIt heavily doubles down on a set of incompatible goals, ie. no ABI break and the zero-overhead-principle.\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003eWhether this is good or bad, it is a (literal) doubling down on the current trajectory of the C++ language.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the meantime:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe US government wants people to stop using C++:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cisa.gov/resources-tools/resources/product-security-bad-practices\" target=\"_blank\"\u003eThe CISA\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF\" target=\"_blank\"\u003eThe NSA\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf\" target=\"_blank\"\u003eThe White House, apparently.\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eNo, really. Various branches of the US government have released papers, reports, recommendation to warn the industry against usage of memory-unsafe languages.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAll sorts of big tech players are adopting Rust:\n\u003cul\u003e\n\u003cli\u003eMicrosoft is apparently \u003ca href=\"https://www.theregister.com/2023/04/27/microsoft_windows_rust/\" target=\"_blank\"\u003erewriting core-libraries in Rust\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eGoogle seems to \u003ca href=\"https://security.googleblog.com/2021/04/rust-in-android-platform.html\" target=\"_blank\"\u003ebe committing to Rust\u003c/a\u003e, and in fact started working on a \u003ca href=\"https://github.com/google/crubit\" target=\"_blank\"\u003ebidirectional C++/Rust interop tool\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAWS is \u003ca href=\"https://aws.amazon.com/blogs/devops/why-aws-is-the-best-place-to-run-rust/\" target=\"_blank\"\u003eusing Rust\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eetc.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSpeaking of big tech, did you notice that \u003ca href=\"https://herbsutter.com/2024/11/11/a-new-chapter-and-a-pivotal-year-for-cpp/\" target=\"_blank\"\u003eHerb Sutter is leaving Microsoft\u003c/a\u003e, and that it seems like \u003ca href=\"https://www.reddit.com/r/cpp/comments/1gkdr6e/msvc_c23_support/\" target=\"_blank\"\u003eMSVC is slow to implement C++23 features, and asking the community for prioritization\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eThe infamous \u003ca href=\"https://cor3ntin.github.io/posts/abi/\" target=\"_blank\"\u003ePrague ABI-vote\u003c/a\u003e happened (tl;dr: “C++23 will not break ABI, it’s unclear if it ever will.”), Google supposedly significantly lowered its participation in the C++ development process, and instead started to work on \u003ca href=\"https://www.youtube.com/watch?v=omrY53kbVoA\" target=\"_blank\"\u003etheir own C++ successor language\u003c/a\u003e. They even have a \u003ca href=\"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/difficulties_improving_cpp.md\" target=\"_blank\"\u003esummary\u003c/a\u003e outlining all of the issues they had trying to improve C++.\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://thephd.dev/finally-embed-in-c23\" target=\"_blank\"\u003eStories\u003c/a\u003e of people trying their best to participate in the C++-standard committee process across multiple years, only to be chewed up and spit out are widely known and shared throughout the community. (A feature landing in \u003cem\u003eC\u003c/em\u003e first doesn’t help either.)\u003c/li\u003e\n\u003cli\u003eModules are still not implemented. \u003ca href=\"https://arewemodulesyet.org/\" target=\"_blank\"\u003eAre we modules yet?\u003c/a\u003e \u003cimg alt=\"image\" src=\"https://herecomesthemoon.net/2024/11/two-factions-of-cpp/images/modules.png\"/\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://isocpp.org/files/papers/P3081R0.pdf\" target=\"_blank\"\u003e‘Safety Profiles’\u003c/a\u003e are still in a weird state with no existing implementation, trying to retrofit \u003cem\u003esome\u003c/em\u003e amount of safety onto existing C++ code while minimizing changes to existing code. Sean Baxter himself \u003ca href=\"https://www.circle-lang.org/draft-profiles.html\" target=\"_blank\"\u003etook a stance\u003c/a\u003e against profiles, and described C++ as “underspecified”.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI don’t know about you, but if I were to look at all of this \u003cem\u003eas an outsider\u003c/em\u003e, it sure would look as if C++ is \u003cem\u003ebasically falling apart\u003c/em\u003e, and as if a vast amount of people lost faith in the ability of C++’s committee to \u003cem\u003esomehow\u003c/em\u003e stay on top of this.\u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003ch2 id=\"two-cultures\"\u003eTwo Cultures\u003c/h2\u003e\n\u003cp\u003ePeople seem to be looking for other solutions.\u003c/p\u003e\n\u003cp\u003eSay, Google. Google evidently lost faith in ’the process’ ever since the ABI-vote. This isn’t a loss of faith in the language itself, Google has one of the largest C++ codebases in the world, and it has served them incredibly well. It’s a loss of faith in the language’s ability to evolve as pressure mounts from different angles (potential government regulations, competing languages, a desire for better performance and safety guarantees from key players, etc.).\u003c/p\u003e\n\u003cp\u003eSo what’s the problem? Why doesn’t C++ just…change?\u003c/p\u003e\n\u003cp\u003eWell, figuring that out is easy. Just \u003ca href=\"https://isocpp.org/files/papers/P3081R0.pdf\" target=\"_blank\"\u003elook at what Herb Sutter said in his paper on profiles\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“\u003cstrong\u003eWe must minimize the need to change existing code.\u003c/strong\u003e For adoption in existing code, decades of experience has consistently shown that most customers with large code bases cannot and will not change even 1% of their lines of code in order to satisfy strictness rules, not even for safety reasons unless regulatory requirements compel them to do so.” – Herb Sutter\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCool. Is anyone surprised by this? I don’t think so.\u003c/p\u003e\n\u003cp\u003eNow, let’s contrast this with \u003ca href=\"https://isocpp.org/wiki/faq/wg21#chandler-carruth\" target=\"_blank\"\u003eChandler Carruth’s biography on the WG21 member page\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI led the design of \u003cstrong\u003eC++ tooling and automated refactoring systems built on top of Clang\u003c/strong\u003e and now part of the Clang project. […]\u003cbr/\u003e\nWithin Google, I led the effort to scale the \u003cstrong\u003eautomated Clang-based refactoring\u003c/strong\u003e tools up to our entire codebase, over 100 million lines of C++ code. We can analyze and apply refactorings across the entire codebase in 20 minutes.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOh. Do you see it? (Yes you do, I highlighted it.)\u003c/p\u003e\n\u003cp\u003eIt’s “automated migration tooling”. Except it’s not \u003cem\u003ejust\u003c/em\u003e that, automated migration tooling is just the peak, the single brightly glowing example.\u003c/p\u003e\n\u003cp\u003eWe’re basically seeing a conflict between two starkly different camps of C++-users:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNimble, modern, highly capable tech corporations that understand that their code is an asset. (This isn’t strictly \u003cem\u003ebig\u003c/em\u003e tech. Any sane greenfield C++ startup will also fall into this category.)\u003c/li\u003e\n\u003cli\u003eEveryone else. Every ancient corporation where people are still fighting over how to indent their code, and some young engineer is begging management to allow him to set up a linter.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne of these groups will be capable of handling a migration \u003cem\u003esomewhat\u003c/em\u003e gracefully, and it’s the group that is capable of \u003cstrong\u003ebuilding their C++ stack from versioned source\u003c/strong\u003e, not the group that still uses ancient pre-built libraries from 1998.\u003c/p\u003e\n\u003cp\u003eIn practice, of course, this is a gradient. I can only imagine how much sweat, tears, bills and blood must’ve flown to turn big tech codebases from terrifying balls of mud into semi-manageable, buildable, linted, properly versioned, slightly-less-terrifying balls of mud.\u003c/p\u003e\n\u003cp\u003eWith the bias of hindsight, it’s easy to think of all of this as inevitable: There was a clear disconnect between the needs of corporations such as Google (who use highly modern C++, have automated tooling and testing, and modern infrastructure), and the (very strong) desire for backwards compatibility.\u003c/p\u003e\n\u003cp\u003eTo go out on a limb, the notion of a single, dialect-free and unified C++ seems like it’s been \u003cstrong\u003edead for years\u003c/strong\u003e.\u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e We have, at the very least, two major flavors of C++:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAny \u003cem\u003eremotely\u003c/em\u003e modern C++. Probably at least C++17. \u003ccode\u003euniqe_ptr\u003c/code\u003e, \u003ccode\u003econstexpr\u003c/code\u003e, lambdas, \u003ccode\u003eoptional\u003c/code\u003e. Everything can be built from versioned source using some sort of dedicated, clean and unified build process that’s at least slightly more sophisticated than raw CMake, and sort of looks like it just works if you squint a little. Some sort of static analyzers, formatter, linter. \u003cem\u003eAny\u003c/em\u003e sort of agreement that keeping a codebase clean and modern is worthwhile.\u003c/li\u003e\n\u003cli\u003eAnything that’s not that. Any C++ that’s been sitting in ancient, dusted-up servers of a medium-sized bank. Any C++ that relies on some utterly ancient chunk of compiled code, whose source has been lost, and whose original authors are unreachable. Any C++ that sits deployed on pet-type servers, to the point that spinning it up anywhere else would take an engineer a full month just to figure out all of the implicit dependencies, configs, and environment variables. Any codebase which is primarily classified as a cost-center.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou’ll notice that the main difference isn’t about C++ itself at all. The difference is \u003cem\u003etooling\u003c/em\u003e and the ability to build from versioned source in any clean, well-defined manner. Ideally, even the ability to \u003cem\u003edeploy\u003c/em\u003e without needing to remember that one flag or environment variable the previous guy usually set to keep everything from imploding.\u003c/p\u003e\n\u003cp\u003eA lot of people will tell you that tooling isn’t the responsibility of the C++ standard committee, and \u003cem\u003ethey are right\u003c/em\u003e. Tooling isn’t the responsibility of the C++ standard committee, \u003cem\u003ebecause the C++ standard committee abdicates any responsibility for it\u003c/em\u003e (it focuses on specifications for the C++ language, \u003cem\u003enot\u003c/em\u003e on concrete implementations). This is by design, and it’s hard to blame them considering the legacy baggage. C++ is a standard unifying different implementations.\u003c/p\u003e\n\u003cp\u003eThat said, if there’s \u003cem\u003eone\u003c/em\u003e thing which Go got right, it’s that tooling matters. C++, in comparison, is from a prehistoric age before linters were invented. C++ has no unified build system, it has nothing even close to a unified package management system, it is incredibly hard to parse and analyze (this is \u003cem\u003eterrible\u003c/em\u003e  for tooling), and is fighting a horrifying uphill battle against Hyrum’s Law for every change that needs to be made.\u003c/p\u003e\n\u003cp\u003eThere’s a massive, growing rift between those two factions, and I honestly don’t see it closing anytime soon. The C++ committee seems pretty committed (committeed, if you will) to maintaining backwards compatibility, no matter the cost.\u003c/p\u003e\n\u003ch2 id=\"consequences\"\u003eConsequences\u003c/h2\u003e\n\u003cp\u003eThis is why profiles are the way they are: Safety Profiles are \u003cem\u003enot\u003c/em\u003e intended to solve the problems of modern, tech-savvy C++ corporations. They’re intended to bring improvements \u003cem\u003ewithout\u003c/em\u003e requiring any changes to old code.\u003c/p\u003e\n\u003cp\u003eLikewise, modules. You’re intended to be able to “just” import a header file as a module, and there should not be any sort of backwards compatibility issues.\u003c/p\u003e\n\u003cp\u003eOf course, \u003cem\u003eeveryone\u003c/em\u003e loves features which can just be dropped-in and bring improvements without requiring any changes to old code. But it’s pretty clear that these features are designed (first and foremost) with the goal of ’legacy C++’ in mind. Any feature that would require a migration from legacy C++ is a non-starter for the C++ committee since, as Herb Sutter said, you essentially cannot expect people to migrate.\u003c/p\u003e\n\u003cp\u003eThis is something which I try to keep in mind when I look at C++ papers: There’s two large audiences here. One is that of modern C++, the other is that of legacy C++. These two camps disagree fiercely, and many papers are written with the needs of one specific group in mind.\u003c/p\u003e\n\u003cp\u003eThe C++-committee is trying to keep this rift from widening. That’s, presumably, why anything in the direction of \u003ca href=\"https://safecpp.org/draft.html\" target=\"_blank\"\u003eSafe C++ by Sean Baxter\u003c/a\u003e is a non-starter for them. This is a radical, sweeping change that could create a fundamentally new way of writing C++.\u003c/p\u003e\n\u003cp\u003eOf course, there’s also the question of whether specific C++ standard committee members are just being very, very stubborn, and grasping at straws to prevent an evolution which they personally aesthetically disagree with.\u003c/p\u003e\n\u003cp\u003eFar be it from to accuse anyone, but it wouldn’t be the first time I heard that the C++ committee applied double standards such as: “We expect a full, working implementation across several working compilers from you if you’d like to see this proposal approved, but we’re still happy to commit to certain vast projects (eg. modules, profiles) that have no functioning proof of concept implementation.”\u003c/p\u003e\n\u003cp\u003eIf \u003cem\u003ethis\u003c/em\u003e were the case (I genuinely cannot say) then I really wouldn’t know for how much longer C++ could continue going down that road without a much more dramatic split.\u003c/p\u003e\n\u003cp\u003eAnd all of that that is not even getting into the massive can of worms and problems that’d be caused by breaking ABI compatibility.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-11-24T00:00:00Z",
  "modifiedTime": "2024-11-24T18:52:16+01:00"
}
