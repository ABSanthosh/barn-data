{
  "id": "b1687116-db1e-4668-98ed-f2e6a054024d",
  "title": "CodeSOD: The XML Dating Service",
  "link": "https://thedailywtf.com/articles/the-xml-dating-service",
  "description": "One of the endless struggles in writing reusable API endpoints is creating useful schemas to describe them. Each new serialization format comes up with new ways to express your constraints, each with their own quirks and footguns and absolute trainwrecks. Maarten has the \"pleasure\" of consuming an XML-based API, provided by a third party. It comes with an XML schema, for validation. Now, the XML Schema Language has a large number of validators built in. For example, if you want to restrict a field to being a date, you can mark it's type as xsd:date. This will enforce a YYYY-MM-DD format on the data. If you want to ruin that validation, you can do what the vendor did: \u003cxsd:simpleType name=\"DatumType\"\u003e \u003cxsd:annotation\u003e \u003cxsd:documentation\u003eYYYY-MM-DDxsd:documentation\u003e xsd:annotation\u003e \u003cxsd:restriction base=\"xsd:date\"\u003e \u003cxsd:pattern value=\"(1|2)[0-9]{3}-(0|1)[0-9]-[0-3][0-9]\" /\u003e xsd:restriction\u003e xsd:simpleType\u003e You can see the xsd:pattern element, which applies a regular expression to validation. And this regex will \"validate\" dates, excluding things which are definitely not dates, and allowing very valid dates, like February 31st, November 39th, and the 5th of Bureaucracy (the 18th month of the year), as 2025-02-31, 2025-11-39 and 2025-18-05 are all valid strings according to the regex. Now, an astute reader will note that this is a xsd:restriction on a date; this means that it's applied in addition to ensuring the value is a valid date. So this idiocy is harmless. If you removed the xsd:pattern element, the behavior would remain unchanged. That leads us to a series of possible conclusions: either they don't understand how XML schema restrictions work, or they don't understand how dates work. As to which one applies, well, I'd say 1/3 chance they don't understand XML, 1/3 chance they don't understand dates, and a 1/3 chance they don't understand both. [Advertisement] Picking up NuGet is easy. Getting good at it takes time. Download our guide to learn the best practice of NuGet for the Enterprise.",
  "author": "Remy Porter",
  "published": "Wed, 09 Jul 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2159,
  "excerpt": "One of the endless struggles in writing reusable API endpoints is creating useful schemas to describe them. Each new serialization format comes up with new ways to express your constraints, each with their own quirks and footguns and absolute trainwrecks. Maarten has the \"pleasure\" of consuming an XML-based API, provided by a third party. It comes with an XML schema, for validation. Now, the XML Schema Language has a large number of validators built in. For example, if you want to restrict a field to being a date, you can mark it's type as xsd:date. This will enforce a YYYY-MM-DD format on the data.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-07-09 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. One of the endless struggles in writing reusable API endpoints is creating useful schemas to describe them. Each new serialization format comes up with new ways to express your constraints, each with their own quirks and footguns and absolute trainwrecks. Maarten has the \"pleasure\" of consuming an XML-based API, provided by a third party. It comes with an XML schema, for validation. Now, the XML Schema Language has a large number of validators built in. For example, if you want to restrict a field to being a date, you can mark it's type as xsd:date. This will enforce a YYYY-MM-DD format on the data. If you want to ruin that validation, you can do what the vendor did: \u003cxsd:simpleType name=\"DatumType\"\u003e \u003cxsd:annotation\u003e \u003cxsd:documentation\u003eYYYY-MM-DD\u003c/xsd:documentation\u003e \u003c/xsd:annotation\u003e \u003cxsd:restriction base=\"xsd:date\"\u003e \u003cxsd:pattern value=\"(1|2)[0-9]{3}-(0|1)[0-9]-[0-3][0-9]\" /\u003e \u003c/xsd:restriction\u003e \u003c/xsd:simpleType\u003e You can see the xsd:pattern element, which applies a regular expression to validation. And this regex will \"validate\" dates, excluding things which are definitely not dates, and allowing very valid dates, like February 31st, November 39th, and the 5th of Bureaucracy (the 18th month of the year), as 2025-02-31, 2025-11-39 and 2025-18-05 are all valid strings according to the regex. Now, an astute reader will note that this is a xsd:restriction on a date; this means that it's applied in addition to ensuring the value is a valid date. So this idiocy is harmless. If you removed the xsd:pattern element, the behavior would remain unchanged. That leads us to a series of possible conclusions: either they don't understand how XML schema restrictions work, or they don't understand how dates work. As to which one applies, well, I'd say 1/3 chance they don't understand XML, 1/3 chance they don't understand dates, and a 1/3 chance they don't understand both.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-07-09\"\u003e2025-07-09\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10957\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eOne of the endless struggles in writing reusable API endpoints is creating useful schemas to describe them. Each new serialization format comes up with new ways to express your constraints, each with their own quirks and footguns and absolute trainwrecks.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMaarten\u003c/strong\u003e has the \u0026#34;pleasure\u0026#34; of consuming an XML-based API, provided by a third party. It comes with an XML schema, for validation. Now, the XML Schema Language has a large number of validators built in. For example, if you want to restrict a field to being a \u003cem\u003edate\u003c/em\u003e, you can mark it\u0026#39;s type as \u003ccode\u003exsd:date\u003c/code\u003e. This will enforce a \u003ccode\u003eYYYY-MM-DD\u003c/code\u003e format on the data.\u003c/p\u003e\n\u003cp\u003eIf you want to \u003cem\u003eruin\u003c/em\u003e that validation, you can do what the vendor did:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;\u003cspan\u003exsd:simpleType\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e=\u003cspan\u003e\u0026#34;DatumType\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;\u003cspan\u003exsd:annotation\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;\u003cspan\u003exsd:documentation\u003c/span\u003e\u0026gt;\u003c/span\u003eYYYY-MM-DD\u003cspan\u003e\u0026lt;/\u003cspan\u003exsd:documentation\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/\u003cspan\u003exsd:annotation\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;\u003cspan\u003exsd:restriction\u003c/span\u003e \u003cspan\u003ebase\u003c/span\u003e=\u003cspan\u003e\u0026#34;xsd:date\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;\u003cspan\u003exsd:pattern\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e=\u003cspan\u003e\u0026#34;(1|2)[0-9]{3}-(0|1)[0-9]-[0-3][0-9]\u0026#34;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/\u003cspan\u003exsd:restriction\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003e\u0026lt;/\u003cspan\u003exsd:simpleType\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can see the \u003ccode\u003exsd:pattern\u003c/code\u003e element, which applies a regular expression to validation. And this regex will \u0026#34;validate\u0026#34; dates, excluding things which are definitely not dates, and allowing very valid dates, like February 31st, November 39th, and the 5th of Bureaucracy (the 18th month of the year), as \u003ccode\u003e2025-02-31\u003c/code\u003e, \u003ccode\u003e2025-11-39\u003c/code\u003e and \u003ccode\u003e2025-18-05\u003c/code\u003e are all valid strings according to the regex.\u003c/p\u003e\n\u003cp\u003eNow, an astute reader will note that this is a \u003ccode\u003exsd:restriction\u003c/code\u003e on a date; this means that it\u0026#39;s applied \u003cem\u003ein addition\u003c/em\u003e to ensuring the value is a valid date. So this idiocy is harmless. If you removed the \u003ccode\u003exsd:pattern\u003c/code\u003e element, the behavior would remain unchanged.\u003c/p\u003e\n\u003cp\u003eThat leads us to a series of possible conclusions: either they don\u0026#39;t understand how XML schema restrictions work, \u003cem\u003eor\u003c/em\u003e they don\u0026#39;t understand how dates work. As to which one applies, well, I\u0026#39;d say 1/3 chance they don\u0026#39;t understand XML, 1/3 chance they don\u0026#39;t understand dates, and a 1/3 chance they don\u0026#39;t understand both.\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-07-09T06:30:00Z",
  "modifiedTime": null
}
