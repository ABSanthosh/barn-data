{
  "id": "69847995-7929-461b-925b-0864e8c03854",
  "title": "Representative Line: Get Explosive",
  "link": "https://thedailywtf.com/articles/get-explosive",
  "description": "Sean sends us a one-line function that is a delight, if by delight you mean \"horror\". You'll be shocked to know it's PHP. function proget(){foreach($_GET as $k=\u003e$v){if($k==\"h\"){$GLOBALS[\"h\"]=1;}$p=explode(\",\",$k);}return($p);} //function to process GET headers Based on the comment, proget is a shorthand for process_get_parameters. Which is sort of what it does. Sort of. Let's go through this. We iterate across our $_GET parameters using $k for the key, $v for the value, but we never reference the value so forget it exists. We're iterating across every key. The first thing we check is if a key \"h\" exists. We don't look at its value, we just check if it exists, and if it does, we set a global variable. And this, right here, is enough for this to be a WTF. The logic of \"set a global variable based on the existence of a query parameter regardless of the value of the query parameter\" is… a lot. But then, somehow, this actually gets more out there. We explode the key on commas (explode being PHP's much cooler name for split), which implies… our keys may be lists of values? Which I feel like is an example of someone not understanding what a \"key\" is. But worse than that, we just do this for every key, and return the results of performing that operation on the last key. Which means that if this function is doing anything at all, it's entirely dependent on the order of the keys. Which, PHP does order the keys by the order they're added, which I take to mean that if the URL has query params like ?foo=1\u0026h=0\u0026a,b,c,d=wtf. Or, if we're being picky about encoding, ?foo=1\u0026h=0\u0026a%2Cb%2Cc%2Cd=wtf. The only good news here is that PHP handles the encoding/decoding for you, so the explode will work as expected. This is the kind of bad code that leaves me with lots of questions, and I'm not sure I want any of the answers. How did this happen, and why are questions best left unanswered, because I think the answers might cause more harm. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Thu, 03 Apr 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Representative Line"
  ],
  "byline": "Remy Porter",
  "length": 2417,
  "excerpt": "Sean sends us a one-line function that is a delight, if by delight you mean \"horror\". You'll be shocked to know it's PHP. function proget(){foreach($_GET as $k=\u003e$v){if($k==\"h\"){$GLOBALS[\"h\"]=1;}$p=explode(\",\",$k);}return($p);} //function to process GET headers",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in Representative Line on 2025-04-03 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Sean sends us a one-line function that is a delight, if by delight you mean \"horror\". You'll be shocked to know it's PHP. function proget(){foreach($_GET as $k=\u003e$v){if($k==\"h\"){$GLOBALS[\"h\"]=1;}$p=explode(\",\",$k);}return($p);} //function to process GET headers Based on the comment, proget is a shorthand for process_get_parameters. Which is sort of what it does. Sort of. Let's go through this. We iterate across our $_GET parameters using $k for the key, $v for the value, but we never reference the value so forget it exists. We're iterating across every key. The first thing we check is if a key \"h\" exists. We don't look at its value, we just check if it exists, and if it does, we set a global variable. And this, right here, is enough for this to be a WTF. The logic of \"set a global variable based on the existence of a query parameter regardless of the value of the query parameter\" is… a lot. But then, somehow, this actually gets more out there. We explode the key on commas (explode being PHP's much cooler name for split), which implies… our keys may be lists of values? Which I feel like is an example of someone not understanding what a \"key\" is. But worse than that, we just do this for every key, and return the results of performing that operation on the last key. Which means that if this function is doing anything at all, it's entirely dependent on the order of the keys. Which, PHP does order the keys by the order they're added, which I take to mean that if the URL has query params like ?foo=1\u0026h=0\u0026a,b,c,d=wtf. Or, if we're being picky about encoding, ?foo=1\u0026h=0\u0026a%2Cb%2Cc%2Cd=wtf. The only good news here is that PHP handles the encoding/decoding for you, so the explode will work as expected. This is the kind of bad code that leaves me with lots of questions, and I'm not sure I want any of the answers. How did this happen, and why are questions best left unanswered, because I think the answers might cause more harm. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/representative-line\"\u003eRepresentative Line\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-04-03\"\u003e2025-04-03\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10884\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eSean\u003c/strong\u003e sends us a one-line function that is a delight, if by delight you mean \u0026#34;horror\u0026#34;. You\u0026#39;ll be shocked to know it\u0026#39;s PHP.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eproget\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e)\u003c/span\u003e{\u003cspan\u003eforeach\u003c/span\u003e(\u003cspan\u003e$_GET\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003e$k\u003c/span\u003e=\u0026gt;\u003cspan\u003e$v\u003c/span\u003e){\u003cspan\u003eif\u003c/span\u003e(\u003cspan\u003e$k\u003c/span\u003e==\u003cspan\u003e\u0026#34;h\u0026#34;\u003c/span\u003e){\u003cspan\u003e$GLOBALS\u003c/span\u003e[\u003cspan\u003e\u0026#34;h\u0026#34;\u003c/span\u003e]=\u003cspan\u003e1\u003c/span\u003e;}\u003cspan\u003e$p\u003c/span\u003e=\u003cspan\u003eexplode\u003c/span\u003e(\u003cspan\u003e\u0026#34;,\u0026#34;\u003c/span\u003e,\u003cspan\u003e$k\u003c/span\u003e);}\u003cspan\u003ereturn\u003c/span\u003e(\u003cspan\u003e$p\u003c/span\u003e);} \u003cspan\u003e//function to process GET headers\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBased on the comment, \u003ccode\u003eproget\u003c/code\u003e is a shorthand for \u003ccode\u003eprocess_get_parameters\u003c/code\u003e. Which is sort of what it does. Sort of.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s go through this. We iterate across our \u003ccode\u003e$_GET\u003c/code\u003e parameters using \u003ccode\u003e$k\u003c/code\u003e for the key, \u003ccode\u003e$v\u003c/code\u003e for the value, but we never reference the value so forget it exists. We\u0026#39;re iterating across every key. The first thing we check is if a key \u003ccode\u003e\u0026#34;h\u0026#34;\u003c/code\u003e exists. We don\u0026#39;t look at its value, we just check if it exists, and if it does, we set a global variable. And this, right here, is enough for this to be a WTF. The logic of \u0026#34;set a global variable based on the existence of a query parameter regardless of the value of the query parameter\u0026#34; is… a lot. But then, \u003cem\u003esomehow\u003c/em\u003e, this actually gets more out there.\u003c/p\u003e\n\u003cp\u003eWe \u003ccode\u003eexplode\u003c/code\u003e the key on commas (\u003ccode\u003eexplode\u003c/code\u003e being PHP\u0026#39;s much cooler name for \u003ccode\u003esplit\u003c/code\u003e), which implies… our keys may be lists of values? Which I feel like is an example of someone not understanding what a \u0026#34;key\u0026#34; is. But worse than that, we just do this for every key, and return the results of performing that operation on the \u003cem\u003elast\u003c/em\u003e key. Which means that if this function is doing anything at all, it\u0026#39;s entirely dependent on the \u003cem\u003eorder of the keys\u003c/em\u003e. Which, PHP does order the keys by the order they\u0026#39;re added, which I take to mean that if the URL has query params like \u003ccode\u003e?foo=1\u0026amp;h=0\u0026amp;a,b,c,d=wtf\u003c/code\u003e. Or, if we\u0026#39;re being picky about encoding, \u003ccode\u003e?foo=1\u0026amp;h=0\u0026amp;a%2Cb%2Cc%2Cd=wtf\u003c/code\u003e. The only good news here is that PHP handles the encoding/decoding for you, so the \u003ccode\u003eexplode\u003c/code\u003e will work as expected.\u003c/p\u003e\n\u003cp\u003eThis is the kind of bad code that leaves me with lots of questions, and I\u0026#39;m not sure I want any of the answers. How did this happen, and \u003cem\u003ewhy\u003c/em\u003e are questions best left unanswered, because I think the answers might cause more harm.\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-04-03T06:30:00Z",
  "modifiedTime": null
}
