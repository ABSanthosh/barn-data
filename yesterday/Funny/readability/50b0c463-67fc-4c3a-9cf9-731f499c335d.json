{
  "id": "50b0c463-67fc-4c3a-9cf9-731f499c335d",
  "title": "CodeSOD: Consultant Conversions",
  "link": "https://thedailywtf.com/articles/consultant-conversions",
  "description": "Janet's company had a glut of work, and thus didn't have the staffing required to do it all. It didn't make sense to hire on any new full-time employees, so they went the route of bringing on a few highly paid consultants, specifically ones who specialized in one specific problem: talking to a piece of hardware purchased from a vendor. The hardware in question was a scientific which communicated over a serial line. This device provided a lot of data that represented decimal values, but that data was not encoded as an IEEE float. Instead, they used two integers- one for the data, and one representing the number of decimal places. So, for example, \"555.55\" would be represented as \"55555 2\". Now, in embedded devices, this isn't too unusual. It's entirely possible that the embedded CPU didn't even support true floating point operations, and this was just how they decided to work around that. When communicating over the serial line, the device didn't send the data encoded in binary, however- it did everything as text. This was arguably helpful as it meant a technician could communicate with the device directly over a terminal emulator, but it meant any software talking to the device had to parse data. Which brings us to the code written by the highly paid consultants. This code needs to take two 16-bit integers and turn them into a single decimal value. Let's see how they did it. /// /// Sets the single parameter value. /// /// Name of the parameter. /// /// public double ConvertIntToDecimal(string Value, string decimalCount) { double Result; var decimals = UInt16.Parse(decimalCount); var Val = UInt16.Parse(Value); if (decimals \u003e 0) { var divider = Math.Pow(10, decimals); Result = ((float)Val) / divider; } else { Result = Val; } return Result; } We start with comments that are just wrong, which is always a good start. The whole thing has delightfully randomized capitalization- a mix of PascalCase and camelCase. In the core logic, we parse the input values, and if there are any decimal places, we do some arithmetic to build our floating point value. We get the fun bonus inconsistency of casting to float when we handle our result in double, but at least it's a widening inconsistency, I suppose. As an overall approach to the problem, it's not a train wreck, but there's one very important thing that our highly paid consultant forgot. Our HPC, remember, was an expert in this particular instrument, or at least that was their claim. And while their mistake is an easy mistake to make while coding, it should also be an easy mistake to catch during testing, too. What was the mistake? The value is frequently negative, and they're using UInt16 to parse the inputs. Which means this function frequently threw an exception. Literally five minutes of testing would have turned it up. Janet had piles of sample data, recorded from the device, which she used for testing. Almost all of her test cases would trigger the bug at some point. It seems likely, at this juncture, that the HPC simply never actually tested the code. They wrote it. They committed it. They collected their check and left. Janet may have been the first person to actually run the code at all. In the end, hiring the HPC cost a lot of money, and maybe saved a few days of work over the course of months. It's hard to say, as it may have created more work, since so much of what the HPC did had to be debugged and often rewritten. The \"good\" news is that they have another glut of work, so management is looking to bring back the consultants for another round. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Mon, 20 Jan 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3926,
  "excerpt": "Janet's company had a glut of work, and thus didn't have the staffing required to do it all. It didn't make sense to hire on any new full-time employees, so they went the route of bringing on a few highly paid consultants, specifically ones who specialized in one specific problem: talking to a piece of hardware purchased from a vendor. The hardware in question was a scientific which communicated over a serial line. This device provided a lot of data that represented decimal values, but that data was not encoded as an IEEE float. Instead, they used two integers- one for the data, and one representing the number of decimal places.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Janet's company had a glut of work, and thus didn't have the staffing required to do it all. It didn't make sense to hire on any new full-time employees, so they went the route of bringing on a few highly paid consultants, specifically ones who specialized in one specific problem: talking to a piece of hardware purchased from a vendor. The hardware in question was a scientific which communicated over a serial line. This device provided a lot of data that represented decimal values, but that data was not encoded as an IEEE float. Instead, they used two integers- one for the data, and one representing the number of decimal places. So, for example, \"555.55\" would be represented as \"55555 2\". Now, in embedded devices, this isn't too unusual. It's entirely possible that the embedded CPU didn't even support true floating point operations, and this was just how they decided to work around that. When communicating over the serial line, the device didn't send the data encoded in binary, however- it did everything as text. This was arguably helpful as it meant a technician could communicate with the device directly over a terminal emulator, but it meant any software talking to the device had to parse data. Which brings us to the code written by the highly paid consultants. This code needs to take two 16-bit integers and turn them into a single decimal value. Let's see how they did it. /// \u003csummary\u003e /// Sets the single parameter value. /// \u003c/summary\u003e /// \u003cparam name=\"Value\"\u003eName of the parameter.\u003c/param\u003e /// \u003cparam name=\"decimals\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public double ConvertIntToDecimal(string Value, string decimalCount) { double Result; var decimals = UInt16.Parse(decimalCount); var Val = UInt16.Parse(Value); if (decimals \u003e 0) { var divider = Math.Pow(10, decimals); Result = ((float)Val) / divider; } else { Result = Val; } return Result; } We start with comments that are just wrong, which is always a good start. The whole thing has delightfully randomized capitalization- a mix of PascalCase and camelCase. In the core logic, we parse the input values, and if there are any decimal places, we do some arithmetic to build our floating point value. We get the fun bonus inconsistency of casting to float when we handle our result in double, but at least it's a widening inconsistency, I suppose. As an overall approach to the problem, it's not a train wreck, but there's one very important thing that our highly paid consultant forgot. Our HPC, remember, was an expert in this particular instrument, or at least that was their claim. And while their mistake is an easy mistake to make while coding, it should also be an easy mistake to catch during testing, too. What was the mistake? The value is frequently negative, and they're using UInt16 to parse the inputs. Which means this function frequently threw an exception. Literally five minutes of testing would have turned it up. Janet had piles of sample data, recorded from the device, which she used for testing. Almost all of her test cases would trigger the bug at some point. It seems likely, at this juncture, that the HPC simply never actually tested the code. They wrote it. They committed it. They collected their check and left. Janet may have been the first person to actually run the code at all. In the end, hiring the HPC cost a lot of money, and maybe saved a few days of work over the course of months. It's hard to say, as it may have created more work, since so much of what the HPC did had to be debugged and often rewritten. The \"good\" news is that they have another glut of work, so management is looking to bring back the consultants for another round. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eJanet\u003c/strong\u003e\u0026#39;s company had a glut of work, and thus didn\u0026#39;t have the staffing required to do it all. It didn\u0026#39;t make sense to hire on any new full-time employees, so they went the route of bringing on a few highly paid consultants, specifically ones who specialized in one specific problem: talking to a piece of hardware purchased from a vendor.\u003c/p\u003e\n\u003cp\u003eThe hardware in question was a scientific which communicated over a serial line. This device provided a lot of data that represented decimal values, but that data was not encoded as an IEEE float. Instead, they used two integers- one for the data, and one representing the number of decimal places.\u003c/p\u003e\n\u003cp\u003eSo, for example, \u0026#34;555.55\u0026#34; would be represented as \u0026#34;55555 2\u0026#34;.\u003c/p\u003e\n\u003cp\u003eNow, in embedded devices, this isn\u0026#39;t too unusual. It\u0026#39;s entirely possible that the embedded CPU didn\u0026#39;t even support true floating point operations, and this was just how they decided to work around that.\u003c/p\u003e\n\u003cp\u003eWhen communicating over the serial line, the device didn\u0026#39;t send the data encoded in binary, however- it did everything as text. This was arguably helpful as it meant a technician could communicate with the device directly over a terminal emulator, but it meant any software talking to the device had to parse data.\u003c/p\u003e\n\u003cp\u003eWhich brings us to the code written by the highly paid consultants. This code needs to take two 16-bit integers and turn them into a single decimal value. Let\u0026#39;s see how they did it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e \u003cspan\u003e\u0026lt;summary\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e Sets the single parameter value.\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e \u003cspan\u003e\u0026lt;/summary\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e \u003cspan\u003e\u0026lt;param name=\u0026#34;Value\u0026#34;\u0026gt;\u003c/span\u003eName of the parameter.\u003cspan\u003e\u0026lt;/param\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e \u003cspan\u003e\u0026lt;param name=\u0026#34;decimals\u0026#34;\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;/param\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e///\u003c/span\u003e \u003cspan\u003e\u0026lt;returns\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;/returns\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003edouble\u003c/span\u003e \u003cspan\u003eConvertIntToDecimal\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e Value, \u003cspan\u003estring\u003c/span\u003e decimalCount\u003c/span\u003e)\u003c/span\u003e\n{\n    \u003cspan\u003edouble\u003c/span\u003e Result;\n\n    \u003cspan\u003evar\u003c/span\u003e decimals = UInt16.Parse(decimalCount);\n    \u003cspan\u003evar\u003c/span\u003e Val = UInt16.Parse(Value);\n    \u003cspan\u003eif\u003c/span\u003e (decimals \u0026gt; \u003cspan\u003e0\u003c/span\u003e)\n    {\n        \u003cspan\u003evar\u003c/span\u003e divider = Math.Pow(\u003cspan\u003e10\u003c/span\u003e, decimals);\n        Result = ((\u003cspan\u003efloat\u003c/span\u003e)Val) / divider;\n    }\n    \u003cspan\u003eelse\u003c/span\u003e\n    {\n        Result = Val;\n    }\n\n    \u003cspan\u003ereturn\u003c/span\u003e Result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe start with comments that are just wrong, which is always a good start. The whole thing has delightfully randomized capitalization- a mix of \u003ccode\u003ePascalCase\u003c/code\u003e and \u003ccode\u003ecamelCase\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn the core logic, we parse the input values, and if there are any decimal places, we do some arithmetic to build our floating point value. We get the fun bonus inconsistency of casting to \u003ccode\u003efloat\u003c/code\u003e when we handle our result in \u003ccode\u003edouble\u003c/code\u003e, but at least it\u0026#39;s a widening inconsistency, I suppose.\u003c/p\u003e\n\u003cp\u003eAs an overall approach to the problem, it\u0026#39;s not a train wreck, but there\u0026#39;s one \u003cem\u003every important thing\u003c/em\u003e that our highly paid consultant forgot. Our HPC, remember, was an expert in this particular instrument, or at least that was their claim. And while their mistake is an easy mistake to make while coding, it should also be an easy mistake to catch during testing, too.\u003c/p\u003e\n\u003cp\u003eWhat was the mistake?\u003c/p\u003e\n\u003cp\u003eThe value is frequently negative, and they\u0026#39;re using \u003ccode\u003eUInt16\u003c/code\u003e to parse the inputs. Which means this function frequently threw an exception. Literally five minutes of testing would have turned it up. Janet had piles of sample data, recorded from the device, which she used for testing. Almost all of her test cases would trigger the bug at some point.\u003c/p\u003e\n\u003cp\u003eIt seems likely, at this juncture, that the HPC simply never actually tested the code. They wrote it. They committed it. They collected their check and left. Janet may have been the first person to actually run the code at all.\u003c/p\u003e\n\u003cp\u003eIn the end, hiring the HPC cost a lot of money, and \u003cem\u003emaybe\u003c/em\u003e saved a few days of work over the course of months. It\u0026#39;s hard to say, as it may have created more work, since so much of what the HPC did had to be debugged and often rewritten.\u003c/p\u003e\n\u003cp\u003eThe \u0026#34;good\u0026#34; news is that they have another glut of work, so management is looking to bring back the consultants for another round.\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-01-20T06:30:00Z",
  "modifiedTime": null
}
