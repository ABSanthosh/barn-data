{
  "id": "8dc17f6f-b0ff-40eb-993d-b1e3eeac321e",
  "title": "CodeSOD: Uniquely Validated",
  "link": "https://thedailywtf.com/articles/uniquely-validated",
  "description": "There's the potential for endless installments of \"programmers not understanding how UUIDs work.\" Frankly, I think the fact that we represent them as human readable strings is part of the problem; sure, it's readable, but conceals the fact that it's just a large integer. Which brings us to this snippet, from Capybara James. if (!StringUtils.hasLength(uuid) || uuid.length() != 36) { throw new RequestParameterNotFoundException(ErrorCodeCostants.UUID_MANDATORY_OR_FORMAT); } StringUtils.hasLength comes from the Spring library, and it's a simple \"is not null or empty\" check. So- we're testing to see if a string is null or empty, or isn't exactly 36 characters long. That tells us the input is bad, so we throw a RequestParameterNotFoundException, along with an error code. So, as already pointed out, a UUID is just a large integer that we render as a 36 character string, and there are better ways to validate a UUID. But this also will accept any 36 character string- as long as you've got 36 characters, we'll call it a UUID. \"This is valid, really valid, dumbass\" is now a valid UUID. With that in mind, I also like the bonus of it not distinguishing between whether or not the input was missing or invalid, because that'll make it real easy for users to understand why their input is getting rejected. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "author": "Remy Porter",
  "published": "Wed, 06 Nov 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 1694,
  "excerpt": "There's the potential for endless installments of \"programmers not understanding how UUIDs work.\" Frankly, I think the fact that we represent them as human readable strings is part of the problem; sure, it's readable, but conceals the fact that it's just a large integer. Which brings us to this snippet, from Capybara James.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2024-11-06 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. There's the potential for endless installments of \"programmers not understanding how UUIDs work.\" Frankly, I think the fact that we represent them as human readable strings is part of the problem; sure, it's readable, but conceals the fact that it's just a large integer. Which brings us to this snippet, from Capybara James. if (!StringUtils.hasLength(uuid) || uuid.length() != 36) { throw new RequestParameterNotFoundException(ErrorCodeCostants.UUID_MANDATORY_OR_FORMAT); } StringUtils.hasLength comes from the Spring library, and it's a simple \"is not null or empty\" check. So- we're testing to see if a string is null or empty, or isn't exactly 36 characters long. That tells us the input is bad, so we throw a RequestParameterNotFoundException, along with an error code. So, as already pointed out, a UUID is just a large integer that we render as a 36 character string, and there are better ways to validate a UUID. But this also will accept any 36 character string- as long as you've got 36 characters, we'll call it a UUID. \"This is valid, really valid, dumbass\" is now a valid UUID. With that in mind, I also like the bonus of it not distinguishing between whether or not the input was missing or invalid, because that'll make it real easy for users to understand why their input is getting rejected. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-11-06\"\u003e2024-11-06\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10775\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eThere\u0026#39;s the potential for endless installments of \u0026#34;programmers not understanding how UUIDs work.\u0026#34; Frankly, I think the fact that we represent them as human readable strings is part of the problem; sure, it\u0026#39;s readable, but conceals the fact that it\u0026#39;s just a large integer.\u003c/p\u003e\n\u003cp\u003eWhich brings us to this snippet, from \u003cstrong\u003eCapybara James\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003eif\u003c/span\u003e (!StringUtils.hasLength(uuid) || uuid.length() != \u003cspan\u003e36\u003c/span\u003e) {\n        \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eRequestParameterNotFoundException\u003c/span\u003e(ErrorCodeCostants.UUID_MANDATORY_OR_FORMAT);\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eStringUtils.hasLength\u003c/code\u003e comes from the Spring library, and it\u0026#39;s a simple \u0026#34;is not null or empty\u0026#34; check. So- we\u0026#39;re testing to see if a string is null or empty, \u003cem\u003eor\u003c/em\u003e isn\u0026#39;t exactly 36 characters long. That tells us the input is bad, so we throw a \u003ccode\u003eRequestParameterNotFoundException\u003c/code\u003e, along with an error code.\u003c/p\u003e\n\u003cp\u003eSo, as already pointed out, a UUID is just a large integer that we \u003cem\u003erender\u003c/em\u003e as a 36 character string, and there are better ways to validate a UUID. But this also will accept any 36 character string- as long as you\u0026#39;ve got 36 characters, we\u0026#39;ll call it a UUID. \u0026#34;This is valid, really valid, dumbass\u0026#34; is now a valid UUID.\u003c/p\u003e\n\u003cp\u003eWith that in mind, I also like the bonus of it not distinguishing between whether or not the input was \u003cem\u003emissing\u003c/em\u003e or \u003cem\u003einvalid\u003c/em\u003e, because that\u0026#39;ll make it real easy for users to understand why their input is getting rejected.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tProGet’s got you covered with security and access controls on your NuGet feeds. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=GotYouCoveredFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "2 min read",
  "publishedTime": "2024-11-06T06:30:00Z",
  "modifiedTime": null
}
