{
  "id": "ddeec95a-1dbd-4436-9967-e15d70674eb7",
  "title": "CodeSOD: The Wrong Kind of Character",
  "link": "https://thedailywtf.com/articles/the-wrong-kind-of-character",
  "description": "Today's code, at first, just looks like using literals instead of constants. Austin sends us this C#, from an older Windows Forms application: if (e.KeyChar == (char)4) { // is it a ^D? e.Handled = true; DoStuff(); } else if (e.KeyChar == (char)7) { // is it a ^g? e.Handled = true; DoOtherStuff(); } else if (e.KeyChar == (char)Keys.Home) { e.Handled = true; SpecialGoToStart(); } else if (e.KeyChar == (char)Keys.End) { e.Handled = true; SpecialGoToEnd(); } Austin discovered this code when looking for a bug where some keyboard shortcuts didn't work. He made some incorrect assumptions about the code- first, that they were checking for a KeyDown or KeyUp event, a pretty normal way to check for keyboard shortcuts. Under that assumption, a developer would compare the KeyEventArgs.KeyCode property against an enum- something like e.KeyCode == Keys.D \u0026\u0026 Keys.Control, for a CTRL+D. That's clearly not what's happening here. No, here, they used the KeyPressEvent, which is meant to represent the act of typing. That gives you a KeyPressEventArgs with a KeyChar property- because again, it's meant to represent typing text not keyboard shortcuts. They used the wrong event type, as it won't tell them about modifier keys in use, or gracefully handle the home or end keys. KeyChar is the ASCII character code of the key press: which, in this case, CTRL+D is the \"end of transmit\" character in ASCII (4), and CTRL+G is the goddamn bell character (7). So those two branches work. But home and end don't have ASCII code points. They're not characters that show up in text. They get key codes, which represent the physical key pressed, not the character of text. So (char)Keys.Home isn't really a meaningful operation. But the enum is still a numeric value, so you can still turn it into a character- it just turns into a character that emphatically isn't the home key. It's the \"$\". And Keys.End turns into a \"#\". It wasn't very much work for Austin to move the event handler to the correct event type, and switch to using KeyCodes, which were both more correct and more readable. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Tue, 29 Apr 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2684,
  "excerpt": "Today's code, at first, just looks like using literals instead of constants. Austin sends us this C#, from an older Windows Forms application: if (e.KeyChar == (char)4) { // is it a ^D? e.Handled = true; DoStuff(); } else if (e.KeyChar == (char)7) { // is it a ^g? e.Handled = true; DoOtherStuff(); } else if (e.KeyChar == (char)Keys.Home) { e.Handled = true; SpecialGoToStart(); } else if (e.KeyChar == (char)Keys.End) { e.Handled = true; SpecialGoToEnd(); }",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-04-29 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Today's code, at first, just looks like using literals instead of constants. Austin sends us this C#, from an older Windows Forms application: if (e.KeyChar == (char)4) { // is it a ^D? e.Handled = true; DoStuff(); } else if (e.KeyChar == (char)7) { // is it a ^g? e.Handled = true; DoOtherStuff(); } else if (e.KeyChar == (char)Keys.Home) { e.Handled = true; SpecialGoToStart(); } else if (e.KeyChar == (char)Keys.End) { e.Handled = true; SpecialGoToEnd(); } Austin discovered this code when looking for a bug where some keyboard shortcuts didn't work. He made some incorrect assumptions about the code- first, that they were checking for a KeyDown or KeyUp event, a pretty normal way to check for keyboard shortcuts. Under that assumption, a developer would compare the KeyEventArgs.KeyCode property against an enum- something like e.KeyCode == Keys.D \u0026\u0026 Keys.Control, for a CTRL+D. That's clearly not what's happening here. No, here, they used the KeyPressEvent, which is meant to represent the act of typing. That gives you a KeyPressEventArgs with a KeyChar property- because again, it's meant to represent typing text not keyboard shortcuts. They used the wrong event type, as it won't tell them about modifier keys in use, or gracefully handle the home or end keys. KeyChar is the ASCII character code of the key press: which, in this case, CTRL+D is the \"end of transmit\" character in ASCII (4), and CTRL+G is the goddamn bell character (7). So those two branches work. But home and end don't have ASCII code points. They're not characters that show up in text. They get key codes, which represent the physical key pressed, not the character of text. So (char)Keys.Home isn't really a meaningful operation. But the enum is still a numeric value, so you can still turn it into a character- it just turns into a character that emphatically isn't the home key. It's the \"$\". And Keys.End turns into a \"#\". It wasn't very much work for Austin to move the event handler to the correct event type, and switch to using KeyCodes, which were both more correct and more readable. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-04-29\"\u003e2025-04-29\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10902\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eToday\u0026#39;s code, at first, just looks like using literals instead of constants. \u003cstrong\u003eAustin\u003c/strong\u003e sends us this C#, from an older Windows Forms application:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eif\u003c/span\u003e (e.KeyChar == (\u003cspan\u003echar\u003c/span\u003e)\u003cspan\u003e4\u003c/span\u003e) {   \u003cspan\u003e// is it a ^D?\u003c/span\u003e\n        e.Handled = \u003cspan\u003etrue\u003c/span\u003e;\n        DoStuff();\n}\n\u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (e.KeyChar == (\u003cspan\u003echar\u003c/span\u003e)\u003cspan\u003e7\u003c/span\u003e) {   \u003cspan\u003e// is it a ^g?\u003c/span\u003e\n        e.Handled = \u003cspan\u003etrue\u003c/span\u003e;\n        DoOtherStuff();\n}\n\u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (e.KeyChar == (\u003cspan\u003echar\u003c/span\u003e)Keys.Home) {\n        e.Handled = \u003cspan\u003etrue\u003c/span\u003e;\n        SpecialGoToStart();\n}\n\u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (e.KeyChar == (\u003cspan\u003echar\u003c/span\u003e)Keys.End) {\n        e.Handled = \u003cspan\u003etrue\u003c/span\u003e;\n        SpecialGoToEnd();\n} \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAustin discovered this code when looking for a bug where some keyboard shortcuts didn\u0026#39;t work. He made some incorrect assumptions about the code- first, that they were checking for a \u003ccode\u003eKeyDown\u003c/code\u003e or \u003ccode\u003eKeyUp\u003c/code\u003e event, a pretty normal way to check for keyboard shortcuts. Under that assumption, a developer would compare the \u003ccode\u003eKeyEventArgs.KeyCode\u003c/code\u003e property against an enum- something like \u003ccode\u003ee.KeyCode == Keys.D \u0026amp;\u0026amp; Keys.Control\u003c/code\u003e, for a \u003ccode\u003eCTRL+D\u003c/code\u003e. That\u0026#39;s clearly not what\u0026#39;s happening here.\u003c/p\u003e\n\u003cp\u003eNo, here, they used the \u003ccode\u003eKeyPressEvent\u003c/code\u003e, which is meant to represent the act of typing. That gives you a \u003ccode\u003eKeyPressEventArgs\u003c/code\u003e with a \u003ccode\u003eKeyChar\u003c/code\u003e property- because again, it\u0026#39;s meant to represent \u003cem\u003etyping text\u003c/em\u003e not keyboard shortcuts. They used the wrong event type, as it won\u0026#39;t tell them about modifier keys in use, or gracefully handle the home or end keys. \u003ccode\u003eKeyChar\u003c/code\u003e is the ASCII character code of the key press: which, in this case, \u003ccode\u003eCTRL+D\u003c/code\u003e is the \u0026#34;end of transmit\u0026#34; character in ASCII (4), and \u003ccode\u003eCTRL+G\u003c/code\u003e is the goddamn \u003cem\u003ebell\u003c/em\u003e character (7). So those two branches work.\u003c/p\u003e\n\u003cp\u003eBut home and end don\u0026#39;t have ASCII code points. They\u0026#39;re not characters that show up in text. They get key \u003cem\u003ecodes\u003c/em\u003e, which represent the physical key pressed, not the \u003cem\u003echaracter of text\u003c/em\u003e. So \u003ccode\u003e(char)Keys.Home\u003c/code\u003e isn\u0026#39;t really a meaningful operation. But the enum is still a numeric value, so you can still turn it into a character- it just turns into a character that emphatically \u003cem\u003eisn\u0026#39;t\u003c/em\u003e the home key. It\u0026#39;s the \u0026#34;$\u0026#34;. And \u003ccode\u003eKeys.End\u003c/code\u003e turns into a \u0026#34;#\u0026#34;.\u003c/p\u003e\n\u003cp\u003eIt wasn\u0026#39;t very much work for Austin to move the event handler to the \u003cem\u003ecorrect\u003c/em\u003e event type, and switch to using \u003ccode\u003eKeyCode\u003c/code\u003es, which were both more correct \u003cem\u003eand\u003c/em\u003e more readable.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-04-29T06:30:00Z",
  "modifiedTime": null
}
