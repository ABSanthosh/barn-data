{
  "id": "3d943f09-30d2-4f6d-9be8-2823c0e07177",
  "title": "CodeSOD: Born Single",
  "link": "https://thedailywtf.com/articles/born-single",
  "description": "Alistair sends us a pretty big blob of code, but it's a blob which touches upon everyone's favorite design pattern: the singleton. It's a lot of Java code, so we're going to take this as chunks. Let's start with the two methods responsible for constructing the object. The purpose of this code is to parse an XML file, and construct a mapping from a \"name\" field in the XML to a \"batch descriptor\". /** * Instantiates a new batch manager. */ private BatchManager() { try { final XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.setContentHandler(this); xmlReader.parse(new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"templates/\" + DOCUMENT))); } catch (final Exception e) { logger.error(\"Error parsing Batch XML.\", e); } } /* * (non-Javadoc) * * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { final BatchDescriptor batchDescriptor = new BatchDescriptor(); // put it in the map batchMap.put(attributes.getValue(\"name\"), batchDescriptor); return batchDescriptor; } Here we see a private constructor, which is reasonable for a singleton. It creates a SAX based reader. SAX is event driven- instead of loading the whole document into a DOM, it emits an event as it encounters each new key element in the XML document. It's cumbersome to use, but far more memory efficient, and I'd hardly say this.is.absolute.crap, but whatever. This code is perfectly reasonable. But do you know what's unreasonable? There's a lot more code, and these are the only things not marked as static. So let's keep going. // singleton instance so that static batch map can be initialised using // xml /** The Constant singleton. */ @SuppressWarnings(\"unused\") private static final Object singleton = new BatchManager(); Wait… why is the singleton object throwing warnings about being unused? And wait a second, what is that comment saying, \"so the static batch map can be initalalised\"? I saw a batchMap up in the initChild method above, but it can't be… private static Map batchMap = new HashMap(); Oh. Oh no. /** * Gets the. * * @param batchName * the batch name * * @return the batch descriptor */ public static BatchDescriptor get(String batchName) { return batchMap.get(batchName); } /** * Gets the post to selector name. * * @param batchName * the batch name * * @return the post to selector name */ public static String getPostToSelectorName(String batchName) { final BatchDescriptor batchDescriptor = batchMap.get(batchName); if (batchDescriptor == null) { return null; } return batchDescriptor.getPostTo(); } There are more methods, and I'll share the whole code at the end, but this gives us a taste. Here's what this code is actually doing. It creates a static Map. static, in this context, means that this instance is shared across all instances of BatchManager.They also create a static instance of BatchManager inside of itself. The constructor of that instance then executes, populating that static Map. Now, when anyone invokes BatchManager.get it will use that static Map to resolve that. This certainly works, and it offers a certain degree of cleanness in its implementation. A more conventional singleton would have the Map being owned by an instance, and it's just using the singleton convention to ensure there's only a single instance. This version's calling convention is certainly nicer than doing something like BatchManager.getInstance().get(…), but there's just something unholy about this that sticks into me. I can't say for certain if it's because I just hate Singletons, or if it's this specific abuse of constructors and static members. This is certainly one of the cases of misusing a singleton- it does not represent something there can be only one of, it's ensuring that an expensive computation is only allowed to be done once. There are better ways to handle that lifecycle. This approach also forces that expensive operation to happen at application startup, instead of being something flexible that can be evaluated lazily. It's not wrong to do this eagerly, but building something that can only do it eagerly is a mistake. In any case, the full code submission follows: package nz.this.is.absolute.crap.server.template; import java.io.IOException; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.ResourceBundle; import nz.this.is.absolute.crap.KupengaException; import nz.this.is.absolute.crap.SafeComparator; import nz.this.is.absolute.crap.sax.XMLEntity; import nz.this.is.absolute.crap.selector.Selector; import nz.this.is.absolute.crap.selector.SelectorItem; import nz.this.is.absolute.crap.server.BatchValidator; import nz.this.is.absolute.crap.server.Validatable; import nz.this.is.absolute.crap.server.ValidationException; import nz.this.is.absolute.crap.server.business.BusinessObject; import nz.this.is.absolute.crap.server.database.EntityHandler; import nz.this.is.absolute.crap.server.database.SQLEntityHandler; import org.apache.log4j.Logger; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.XMLReaderFactory; /** * The Class BatchManager. */ public class BatchManager extends XMLEntity { private static final Logger logger = Logger.getLogger(BatchManager.class); /** The Constant DOCUMENT. */ private final static String DOCUMENT = \"Batches.xml\"; /** * The Class BatchDescriptor. */ public class BatchDescriptor extends XMLEntity { /** The batchSelectors. */ private final Collection batchSelectors = new ArrayList(); /** The dependentCollections. */ private final Collection dependentCollections = new ArrayList(); /** The directSelectors. */ private final Collection directSelectors = new ArrayList(); /** The postTo. */ private String postTo; /** The properties. */ private final Collection properties = new ArrayList(); /** * Gets the batch selectors iterator. * * @return the batch selectors iterator */ public Iterator getBatchSelectorsIterator() { return this.batchSelectors.iterator(); } /** * Gets the dependent collections iterator. * * @return the dependent collections iterator */ public Iterator getDependentCollectionsIterator() { return this.dependentCollections.iterator(); } /** * Gets the post to. * * @return the post to */ public String getPostTo() { return this.postTo; } /** * Gets the post to business object. * * @param businessObject * the business object * @param postHandler * the post handler * * @return the post to business object * * @throws ValidationException * the validation exception */ private BusinessObject getPostToBusinessObject( BusinessObject businessObject, EntityHandler postHandler) throws ValidationException { if (this.postTo == null) { return null; } final BusinessObject postToBusinessObject = businessObject .getBusinessObjectFromMap(this.postTo, postHandler); // copy properties for (final String propertyName : this.properties) { String postToPropertyName; if (\"postToStatus\".equals(propertyName)) { // status field on batch entity refers to the batch entity // itself // so postToStatus is used for updating the status property // of the postToBusinessObject itself postToPropertyName = \"status\"; } else { postToPropertyName = propertyName; } final SelectorItem destinationItem = postToBusinessObject .find(postToPropertyName); if (destinationItem != null) { final Object oldValue = destinationItem.getValue(); final Object newValue = businessObject.get(propertyName); if (SafeComparator.areDifferent(oldValue, newValue)) { destinationItem.setValue(newValue); } } } // copy direct selectors for (final String selectorName : this.directSelectors) { final SelectorItem destinationItem = postToBusinessObject .find(selectorName); if (destinationItem != null) { // get the old and new values for the selectors Selector oldSelector = (Selector) destinationItem .getValue(); Selector newSelector = (Selector) businessObject .get(selectorName); // strip them down to bare identifiers for comparison if (oldSelector != null) { oldSelector = oldSelector.getAsIdentifier(); } if (newSelector != null) { newSelector = newSelector.getAsIdentifier(); } // if they're different then update if (SafeComparator.areDifferent(oldSelector, newSelector)) { destinationItem.setValue(newSelector); } } } // copy batch selectors for (final String batchSelectorName : this.batchSelectors) { final Selector batchSelector = (Selector) businessObject .get(batchSelectorName); if (batchSelector == null) { throw new ValidationException( \"\\\"PostTo\\\" selector missing.\"); } final BusinessObject batchObject = postHandler .find(batchSelector); if (batchObject != null) { // get the postTo selector for the batch object we depend on final BatchDescriptor batchDescriptor = batchMap .get(batchObject.getName()); if (batchDescriptor.postTo != null \u0026\u0026 postToBusinessObject .containsKey(batchDescriptor.postTo)) { final Selector realSelector = batchObject .getBusinessObjectFromMap( batchDescriptor.postTo, postHandler); postToBusinessObject.put(batchDescriptor.postTo, realSelector); } } } businessObject.put(this.postTo, postToBusinessObject); return postToBusinessObject; } /* * (non-Javadoc) * * @see * nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { if (\"Properties\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.properties.add(attributes .getValue(\"name\")); return null; } }; } else if (\"DirectSelectors\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.directSelectors.add(attributes .getValue(\"name\")); return null; } }; } else if (\"BatchSelectors\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.batchSelectors.add(attributes .getValue(\"name\")); return null; } }; } else if (\"PostTo\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.postTo = attributes .getValue(\"name\"); return null; } }; } else if (\"DependentCollections\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.dependentCollections .add(attributes.getValue(\"name\")); return null; } }; } return null; } } /** The batchMap. */ private static Map batchMap = new HashMap(); /** * Gets the. * * @param batchName * the batch name * * @return the batch descriptor */ public static BatchDescriptor get(String batchName) { return batchMap.get(batchName); } /** * Gets the post to selector name. * * @param batchName * the batch name * * @return the post to selector name */ public static String getPostToSelectorName(String batchName) { final BatchDescriptor batchDescriptor = batchMap.get(batchName); if (batchDescriptor == null) { return null; } return batchDescriptor.getPostTo(); } // singleton instance so that static batch map can be initialised using // xml /** The Constant singleton. */ @SuppressWarnings(\"unused\") private static final Object singleton = new BatchManager(); /** * Post. * * @param businessObject * the business object * * @throws Exception * the exception */ public static void post(BusinessObject businessObject) throws Exception { // validate the batch root object only - it can validate the rest if it // needs to if (businessObject instanceof Validatable) { if (!BatchValidator.validate(businessObject)) { logger.warn(String.format(\"Validating %s failed\", businessObject.getClass().getSimpleName())); throw new ValidationException( \"Batch did not validate - it was not posted\"); } ((Validatable) businessObject).validator().prepareToPost(); } final SQLEntityHandler postHandler = new SQLEntityHandler(true); final Iterator batchIterator = new BatchIterator( businessObject, null, postHandler); // iterate through batch again posting each object try { while (batchIterator.hasNext()) { post(batchIterator.next(), postHandler); } postHandler.commit(); } catch (final Exception e) { logger.error(\"Exception occurred while posting batches\", e); // something went wrong postHandler.rollback(); throw e; } return; } /** * Post. * * @param businessObject * the business object * @param postHandler * the post handler * * @throws KupengaException * the kupenga exception */ private static void post(BusinessObject businessObject, EntityHandler postHandler) throws KupengaException { if (businessObject == null) { return; } if (Boolean.TRUE.equals(businessObject.get(\"posted\"))) { return; } final BatchDescriptor batchDescriptor = batchMap.get(businessObject .getName()); final BusinessObject postToBusinessObject = batchDescriptor .getPostToBusinessObject(businessObject, postHandler); if (postToBusinessObject != null) { postToBusinessObject.save(postHandler); } businessObject.setItemValue(\"posted\", Boolean.TRUE); businessObject.save(postHandler); } /** * Instantiates a new batch manager. */ private BatchManager() { try { final XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.setContentHandler(this); xmlReader.parse(new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"templates/\" + DOCUMENT))); } catch (final Exception e) { logger.error(\"Error parsing Batch XML.\", e); } } /* * (non-Javadoc) * * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { final BatchDescriptor batchDescriptor = new BatchDescriptor(); // put it in the map batchMap.put(attributes.getValue(\"name\"), batchDescriptor); return batchDescriptor; } } .comment { border: none; } [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Tue, 15 Jul 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 16470,
  "excerpt": "Alistair sends us a pretty big blob of code, but it's a blob which touches upon everyone's favorite design pattern: the singleton. It's a lot of Java code, so we're going to take this as chunks. Let's start with the two methods responsible for constructing the object. The purpose of this code is to parse an XML file, and construct a mapping from a \"name\" field in the XML to a \"batch descriptor\".",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Alistair sends us a pretty big blob of code, but it's a blob which touches upon everyone's favorite design pattern: the singleton. It's a lot of Java code, so we're going to take this as chunks. Let's start with the two methods responsible for constructing the object. The purpose of this code is to parse an XML file, and construct a mapping from a \"name\" field in the XML to a \"batch descriptor\". /** * Instantiates a new batch manager. */ private BatchManager() { try { final XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.setContentHandler(this); xmlReader.parse(new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"templates/\" + DOCUMENT))); } catch (final Exception e) { logger.error(\"Error parsing Batch XML.\", e); } } /* * (non-Javadoc) * * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { final BatchDescriptor batchDescriptor = new BatchDescriptor(); // put it in the map batchMap.put(attributes.getValue(\"name\"), batchDescriptor); return batchDescriptor; } Here we see a private constructor, which is reasonable for a singleton. It creates a SAX based reader. SAX is event driven- instead of loading the whole document into a DOM, it emits an event as it encounters each new key element in the XML document. It's cumbersome to use, but far more memory efficient, and I'd hardly say this.is.absolute.crap, but whatever. This code is perfectly reasonable. But do you know what's unreasonable? There's a lot more code, and these are the only things not marked as static. So let's keep going. // singleton instance so that static batch map can be initialised using // xml /** The Constant singleton. */ @SuppressWarnings(\"unused\") private static final Object singleton = new BatchManager(); Wait… why is the singleton object throwing warnings about being unused? And wait a second, what is that comment saying, \"so the static batch map can be initalalised\"? I saw a batchMap up in the initChild method above, but it can't be… private static Map\u003cString, BatchDescriptor\u003e batchMap = new HashMap\u003cString, BatchDescriptor\u003e(); Oh. Oh no. /** * Gets the. * * @param batchName * the batch name * * @return the batch descriptor */ public static BatchDescriptor get(String batchName) { return batchMap.get(batchName); } /** * Gets the post to selector name. * * @param batchName * the batch name * * @return the post to selector name */ public static String getPostToSelectorName(String batchName) { final BatchDescriptor batchDescriptor = batchMap.get(batchName); if (batchDescriptor == null) { return null; } return batchDescriptor.getPostTo(); } There are more methods, and I'll share the whole code at the end, but this gives us a taste. Here's what this code is actually doing. It creates a static Map. static, in this context, means that this instance is shared across all instances of BatchManager.They also create a static instance of BatchManager inside of itself. The constructor of that instance then executes, populating that static Map. Now, when anyone invokes BatchManager.get it will use that static Map to resolve that. This certainly works, and it offers a certain degree of cleanness in its implementation. A more conventional singleton would have the Map being owned by an instance, and it's just using the singleton convention to ensure there's only a single instance. This version's calling convention is certainly nicer than doing something like BatchManager.getInstance().get(…), but there's just something unholy about this that sticks into me. I can't say for certain if it's because I just hate Singletons, or if it's this specific abuse of constructors and static members. This is certainly one of the cases of misusing a singleton- it does not represent something there can be only one of, it's ensuring that an expensive computation is only allowed to be done once. There are better ways to handle that lifecycle. This approach also forces that expensive operation to happen at application startup, instead of being something flexible that can be evaluated lazily. It's not wrong to do this eagerly, but building something that can only do it eagerly is a mistake. In any case, the full code submission follows: package nz.this.is.absolute.crap.server.template; import java.io.IOException; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.ResourceBundle; import nz.this.is.absolute.crap.KupengaException; import nz.this.is.absolute.crap.SafeComparator; import nz.this.is.absolute.crap.sax.XMLEntity; import nz.this.is.absolute.crap.selector.Selector; import nz.this.is.absolute.crap.selector.SelectorItem; import nz.this.is.absolute.crap.server.BatchValidator; import nz.this.is.absolute.crap.server.Validatable; import nz.this.is.absolute.crap.server.ValidationException; import nz.this.is.absolute.crap.server.business.BusinessObject; import nz.this.is.absolute.crap.server.database.EntityHandler; import nz.this.is.absolute.crap.server.database.SQLEntityHandler; import org.apache.log4j.Logger; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; import org.xml.sax.helpers.XMLReaderFactory; /** * The Class BatchManager. */ public class BatchManager extends XMLEntity { private static final Logger logger = Logger.getLogger(BatchManager.class); /** The Constant DOCUMENT. */ private final static String DOCUMENT = \"Batches.xml\"; /** * The Class BatchDescriptor. */ public class BatchDescriptor extends XMLEntity { /** The batchSelectors. */ private final Collection\u003cString\u003e batchSelectors = new ArrayList\u003cString\u003e(); /** The dependentCollections. */ private final Collection\u003cString\u003e dependentCollections = new ArrayList\u003cString\u003e(); /** The directSelectors. */ private final Collection\u003cString\u003e directSelectors = new ArrayList\u003cString\u003e(); /** The postTo. */ private String postTo; /** The properties. */ private final Collection\u003cString\u003e properties = new ArrayList\u003cString\u003e(); /** * Gets the batch selectors iterator. * * @return the batch selectors iterator */ public Iterator\u003cString\u003e getBatchSelectorsIterator() { return this.batchSelectors.iterator(); } /** * Gets the dependent collections iterator. * * @return the dependent collections iterator */ public Iterator\u003cString\u003e getDependentCollectionsIterator() { return this.dependentCollections.iterator(); } /** * Gets the post to. * * @return the post to */ public String getPostTo() { return this.postTo; } /** * Gets the post to business object. * * @param businessObject * the business object * @param postHandler * the post handler * * @return the post to business object * * @throws ValidationException * the validation exception */ private BusinessObject getPostToBusinessObject( BusinessObject businessObject, EntityHandler postHandler) throws ValidationException { if (this.postTo == null) { return null; } final BusinessObject postToBusinessObject = businessObject .getBusinessObjectFromMap(this.postTo, postHandler); // copy properties for (final String propertyName : this.properties) { String postToPropertyName; if (\"postToStatus\".equals(propertyName)) { // status field on batch entity refers to the batch entity // itself // so postToStatus is used for updating the status property // of the postToBusinessObject itself postToPropertyName = \"status\"; } else { postToPropertyName = propertyName; } final SelectorItem destinationItem = postToBusinessObject .find(postToPropertyName); if (destinationItem != null) { final Object oldValue = destinationItem.getValue(); final Object newValue = businessObject.get(propertyName); if (SafeComparator.areDifferent(oldValue, newValue)) { destinationItem.setValue(newValue); } } } // copy direct selectors for (final String selectorName : this.directSelectors) { final SelectorItem destinationItem = postToBusinessObject .find(selectorName); if (destinationItem != null) { // get the old and new values for the selectors Selector oldSelector = (Selector) destinationItem .getValue(); Selector newSelector = (Selector) businessObject .get(selectorName); // strip them down to bare identifiers for comparison if (oldSelector != null) { oldSelector = oldSelector.getAsIdentifier(); } if (newSelector != null) { newSelector = newSelector.getAsIdentifier(); } // if they're different then update if (SafeComparator.areDifferent(oldSelector, newSelector)) { destinationItem.setValue(newSelector); } } } // copy batch selectors for (final String batchSelectorName : this.batchSelectors) { final Selector batchSelector = (Selector) businessObject .get(batchSelectorName); if (batchSelector == null) { throw new ValidationException( \"\\\"PostTo\\\" selector missing.\"); } final BusinessObject batchObject = postHandler .find(batchSelector); if (batchObject != null) { // get the postTo selector for the batch object we depend on final BatchDescriptor batchDescriptor = batchMap .get(batchObject.getName()); if (batchDescriptor.postTo != null \u0026\u0026 postToBusinessObject .containsKey(batchDescriptor.postTo)) { final Selector realSelector = batchObject .getBusinessObjectFromMap( batchDescriptor.postTo, postHandler); postToBusinessObject.put(batchDescriptor.postTo, realSelector); } } } businessObject.put(this.postTo, postToBusinessObject); return postToBusinessObject; } /* * (non-Javadoc) * * @see * nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { if (\"Properties\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.properties.add(attributes .getValue(\"name\")); return null; } }; } else if (\"DirectSelectors\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.directSelectors.add(attributes .getValue(\"name\")); return null; } }; } else if (\"BatchSelectors\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.batchSelectors.add(attributes .getValue(\"name\")); return null; } }; } else if (\"PostTo\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.postTo = attributes .getValue(\"name\"); return null; } }; } else if (\"DependentCollections\".equals(qName)) { return new XMLEntity() { @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { BatchDescriptor.this.dependentCollections .add(attributes.getValue(\"name\")); return null; } }; } return null; } } /** The batchMap. */ private static Map\u003cString, BatchDescriptor\u003e batchMap = new HashMap\u003cString, BatchDescriptor\u003e(); /** * Gets the. * * @param batchName * the batch name * * @return the batch descriptor */ public static BatchDescriptor get(String batchName) { return batchMap.get(batchName); } /** * Gets the post to selector name. * * @param batchName * the batch name * * @return the post to selector name */ public static String getPostToSelectorName(String batchName) { final BatchDescriptor batchDescriptor = batchMap.get(batchName); if (batchDescriptor == null) { return null; } return batchDescriptor.getPostTo(); } // singleton instance so that static batch map can be initialised using // xml /** The Constant singleton. */ @SuppressWarnings(\"unused\") private static final Object singleton = new BatchManager(); /** * Post. * * @param businessObject * the business object * * @throws Exception * the exception */ public static void post(BusinessObject businessObject) throws Exception { // validate the batch root object only - it can validate the rest if it // needs to if (businessObject instanceof Validatable) { if (!BatchValidator.validate(businessObject)) { logger.warn(String.format(\"Validating %s failed\", businessObject.getClass().getSimpleName())); throw new ValidationException( \"Batch did not validate - it was not posted\"); } ((Validatable) businessObject).validator().prepareToPost(); } final SQLEntityHandler postHandler = new SQLEntityHandler(true); final Iterator\u003cBusinessObject\u003e batchIterator = new BatchIterator( businessObject, null, postHandler); // iterate through batch again posting each object try { while (batchIterator.hasNext()) { post(batchIterator.next(), postHandler); } postHandler.commit(); } catch (final Exception e) { logger.error(\"Exception occurred while posting batches\", e); // something went wrong postHandler.rollback(); throw e; } return; } /** * Post. * * @param businessObject * the business object * @param postHandler * the post handler * * @throws KupengaException * the kupenga exception */ private static void post(BusinessObject businessObject, EntityHandler postHandler) throws KupengaException { if (businessObject == null) { return; } if (Boolean.TRUE.equals(businessObject.get(\"posted\"))) { return; } final BatchDescriptor batchDescriptor = batchMap.get(businessObject .getName()); final BusinessObject postToBusinessObject = batchDescriptor .getPostToBusinessObject(businessObject, postHandler); if (postToBusinessObject != null) { postToBusinessObject.save(postHandler); } businessObject.setItemValue(\"posted\", Boolean.TRUE); businessObject.save(postHandler); } /** * Instantiates a new batch manager. */ private BatchManager() { try { final XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.setContentHandler(this); xmlReader.parse(new InputSource(this.getClass().getClassLoader().getResourceAsStream(\"templates/\" + DOCUMENT))); } catch (final Exception e) { logger.error(\"Error parsing Batch XML.\", e); } } /* * (non-Javadoc) * * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String, * java.lang.String, java.lang.String, org.xml.sax.Attributes) */ @Override protected ContentHandler initChild(String uri, String localName, String qName, Attributes attributes) throws SAXException { final BatchDescriptor batchDescriptor = new BatchDescriptor(); // put it in the map batchMap.put(attributes.getValue(\"name\"), batchDescriptor); return batchDescriptor; } } [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eAlistair\u003c/strong\u003e sends us a pretty big blob of code, but it\u0026#39;s a blob which touches upon everyone\u0026#39;s favorite design pattern: the \u003cem\u003esingleton\u003c/em\u003e. It\u0026#39;s a lot of Java code, so we\u0026#39;re going to take this as chunks. Let\u0026#39;s start with the two methods responsible for constructing the object.\u003c/p\u003e\n\u003cp\u003eThe purpose of this code is to parse an XML file, and construct a mapping from a \u0026#34;name\u0026#34; field in the XML to a \u0026#34;batch descriptor\u0026#34;.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003e/**\n\t * Instantiates a new batch manager.\n\t */\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eBatchManager\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e {\n\t\t\u003cspan\u003etry\u003c/span\u003e {\n\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eXMLReader\u003c/span\u003e \u003cspan\u003exmlReader\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e XMLReaderFactory.createXMLReader();\n\t\t\txmlReader.setContentHandler(\u003cspan\u003ethis\u003c/span\u003e);\n\t\t\txmlReader.parse(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eInputSource\u003c/span\u003e(\u003cspan\u003ethis\u003c/span\u003e.getClass().getClassLoader().getResourceAsStream(\u003cspan\u003e\u0026#34;templates/\u0026#34;\u003c/span\u003e + DOCUMENT)));\n\t\t} \u003cspan\u003ecatch\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e Exception e) {\n\t\t\tlogger.error(\u003cspan\u003e\u0026#34;Error parsing Batch XML.\u0026#34;\u003c/span\u003e, e);\n\t\t}\n\t}\n\n\t\u003cspan\u003e/*\n\t * (non-Javadoc)\n\t * \n\t * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String,\n\t * java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\u003c/span\u003e\n\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri, String localName,\n\t\t\tString qName, Attributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e();\n\t\t\u003cspan\u003e// put it in the map\u003c/span\u003e\n\t\tbatchMap.put(attributes.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e), batchDescriptor);\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchDescriptor;\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we see a private constructor, which is reasonable for a singleton. It creates a SAX based reader. SAX is event driven- instead of loading the whole document into a DOM, it emits an event as it encounters each new key element in the XML document. It\u0026#39;s cumbersome to use, but far more memory efficient, and I\u0026#39;d hardly say \u003ccode\u003ethis.is.absolute.crap\u003c/code\u003e, but whatever.\u003c/p\u003e\n\u003cp\u003eThis code is perfectly reasonable. But do you know what\u0026#39;s unreasonable? There\u0026#39;s a lot more code, and these are the only things \u003cem\u003enot marked as \u003ccode\u003estatic\u003c/code\u003e\u003c/em\u003e. So let\u0026#39;s keep going.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003e// singleton instance so that static batch map can be initialised using\u003c/span\u003e\n\t\u003cspan\u003e// xml\u003c/span\u003e\n\t\u003cspan\u003e/** The Constant singleton. */\u003c/span\u003e\n\t\u003cspan\u003e@SuppressWarnings(\u0026#34;unused\u0026#34;)\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eObject\u003c/span\u003e \u003cspan\u003esingleton\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBatchManager\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWait… why is the singleton object throwing warnings about being unused? And wait a second, what is that comment saying, \u0026#34;so the static batch map can be initalalised\u0026#34;? I saw a \u003ccode\u003ebatchMap\u003c/code\u003e up in the \u003ccode\u003einitChild\u003c/code\u003e method above, but it can\u0026#39;t be…\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e Map\u0026lt;String, BatchDescriptor\u0026gt; batchMap = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eHashMap\u003c/span\u003e\u0026lt;String, BatchDescriptor\u0026gt;();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh. Oh no.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003e/**\n\t * Gets the.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e batchName\n\t *            the batch name\n\t * \n\t * \u003cspan\u003e@return\u003c/span\u003e the batch descriptor\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e BatchDescriptor \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(String batchName)\u003c/span\u003e {\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchMap.get(batchName);\n\t}\n\n\t\u003cspan\u003e/**\n\t * Gets the post to selector name.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e batchName\n\t *            the batch name\n\t * \n\t * \u003cspan\u003e@return\u003c/span\u003e the post to selector name\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e String \u003cspan\u003egetPostToSelectorName\u003c/span\u003e\u003cspan\u003e(String batchName)\u003c/span\u003e {\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchMap.get(batchName);\n\t\t\u003cspan\u003eif\u003c/span\u003e (batchDescriptor == \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t}\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchDescriptor.getPostTo();\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are more methods, and I\u0026#39;ll share the whole code at the end, but this gives us a taste. Here\u0026#39;s what this code is \u003cem\u003eactually\u003c/em\u003e doing.\u003c/p\u003e\n\u003cp\u003eIt creates a \u003ccode\u003estatic\u003c/code\u003e \u003ccode\u003eMap\u003c/code\u003e. \u003ccode\u003estatic\u003c/code\u003e, in this context, means that this instance is shared across all instances of \u003ccode\u003eBatchManager\u003c/code\u003e.They also create a \u003ccode\u003estatic\u003c/code\u003e instance of \u003ccode\u003eBatchManager\u003c/code\u003e inside of itself. The constructor of that instance then executes, populating that \u003ccode\u003estatic\u003c/code\u003e \u003ccode\u003eMap\u003c/code\u003e. Now, when anyone invokes \u003ccode\u003eBatchManager.get\u003c/code\u003e it will use that \u003ccode\u003estatic\u003c/code\u003e \u003ccode\u003eMap\u003c/code\u003e to resolve that.\u003c/p\u003e\n\u003cp\u003eThis certainly works, and it offers a certain degree of \u003cem\u003ecleanness\u003c/em\u003e in its implementation. A more conventional singleton would have the \u003ccode\u003eMap\u003c/code\u003e being owned by an \u003cem\u003einstance\u003c/em\u003e, and it\u0026#39;s just using the singleton convention to ensure there\u0026#39;s only a single instance. This version\u0026#39;s calling convention is certainly nicer than doing something like \u003ccode\u003eBatchManager.getInstance().get(…)\u003c/code\u003e, but there\u0026#39;s just something unholy about this that sticks into me.\u003c/p\u003e\n\u003cp\u003eI can\u0026#39;t say for certain if it\u0026#39;s because I just hate Singletons, or if it\u0026#39;s this specific abuse of constructors and static members.\u003c/p\u003e\n\u003cp\u003eThis is certainly one of the cases of misusing a singleton- it does not represent something there can be only one of, it\u0026#39;s ensuring that an expensive computation is only allowed to be done once. There are better ways to handle that lifecycle. This approach also forces that expensive operation to happen at application startup, instead of being something flexible that can be evaluated lazily. It\u0026#39;s not \u003cem\u003ewrong\u003c/em\u003e to do this eagerly, but building something that \u003cem\u003ecan only do it\u003c/em\u003e eagerly is a mistake.\u003c/p\u003e\n\u003cp\u003eIn any case, the full code submission follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epackage\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.template;\n\n\u003cspan\u003eimport\u003c/span\u003e java.io.IOException;\n\u003cspan\u003eimport\u003c/span\u003e java.util.ArrayList;\n\u003cspan\u003eimport\u003c/span\u003e java.util.Collection;\n\u003cspan\u003eimport\u003c/span\u003e java.util.HashMap;\n\u003cspan\u003eimport\u003c/span\u003e java.util.Iterator;\n\u003cspan\u003eimport\u003c/span\u003e java.util.Map;\n\u003cspan\u003eimport\u003c/span\u003e java.util.ResourceBundle;\n\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.KupengaException;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.SafeComparator;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.sax.XMLEntity;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.selector.Selector;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.selector.SelectorItem;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.BatchValidator;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.Validatable;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.ValidationException;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.business.BusinessObject;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.database.EntityHandler;\n\u003cspan\u003eimport\u003c/span\u003e nz.\u003cspan\u003ethis\u003c/span\u003e.is.absolute.crap.server.database.SQLEntityHandler;\n\n\u003cspan\u003eimport\u003c/span\u003e org.apache.log4j.Logger;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.Attributes;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.ContentHandler;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.InputSource;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.SAXException;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.XMLReader;\n\u003cspan\u003eimport\u003c/span\u003e org.xml.sax.helpers.XMLReaderFactory;\n\n\u003cspan\u003e/**\n * The Class BatchManager.\n */\u003c/span\u003e\n\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eBatchManager\u003c/span\u003e \u003cspan\u003eextends\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e {\n\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eLogger\u003c/span\u003e \u003cspan\u003elogger\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e Logger.getLogger(BatchManager.class);\n\t\n\t\u003cspan\u003e/** The Constant DOCUMENT. */\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003eDOCUMENT\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Batches.xml\u0026#34;\u003c/span\u003e;\n\n\t\u003cspan\u003e/**\n\t * The Class BatchDescriptor.\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003eextends\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e {\n\n\t\t\u003cspan\u003e/** The batchSelectors. */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e Collection\u0026lt;String\u0026gt; batchSelectors = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eArrayList\u003c/span\u003e\u0026lt;String\u0026gt;();\n\n\t\t\u003cspan\u003e/** The dependentCollections. */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e Collection\u0026lt;String\u0026gt; dependentCollections = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eArrayList\u003c/span\u003e\u0026lt;String\u0026gt;();\n\n\t\t\u003cspan\u003e/** The directSelectors. */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e Collection\u0026lt;String\u0026gt; directSelectors = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eArrayList\u003c/span\u003e\u0026lt;String\u0026gt;();\n\n\t\t\u003cspan\u003e/** The postTo. */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e String postTo;\n\n\t\t\u003cspan\u003e/** The properties. */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e Collection\u0026lt;String\u0026gt; properties = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eArrayList\u003c/span\u003e\u0026lt;String\u0026gt;();\n\n\t\t\u003cspan\u003e/**\n\t\t * Gets the batch selectors iterator.\n\t\t * \n\t\t * \u003cspan\u003e@return\u003c/span\u003e the batch selectors iterator\n\t\t */\u003c/span\u003e\n\t\t\u003cspan\u003epublic\u003c/span\u003e Iterator\u0026lt;String\u0026gt; \u003cspan\u003egetBatchSelectorsIterator\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e.batchSelectors.iterator();\n\t\t}\n\n\t\t\u003cspan\u003e/**\n\t\t * Gets the dependent collections iterator.\n\t\t * \n\t\t * \u003cspan\u003e@return\u003c/span\u003e the dependent collections iterator\n\t\t */\u003c/span\u003e\n\t\t\u003cspan\u003epublic\u003c/span\u003e Iterator\u0026lt;String\u0026gt; \u003cspan\u003egetDependentCollectionsIterator\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e.dependentCollections.iterator();\n\t\t}\n\n\t\t\u003cspan\u003e/**\n\t\t * Gets the post to.\n\t\t * \n\t\t * \u003cspan\u003e@return\u003c/span\u003e the post to\n\t\t */\u003c/span\u003e\n\t\t\u003cspan\u003epublic\u003c/span\u003e String \u003cspan\u003egetPostTo\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e.postTo;\n\t\t}\n\n\t\t\u003cspan\u003e/**\n\t\t * Gets the post to business object.\n\t\t * \n\t\t * \u003cspan\u003e@param\u003c/span\u003e businessObject\n\t\t *            the business object\n\t\t * \u003cspan\u003e@param\u003c/span\u003e postHandler\n\t\t *            the post handler\n\t\t * \n\t\t * \u003cspan\u003e@return\u003c/span\u003e the post to business object\n\t\t * \n\t\t * \u003cspan\u003e@throws\u003c/span\u003e ValidationException\n\t\t *             the validation exception\n\t\t */\u003c/span\u003e\n\t\t\u003cspan\u003eprivate\u003c/span\u003e BusinessObject \u003cspan\u003egetPostToBusinessObject\u003c/span\u003e\u003cspan\u003e(\n\t\t\t\tBusinessObject businessObject, EntityHandler postHandler)\u003c/span\u003e\n\t\t\t\t\u003cspan\u003ethrows\u003c/span\u003e ValidationException {\n\t\t\t\u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003ethis\u003c/span\u003e.postTo == \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t}\n\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBusinessObject\u003c/span\u003e \u003cspan\u003epostToBusinessObject\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e businessObject\n\t\t\t\t\t.getBusinessObjectFromMap(\u003cspan\u003ethis\u003c/span\u003e.postTo, postHandler);\n\t\t\t\u003cspan\u003e// copy properties\u003c/span\u003e\n\t\t\t\u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e String propertyName : \u003cspan\u003ethis\u003c/span\u003e.properties) {\n\t\t\t\tString postToPropertyName;\n\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;postToStatus\u0026#34;\u003c/span\u003e.equals(propertyName)) {\n\t\t\t\t\t\u003cspan\u003e// status field on batch entity refers to the batch entity\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003e// itself\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003e// so postToStatus is used for updating the status property\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003e// of the postToBusinessObject itself\u003c/span\u003e\n\t\t\t\t\tpostToPropertyName = \u003cspan\u003e\u0026#34;status\u0026#34;\u003c/span\u003e;\n\t\t\t\t} \u003cspan\u003eelse\u003c/span\u003e {\n\t\t\t\t\tpostToPropertyName = propertyName;\n\t\t\t\t}\n\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eSelectorItem\u003c/span\u003e \u003cspan\u003edestinationItem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e postToBusinessObject\n\t\t\t\t\t\t.find(postToPropertyName);\n\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (destinationItem != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eObject\u003c/span\u003e \u003cspan\u003eoldValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e destinationItem.getValue();\n\t\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eObject\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e businessObject.get(propertyName);\n\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (SafeComparator.areDifferent(oldValue, newValue)) {\n\t\t\t\t\t\tdestinationItem.setValue(newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\u003cspan\u003e// copy direct selectors\u003c/span\u003e\n\t\t\t\u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e String selectorName : \u003cspan\u003ethis\u003c/span\u003e.directSelectors) {\n\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eSelectorItem\u003c/span\u003e \u003cspan\u003edestinationItem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e postToBusinessObject\n\t\t\t\t\t\t.find(selectorName);\n\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (destinationItem != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\u003cspan\u003e// get the old and new values for the selectors\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eSelector\u003c/span\u003e \u003cspan\u003eoldSelector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e (Selector) destinationItem\n\t\t\t\t\t\t\t.getValue();\n\t\t\t\t\t\u003cspan\u003eSelector\u003c/span\u003e \u003cspan\u003enewSelector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e (Selector) businessObject\n\t\t\t\t\t\t\t.get(selectorName);\n\t\t\t\t\t\u003cspan\u003e// strip them down to bare identifiers for comparison\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (oldSelector != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\toldSelector = oldSelector.getAsIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (newSelector != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\tnewSelector = newSelector.getAsIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\t\u003cspan\u003e// if they\u0026#39;re different then update\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (SafeComparator.areDifferent(oldSelector, newSelector)) {\n\t\t\t\t\t\tdestinationItem.setValue(newSelector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\u003cspan\u003e// copy batch selectors\u003c/span\u003e\n\t\t\t\u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e String batchSelectorName : \u003cspan\u003ethis\u003c/span\u003e.batchSelectors) {\n\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eSelector\u003c/span\u003e \u003cspan\u003ebatchSelector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e (Selector) businessObject\n\t\t\t\t\t\t.get(batchSelectorName);\n\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (batchSelector == \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eValidationException\u003c/span\u003e(\n\t\t\t\t\t\t\t\u003cspan\u003e\u0026#34;\\\u0026#34;PostTo\\\u0026#34; selector missing.\u0026#34;\u003c/span\u003e);\n\t\t\t\t}\n\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBusinessObject\u003c/span\u003e \u003cspan\u003ebatchObject\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e postHandler\n\t\t\t\t\t\t.find(batchSelector);\n\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (batchObject != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\t\t\u003cspan\u003e// get the postTo selector for the batch object we depend on\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchMap\n\t\t\t\t\t\t\t.get(batchObject.getName());\n\t\t\t\t\t\u003cspan\u003eif\u003c/span\u003e (batchDescriptor.postTo != \u003cspan\u003enull\u003c/span\u003e\n\t\t\t\t\t\t\t\u0026amp;\u0026amp; postToBusinessObject\n\t\t\t\t\t\t\t\t\t.containsKey(batchDescriptor.postTo)) {\n\t\t\t\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eSelector\u003c/span\u003e \u003cspan\u003erealSelector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchObject\n\t\t\t\t\t\t\t\t.getBusinessObjectFromMap(\n\t\t\t\t\t\t\t\t\t\tbatchDescriptor.postTo, postHandler);\n\t\t\t\t\t\tpostToBusinessObject.put(batchDescriptor.postTo,\n\t\t\t\t\t\t\t\trealSelector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbusinessObject.put(\u003cspan\u003ethis\u003c/span\u003e.postTo, postToBusinessObject);\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e postToBusinessObject;\n\t\t}\n\n\t\t\u003cspan\u003e/*\n\t\t * (non-Javadoc)\n\t\t * \n\t\t * @see\n\t\t * nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String,\n\t\t * java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\u003c/span\u003e\n\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri, String localName,\n\t\t\t\tString qName, Attributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;Properties\u0026#34;\u003c/span\u003e.equals(qName)) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e() {\n\t\t\t\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri,\n\t\t\t\t\t\t\tString localName, String qName,\n\t\t\t\t\t\t\tAttributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\t\t\tBatchDescriptor.\u003cspan\u003ethis\u003c/span\u003e.properties.add(attributes\n\t\t\t\t\t\t\t\t.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e));\n\t\t\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;DirectSelectors\u0026#34;\u003c/span\u003e.equals(qName)) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e() {\n\t\t\t\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri,\n\t\t\t\t\t\t\tString localName, String qName,\n\t\t\t\t\t\t\tAttributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\t\t\tBatchDescriptor.\u003cspan\u003ethis\u003c/span\u003e.directSelectors.add(attributes\n\t\t\t\t\t\t\t\t.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e));\n\t\t\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;BatchSelectors\u0026#34;\u003c/span\u003e.equals(qName)) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e() {\n\t\t\t\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri,\n\t\t\t\t\t\t\tString localName, String qName,\n\t\t\t\t\t\t\tAttributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\t\t\tBatchDescriptor.\u003cspan\u003ethis\u003c/span\u003e.batchSelectors.add(attributes\n\t\t\t\t\t\t\t\t.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e));\n\t\t\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;PostTo\u0026#34;\u003c/span\u003e.equals(qName)) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e() {\n\t\t\t\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri,\n\t\t\t\t\t\t\tString localName, String qName,\n\t\t\t\t\t\t\tAttributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\t\t\tBatchDescriptor.\u003cspan\u003ethis\u003c/span\u003e.postTo = attributes\n\t\t\t\t\t\t\t\t.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e);\n\t\t\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e\u0026#34;DependentCollections\u0026#34;\u003c/span\u003e.equals(qName)) {\n\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eXMLEntity\u003c/span\u003e() {\n\t\t\t\t\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\t\t\t\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri,\n\t\t\t\t\t\t\tString localName, String qName,\n\t\t\t\t\t\t\tAttributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\t\t\t\tBatchDescriptor.\u003cspan\u003ethis\u003c/span\u003e.dependentCollections\n\t\t\t\t\t\t\t\t.add(attributes.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e));\n\t\t\t\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t}\n\t}\n\n\t\u003cspan\u003e/** The batchMap. */\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e Map\u0026lt;String, BatchDescriptor\u0026gt; batchMap = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eHashMap\u003c/span\u003e\u0026lt;String, BatchDescriptor\u0026gt;();\n\n\t\u003cspan\u003e/**\n\t * Gets the.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e batchName\n\t *            the batch name\n\t * \n\t * \u003cspan\u003e@return\u003c/span\u003e the batch descriptor\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e BatchDescriptor \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(String batchName)\u003c/span\u003e {\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchMap.get(batchName);\n\t}\n\n\t\u003cspan\u003e/**\n\t * Gets the post to selector name.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e batchName\n\t *            the batch name\n\t * \n\t * \u003cspan\u003e@return\u003c/span\u003e the post to selector name\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e String \u003cspan\u003egetPostToSelectorName\u003c/span\u003e\u003cspan\u003e(String batchName)\u003c/span\u003e {\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchMap.get(batchName);\n\t\t\u003cspan\u003eif\u003c/span\u003e (batchDescriptor == \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n\t\t}\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchDescriptor.getPostTo();\n\t}\n\n\t\u003cspan\u003e// singleton instance so that static batch map can be initialised using\u003c/span\u003e\n\t\u003cspan\u003e// xml\u003c/span\u003e\n\t\u003cspan\u003e/** The Constant singleton. */\u003c/span\u003e\n\t\u003cspan\u003e@SuppressWarnings(\u0026#34;unused\u0026#34;)\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eObject\u003c/span\u003e \u003cspan\u003esingleton\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBatchManager\u003c/span\u003e();\n\n\t\u003cspan\u003e/**\n\t * Post.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e businessObject\n\t *            the business object\n\t * \n\t * \u003cspan\u003e@throws\u003c/span\u003e Exception\n\t *             the exception\n\t */\u003c/span\u003e\n\t\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(BusinessObject businessObject)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e Exception {\n\t\t\u003cspan\u003e// validate the batch root object only - it can validate the rest if it\u003c/span\u003e\n\t\t\u003cspan\u003e// needs to\u003c/span\u003e\n\t\t\n\t\t\u003cspan\u003eif\u003c/span\u003e (businessObject \u003cspan\u003einstanceof\u003c/span\u003e Validatable) {\n\t\t\t\u003cspan\u003eif\u003c/span\u003e (!BatchValidator.validate(businessObject)) {\n\t\t\t\tlogger.warn(String.format(\u003cspan\u003e\u0026#34;Validating %s failed\u0026#34;\u003c/span\u003e, businessObject.getClass().getSimpleName()));\n\t\t\t\t\u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eValidationException\u003c/span\u003e(\n\t\t\t\t\t\t\u003cspan\u003e\u0026#34;Batch did not validate - it was not posted\u0026#34;\u003c/span\u003e);\n\t\t\t}\n\t\t\n\t\t\t((Validatable) businessObject).validator().prepareToPost();\n\t\t}\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eSQLEntityHandler\u003c/span\u003e \u003cspan\u003epostHandler\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eSQLEntityHandler\u003c/span\u003e(\u003cspan\u003etrue\u003c/span\u003e);\n\t\t\u003cspan\u003efinal\u003c/span\u003e Iterator\u0026lt;BusinessObject\u0026gt; batchIterator = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBatchIterator\u003c/span\u003e(\n\t\t\t\tbusinessObject, \u003cspan\u003enull\u003c/span\u003e, postHandler);\n\t\t\u003cspan\u003e// iterate through batch again posting each object\u003c/span\u003e\n\t\t\u003cspan\u003etry\u003c/span\u003e {\n\t\t\t\u003cspan\u003ewhile\u003c/span\u003e (batchIterator.hasNext()) {\n\t\t\t\tpost(batchIterator.next(), postHandler);\n\t\t\t}\n\t\t\tpostHandler.commit();\n\t\t} \u003cspan\u003ecatch\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e Exception e) {\n\t\t\tlogger.error(\u003cspan\u003e\u0026#34;Exception occurred while posting batches\u0026#34;\u003c/span\u003e, e);\n\t\t\t\u003cspan\u003e// something went wrong\u003c/span\u003e\n\t\t\tpostHandler.rollback();\n\t\t\t\u003cspan\u003ethrow\u003c/span\u003e e;\n\t\t}\n\t\t\u003cspan\u003ereturn\u003c/span\u003e;\n\t}\n\n\t\u003cspan\u003e/**\n\t * Post.\n\t * \n\t * \u003cspan\u003e@param\u003c/span\u003e businessObject\n\t *            the business object\n\t * \u003cspan\u003e@param\u003c/span\u003e postHandler\n\t *            the post handler\n\t * \n\t * \u003cspan\u003e@throws\u003c/span\u003e KupengaException\n\t *             the kupenga exception\n\t */\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(BusinessObject businessObject,\n\t\t\tEntityHandler postHandler)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e KupengaException {\n\t\t\u003cspan\u003eif\u003c/span\u003e (businessObject == \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e;\n\t\t}\n\t\t\u003cspan\u003eif\u003c/span\u003e (Boolean.TRUE.equals(businessObject.get(\u003cspan\u003e\u0026#34;posted\u0026#34;\u003c/span\u003e))) {\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e;\n\t\t}\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchMap.get(businessObject\n\t\t\t\t.getName());\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBusinessObject\u003c/span\u003e \u003cspan\u003epostToBusinessObject\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e batchDescriptor\n\t\t\t\t.getPostToBusinessObject(businessObject, postHandler);\n\t\t\u003cspan\u003eif\u003c/span\u003e (postToBusinessObject != \u003cspan\u003enull\u003c/span\u003e) {\n\t\t\tpostToBusinessObject.save(postHandler);\n\t\t}\n\t\tbusinessObject.setItemValue(\u003cspan\u003e\u0026#34;posted\u0026#34;\u003c/span\u003e, Boolean.TRUE);\n\t\tbusinessObject.save(postHandler);\n\t}\n\n\t\u003cspan\u003e/**\n\t * Instantiates a new batch manager.\n\t */\u003c/span\u003e\n\t\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eBatchManager\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e {\n\t\t\u003cspan\u003etry\u003c/span\u003e {\n\t\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eXMLReader\u003c/span\u003e \u003cspan\u003exmlReader\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e XMLReaderFactory.createXMLReader();\n\t\t\txmlReader.setContentHandler(\u003cspan\u003ethis\u003c/span\u003e);\n\t\t\txmlReader.parse(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eInputSource\u003c/span\u003e(\u003cspan\u003ethis\u003c/span\u003e.getClass().getClassLoader().getResourceAsStream(\u003cspan\u003e\u0026#34;templates/\u0026#34;\u003c/span\u003e + DOCUMENT)));\n\t\t} \u003cspan\u003ecatch\u003c/span\u003e (\u003cspan\u003efinal\u003c/span\u003e Exception e) {\n\t\t\tlogger.error(\u003cspan\u003e\u0026#34;Error parsing Batch XML.\u0026#34;\u003c/span\u003e, e);\n\t\t}\n\t}\n\n\t\u003cspan\u003e/*\n\t * (non-Javadoc)\n\t * \n\t * @see nz.this.is.absolute.crap.sax.XMLEntity#initChild(java.lang.String,\n\t * java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t */\u003c/span\u003e\n\t\u003cspan\u003e@Override\u003c/span\u003e\n\t\u003cspan\u003eprotected\u003c/span\u003e ContentHandler \u003cspan\u003einitChild\u003c/span\u003e\u003cspan\u003e(String uri, String localName,\n\t\t\tString qName, Attributes attributes)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e SAXException {\n\t\t\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e \u003cspan\u003ebatchDescriptor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBatchDescriptor\u003c/span\u003e();\n\t\t\u003cspan\u003e// put it in the map\u003c/span\u003e\n\t\tbatchMap.put(attributes.getValue(\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e), batchDescriptor);\n\t\t\u003cspan\u003ereturn\u003c/span\u003e batchDescriptor;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-07-15T06:30:00Z",
  "modifiedTime": null
}
