{
  "id": "361368ea-8693-4e61-9f38-028f4b75af90",
  "title": "CodeSOD: Spaced Out Prefix",
  "link": "https://thedailywtf.com/articles/spaced-out-prefix",
  "description": "Alex had the misfortune to work on the kind of application which has forms with gigantic piles of fields, stuffed haphazardly into objects. A single form could easily have fifty or sixty fields for the user to interact with. That leads to C# code like this: private static String getPrefix(AV_Suchfilter filter) { String pr = String.Empty; try { int maxLength = 0; if (filter.Angebots_id != null) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsID.Length); } if (filter.InternesKennzeichen != null) { if (filter.InternesKennzeichen.Trim() != String.Empty) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_internesKennzeichen.Length); } } if (filter.Angebotsverantwortlicher_guid != null) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsverantwortlicher.Length); } // Do this another 50 times.... // and then .... int counter = 0; while (counter \u003c maxLength) { pr += \" \"; counter++; } } catch (Exception error) { ErrorForm frm = new ErrorForm(error); frm.ShowDialog(); } return pr; } The \"Do this another 50 times\" is doing a lot of heavy lifting in here. What really infuriates me about it, though, which we can see here, is that not all of the fields we're looking at are parameters to this function. And because the function here is static, they're not instance members either. I assume AV_MessagesTexte is basically a global of text labels, which isn't a bad way to manage such a thing, but functions should still take those globals as parameters so you can test them. I'm kidding, of course. This function has never been tested. Aside from a gigantic pile of string length comparisons, what does this function actually do? Well, it returns a new string which is a number of spaces exactly equal to the length of the longest string. And the way we build that output string is not only through string concatenation, but the use of a while loop where a for loop makes more sense. Also, just… why? Why do we need a spaces-only-string the length of another string? Even if we're trying to do some sort of text layout, that seems like a bad way to do whatever it is we're doing, and also if that's the case, why is it called getPrefix? WHY IS OUR PREFIX A STRING OF SPACES THE LENGTH OF OUR FIELD? HOW IS THAT A PREFIX? I feel like I'm going mad. But the real star of this horrible mess, in my opinion, is the exception handling. Get an exception? Show the user a form! There's no attempt to decide if or how we could recover from this error, we just annoy the user with it. Which isn't just unique to this function. Notice the getmaxLength function? It's really a max and it looks like this: private static int getmaxLength(int old, int current) { int result = old; try { if (current \u003e old) { result = current; } } catch (Exception error) { ErrorForm frm = new ErrorForm(error); frm.ShowDialog(); } return result; } What's especially delightful here is that this function couldn't possibly throw an exception. And you know what that tells me? This try/catch/form pattern is just their default error handling. They spam this everywhere, in every function, and the tech lead or architect pats themselves on the back for ensuring that the application \"never crashes!\" all the while annoying the users with messages they can't do anything about. .comment { border: none; } [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "author": "Remy Porter",
  "published": "Tue, 18 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3809,
  "excerpt": "Alex had the misfortune to work on the kind of application which has forms with gigantic piles of fields, stuffed haphazardly into objects. A single form could easily have fifty or sixty fields for the user to interact with. That leads to C# code like this:",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-03-18 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Alex had the misfortune to work on the kind of application which has forms with gigantic piles of fields, stuffed haphazardly into objects. A single form could easily have fifty or sixty fields for the user to interact with. That leads to C# code like this: private static String getPrefix(AV_Suchfilter filter) { String pr = String.Empty; try { int maxLength = 0; if (filter.Angebots_id != null) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsID.Length); } if (filter.InternesKennzeichen != null) { if (filter.InternesKennzeichen.Trim() != String.Empty) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_internesKennzeichen.Length); } } if (filter.Angebotsverantwortlicher_guid != null) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsverantwortlicher.Length); } // Do this another 50 times.... // and then .... int counter = 0; while (counter \u003c maxLength) { pr += \" \"; counter++; } } catch (Exception error) { ErrorForm frm = new ErrorForm(error); frm.ShowDialog(); } return pr; } The \"Do this another 50 times\" is doing a lot of heavy lifting in here. What really infuriates me about it, though, which we can see here, is that not all of the fields we're looking at are parameters to this function. And because the function here is static, they're not instance members either. I assume AV_MessagesTexte is basically a global of text labels, which isn't a bad way to manage such a thing, but functions should still take those globals as parameters so you can test them. I'm kidding, of course. This function has never been tested. Aside from a gigantic pile of string length comparisons, what does this function actually do? Well, it returns a new string which is a number of spaces exactly equal to the length of the longest string. And the way we build that output string is not only through string concatenation, but the use of a while loop where a for loop makes more sense. Also, just… why? Why do we need a spaces-only-string the length of another string? Even if we're trying to do some sort of text layout, that seems like a bad way to do whatever it is we're doing, and also if that's the case, why is it called getPrefix? WHY IS OUR PREFIX A STRING OF SPACES THE LENGTH OF OUR FIELD? HOW IS THAT A PREFIX? I feel like I'm going mad. But the real star of this horrible mess, in my opinion, is the exception handling. Get an exception? Show the user a form! There's no attempt to decide if or how we could recover from this error, we just annoy the user with it. Which isn't just unique to this function. Notice the getmaxLength function? It's really a max and it looks like this: private static int getmaxLength(int old, int current) { int result = old; try { if (current \u003e old) { result = current; } } catch (Exception error) { ErrorForm frm = new ErrorForm(error); frm.ShowDialog(); } return result; } What's especially delightful here is that this function couldn't possibly throw an exception. And you know what that tells me? This try/catch/form pattern is just their default error handling. They spam this everywhere, in every function, and the tech lead or architect pats themselves on the back for ensuring that the application \"never crashes!\" all the while annoying the users with messages they can't do anything about. [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-03-18\"\u003e2025-03-18\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10872\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eAlex\u003c/strong\u003e had the misfortune to work on the kind of application which has forms with gigantic piles of fields, stuffed haphazardly into objects. A single form could easily have fifty or sixty fields for the user to interact with.\u003c/p\u003e\n\u003cp\u003eThat leads to C# code like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e \u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e String \u003cspan\u003egetPrefix\u003c/span\u003e(\u003cspan\u003eAV_Suchfilter filter\u003c/span\u003e)\u003c/span\u003e\n{\n\tString pr = String.Empty;\n\t\u003cspan\u003etry\u003c/span\u003e\n\t{\n\t\t\u003cspan\u003eint\u003c/span\u003e maxLength = \u003cspan\u003e0\u003c/span\u003e;\n\t\t\u003cspan\u003eif\u003c/span\u003e (filter.Angebots_id != \u003cspan\u003enull\u003c/span\u003e) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsID.Length); }\n\t\t\u003cspan\u003eif\u003c/span\u003e (filter.InternesKennzeichen != \u003cspan\u003enull\u003c/span\u003e) { \u003cspan\u003eif\u003c/span\u003e (filter.InternesKennzeichen.Trim() != String.Empty) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_internesKennzeichen.Length); } }\n\t\t\u003cspan\u003eif\u003c/span\u003e (filter.Angebotsverantwortlicher_guid != \u003cspan\u003enull\u003c/span\u003e) { maxLength = getmaxLength(maxLength, AV_MessagesTexte.Reportliste_sf_angebotsverantwortlicher.Length); }\n\n\t\t\u003cspan\u003e// Do this another 50 times....\u003c/span\u003e\n\t\t\u003cspan\u003e// and then ....\u003c/span\u003e\n\n\t\t\u003cspan\u003eint\u003c/span\u003e counter = \u003cspan\u003e0\u003c/span\u003e;\n\t\t\u003cspan\u003ewhile\u003c/span\u003e (counter \u0026lt; maxLength)\n\t\t{\n\t\t\tpr += \u003cspan\u003e\u0026#34; \u0026#34;\u003c/span\u003e;\n\t\t\tcounter++;\n\t\t}\n\t}\n\t\u003cspan\u003ecatch\u003c/span\u003e (Exception error)\n\t{\n\t\tErrorForm frm = \u003cspan\u003enew\u003c/span\u003e ErrorForm(error);\n\t\tfrm.ShowDialog();\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e pr;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u0026#34;Do this another 50 times\u0026#34; is doing a lot of heavy lifting in here. What really infuriates me about it, though, which we can see here, is that not all of the fields we\u0026#39;re looking at are parameters to this function. And because the function here is \u003ccode\u003estatic\u003c/code\u003e, they\u0026#39;re not instance members either. I assume \u003ccode\u003eAV_MessagesTexte\u003c/code\u003e is basically a global of text labels, which isn\u0026#39;t a bad way to manage such a thing, but functions should still take those globals as parameters so you can test them.\u003c/p\u003e\n\u003cp\u003eI\u0026#39;m kidding, of course. This function has never been tested.\u003c/p\u003e\n\u003cp\u003eAside from a gigantic pile of string length comparisons, what does this function actually do? Well, it returns a new string which is a number of spaces exactly equal to the length of the longest string. And the way we build that output string is not only through string concatenation, but the use of a \u003ccode\u003ewhile\u003c/code\u003e loop where a \u003ccode\u003efor\u003c/code\u003e loop makes more sense.\u003c/p\u003e\n\u003cp\u003eAlso, just… why? Why do we need a spaces-only-string the length of another string? Even if we\u0026#39;re trying to do some sort of text layout, that seems like a bad way to do whatever it is we\u0026#39;re doing, and also if that\u0026#39;s the case, why is it called \u003ccode\u003egetPrefix\u003c/code\u003e? WHY IS OUR PREFIX A STRING OF SPACES THE LENGTH OF OUR FIELD? HOW IS THAT A PREFIX?\u003c/p\u003e\n\u003cp\u003eI feel like I\u0026#39;m going mad.\u003c/p\u003e\n\u003cp\u003eBut the real star of this horrible mess, in my opinion, is the exception handling. Get an exception? Show the user a form! There\u0026#39;s no attempt to decide if or how we could recover from this error, we just annoy the user with it.\u003c/p\u003e\n\u003cp\u003eWhich isn\u0026#39;t just unique to this function. Notice the \u003ccode\u003egetmaxLength\u003c/code\u003e function? It\u0026#39;s really a \u003ccode\u003emax\u003c/code\u003e and it looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003egetmaxLength\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e old, \u003cspan\u003eint\u003c/span\u003e current\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan\u003eint\u003c/span\u003e result = old;\n\t\u003cspan\u003etry\u003c/span\u003e\n\t{\n\t\t\u003cspan\u003eif\u003c/span\u003e (current \u0026gt; old)\n\t\t{\n\t\t\tresult = current;\n\t\t}\n\t}\n\t\u003cspan\u003ecatch\u003c/span\u003e (Exception error)\n\t{\n\t\tErrorForm frm = \u003cspan\u003enew\u003c/span\u003e ErrorForm(error);\n\t\tfrm.ShowDialog();\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat\u0026#39;s especially delightful here is that this function couldn\u0026#39;t possibly throw an exception. And you know what that tells me? This \u003ccode\u003etry/catch/form\u003c/code\u003e pattern is just their default error handling. They spam this everywhere, in every function, and the tech lead or architect pats themselves on the back for ensuring that the application \u0026#34;never crashes!\u0026#34; all the while annoying the users with messages they can\u0026#39;t do anything about.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eBuildMaster\u003c/a\u003e allows you to create a self-service release management platform that allows different teams to manage their applications. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eExplore how!\u003c/a\u003e \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-18T06:30:00Z",
  "modifiedTime": null
}
