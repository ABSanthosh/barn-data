{
  "id": "5a8ec942-2c85-45f5-af84-ca3e4f3f8278",
  "title": "CodeSOD: An Argument With QA",
  "link": "https://thedailywtf.com/articles/an-argument-with-qa",
  "description": "Markus does QA, and this means writing automated tests which wrap around the code written by developers. Mostly this is a \"black box\" situation, where Markus doesn't look at the code, and instead goes by the interface and the requirements. Sometimes, though, he does look at the code, and wishes he hadn't. Today's snippet comes from a program which is meant to generate PDF files and then, optionally, email them. There are a few methods we're going to look at, because they invested a surprising amount of code into doing this the wrong way. protected override void Execute() { int sendMail = this.VerifyParameterValue(ParamSendMail); if (sendMail == -1) return; if (sendMail == 1) mail = true; this.TraceOutput(Properties.Resources.textGetCustomerForAccountStatement); IList customers = AccountStatement.GetCustomersForAccountStatement(); if (customers.Count == 0) return; StreamWriter streamWriter = null; if (mail) streamWriter = AccountStatement.CreateAccountStatementLogFile(); CreateAccountStatementDocumentEngine engine = new CreateAccountStatementDocumentEngine(); foreach (CustomerModel customer in customers) { this.TraceOutput(Properties.Resources.textCustomerAccountStatementBegin + customer.DisplayName.ToString()); // Generate the PDF, optionally send an email with the document attached engine.Execute(customer, mail); if (mail) { AccountStatement.WriteToLogFile(customer, streamWriter); this.TraceOutput(Properties.Resources.textLogWriting); } } engine.Dispose(); if (streamWriter != null) streamWriter.Close(); } Now, this might sound unfair, but right off the bat I'm going to complain about separation of concerns. This function both generates output and emails it (optionally), while handling all of the stream management. Honestly, I think if the developer were simply forced to go back and make this a set of small, cohesive methods, most of the WTFs would vanish. But there's more to say here. Specifically, let's look at the first few lines, where we VerifyParameterValue. Note that this function clearly returns -1 when it fails, which is a very C-programmer-forced-to-do-OO idiom. But let's look at that method. private int VerifyParameterValue(string name) { string stringValue = this.GetParam(name, string.Empty); bool isValid = this.VerifyByParameterFormat(name, stringValue); if (!isValid) return -1; int value = -1; try { value = Convert.ToInt32(stringValue); } catch (Exception e) { this.TraceOutput(string.Concat(\"\\n\\n\\n\", e.Message, \"\\n\\n\\n\")); return -1; } return value; } We'll come back to the VerifyByParameterFormat but otherwise, this is basically a wrapper around Convert.ToInt32, and could easily be replaced with Int32.TryParse. Bonus points for spamming the log output with loads of newlines. Okay, but what is the VerifyByParameterFormat doing? private bool VerifyByParameterFormat(string name, string value) { string parameter = string.Empty; string message = string.Empty; if (value.Length != 1) { parameter = Properties.Resources.textSendMail; message = string.Format(Properties.Resources.textSendMailNotValid, value); this.TraceOutput(string.Concat(\"\\n\\n\\n\", message, \"\\n\\n\\n\")); return false; } string numbers = \"0123456789\"; char[] characters = value.ToCharArray(); for (byte i = 0; i \u003c characters.Length; i++) { if (numbers.IndexOf(characters[i]) \u003c 0) { parameter = Properties.Resources.textSendMail; message = Properties.Resources.textSendMailNotValid; this.TraceOutput(string.Concat(\"\\n\\n\\n\", message, \"\\n\\n\\n\")); return false; } } return true; } Oh, it just goes character by character to verify whether or not this is made up of only digits. Which, by the way, means the CLI argument needs to be an integer, and only when that integer is 1 do we send emails. It's a boolean, but worse. Let's assume, however, that passing numbers is required by the specification. Still, Markus has thoughts: Handling this command line argument might seem obvious enough. I'd probably do something along the lines of \"if (arg == \"1\") { sendMail = true } else if (arg != \"0\") { tell the user they're an idiot }. Of course, I'm not a professional programmer, so my solution is way too simple as the attached piece of code will show you. There are better ways to do it, Markus, but as you've shown us, there are definitely worse ways. .comment { border: none; } [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Thu, 06 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 4614,
  "excerpt": "Markus does QA, and this means writing automated tests which wrap around the code written by developers. Mostly this is a \"black box\" situation, where Markus doesn't look at the code, and instead goes by the interface and the requirements. Sometimes, though, he does look at the code, and wishes he hadn't. Today's snippet comes from a program which is meant to generate PDF files and then, optionally, email them. There are a few methods we're going to look at, because they invested a surprising amount of code into doing this the wrong way.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Markus does QA, and this means writing automated tests which wrap around the code written by developers. Mostly this is a \"black box\" situation, where Markus doesn't look at the code, and instead goes by the interface and the requirements. Sometimes, though, he does look at the code, and wishes he hadn't. Today's snippet comes from a program which is meant to generate PDF files and then, optionally, email them. There are a few methods we're going to look at, because they invested a surprising amount of code into doing this the wrong way. protected override void Execute() { int sendMail = this.VerifyParameterValue(ParamSendMail); if (sendMail == -1) return; if (sendMail == 1) mail = true; this.TraceOutput(Properties.Resources.textGetCustomerForAccountStatement); IList\u003cCustomerModel\u003e customers = AccountStatement.GetCustomersForAccountStatement(); if (customers.Count == 0) return; StreamWriter streamWriter = null; if (mail) streamWriter = AccountStatement.CreateAccountStatementLogFile(); CreateAccountStatementDocumentEngine engine = new CreateAccountStatementDocumentEngine(); foreach (CustomerModel customer in customers) { this.TraceOutput(Properties.Resources.textCustomerAccountStatementBegin + customer.DisplayName.ToString()); // Generate the PDF, optionally send an email with the document attached engine.Execute(customer, mail); if (mail) { AccountStatement.WriteToLogFile(customer, streamWriter); this.TraceOutput(Properties.Resources.textLogWriting); } } engine.Dispose(); if (streamWriter != null) streamWriter.Close(); } Now, this might sound unfair, but right off the bat I'm going to complain about separation of concerns. This function both generates output and emails it (optionally), while handling all of the stream management. Honestly, I think if the developer were simply forced to go back and make this a set of small, cohesive methods, most of the WTFs would vanish. But there's more to say here. Specifically, let's look at the first few lines, where we VerifyParameterValue. Note that this function clearly returns -1 when it fails, which is a very C-programmer-forced-to-do-OO idiom. But let's look at that method. private int VerifyParameterValue(string name) { string stringValue = this.GetParam(name, string.Empty); bool isValid = this.VerifyByParameterFormat(name, stringValue); if (!isValid) return -1; int value = -1; try { value = Convert.ToInt32(stringValue); } catch (Exception e) { this.TraceOutput(string.Concat(\"\\n\\n\\n\", e.Message, \"\\n\\n\\n\")); return -1; } return value; } We'll come back to the VerifyByParameterFormat but otherwise, this is basically a wrapper around Convert.ToInt32, and could easily be replaced with Int32.TryParse. Bonus points for spamming the log output with loads of newlines. Okay, but what is the VerifyByParameterFormat doing? private bool VerifyByParameterFormat(string name, string value) { string parameter = string.Empty; string message = string.Empty; if (value.Length != 1) { parameter = Properties.Resources.textSendMail; message = string.Format(Properties.Resources.textSendMailNotValid, value); this.TraceOutput(string.Concat(\"\\n\\n\\n\", message, \"\\n\\n\\n\")); return false; } string numbers = \"0123456789\"; char[] characters = value.ToCharArray(); for (byte i = 0; i \u003c characters.Length; i++) { if (numbers.IndexOf(characters[i]) \u003c 0) { parameter = Properties.Resources.textSendMail; message = Properties.Resources.textSendMailNotValid; this.TraceOutput(string.Concat(\"\\n\\n\\n\", message, \"\\n\\n\\n\")); return false; } } return true; } Oh, it just goes character by character to verify whether or not this is made up of only digits. Which, by the way, means the CLI argument needs to be an integer, and only when that integer is 1 do we send emails. It's a boolean, but worse. Let's assume, however, that passing numbers is required by the specification. Still, Markus has thoughts: Handling this command line argument might seem obvious enough. I'd probably do something along the lines of \"if (arg == \"1\") { sendMail = true } else if (arg != \"0\") { tell the user they're an idiot }. Of course, I'm not a professional programmer, so my solution is way too simple as the attached piece of code will show you. There are better ways to do it, Markus, but as you've shown us, there are definitely worse ways. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eMarkus\u003c/strong\u003e does QA, and this means writing automated tests which wrap around the code written by developers. \u003cem\u003eMostly\u003c/em\u003e this is a \u0026#34;black box\u0026#34; situation, where Markus doesn\u0026#39;t look at the code, and instead goes by the interface and the requirements. Sometimes, though, he does look at the code, and wishes he hadn\u0026#39;t.\u003c/p\u003e\n\u003cp\u003eToday\u0026#39;s snippet comes from a program which is meant to generate PDF files and then, optionally, email them. There are a few methods we\u0026#39;re going to look at, because they invested a surprising amount of code into doing this the wrong way.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprotected\u003c/span\u003e \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eExecute\u003c/span\u003e()\u003c/span\u003e\n{\n\t\u003cspan\u003eint\u003c/span\u003e sendMail = \u003cspan\u003ethis\u003c/span\u003e.VerifyParameterValue(ParamSendMail);\n\n\t\u003cspan\u003eif\u003c/span\u003e (sendMail == \u003cspan\u003e-1\u003c/span\u003e)\n\t\t\u003cspan\u003ereturn\u003c/span\u003e;\n\n\t\u003cspan\u003eif\u003c/span\u003e (sendMail == \u003cspan\u003e1\u003c/span\u003e)\n\t\tmail = \u003cspan\u003etrue\u003c/span\u003e;\n\n\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(Properties.Resources.textGetCustomerForAccountStatement);\n\tIList\u0026lt;CustomerModel\u0026gt; customers = AccountStatement.GetCustomersForAccountStatement();\n\t\u003cspan\u003eif\u003c/span\u003e (customers.Count == \u003cspan\u003e0\u003c/span\u003e) \u003cspan\u003ereturn\u003c/span\u003e;\n\n\tStreamWriter streamWriter = \u003cspan\u003enull\u003c/span\u003e;\n\t\u003cspan\u003eif\u003c/span\u003e (mail)\n\t\tstreamWriter = AccountStatement.CreateAccountStatementLogFile();\n\n\tCreateAccountStatementDocumentEngine engine = \u003cspan\u003enew\u003c/span\u003e CreateAccountStatementDocumentEngine();\n\n\t\u003cspan\u003eforeach\u003c/span\u003e (CustomerModel customer \u003cspan\u003ein\u003c/span\u003e customers)\n\t{\n\t\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(Properties.Resources.textCustomerAccountStatementBegin + customer.DisplayName.ToString());\n\n\t\t\u003cspan\u003e// Generate the PDF, optionally send an email with the document attached\u003c/span\u003e\n\t\tengine.Execute(customer, mail);\n\n\t\t\u003cspan\u003eif\u003c/span\u003e (mail)\n\t\t{\n\t\t\tAccountStatement.WriteToLogFile(customer, streamWriter);\n\t\t\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(Properties.Resources.textLogWriting);\n\t\t}\n\t}\n\tengine.Dispose();\n\t\u003cspan\u003eif\u003c/span\u003e (streamWriter != \u003cspan\u003enull\u003c/span\u003e)\n\t\tstreamWriter.Close();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, this might sound unfair, but right off the bat I\u0026#39;m going to complain about separation of concerns. This function both generates output \u003cem\u003eand\u003c/em\u003e emails it (optionally), while handling all of the stream management. Honestly, I think if the developer were simply forced to go back and make this a set of small, cohesive methods, most of the WTFs would vanish. But there\u0026#39;s more to say here.\u003c/p\u003e\n\u003cp\u003eSpecifically, let\u0026#39;s look at the first few lines, where we \u003ccode\u003eVerifyParameterValue\u003c/code\u003e. Note that this function clearly returns \u003ccode\u003e-1\u003c/code\u003e when it fails, which is a very C-programmer-forced-to-do-OO idiom. But let\u0026#39;s look at that method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003eVerifyParameterValue\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e name\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan\u003estring\u003c/span\u003e stringValue = \u003cspan\u003ethis\u003c/span\u003e.GetParam(name, \u003cspan\u003estring\u003c/span\u003e.Empty);\n\n\t\u003cspan\u003ebool\u003c/span\u003e isValid = \u003cspan\u003ethis\u003c/span\u003e.VerifyByParameterFormat(name, stringValue);\n\n\t\u003cspan\u003eif\u003c/span\u003e (!isValid)\n\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e-1\u003c/span\u003e;\n\n\t\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e = \u003cspan\u003e-1\u003c/span\u003e;\n\n\t\u003cspan\u003etry\u003c/span\u003e\n\t{\n\t\t\u003cspan\u003evalue\u003c/span\u003e = Convert.ToInt32(stringValue);\n\t}\n\t\u003cspan\u003ecatch\u003c/span\u003e (Exception e)\n\t{\n\t\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(\u003cspan\u003estring\u003c/span\u003e.Concat(\u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e, e.Message, \u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e));\n\n\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e-1\u003c/span\u003e;\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe\u0026#39;ll come back to the \u003ccode\u003eVerifyByParameterFormat\u003c/code\u003e  but otherwise, this is basically a wrapper around \u003ccode\u003eConvert.ToInt32\u003c/code\u003e, and could easily be replaced with \u003ccode\u003eInt32.TryParse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBonus points for spamming the log output with loads of newlines.\u003c/p\u003e\n\u003cp\u003eOkay, but what is the \u003ccode\u003eVerifyByParameterFormat\u003c/code\u003e doing?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eVerifyByParameterFormat\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e name, \u003cspan\u003estring\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan\u003estring\u003c/span\u003e parameter = \u003cspan\u003estring\u003c/span\u003e.Empty;\n\t\u003cspan\u003estring\u003c/span\u003e message = \u003cspan\u003estring\u003c/span\u003e.Empty;\n\t\n\t\u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003evalue\u003c/span\u003e.Length != \u003cspan\u003e1\u003c/span\u003e)\n\t{\n\t\tparameter = Properties.Resources.textSendMail;\n\t\tmessage = \u003cspan\u003estring\u003c/span\u003e.Format(Properties.Resources.textSendMailNotValid, \u003cspan\u003evalue\u003c/span\u003e);\n\n\t\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(\u003cspan\u003estring\u003c/span\u003e.Concat(\u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e, message, \u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e));\n\n\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e;\n\t}\n\n\t\u003cspan\u003estring\u003c/span\u003e numbers = \u003cspan\u003e\u0026#34;0123456789\u0026#34;\u003c/span\u003e;\n\t\u003cspan\u003echar\u003c/span\u003e[] characters = \u003cspan\u003evalue\u003c/span\u003e.ToCharArray();\n\n\t\u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003ebyte\u003c/span\u003e i = \u003cspan\u003e0\u003c/span\u003e; i \u0026lt; characters.Length; i++)\n\t{\n\t\t\u003cspan\u003eif\u003c/span\u003e (numbers.IndexOf(characters[i]) \u0026lt; \u003cspan\u003e0\u003c/span\u003e)\n\t\t{\n\t\t\tparameter = Properties.Resources.textSendMail;\n\t\t\tmessage = Properties.Resources.textSendMailNotValid;\n\t\t\t\n\t\t\t\u003cspan\u003ethis\u003c/span\u003e.TraceOutput(\u003cspan\u003estring\u003c/span\u003e.Concat(\u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e, message, \u003cspan\u003e\u0026#34;\\n\\n\\n\u0026#34;\u003c/span\u003e));\n\t\t\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e;\n\t\t}\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh, it just goes character by character to verify whether or not this is made up of only digits. Which, by the way, means the CLI argument needs to be an integer, and only when that integer is \u003ccode\u003e1\u003c/code\u003e do we send emails. It\u0026#39;s a boolean, but worse.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s assume, however, that passing numbers is required by the specification. Still, Markus has thoughts:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHandling this command line argument might seem obvious enough. I\u0026#39;d probably do something along the lines of \u0026#34;if (arg == \u0026#34;1\u0026#34;) { sendMail = true } else if (arg != \u0026#34;0\u0026#34;) { \u003cem\u003etell the user they\u0026#39;re an idiot\u003c/em\u003e }. Of course, I\u0026#39;m not a professional programmer, so my solution is way too simple as the attached piece of code will show you.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThere are better ways to do it, Markus, but as you\u0026#39;ve shown us, there are definitely \u003cem\u003eworse\u003c/em\u003e ways.\u003c/p\u003e\n\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-03-06T06:30:00Z",
  "modifiedTime": null
}
