{
  "id": "fb582582-d8b8-42c5-8e60-6aa5e3bbc1c2",
  "title": "CodeSOD: itouhhh…",
  "link": "https://thedailywtf.com/articles/itouhhh",
  "description": "Frequently in programming, we can make a tradeoff: use less (or more) CPU in exchange for using more (or less) memory. Lookup tables are a great example: use a big pile of memory to turn complicated calculations into O(1) operations. So, for example, implementing itoa, the C library function for turning an integer into a character array (aka, a string), you could maybe make it more efficient using a lookup table. I say \"maybe\", because Helen inherited some C code that, well, even if it were more efficient, it doesn't help because it's wrong. Let's start with the lookup table: char an[1000][3] = { {'0','0','0'},{'0','0','1'},{'0','0','2'},{'0','0','3'},{'0','0','4'},{'0','0','5'},{'0','0','6'},{'0','0','7'},{'0','0','8'},{'0','0','9'}, {'0','1','0'},{'0','1','1'},{'0','1','2'},{'0','1','3'},{'0','1','4'},{'0','1','5'},{'0','1','6'},{'0','1','7'},{'0','1','8'},{'0','1','9'}, … I'm abbreviating the lookup table for now. This lookup table is meant to be use to convert every number from 0…999 into a string representation. Let's take a look at how it's used. int ll = f-\u003ecfg.len_len; long dl = f-\u003edata_len; // Prepare length if ( NULL == dst ) { dst_len = f-\u003edata_len + ll + 1 ; dst = (char*) malloc ( dst_len ); } else //if( dst_len \u003c ll + dl ) if( dst_len \u003c (unsigned) (ll + dl) ) { // TO DOO - error should be processed break; } long i2; switch ( f-\u003ecfg.len_fmt) { case ASCII_FORM: { if ( ll \u003c 2 ) { dst[0]=an[dl][2]; } else if ( ll \u003c 3 ) { dst[0]=an[dl][1]; dst[1]=an[dl][2]; } else if ( ll \u003c 4 ) { dst[0]=an[dl][0]; dst[1]=an[dl][1]; dst[2]=an[dl][2]; } else if ( ll \u003c 5 ) { i2 = dl / 1000; dst[0]=an[i2][2]; i2 = dl % 1000; dst[3]=an[i2][2]; dst[2]=an[i2][1]; dst[1]=an[i2][0]; } else if ( ll \u003c 6 ) { i2 = dl / 1000; dst[0]=an[i2][1]; dst[1]=an[i2][2]; i2 = dl % 1000; dst[4]=an[i2][2]; dst[3]=an[i2][1]; dst[2]=an[i2][0]; } else { // General case for ( int k = ll ; k \u003e 0 ; k-- ) { dst[k-1] ='0' + dl % 10; dl/=10; } } dst[dl]=0; break; } } Okay, we start with some reasonable bounds checking. I have no idea what to make of a struct member called len_len- the length of the length? I'm lacking some context here. Then we get into the switch statement. For all values less than 4 digits, everything makes sense, more or less. I'm not sure what the point of using a 2D array for you lookup table is if you're also copying one character at a time, but for such a small number of copies I'm sure it's fine. But then we get into the len_lens longer than 3, and we start dividing by 1000 so that our lookup table continues to work. Which, again, I guess is fine, but I'm still left wondering why we're doing this, why this specific chain of optimizations is what we need to do. And frankly, why we couldn't just use itoa or a similar library function which already does this and is probably more optimized than anything I'm going to write. When we have an output longer than 5 characters, we just use a naive for-loop and some modulus as our \"general\" case. So no, I don't like this code. It reeks of premature optimization, and it also has the vibe of someone starting to optimize without fully understanding the problem they were optimizing, and trying to change course midstream without changing their solution. But there's a punchline to all of this. Because, you see, I skipped most of the lookup table. Would you like to see how it ends? Of course you do: {'9','8','0'},{'9','8','1'},{'9','8','2'},{'9','8','3'},{'9','8','4'},{'9','8','5'},{'9','8','6'},{'9','8','7'},{'9','8','8'},{'9','8','9'} }; The lookup table doesn't work for values from 990 to 999. There are just no entries there. All this effort to optimize converting integers to text and we end up here: with a function that doesn't work for 1% of the possible values it could receive. And, given that the result is an out-of-bounds array access, it fails with everyone's favorite problem: undefined behavior. Usually it'll segfault, but who knows! Maybe it returns whatever bytes it finds? Maybe it sends the nasal demons after you. The compiler is allowed to do anything. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "author": "Remy Porter",
  "published": "Wed, 14 May 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 4674,
  "excerpt": "Frequently in programming, we can make a tradeoff: use less (or more) CPU in exchange for using more (or less) memory. Lookup tables are a great example: use a big pile of memory to turn complicated calculations into O(1) operations. So, for example, implementing itoa, the C library function for turning an integer into a character array (aka, a string), you could maybe make it more efficient using a lookup table.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Frequently in programming, we can make a tradeoff: use less (or more) CPU in exchange for using more (or less) memory. Lookup tables are a great example: use a big pile of memory to turn complicated calculations into O(1) operations. So, for example, implementing itoa, the C library function for turning an integer into a character array (aka, a string), you could maybe make it more efficient using a lookup table. I say \"maybe\", because Helen inherited some C code that, well, even if it were more efficient, it doesn't help because it's wrong. Let's start with the lookup table: char an[1000][3] = { {'0','0','0'},{'0','0','1'},{'0','0','2'},{'0','0','3'},{'0','0','4'},{'0','0','5'},{'0','0','6'},{'0','0','7'},{'0','0','8'},{'0','0','9'}, {'0','1','0'},{'0','1','1'},{'0','1','2'},{'0','1','3'},{'0','1','4'},{'0','1','5'},{'0','1','6'},{'0','1','7'},{'0','1','8'},{'0','1','9'}, … I'm abbreviating the lookup table for now. This lookup table is meant to be use to convert every number from 0…999 into a string representation. Let's take a look at how it's used. int ll = f-\u003ecfg.len_len; long dl = f-\u003edata_len; // Prepare length if ( NULL == dst ) { dst_len = f-\u003edata_len + ll + 1 ; dst = (char*) malloc ( dst_len ); } else //if( dst_len \u003c ll + dl ) if( dst_len \u003c (unsigned) (ll + dl) ) { // TO DOO - error should be processed break; } long i2; switch ( f-\u003ecfg.len_fmt) { case ASCII_FORM: { if ( ll \u003c 2 ) { dst[0]=an[dl][2]; } else if ( ll \u003c 3 ) { dst[0]=an[dl][1]; dst[1]=an[dl][2]; } else if ( ll \u003c 4 ) { dst[0]=an[dl][0]; dst[1]=an[dl][1]; dst[2]=an[dl][2]; } else if ( ll \u003c 5 ) { i2 = dl / 1000; dst[0]=an[i2][2]; i2 = dl % 1000; dst[3]=an[i2][2]; dst[2]=an[i2][1]; dst[1]=an[i2][0]; } else if ( ll \u003c 6 ) { i2 = dl / 1000; dst[0]=an[i2][1]; dst[1]=an[i2][2]; i2 = dl % 1000; dst[4]=an[i2][2]; dst[3]=an[i2][1]; dst[2]=an[i2][0]; } else { // General case for ( int k = ll ; k \u003e 0 ; k-- ) { dst[k-1] ='0' + dl % 10; dl/=10; } } dst[dl]=0; break; } } Okay, we start with some reasonable bounds checking. I have no idea what to make of a struct member called len_len- the length of the length? I'm lacking some context here. Then we get into the switch statement. For all values less than 4 digits, everything makes sense, more or less. I'm not sure what the point of using a 2D array for you lookup table is if you're also copying one character at a time, but for such a small number of copies I'm sure it's fine. But then we get into the len_lens longer than 3, and we start dividing by 1000 so that our lookup table continues to work. Which, again, I guess is fine, but I'm still left wondering why we're doing this, why this specific chain of optimizations is what we need to do. And frankly, why we couldn't just use itoa or a similar library function which already does this and is probably more optimized than anything I'm going to write. When we have an output longer than 5 characters, we just use a naive for-loop and some modulus as our \"general\" case. So no, I don't like this code. It reeks of premature optimization, and it also has the vibe of someone starting to optimize without fully understanding the problem they were optimizing, and trying to change course midstream without changing their solution. But there's a punchline to all of this. Because, you see, I skipped most of the lookup table. Would you like to see how it ends? Of course you do: {'9','8','0'},{'9','8','1'},{'9','8','2'},{'9','8','3'},{'9','8','4'},{'9','8','5'},{'9','8','6'},{'9','8','7'},{'9','8','8'},{'9','8','9'} }; The lookup table doesn't work for values from 990 to 999. There are just no entries there. All this effort to optimize converting integers to text and we end up here: with a function that doesn't work for 1% of the possible values it could receive. And, given that the result is an out-of-bounds array access, it fails with everyone's favorite problem: undefined behavior. Usually it'll segfault, but who knows! Maybe it returns whatever bytes it finds? Maybe it sends the nasal demons after you. The compiler is allowed to do anything. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eFrequently in programming, we can make a tradeoff: use less (or more) CPU in exchange for using more (or less) memory. Lookup tables are a great example: use a big pile of memory to turn complicated calculations into \u003ccode\u003eO(1)\u003c/code\u003e operations.\u003c/p\u003e\n\u003cp\u003eSo, for example, implementing \u003ccode\u003eitoa\u003c/code\u003e, the C library function for turning an integer into a character array (aka, a string), you could maybe make it more efficient using a lookup table.\u003c/p\u003e\n\u003cp\u003eI say \u0026#34;maybe\u0026#34;, because \u003cstrong\u003eHelen\u003c/strong\u003e inherited some C code that, well, even if it were more efficient, it doesn\u0026#39;t help because it\u0026#39;s wrong.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s start with the lookup table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003echar\u003c/span\u003e an[\u003cspan\u003e1000\u003c/span\u003e][\u003cspan\u003e3\u003c/span\u003e] = \n{\n\t{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;2\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;3\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;4\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;5\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;6\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;7\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e},\n\t{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;2\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;3\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;4\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;5\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;6\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;7\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e},\n    …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI\u0026#39;m abbreviating the lookup table for now. This lookup table is meant to be use to convert every number from 0…999 into a string representation.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s take a look at how it\u0026#39;s used.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eint\u003c/span\u003e ll = f-\u0026gt;cfg.len_len;\n\u003cspan\u003elong\u003c/span\u003e dl = f-\u0026gt;data_len;\n\u003cspan\u003e// Prepare length\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e ( \u003cspan\u003eNULL\u003c/span\u003e == dst )\n{\n    dst_len = f-\u0026gt;data_len + ll + \u003cspan\u003e1\u003c/span\u003e ;\n    dst = (\u003cspan\u003echar\u003c/span\u003e*) \u003cspan\u003emalloc\u003c/span\u003e ( dst_len );\n}\n\u003cspan\u003eelse\u003c/span\u003e\n\u003cspan\u003e//if( dst_len \u0026lt; ll + dl )\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e( dst_len \u0026lt; (\u003cspan\u003eunsigned\u003c/span\u003e) (ll + dl) )\n{\n    \u003cspan\u003e// TO DOO - error should be processed\u003c/span\u003e\n    \u003cspan\u003ebreak\u003c/span\u003e;\n}\n\u003cspan\u003elong\u003c/span\u003e i2;\n\u003cspan\u003eswitch\u003c/span\u003e ( f-\u0026gt;cfg.len_fmt)\n{\n    \u003cspan\u003ecase\u003c/span\u003e ASCII_FORM:\n    {\n        \u003cspan\u003eif\u003c/span\u003e ( ll \u0026lt; \u003cspan\u003e2\u003c/span\u003e )\n        {\n            dst[\u003cspan\u003e0\u003c/span\u003e]=an[dl][\u003cspan\u003e2\u003c/span\u003e];\n        }\n        \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e ( ll \u0026lt; \u003cspan\u003e3\u003c/span\u003e )\n        {\n            dst[\u003cspan\u003e0\u003c/span\u003e]=an[dl][\u003cspan\u003e1\u003c/span\u003e];\n            dst[\u003cspan\u003e1\u003c/span\u003e]=an[dl][\u003cspan\u003e2\u003c/span\u003e];\n        }\n        \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e ( ll \u0026lt; \u003cspan\u003e4\u003c/span\u003e )\n        {\n            dst[\u003cspan\u003e0\u003c/span\u003e]=an[dl][\u003cspan\u003e0\u003c/span\u003e];\n            dst[\u003cspan\u003e1\u003c/span\u003e]=an[dl][\u003cspan\u003e1\u003c/span\u003e];\n            dst[\u003cspan\u003e2\u003c/span\u003e]=an[dl][\u003cspan\u003e2\u003c/span\u003e];\n        }\n        \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e ( ll \u0026lt; \u003cspan\u003e5\u003c/span\u003e )\n        {\n            i2 = dl / \u003cspan\u003e1000\u003c/span\u003e;\n            dst[\u003cspan\u003e0\u003c/span\u003e]=an[i2][\u003cspan\u003e2\u003c/span\u003e];\n            i2 = dl % \u003cspan\u003e1000\u003c/span\u003e;\n            dst[\u003cspan\u003e3\u003c/span\u003e]=an[i2][\u003cspan\u003e2\u003c/span\u003e];\n            dst[\u003cspan\u003e2\u003c/span\u003e]=an[i2][\u003cspan\u003e1\u003c/span\u003e];\n            dst[\u003cspan\u003e1\u003c/span\u003e]=an[i2][\u003cspan\u003e0\u003c/span\u003e];\n        }\n        \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e ( ll \u0026lt; \u003cspan\u003e6\u003c/span\u003e )\n        {\n            i2 = dl / \u003cspan\u003e1000\u003c/span\u003e;\n            dst[\u003cspan\u003e0\u003c/span\u003e]=an[i2][\u003cspan\u003e1\u003c/span\u003e];\n            dst[\u003cspan\u003e1\u003c/span\u003e]=an[i2][\u003cspan\u003e2\u003c/span\u003e];\n            i2 = dl % \u003cspan\u003e1000\u003c/span\u003e;\n            dst[\u003cspan\u003e4\u003c/span\u003e]=an[i2][\u003cspan\u003e2\u003c/span\u003e];\n            dst[\u003cspan\u003e3\u003c/span\u003e]=an[i2][\u003cspan\u003e1\u003c/span\u003e];\n            dst[\u003cspan\u003e2\u003c/span\u003e]=an[i2][\u003cspan\u003e0\u003c/span\u003e];\n        }\n        \u003cspan\u003eelse\u003c/span\u003e\n        {\n            \u003cspan\u003e// General case\u003c/span\u003e\n            \u003cspan\u003efor\u003c/span\u003e ( \u003cspan\u003eint\u003c/span\u003e k = ll  ; k \u0026gt; \u003cspan\u003e0\u003c/span\u003e  ; k-- )\n            {\n                dst[k\u003cspan\u003e-1\u003c/span\u003e] =\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e + dl % \u003cspan\u003e10\u003c/span\u003e;\n                dl/=\u003cspan\u003e10\u003c/span\u003e;\n            }\n        }\n\n        dst[dl]=\u003cspan\u003e0\u003c/span\u003e;\n\n        \u003cspan\u003ebreak\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOkay, we start with some reasonable bounds checking. I have no idea what to make of a struct member called \u003ccode\u003elen_len\u003c/code\u003e- the length of the length? I\u0026#39;m lacking some context here.\u003c/p\u003e\n\u003cp\u003eThen we get into the switch statement. For all values less than 4 digits, everything makes sense, more or less. I\u0026#39;m not sure what the point of using a 2D array for you lookup table is if you\u0026#39;re also copying one character at a time, but for such a small number of copies I\u0026#39;m sure it\u0026#39;s fine.\u003c/p\u003e\n\u003cp\u003eBut then we get into the \u003ccode\u003elen_len\u003c/code\u003es longer than 3, and we start dividing by 1000 so that our lookup table continues to work. Which, again, I guess is \u003cem\u003efine\u003c/em\u003e, but I\u0026#39;m still left wondering why we\u0026#39;re doing this, why \u003cem\u003ethis\u003c/em\u003e specific chain of optimizations is what we need to do. And frankly, why we couldn\u0026#39;t just use \u003ccode\u003eitoa\u003c/code\u003e or a similar library function which already does this and is probably more optimized than anything I\u0026#39;m going to write.\u003c/p\u003e\n\u003cp\u003eWhen we have an output longer than 5 characters, we just use a naive for-loop and some modulus as our \u0026#34;general\u0026#34; case.\u003c/p\u003e\n\u003cp\u003eSo no, I don\u0026#39;t like this code. It reeks of premature optimization, and it also has the vibe of someone starting to optimize without fully understanding the problem they were optimizing, and trying to change course midstream without changing their solution.\u003c/p\u003e\n\u003cp\u003eBut there\u0026#39;s a punchline to all of this. Because, you see, I skipped most of the lookup table. Would you like to see how it ends? Of course you do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;0\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;1\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;2\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;3\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;4\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;5\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;6\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;7\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e},{\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;8\u0026#39;\u003c/span\u003e,\u003cspan\u003e\u0026#39;9\u0026#39;\u003c/span\u003e}\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe lookup table doesn\u0026#39;t work for values from 990 to 999. There are just no entries there. All this effort to optimize converting integers to text and we end up here: with a function that doesn\u0026#39;t work for 1% of the possible values it could receive. And, given that the result is an out-of-bounds array access, it fails with everyone\u0026#39;s favorite problem: undefined behavior. Usually it\u0026#39;ll segfault, but who knows! Maybe it returns whatever bytes it finds? Maybe it sends the nasal demons after you. The compiler is allowed to do \u003cem\u003eanything\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tProGet’s got you covered with security and access controls on your NuGet feeds. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=GotYouCoveredFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-05-14T06:30:00Z",
  "modifiedTime": null
}
