{
  "id": "2324eeb5-9557-4369-b692-25cd88979006",
  "title": "CodeSOD: Static State",
  "link": "https://thedailywtf.com/articles/static-state",
  "description": "Today's Anonymous submitter was reviewing some C++ code, and saw this perfectly reasonable looking pattern. class SomeClass { public: void setField(int val); int getField(); } Now, we can talk about how overuse of getters and setters is itself an antipattern (especially if they're trivial- you've just made a public variable with extra steps), but it's not wrong and there are certainly good reasons to be cautious with encapsulation. That said, because this is C++, that getField should really be declared int getField() const- appropriate for any method which doesn't cause a mutation to a class instance. Or should it? Let's look at the implementation. void SomeClass::setField(int val) { setGetField(true, val); } void SomeClass::getField() { return setGetField(false); } Wait, what? Why are we passing a boolean to a method called setGet. Why is there a method called setGet? They didn't go and make a method that both sets and gets, and decide which they're doing based on a boolean flag, did they? int SomeClass::setGetField(bool set, int val) { static int s_val = 0; if (set) { s_val = val; } return s_val; } Oh, good, they didn't just make a function that maybe sets or gets based on a boolean flag. They also made the state within that function a static field. And yes, function level statics are not scoped to an instance, so this is shared across all instances of the class. So it's not encapsulated at all, and we've blundered back into Singletons again, somehow. Our anonymous submitter had two reactions. Upon seeing this the first time, they wondered: \"WTF? This must be some kind of joke. I'm being pranked.\" But then they saw the pattern again. And again. After seeing it fifty times, they wondered: \"WTF? Who hired these developers? And can that hiring manager be fired? Out of a cannon? Into the sun?\" [Advertisement] Picking up NuGet is easy. Getting good at it takes time. Download our guide to learn the best practice of NuGet for the Enterprise.",
  "author": "Remy Porter",
  "published": "Thu, 17 Apr 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2094,
  "excerpt": "Today's Anonymous submitter was reviewing some C++ code, and saw this perfectly reasonable looking pattern. class SomeClass { public: void setField(int val); int getField(); }",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-04-17 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Today's Anonymous submitter was reviewing some C++ code, and saw this perfectly reasonable looking pattern. class SomeClass { public: void setField(int val); int getField(); } Now, we can talk about how overuse of getters and setters is itself an antipattern (especially if they're trivial- you've just made a public variable with extra steps), but it's not wrong and there are certainly good reasons to be cautious with encapsulation. That said, because this is C++, that getField should really be declared int getField() const- appropriate for any method which doesn't cause a mutation to a class instance. Or should it? Let's look at the implementation. void SomeClass::setField(int val) { setGetField(true, val); } void SomeClass::getField() { return setGetField(false); } Wait, what? Why are we passing a boolean to a method called setGet. Why is there a method called setGet? They didn't go and make a method that both sets and gets, and decide which they're doing based on a boolean flag, did they? int SomeClass::setGetField(bool set, int val) { static int s_val = 0; if (set) { s_val = val; } return s_val; } Oh, good, they didn't just make a function that maybe sets or gets based on a boolean flag. They also made the state within that function a static field. And yes, function level statics are not scoped to an instance, so this is shared across all instances of the class. So it's not encapsulated at all, and we've blundered back into Singletons again, somehow. Our anonymous submitter had two reactions. Upon seeing this the first time, they wondered: \"WTF? This must be some kind of joke. I'm being pranked.\" But then they saw the pattern again. And again. After seeing it fifty times, they wondered: \"WTF? Who hired these developers? And can that hiring manager be fired? Out of a cannon? Into the sun?\"",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-04-17\"\u003e2025-04-17\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10894\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eToday\u0026#39;s Anonymous submitter was reviewing some C++ code, and saw this perfectly reasonable looking pattern.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass SomeClass\n{\npublic:\n\tvoid setField(int val);\n\tint getField();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we can talk about how overuse of getters and setters is itself an antipattern (especially if they\u0026#39;re trivial- you\u0026#39;ve just made a public variable with extra steps), but it\u0026#39;s not \u003cem\u003ewrong\u003c/em\u003e and there are certainly good reasons to be cautious with encapsulation. That said, because this is C++, that \u003ccode\u003egetField\u003c/code\u003e should really be declared \u003ccode\u003eint getField() const\u003c/code\u003e- appropriate for any method which doesn\u0026#39;t cause a mutation to a class instance.\u003c/p\u003e\n\u003cp\u003eOr should it? Let\u0026#39;s look at the implementation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evoid SomeClass::setField(int val)\n{\n\tsetGetField(true, val);\n}\n\nvoid SomeClass::getField()\n{\n\treturn setGetField(false);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWait, what? Why are we passing a boolean to a method called \u003ccode\u003esetGet\u003c/code\u003e. \u003cem\u003eWhy\u003c/em\u003e is there a method called \u003ccode\u003esetGet\u003c/code\u003e? They didn\u0026#39;t go and make a method that both sets and gets, and decide which they\u0026#39;re doing based on a boolean flag, did they?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint SomeClass::setGetField(bool set, int val)\n{\n\tstatic int s_val = 0;\n\tif (set)\n\t{\n\t\ts_val = val;\n\t}\n\treturn s_val;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh, good, they didn\u0026#39;t \u003cem\u003ejust\u003c/em\u003e make a function that maybe sets or gets based on a boolean flag. They \u003cem\u003ealso\u003c/em\u003e made the state within that function a static field. And yes, function level statics are not scoped to an instance, so this is shared across all instances of the class. So it\u0026#39;s not encapsulated at all, and we\u0026#39;ve blundered back into Singletons again, somehow.\u003c/p\u003e\n\u003cp\u003eOur anonymous submitter had two reactions. Upon seeing this the first time, they wondered: \u0026#34;WTF? This must be some kind of joke. I\u0026#39;m being pranked.\u0026#34;\u003c/p\u003e\n\u003cp\u003eBut then they saw the pattern again. And again. After seeing it fifty times, they wondered: \u0026#34;WTF? Who hired these developers? And can that hiring manager be fired? Out of a cannon? Into the sun?\u0026#34;\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-04-17T06:30:00Z",
  "modifiedTime": null
}
