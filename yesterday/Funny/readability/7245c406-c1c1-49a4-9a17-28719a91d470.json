{
  "id": "7245c406-c1c1-49a4-9a17-28719a91d470",
  "title": "CodeSOD: Back Up for a Moment",
  "link": "https://thedailywtf.com/articles/back-up-for-a-moment",
  "description": "James's team has a pretty complicated deployment process implemented as a series of bash scripts. The deployment is complicated, the scripts doing the deployment are complicated, and failures mid-deployment are common. That means they need to gracefully roll back, and they way they do that is by making backup copies of the modified files. This is how they do that. DATE=`date '+%Y%m%d'` BACKUPDIR=`dirname ${DESTINATION}`/backup if [ ! -d $BACKUPDIR ] then echo \"Creating backup directory ...\" mkdir -p $BACKUPDIR fi FILENAME=`basename ${DESTINATION}` BACKUPFILETYPE=${BACKUPDIR}/${FILENAME}.${DATE} BACKUPFILE=${BACKUPFILETYPE}-1 if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-2 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-3 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-4 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-5 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-6 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-7 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-8 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-9 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then cat \u003c\u003cEOF You have already had 9 rates releases in one day. ${BACKUPFILE} already exists, do it manually !!! EOF exit 2 fi Look, I know that loops in bash can be annoying, but they're not that annoying. This code creates a backup directory (if it doesn't already exist), and then creates a file name for the file we're about to backup, in the form OriginalName.Ymd-n.gz. It tests to see if this file exists, and if it does, it increments n by one. It does this until either it finds a file name that doesn't exist, or it hits 9, at which point it gives you a delightfully passive aggressive message: You have already had 9 rates releases in one day. ${BACKUPFILE} already exists, do it manually !!! Yeah, do it manually. Now, admittedly, I don't think a lot of folks want to do more than 9 releases in a given day, but there's no reason why they couldn't just keep trying until they find a good filename. Or even better, require each release to have an identifier (like the commit or build number or whatever) and then use that for the filenames. Of course, just fixing this copy doesn't address the real WTF, because we laid out the real WTF in the first paragraph: deployment is a series of complicated bash scripts doing complicated steps that can fail all the time. I've worked in places like that, and it's always a nightmare. There are better tools! Our very own Alex has his product, of course, but there are a million ways to get your builds repeatable and reliable that don't involve BuildMaster but also don't involve fragile scripts. Please, please use one of those. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Mon, 14 Jul 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3499,
  "excerpt": "James's team has a pretty complicated deployment process implemented as a series of bash scripts. The deployment is complicated, the scripts doing the deployment are complicated, and failures mid-deployment are common. That means they need to gracefully roll back, and they way they do that is by making backup copies of the modified files. This is how they do that.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-07-14 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. James's team has a pretty complicated deployment process implemented as a series of bash scripts. The deployment is complicated, the scripts doing the deployment are complicated, and failures mid-deployment are common. That means they need to gracefully roll back, and they way they do that is by making backup copies of the modified files. This is how they do that. DATE=`date '+%Y%m%d'` BACKUPDIR=`dirname ${DESTINATION}`/backup if [ ! -d $BACKUPDIR ] then echo \"Creating backup directory ...\" mkdir -p $BACKUPDIR fi FILENAME=`basename ${DESTINATION}` BACKUPFILETYPE=${BACKUPDIR}/${FILENAME}.${DATE} BACKUPFILE=${BACKUPFILETYPE}-1 if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-2 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-3 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-4 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-5 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-6 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-7 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-8 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then BACKUPFILE=${BACKUPFILETYPE}-9 ; fi if [ -f ${BACKUPFILE} ] || [ -f ${BACKUPFILE}.gz ] ; then cat \u003c\u003cEOF You have already had 9 rates releases in one day. ${BACKUPFILE} already exists, do it manually !!! EOF exit 2 fi Look, I know that loops in bash can be annoying, but they're not that annoying. This code creates a backup directory (if it doesn't already exist), and then creates a file name for the file we're about to backup, in the form OriginalName.Ymd-n.gz. It tests to see if this file exists, and if it does, it increments n by one. It does this until either it finds a file name that doesn't exist, or it hits 9, at which point it gives you a delightfully passive aggressive message: You have already had 9 rates releases in one day. ${BACKUPFILE} already exists, do it manually !!! Yeah, do it manually. Now, admittedly, I don't think a lot of folks want to do more than 9 releases in a given day, but there's no reason why they couldn't just keep trying until they find a good filename. Or even better, require each release to have an identifier (like the commit or build number or whatever) and then use that for the filenames. Of course, just fixing this copy doesn't address the real WTF, because we laid out the real WTF in the first paragraph: deployment is a series of complicated bash scripts doing complicated steps that can fail all the time. I've worked in places like that, and it's always a nightmare. There are better tools! Our very own Alex has his product, of course, but there are a million ways to get your builds repeatable and reliable that don't involve BuildMaster but also don't involve fragile scripts. Please, please use one of those. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-07-14\"\u003e2025-07-14\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10960\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eJames\u003c/strong\u003e\u0026#39;s team has a pretty complicated deployment process implemented as a series of bash scripts. The deployment is complicated, the scripts doing the deployment are complicated, and failures mid-deployment are common. That means they need to gracefully roll back, and they way they do that is by making backup copies of the modified files.\u003c/p\u003e\n\u003cp\u003eThis is how they do that.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDATE=`\u003cspan\u003edate\u003c/span\u003e \u003cspan\u003e\u0026#39;+%Y%m%d\u0026#39;\u003c/span\u003e`\nBACKUPDIR=`\u003cspan\u003edirname\u003c/span\u003e \u003cspan\u003e${DESTINATION}\u003c/span\u003e`/backup\n\u003cspan\u003eif\u003c/span\u003e [ ! -d \u003cspan\u003e$BACKUPDIR\u003c/span\u003e ]\n\u003cspan\u003ethen\u003c/span\u003e\n        \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;Creating backup directory ...\u0026#34;\u003c/span\u003e\n        \u003cspan\u003emkdir\u003c/span\u003e -p \u003cspan\u003e$BACKUPDIR\u003c/span\u003e\n\u003cspan\u003efi\u003c/span\u003e\nFILENAME=`\u003cspan\u003ebasename\u003c/span\u003e \u003cspan\u003e${DESTINATION}\u003c/span\u003e`\nBACKUPFILETYPE=\u003cspan\u003e${BACKUPDIR}\u003c/span\u003e/\u003cspan\u003e${FILENAME}\u003c/span\u003e.\u003cspan\u003e${DATE}\u003c/span\u003e\nBACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-1\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-2 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-3 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-4 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-5 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-6 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-7 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-8 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e BACKUPFILE=\u003cspan\u003e${BACKUPFILETYPE}\u003c/span\u003e-9 ; \u003cspan\u003efi\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e ] || [ -f \u003cspan\u003e${BACKUPFILE}\u003c/span\u003e.gz ] ; \u003cspan\u003ethen\u003c/span\u003e\n\u003cspan\u003ecat\u003c/span\u003e \u0026lt;\u0026lt;\u003cspan\u003eEOF\nYou have already had 9 rates releases in one day.\n\n${BACKUPFILE} already exists, do it manually !!!\nEOF\u003c/span\u003e\n\u003cspan\u003eexit\u003c/span\u003e 2\n\u003cspan\u003efi\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLook, I know that loops in bash can be annoying, but they\u0026#39;re not \u003cem\u003ethat\u003c/em\u003e annoying.\u003c/p\u003e\n\u003cp\u003eThis code creates a backup directory  (if it doesn\u0026#39;t already exist), and then creates a file name for the file we\u0026#39;re about to backup, in the form \u003ccode\u003eOriginalName.Ymd-n.gz\u003c/code\u003e. It tests to see if this file exists, and if it does, it increments \u003ccode\u003en\u003c/code\u003e by one. It does this until either it finds a file name that doesn\u0026#39;t exist, or it hits \u003ccode\u003e9\u003c/code\u003e, at which point it gives you a delightfully passive aggressive message:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou have already had 9 rates releases in one day.\n${BACKUPFILE} already exists, do it manually !!!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYeah, \u003cem\u003edo it manually\u003c/em\u003e. Now, admittedly, I don\u0026#39;t think a lot of folks want to do more than 9 releases in a given day, but there\u0026#39;s no reason why they couldn\u0026#39;t \u003cem\u003ejust keep trying\u003c/em\u003e until they find a good filename. Or even better, require each release to have an identifier (like the commit or build number or whatever) and then use \u003cem\u003ethat\u003c/em\u003e for the filenames.\u003c/p\u003e\n\u003cp\u003eOf course, just fixing this copy doesn\u0026#39;t address the \u003cem\u003ereal\u003c/em\u003e WTF, because we laid out the real WTF in the first paragraph: deployment is a series of complicated bash scripts doing complicated steps that can fail all the time. I\u0026#39;ve worked in places like that, and it\u0026#39;s always a nightmare. There are better tools! Our very own Alex \u003ca href=\"https://thedailywtf.com/articles/A-(Long-Overdue)-BuildMaster-Introduction\"\u003ehas his product\u003c/a\u003e, of course, but there are a million ways to get your builds repeatable and reliable that don\u0026#39;t involve BuildMaster but also don\u0026#39;t involve fragile scripts. Please, \u003cem\u003eplease\u003c/em\u003e use one of those.\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-07-14T06:30:00Z",
  "modifiedTime": null
}
