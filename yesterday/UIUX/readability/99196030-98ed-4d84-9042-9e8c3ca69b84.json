{
  "id": "99196030-98ed-4d84-9042-9e8c3ca69b84",
  "title": "Building An Offline-Friendly Image Upload System",
  "link": "https://smashingmagazine.com/2025/04/building-offline-friendly-image-upload-system/",
  "description": "Poor internet connectivity doesn’t have to mean poor UX. With PWA technologies like `IndexedDB`, service workers, and the Background Sync API, you can build an offline-friendly image upload system that queues uploads and retries them automatically — so your users can upload stress-free, even when offline.",
  "author": "Amejimaobari Ollornwi",
  "published": "Wed, 23 Apr 2025 10:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 12329,
  "excerpt": "Poor internet connectivity doesn’t have to mean poor UX. With PWA technologies like `IndexedDB`, service workers, and the Background Sync API, you can build an offline-friendly image upload system that queues uploads and retries them automatically — so your users can upload stress-free, even when offline.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "9 min readServerless, JavaScript, User ExperiencePoor internet connectivity doesn’t have to mean poor UX. With PWA technologies like IndexedDB, service workers, and the Background Sync API, you can build an offline-friendly image upload system that queues uploads and retries them automatically — so your users can upload stress-free, even when offline.So, you’re filling out an online form, and it asks you to upload a file. You click the input, select a file from your desktop, and are good to go. But something happens. The network drops, the file disappears, and you’re stuck having to re-upload the file. Poor network connectivity can lead you to spend an unreasonable amount of time trying to upload files successfully.What ruins the user experience stems from having to constantly check network stability and retry the upload several times. While we may not be able to do much about network connectivity, as developers, we can always do something to ease the pain that comes with this problem.One of the ways we can solve this problem is by tweaking image upload systems in a way that enables users to upload images offline — eliminating the need for a reliable network connection, and then having the system retry the upload process when the network becomes stable, without the user intervening.This article is going to focus on explaining how to build an offline-friendly image upload system using PWA (progressive web application) technologies such as IndexedDB, service workers, and the Background Sync API. We will also briefly cover tips for improving the user experience for this system.Planning The Offline Image Upload SystemHere’s a flow chart for an offline-friendly image upload system.Flow chart of an offline-friendly image upload system (Large preview)As shown in the flow chart, the process unfolds as follows:The user selects an image.The process begins by letting the user select their image.The image is stored locally in IndexedDB.Next, the system checks for network connectivity. If network connectivity is available, the system uploads the image directly, avoiding unnecessary local storage usage. However, if the network is not available, the image will be stored in IndexedDB.The service worker detects when the network is restored.With the image stored in IndexedDB, the system waits to detect when the network connection is restored to continue with the next step.The background sync processes pending uploads.The moment the connection is restored, the system will try to upload the image again.The file is successfully uploaded.The moment the image is uploaded, the system will remove the local copy stored in IndexedDB.Implementing The SystemThe first step in the system implementation is allowing the user to select their images. There are different ways you can achieve this:You can use a simple \u003cinput type=\"file\"\u003e element;A drag-and-drop interface.I would advise that you use both. Some users prefer to use the drag-and-drop interface, while others think the only way to upload images is through the \u003cinput type=\"file\"\u003e element. Having both options will help improve the user experience. You can also consider allowing users to paste images directly in the browser using the Clipboard API.Registering The Service WorkerAt the heart of this solution is the service worker. Our service worker is going to be responsible for retrieving the image from the IndexedDB store, uploading it when the internet connection is restored, and clearing the IndexedDB store when the image has been uploaded.To use a service worker, you first have to register one:if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/service-worker.js') .then(reg =\u003e console.log('Service Worker registered', reg)) .catch(err =\u003e console.error('Service Worker registration failed', err)); } Checking For Network ConnectivityRemember, the problem we are trying to solve is caused by unreliable network connectivity. If this problem does not exist, there is no point in trying to solve anything. Therefore, once the image is selected, we need to check if the user has a reliable internet connection before registering a sync event and storing the image in IndexedDB.function uploadImage() { if (navigator.onLine) { // Upload Image } else { // register Sync Event // Store Images in IndexedDB } } Note: I’m only using the navigator.onLine property here to demonstrate how the system would work. The navigator.onLine property is unreliable, and I would suggest you come up with a custom solution to check whether the user is connected to the internet or not. One way you can do this is by sending a ping request to a server endpoint you’ve created.Registering The Sync EventOnce the network test fails, the next step is to register a sync event. The sync event needs to be registered at the point where the system fails to upload the image due to a poor internet connection.async function registerSyncEvent() { if ('SyncManager' in window) { const registration = await navigator.serviceWorker.ready; await registration.sync.register('uploadImages'); console.log('Background Sync registered'); } } After registering the sync event, you need to listen for it in the service worker.self.addEventListener('sync', (event) =\u003e { if (event.tag === 'uploadImages') { event.waitUntil(sendImages()); } }); The sendImages function is going to be an asynchronous process that will retrieve the image from IndexedDB and upload it to the server. This is what it’s going to look like:async function sendImages() { try { // await image retrieval and upload } catch (error) { // throw error } } Opening The DatabaseThe first thing we need to do in order to store our image locally is to open an IndexedDB store. As you can see from the code below, we are creating a global variable to store the database instance. The reason for doing this is that, subsequently, when we want to retrieve our image from IndexedDB, we wouldn’t need to write the code to open the database again.let database; // Global variable to store the database instance function openDatabase() { return new Promise((resolve, reject) =\u003e { if (database) return resolve(database); // Return existing database instance const request = indexedDB.open(\"myDatabase\", 1); request.onerror = (event) =\u003e { console.error(\"Database error:\", event.target.error); reject(event.target.error); // Reject the promise on error }; request.onupgradeneeded = (event) =\u003e { const db = event.target.result; // Create the \"images\" object store if it doesn't exist. if (!db.objectStoreNames.contains(\"images\")) { db.createObjectStore(\"images\", { keyPath: \"id\" }); } console.log(\"Database setup complete.\"); }; request.onsuccess = (event) =\u003e { database = event.target.result; // Store the database instance globally resolve(database); // Resolve the promise with the database instance }; }); } Storing The Image In IndexedDBWith the IndexedDB store open, we can now store our images.Now, you may be wondering why an easier solution like localStorage wasn’t used for this purpose.The reason for that is that IndexedDB operates asynchronously and doesn’t block the main JavaScript thread, whereas localStorage runs synchronously and can block the JavaScript main thread if it is being used.Here’s how you can store the image in IndexedDB:async function storeImages(file) { // Open the IndexedDB database. const db = await openDatabase(); // Create a transaction with read and write access. const transaction = db.transaction(\"images\", \"readwrite\"); // Access the \"images\" object store. const store = transaction.objectStore(\"images\"); // Define the image record to be stored. const imageRecord = { id: IMAGE_ID, // a unique ID image: file // Store the image file (Blob) }; // Add the image record to the store. const addRequest = store.add(imageRecord); // Handle successful addition. addRequest.onsuccess = () =\u003e console.log(\"Image added successfully!\"); // Handle errors during insertion. addRequest.onerror = (e) =\u003e console.error(\"Error storing image:\", e.target.error); } With the images stored and the background sync set, the system is ready to upload the image whenever the network connection is restored.Retrieving And Uploading The ImagesOnce the network connection is restored, the sync event will fire, and the service worker will retrieve the image from IndexedDB and upload it.async function retrieveAndUploadImage(IMAGE_ID) { try { const db = await openDatabase(); // Ensure the database is open const transaction = db.transaction(\"images\", \"readonly\"); const store = transaction.objectStore(\"images\"); const request = store.get(IMAGE_ID); request.onsuccess = function (event) { const image = event.target.result; if (image) { // upload Image to server here } else { console.log(\"No image found with ID:\", IMAGE_ID); } }; request.onerror = () =\u003e { console.error(\"Error retrieving image.\"); }; } catch (error) { console.error(\"Failed to open database:\", error); } } Deleting The IndexedDB DatabaseOnce the image has been uploaded, the IndexedDB store is no longer needed. Therefore, it should be deleted along with its content to free up storage.function deleteDatabase() { // Check if there's an open connection to the database. if (database) { database.close(); // Close the database connection console.log(\"Database connection closed.\"); } // Request to delete the database named \"myDatabase\". const deleteRequest = indexedDB.deleteDatabase(\"myDatabase\"); // Handle successful deletion of the database. deleteRequest.onsuccess = function () { console.log(\"Database deleted successfully!\"); }; // Handle errors that occur during the deletion process. deleteRequest.onerror = function (event) { console.error(\"Error deleting database:\", event.target.error); }; // Handle cases where the deletion is blocked (e.g., if there are still open connections). deleteRequest.onblocked = function () { console.warn(\"Database deletion blocked. Close open connections and try again.\"); }; } With that, the entire process is complete!Considerations And LimitationsWhile we’ve done a lot to help improve the experience by supporting offline uploads, the system is not without its limitations. I figured I would specifically call those out because it’s worth knowing where this solution might fall short of your needs.No Reliable Internet Connectivity DetectionJavaScript does not provide a foolproof way to detect online status. For this reason, you need to come up with a custom solution for detecting online status.Chromium-Only SolutionThe Background Sync API is currently limited to Chromium-based browsers. As such, this solution is only supported by Chromium browsers. That means you will need a more robust solution if you have the majority of your users on non-Chromium browsers.IndexedDB Storage PoliciesBrowsers impose storage limitations and eviction policies for IndexedDB. For instance, in Safari, data stored in IndexedDB has a lifespan of seven days if the user doesn’t interact with the website. This is something you should bear in mind if you do come up with an alternative for the background sync API that supports Safari.Enhancing The User ExperienceSince the entire process happens in the background, we need a way to inform the users when images are stored, waiting to be uploaded, or have been successfully uploaded. Implementing certain UI elements for this purpose will indeed enhance the experience for the users. These UI elements may include toast notifications, upload status indicators like spinners (to show active processes), progress bars (to show state progress), network status indicators, or buttons to provide retry and cancel options.Wrapping UpPoor internet connectivity can disrupt the user experience of a web application. However, by leveraging PWA technologies such as IndexedDB, service workers, and the Background Sync API, developers can help improve the reliability of web applications for their users, especially those in areas with unreliable internet connectivity. (gg, yk)",
  "image": "https://files.smashing.media/articles/building-offline-friendly-image-upload-system/building-offline-friendly-image-upload-system.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e9 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/serverless\"\u003eServerless\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/javascript\"\u003eJavaScript\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/user-experience\"\u003eUser Experience\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003ePoor internet connectivity doesn’t have to mean poor UX. With PWA technologies like \u003ccode\u003eIndexedDB\u003c/code\u003e, service workers, and the Background Sync API, you can build an offline-friendly image upload system that queues uploads and retries them automatically — so your users can upload stress-free, even when offline.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eSo, you’re filling out an online form, and it asks you to upload a file. You click the input, select a file from your desktop, and are good to go. But something happens. The network drops, the file disappears, and you’re stuck having to re-upload the file. \u003cstrong\u003ePoor network connectivity\u003c/strong\u003e can lead you to spend an unreasonable amount of time trying to upload files successfully.\u003c/p\u003e\u003cp\u003eWhat ruins the user experience stems from having to constantly check network stability and retry the upload several times. While we may not be able to do much about network connectivity, as developers, we can always do something to ease the pain that comes with this problem.\u003c/p\u003e\u003cp\u003eOne of the ways we can solve this problem is by tweaking image upload systems in a way that enables users to upload images offline — \u003cstrong\u003eeliminating the need for a reliable network connection\u003c/strong\u003e, and then having the system retry the upload process when the network becomes stable, without the user intervening.\u003c/p\u003e\u003cp\u003eThis article is going to focus on explaining how to build \u003cstrong\u003ean offline-friendly image upload system\u003c/strong\u003e using PWA (progressive web application) technologies such as \u003ccode\u003eIndexedDB\u003c/code\u003e, service workers, and the Background Sync API. We will also briefly cover tips for improving the user experience for this system.\u003c/p\u003e\u003ch2 id=\"planning-the-offline-image-upload-system\"\u003ePlanning The Offline Image Upload System\u003c/h2\u003e\u003cp\u003eHere’s a flow chart for an offline-friendly image upload system.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"678\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png\" sizes=\"100vw\" alt=\"Flow chart of an offline-friendly image upload system\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFlow chart of an offline-friendly image upload system (\u003ca href=\"https://files.smashing.media/articles/building-offline-friendly-image-upload-system/1-upload-system-flow-chart.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eAs shown in the flow chart, the process unfolds as follows:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eThe user selects an image.\u003c/strong\u003e\u003cbr/\u003eThe process begins by letting the user select their image.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThe image is stored locally in \u003ccode\u003eIndexedDB\u003c/code\u003e.\u003c/strong\u003e\u003cbr/\u003eNext, the system checks for network connectivity. If network connectivity is available, the system uploads the image directly, avoiding unnecessary local storage usage. However, if the network is not available, the image will be stored in \u003ccode\u003eIndexedDB\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThe service worker detects when the network is restored.\u003c/strong\u003e\u003cbr/\u003eWith the image stored in \u003ccode\u003eIndexedDB\u003c/code\u003e, the system waits to detect when the network connection is restored to continue with the next step.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThe background sync processes pending uploads.\u003c/strong\u003e\u003cbr/\u003eThe moment the connection is restored, the system will try to upload the image again.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThe file is successfully uploaded\u003c/strong\u003e.\u003cbr/\u003eThe moment the image is uploaded, the system will remove the local copy stored in \u003ccode\u003eIndexedDB\u003c/code\u003e.\u003cbr/\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"implementing-the-system\"\u003eImplementing The System\u003c/h2\u003e\u003cp\u003eThe first step in the system implementation is allowing the user to select their images. There are different ways you can achieve this:\u003c/p\u003e\u003cul\u003e\u003cli\u003eYou can use a simple \u003ccode\u003e\u0026lt;input type=\u0026#34;file\u0026#34;\u0026gt;\u003c/code\u003e element;\u003c/li\u003e\u003cli\u003eA drag-and-drop interface.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI would advise that you use both. Some users prefer to use the drag-and-drop interface, while others think the only way to upload images is through the \u003ccode\u003e\u0026lt;input type=\u0026#34;file\u0026#34;\u0026gt;\u003c/code\u003e element. Having both options will help improve the user experience. You can also consider allowing users to paste images directly in the browser using the Clipboard API.\u003c/p\u003e\u003ch3 id=\"registering-the-service-worker\"\u003eRegistering The Service Worker\u003c/h3\u003e\u003cp\u003eAt the heart of this solution is the \u003ca href=\"https://www.smashingmagazine.com/2016/02/making-a-service-worker/\"\u003eservice worker\u003c/a\u003e. Our service worker is going to be responsible for retrieving the image from the \u003ccode\u003eIndexedDB\u003c/code\u003e store, uploading it when the internet connection is restored, and clearing the \u003ccode\u003eIndexedDB\u003c/code\u003e store when the image has been uploaded.\u003c/p\u003e\u003cp\u003eTo use a service worker, you first have to register one:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eif (\u0026#39;serviceWorker\u0026#39; in navigator) {\n  navigator.serviceWorker.register(\u0026#39;/service-worker.js\u0026#39;)\n    .then(reg =\u0026gt; console.log(\u0026#39;Service Worker registered\u0026#39;, reg))\n    .catch(err =\u0026gt; console.error(\u0026#39;Service Worker registration failed\u0026#39;, err));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"checking-for-network-connectivity\"\u003eChecking For Network Connectivity\u003c/h3\u003e\u003cp\u003eRemember, the problem we are trying to solve is caused by \u003cstrong\u003eunreliable network connectivity\u003c/strong\u003e. If this problem does not exist, there is no point in trying to solve anything. Therefore, once the image is selected, we need to check if the user has a reliable internet connection before registering a sync event and storing the image in \u003ccode\u003eIndexedDB\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunction uploadImage() {\n  if (navigator.onLine) {\n    // Upload Image\n  } else {\n    // register Sync Event\n    // Store Images in IndexedDB\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: I’m only using the \u003ccode\u003enavigator.onLine\u003c/code\u003e property here to demonstrate how the system would work. The \u003ccode\u003enavigator.onLine\u003c/code\u003e property is \u003cstrong\u003eunreliable\u003c/strong\u003e, and I would suggest you come up with a custom solution to check whether the user is connected to the internet or not. One way you can do this is by sending a ping request to a server endpoint you’ve created.\u003c/p\u003e\u003ch3 id=\"registering-the-sync-event\"\u003eRegistering The Sync Event\u003c/h3\u003e\u003cp\u003eOnce the network test fails, the next step is to register a sync event. The sync event needs to be registered at the point where the system fails to upload the image due to a poor internet connection.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003easync function registerSyncEvent() {\n  if (\u0026#39;SyncManager\u0026#39; in window) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register(\u0026#39;uploadImages\u0026#39;);\n    console.log(\u0026#39;Background Sync registered\u0026#39;);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter registering the sync event, you need to listen for it in the service worker.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eself.addEventListener(\u0026#39;sync\u0026#39;, (event) =\u0026gt; {\n  if (event.tag === \u0026#39;uploadImages\u0026#39;) {\n    event.waitUntil(sendImages());\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003esendImages\u003c/code\u003e function is going to be an asynchronous process that will retrieve the image from \u003ccode\u003eIndexedDB\u003c/code\u003e and upload it to the server. This is what it’s going to look like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003easync function sendImages() {\n  try {\n    // await image retrieval and upload\n  } catch (error) {\n    // throw error\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"opening-the-database\"\u003eOpening The Database\u003c/h3\u003e\u003cp\u003eThe first thing we need to do in order to store our image locally is to open an \u003ccode\u003eIndexedDB\u003c/code\u003e store. As you can see from the code below, we are creating \u003cstrong\u003ea global variable to store the database instance\u003c/strong\u003e. The reason for doing this is that, subsequently, when we want to retrieve our image from \u003ccode\u003eIndexedDB\u003c/code\u003e, we wouldn’t need to write the code to open the database again.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003elet database; // Global variable to store the database instance\n\nfunction openDatabase() {\n  return new Promise((resolve, reject) =\u0026gt; {\n    if (database) return resolve(database); // Return existing database instance \n\n    const request = indexedDB.open(\u0026#34;myDatabase\u0026#34;, 1);\n\n    request.onerror = (event) =\u0026gt; {\n      console.error(\u0026#34;Database error:\u0026#34;, event.target.error);\n      reject(event.target.error); // Reject the promise on error\n    };\n\n    request.onupgradeneeded = (event) =\u0026gt; {\n        const db = event.target.result;\n        // Create the \u0026#34;images\u0026#34; object store if it doesn\u0026#39;t exist.\n        if (!db.objectStoreNames.contains(\u0026#34;images\u0026#34;)) {\n          db.createObjectStore(\u0026#34;images\u0026#34;, { keyPath: \u0026#34;id\u0026#34; });\n        }\n        console.log(\u0026#34;Database setup complete.\u0026#34;);\n    };\n\n    request.onsuccess = (event) =\u0026gt; {\n      database = event.target.result; // Store the database instance globally\n      resolve(database); // Resolve the promise with the database instance\n    };\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"storing-the-image-in-indexeddb\"\u003eStoring The Image In IndexedDB\u003c/h3\u003e\u003cp\u003eWith the \u003ccode\u003eIndexedDB\u003c/code\u003e store open, we can now store our images.\u003c/p\u003e\u003cblockquote\u003eNow, you may be wondering why an easier solution like \u003ccode\u003elocalStorage\u003c/code\u003e wasn’t used for this purpose.\u003cp\u003eThe reason for that is that \u003ccode\u003eIndexedDB\u003c/code\u003e operates asynchronously and doesn’t block the main JavaScript thread, whereas \u003ccode\u003elocalStorage\u003c/code\u003e runs synchronously and can block the JavaScript main thread if it is being used.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eHere’s how you can store the image in \u003ccode\u003eIndexedDB\u003c/code\u003e:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003easync function storeImages(file) {\n  // Open the IndexedDB database.\n  const db = await openDatabase();\n  // Create a transaction with read and write access.\n  const transaction = db.transaction(\u0026#34;images\u0026#34;, \u0026#34;readwrite\u0026#34;);\n  // Access the \u0026#34;images\u0026#34; object store.\n  const store = transaction.objectStore(\u0026#34;images\u0026#34;);\n  // Define the image record to be stored.\n  const imageRecord = {\n    id: IMAGE_ID,   // a unique ID\n    image: file     // Store the image file (Blob)\n  };\n  // Add the image record to the store.\n  const addRequest = store.add(imageRecord);\n  // Handle successful addition.\n  addRequest.onsuccess = () =\u0026gt; console.log(\u0026#34;Image added successfully!\u0026#34;);\n  // Handle errors during insertion.\n  addRequest.onerror = (e) =\u0026gt; console.error(\u0026#34;Error storing image:\u0026#34;, e.target.error);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith the images stored and the background sync set, the system is ready to upload the image whenever the network connection is restored.\u003c/p\u003e\u003ch3 id=\"retrieving-and-uploading-the-images\"\u003eRetrieving And Uploading The Images\u003c/h3\u003e\u003cp\u003eOnce the network connection is restored, the sync event will fire, and the service worker will retrieve the image from \u003ccode\u003eIndexedDB\u003c/code\u003e and upload it.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003easync function retrieveAndUploadImage(IMAGE_ID) {\n  try {\n    const db = await openDatabase(); // Ensure the database is open\n    const transaction = db.transaction(\u0026#34;images\u0026#34;, \u0026#34;readonly\u0026#34;);\n    const store = transaction.objectStore(\u0026#34;images\u0026#34;);\n    const request = store.get(IMAGE_ID);\n    request.onsuccess = function (event) {\n      const image = event.target.result;\n      if (image) {\n        // upload Image to server here\n      } else {\n        console.log(\u0026#34;No image found with ID:\u0026#34;, IMAGE_ID);\n      }\n    };\n    request.onerror = () =\u0026gt; {\n        console.error(\u0026#34;Error retrieving image.\u0026#34;);\n    };\n  } catch (error) {\n    console.error(\u0026#34;Failed to open database:\u0026#34;, error);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"deleting-the-indexeddb-database\"\u003eDeleting The IndexedDB Database\u003c/h3\u003e\u003cp\u003eOnce the image has been uploaded, the \u003ccode\u003eIndexedDB\u003c/code\u003e store is no longer needed. Therefore, it should be deleted along with its content to free up storage.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003efunction deleteDatabase() {\n  // Check if there\u0026#39;s an open connection to the database.\n  if (database) {\n    database.close(); // Close the database connection\n    console.log(\u0026#34;Database connection closed.\u0026#34;);\n  }\n\n  // Request to delete the database named \u0026#34;myDatabase\u0026#34;.\n  const deleteRequest = indexedDB.deleteDatabase(\u0026#34;myDatabase\u0026#34;);\n\n  // Handle successful deletion of the database.\n  deleteRequest.onsuccess = function () {\n    console.log(\u0026#34;Database deleted successfully!\u0026#34;);\n  };\n\n  // Handle errors that occur during the deletion process.\n  deleteRequest.onerror = function (event) {\n    console.error(\u0026#34;Error deleting database:\u0026#34;, event.target.error);\n  };\n\n  // Handle cases where the deletion is blocked (e.g., if there are still open connections).\n  deleteRequest.onblocked = function () {\n    console.warn(\u0026#34;Database deletion blocked. Close open connections and try again.\u0026#34;);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWith that, the entire process is complete!\u003c/p\u003e\u003ch2 id=\"considerations-and-limitations\"\u003eConsiderations And Limitations\u003c/h2\u003e\u003cp\u003eWhile we’ve done a lot to help improve the experience by supporting offline uploads, the system is not without its limitations. I figured I would specifically call those out because it’s worth knowing where this solution might fall short of your needs.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eNo Reliable Internet Connectivity Detection\u003c/strong\u003e\u003cbr/\u003eJavaScript does not provide a foolproof way to detect online status. For this reason, you need to come up with a custom solution for detecting online status.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eChromium-Only Solution\u003c/strong\u003e\u003cbr/\u003eThe Background Sync API is currently \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Background_Synchronization_API#browser_compatibility\"\u003elimited to Chromium-based browsers\u003c/a\u003e. As such, this solution is only supported by Chromium browsers. That means you will need a more robust solution if you have the majority of your users on non-Chromium browsers.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eIndexedDB\u003c/code\u003e Storage Policies\u003c/strong\u003e\u003cbr/\u003eBrowsers impose storage limitations and eviction policies for \u003ccode\u003eIndexedDB\u003c/code\u003e. For instance, in Safari, data stored in \u003ccode\u003eIndexedDB\u003c/code\u003e has a lifespan of seven days if the user doesn’t interact with the website. This is something you should bear in mind if you do come up with an alternative for the background sync API that supports Safari.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"enhancing-the-user-experience\"\u003eEnhancing The User Experience\u003c/h2\u003e\u003cp\u003eSince the entire process happens in the background, we need a way to inform the users when images are stored, waiting to be uploaded, or have been successfully uploaded. Implementing certain \u003cstrong\u003eUI elements\u003c/strong\u003e for this purpose will indeed enhance the experience for the users. These UI elements may include toast notifications, upload status indicators like spinners (to show active processes), progress bars (to show state progress), network status indicators, or buttons to provide retry and cancel options.\u003c/p\u003e\u003ch2 id=\"wrapping-up\"\u003eWrapping Up\u003c/h2\u003e\u003cp\u003ePoor internet connectivity can disrupt the user experience of a web application. However, by leveraging PWA technologies such as \u003ccode\u003eIndexedDB\u003c/code\u003e, service workers, and the Background Sync API, developers can help improve the reliability of web applications for their users, especially those in areas with unreliable internet connectivity.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-04-23T10:00:00Z",
  "modifiedTime": "2025-04-23T10:00:00Z"
}
