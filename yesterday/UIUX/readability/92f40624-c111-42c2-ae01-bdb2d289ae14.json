{
  "id": "92f40624-c111-42c2-ae01-bdb2d289ae14",
  "title": "Building A Drupal To Storyblok Migration Tool: An Engineering Perspective",
  "link": "https://smashingmagazine.com/2025/04/building-drupal-storyblok-migration-tool-engineering-perspective/",
  "description": "In this article, Edoardo Dusi shares the engineering and architectural choices made by the team at Storyblok and how real-world migration challenges were addressed using modern PHP practices.",
  "author": "Edoardo Dusi",
  "published": "Wed, 02 Apr 2025 12:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 9911,
  "excerpt": "In this article, Edoardo Dusi shares the engineering and architectural choices made by the team at Storyblok and how real-world migration challenges were addressed using modern PHP practices.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "7 min readCMS, Tools, Workflow, HeadlessIn this article, Edoardo Dusi shares the engineering and architectural choices made by the team at Storyblok and how real-world migration challenges were addressed using modern PHP practices.Content management is evolving. The traditional monolithic CMS approach is giving way to headless architectures, where content management and presentation are decoupled. This shift brings new challenges, particularly when organizations need to migrate from legacy systems to modern headless platforms.Our team encountered this scenario when creating a migration path from Drupal to Storyblok. These systems handle content architecture quite differently — Drupal uses an entity-field model integrated with PHP, while Storyblok employs a flexible Stories and Blocks structure designed for headless delivery.If you just need to use a script to do a simple — yet extensible — content migration from Drupal to Storyblok, I already shared step-by-step instructions on how to download and use it. If you’re interested in the process of creating such a script so that you can write your own (possibly) better version, stay here!We observed that developers sometimes struggle with manual content transfers and custom scripts when migrating between CMSs. This led us to develop and share our migration approach, which we implemented as an open-source tool that others could use as a reference for their migration needs.Our solution combines two main components: a custom Drush command that handles content mapping and transformation and a new PHP client for Storyblok’s Management API that leverages modern language features for improved developer experience.We’ll explore the engineering decisions behind this tool’s development, examining our architectural choices and how we addressed real-world migration challenges using modern PHP practices.Note: You can find the complete source code of the migration tool in the Drupal exporter repo.Planning The Migration ArchitectureThe journey from Drupal to Storyblok presents unique architectural challenges. The fundamental difference lies in how these systems conceptualize content: Drupal structures content as entities with fields, while Storyblok uses a component-based approach with Stories and Blocks.Initial Requirements AnalysisA successful migration tool needs to understand both systems intimately. Drupal’s content model relies heavily on its Entity API, storing content as structured field collections within entities. A typical Drupal article might contain fields for the title, body content, images, and taxonomies. Storyblok, on the other hand, structures content as stories that contain blocks, reusable components that can be nested and arranged in a flexible way. It’s a subtle difference that shaped our technical requirements, particularly around content mapping and data transformation, but ultimately, it’s easy to see the relationships between the two content models.Technical ConstraintsEarly in development, we identified several key constraints. Storyblok’s Management API enforces rate limits that affect how quickly we can transfer content. Media assets must first be uploaded and then linked. Error recovery becomes essential when migrating hundreds of pieces of content.The brand-new Management API PHP client handles these constraints through built-in retry mechanisms and response validation, so in writing a migration script, we don’t need to worry about them.Tool SelectionWe chose Drush as our command-line interface for several reasons. First, it’s deeply integrated with Drupal’s bootstrap process, providing direct access to the Entity API and field data. Second, Drupal developers are already familiar with its conventions, making our tool more accessible.The decision to develop a new Management API client came from our experience with the evolution of PHP since we developed the first PHP client, and our goal to provide developers with a dedicated tool for this specific API that offered an improved DX and a tailored set of features.This groundwork shaped how we approached the migration workflow.The Building Blocks: A New Management API ClientA content migration tool interacts heavily with Storyblok’s Management API \u0026mdash, creating stories, uploading assets, and managing tags. Each operation needs to be reliable and predictable. Our brand-new client simplifies these interactions through intuitive method calls: The client handles authentication, request formatting, and response parsing behind the scenes, letting devs focus on content operations rather than API mechanics.Design For ReliabilityContent migrations often involve hundreds of API calls. Our client includes built-in mechanisms for handling common scenarios like rate limiting and failed requests. The response handling pattern provides clear feedback about operation success: A logger can be injected into the client class, as we did using the Drush logger in our migration script from Drupal.Improving The Development ExperienceBeyond basic API operations, the client reduces cognitive load through predictable patterns. Data objects provide a structured way to prepare content for Storyblok: This pattern validates data early in the process, catching potential issues before they reach the API.Designing The Migration WorkflowMoving from Drupal’s entity-based structure to Storyblok’s component model required careful planning of the migration workflow. Our goal was to create a process that would be both reliable and adaptable to different content structures.Command StructureThe migration leverages Drupal’s entity query system to extract content systematically. By default, access checks were disabled (a reversible business decision) to focus solely on migrating published nodes.Key Steps And InsightsText FieldsRequired minimal effort: values like value() mapped directly to Storyblok fields.Rich text posed no encoding challenges, enabling straightforward 1:1 transfers.Handling ImagesUpload: Assets were sent to an AWS S3 bucket.Link: Storyblok’s Asset API upload() method returned an object_id, simplifying field mapping.Assign: The asset ID and filename were attached to the story.Managing TagsTags extracted from Drupal were pre-created via Storyblok’s Tag API (optional but ensures consistency).When assigning tags to stories, Storyblok automatically creates missing ones, streamlining the process.Why Staged Workflows MatterThe migration avoids broken references by prioritizing dependencies (assets first, tags next, content last). While pre-creating tags add control, teams can adapt this logic—for example, letting Storyblok auto-generate tags to save time.Flexibility is key: every decision (access checks, tag workflows) can be adjusted to align with project goals.Real-World Implementation ChallengesMigrating content between Drupal and Storyblok presents challenges that you, as the implementer, may encounter.For example, when dealing with large datasets, you may find that Drupal sites with thousands of nodes can quickly hit the rate limits enforced by Storyblok’s management API. In such cases, a batching mechanism for your requests is worth considering. Instead of processing every node at once, you can process a subset of records, wait for a short period of time, and then continue.Alternatively, you could use the createBulk method of the Story API in the Management API, which allows you to handle multiple story creations with built-in rate limit handling and retries. Another potential hurdle is the conversion of complex field types, especially when Drupal’s nested structures or Paragraph fields need to be mapped to Storyblok’s more flexible block-based model.One approach is first to analyze the nesting depth and structure of the Drupal content, then flatten deeply nested elements into reusable Storyblok components while maintaining the correct hierarchy. For example, a paragraph field with embedded media and text can be split into blocks within Storyblok, with each component representing a logical section of content. By structuring data this way before migration, you ensure that content remains editable and properly structured in the new system.Data consistency is another aspect that you need to manage carefully. When migrating hundreds of records, partial failures are always risky. One approach to managing this is to log detailed information for each migration operation and implement a retry mechanism for failed operations.For example, wrapping API calls in a try-catch block and logging errors can be a practical way to ensure that no records are silently dropped. When dealing with fields such as taxonomy terms or tags created on the fly in Storyblok, you may run into duplication issues. A good practice is to perform a check before creating a new tag. This could involve maintaining a local cache of previously created tags and checking against them before sending a create request to the API.The same goes for images; a check could ensure you don’t upload the same asset twice.Lessons Learned And Looking ForwardA dedicated API client for Storyblok streamlined interactions, abstracting backend complexity while improving code maintainability. Early use of structured data objects to prepare content proved critical, enabling pre-emptive error detection and reducing API failures.We also ran into some challenges and see room for improvement:Encoding issues in rich text (e.g., HTML entities) were resolved with a pre-processing stepPerformance bottlenecks with large text/images required memory optimization and refined request handlingEnhancements could include support for Drupal Layout Builder, advanced validation layers, or dynamic asset management systems.💡 For deeper dives into our Management API client or migration strategies, reach out via Discord, explore the PHP Client repo, or connect with me on Mastodon. Feedback and contributions are welcome! (il)",
  "image": "https://files.smashing.media/articles/building-drupal-storyblok-migration-tool-engineering-perspective/building-drupal-storyblok-migration-tool-engineering-perspective.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e7 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/cms\"\u003eCMS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/tools\"\u003eTools\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/workflow\"\u003eWorkflow\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/headless\"\u003eHeadless\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eIn this article, Edoardo Dusi shares the engineering and architectural choices made by the team at Storyblok and how real-world migration challenges were addressed using modern PHP practices.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eContent management is evolving. The traditional monolithic CMS approach is giving way to headless architectures, where content management and presentation are decoupled. This shift brings new challenges, particularly when organizations need to migrate from legacy systems to modern headless platforms.\u003c/p\u003e\u003cp\u003eOur team encountered this scenario when creating a migration path from Drupal to Storyblok. These systems handle content architecture quite differently — Drupal uses an entity-field model integrated with PHP, while Storyblok employs a flexible Stories and Blocks structure designed for headless delivery.\u003c/p\u003e\u003cp\u003eIf you just need to use a script to do a simple — yet extensible — content migration from Drupal to Storyblok, I already shared \u003ca href=\"https://www.storyblok.com/tp/migrating-drupal-articles-to-storyblok\"\u003estep-by-step instructions\u003c/a\u003e on how to download and use it. If you’re interested in the process of creating such a script so that you can write your own (possibly) better version, stay here!\u003c/p\u003e\u003cp\u003eWe observed that developers sometimes struggle with manual content transfers and custom scripts when migrating between CMSs. This led us to develop and share our migration approach, which we implemented as an open-source tool that others could use as a reference for their migration needs.\u003c/p\u003e\u003cp\u003eOur solution combines two main components: a custom Drush command that handles content mapping and transformation and a new PHP client for Storyblok’s Management API that leverages modern language features for improved developer experience.\u003c/p\u003e\u003cp\u003eWe’ll explore the engineering decisions behind this tool’s development, examining our architectural choices and how we addressed real-world migration challenges using modern PHP practices.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: You can find the complete source code of the migration tool \u003ca href=\"https://github.com/storyblok/drupal-exporter\"\u003ein the Drupal exporter repo\u003c/a\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"planning-the-migration-architecture\"\u003ePlanning The Migration Architecture\u003c/h2\u003e\u003cp\u003eThe journey from Drupal to Storyblok presents unique architectural challenges. The fundamental difference lies in how these systems conceptualize content: Drupal structures content as entities with fields, while Storyblok uses a component-based approach with Stories and Blocks.\u003c/p\u003e\u003ch3 id=\"initial-requirements-analysis\"\u003eInitial Requirements Analysis\u003c/h3\u003e\u003cp\u003eA successful migration tool needs to understand both systems intimately. Drupal’s content model relies heavily on its Entity API, storing content as structured field collections within entities. A typical Drupal article might contain fields for the title, body content, images, and taxonomies. \u003ca href=\"https://www.storyblok.com/?utm_source=smashing\u0026amp;utm_medium=sponsor\u0026amp;utm_campaign=DGM_DEV_SMA_TRA\u0026amp;utm_content=smashing-OSS\"\u003eStoryblok\u003c/a\u003e, on the other hand, structures content as stories that contain blocks, reusable components that can be nested and arranged in a flexible way. It’s a subtle difference that shaped our technical requirements, particularly around content mapping and data transformation, but ultimately, it’s easy to see the relationships between the two content models.\u003c/p\u003e\u003ch3 id=\"technical-constraints\"\u003eTechnical Constraints\u003c/h3\u003e\u003cp\u003eEarly in development, we identified several key constraints. \u003ca href=\"https://www.storyblok.com/docs/api/management/getting-started/?utm_source=smashing\u0026amp;utm_medium=sponsor\u0026amp;utm_campaign=DGM_DEV_SMA_TRA\u0026amp;utm_content=smashing-OSS\"\u003eStoryblok’s Management API\u003c/a\u003e enforces rate limits that affect how quickly we can transfer content. Media assets must first be uploaded and then linked. Error recovery becomes essential when migrating hundreds of pieces of content.\u003c/p\u003e\u003cp\u003eThe brand-new\u003ca href=\"https://github.com/storyblok/php-management-api-client\"\u003e Management API PHP client\u003c/a\u003e handles these constraints through built-in retry mechanisms and response validation, so in writing a migration script, we don’t need to worry about them.\u003c/p\u003e\u003ch3 id=\"tool-selection\"\u003eTool Selection\u003c/h3\u003e\u003cp\u003eWe chose Drush as our command-line interface for several reasons. First, it’s deeply integrated with Drupal’s bootstrap process, providing direct access to the Entity API and field data. Second, Drupal developers are already familiar with its conventions, making our tool more accessible.\u003c/p\u003e\u003cp\u003eThe decision to develop a new \u003cstrong\u003eManagement API client\u003c/strong\u003e came from our experience with the evolution of PHP since we developed the first PHP client, and our goal to provide developers with a dedicated tool for this specific API that offered an improved DX and a tailored set of features.\u003c/p\u003e\u003cp\u003eThis groundwork shaped how we approached the migration workflow.\u003c/p\u003e\u003ch2 id=\"the-building-blocks-a-new-management-api-client\"\u003eThe Building Blocks: A New Management API Client\u003c/h2\u003e\u003cp\u003eA content migration tool interacts heavily with Storyblok’s Management API \u0026amp;mdash, creating stories, uploading assets, and managing tags. Each operation needs to be reliable and predictable. Our brand-new client simplifies these interactions through intuitive method calls: The client handles authentication, request formatting, and response parsing behind the scenes, letting devs focus on content operations rather than API mechanics.\u003c/p\u003e\u003ch3 id=\"design-for-reliability\"\u003eDesign For Reliability\u003c/h3\u003e\u003cp\u003eContent migrations often involve hundreds of API calls. Our client includes built-in mechanisms for handling common scenarios like rate limiting and failed requests. The response handling pattern provides clear feedback about operation success: A logger can be injected into the client class, as we did using the Drush logger in our migration script from Drupal.\u003c/p\u003e\u003ch3 id=\"improving-the-development-experience\"\u003eImproving The Development Experience\u003c/h3\u003e\u003cp\u003eBeyond basic API operations, the client reduces cognitive load through predictable patterns. Data objects provide a structured way to prepare content for Storyblok: This pattern validates data early in the process, catching potential issues before they reach the API.\u003c/p\u003e\u003ch2 id=\"designing-the-migration-workflow\"\u003eDesigning The Migration Workflow\u003c/h2\u003e\u003cp\u003eMoving from Drupal’s entity-based structure to Storyblok’s \u003cstrong\u003ecomponent model\u003c/strong\u003e required careful planning of the migration workflow. Our goal was to create a process that would be both reliable and adaptable to different content structures.\u003c/p\u003e\u003ch3 id=\"command-structure\"\u003eCommand Structure\u003c/h3\u003e\u003cp\u003eThe migration leverages Drupal’s \u003cem\u003eentity query\u003c/em\u003e system to extract content systematically. By default, \u003cstrong\u003eaccess checks were disabled\u003c/strong\u003e (a reversible business decision) to focus solely on migrating \u003cstrong\u003epublished nodes\u003c/strong\u003e.\u003c/p\u003e\u003ch3 id=\"key-steps-and-insights\"\u003eKey Steps And Insights\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eText Fields\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eRequired minimal effort: values like \u003ccode\u003evalue()\u003c/code\u003e mapped directly to Storyblok fields.\u003cbr/\u003e\u003c/li\u003e\u003cli\u003eRich text posed no encoding challenges, enabling straightforward 1:1 transfers.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eHandling Images\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eUpload\u003c/strong\u003e: Assets were sent to an AWS S3 bucket.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLink\u003c/strong\u003e: Storyblok’s \u003cstrong\u003eAsset API\u003c/strong\u003e \u003ccode\u003eupload()\u003c/code\u003e method returned an \u003ccode\u003eobject_id\u003c/code\u003e, simplifying field mapping.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAssign\u003c/strong\u003e: The asset ID and filename were attached to the story.\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eManaging Tags\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eTags extracted from Drupal were pre-created via Storyblok’s \u003cstrong\u003eTag API\u003c/strong\u003e (optional but ensures consistency).\u003c/li\u003e\u003cli\u003eWhen assigning tags to stories, Storyblok automatically creates missing ones, streamlining the process.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"why-staged-workflows-matter\"\u003eWhy Staged Workflows Matter\u003c/h3\u003e\u003cp\u003eThe migration avoids broken references by prioritizing dependencies (assets first, tags next, content last). While pre-creating tags add control, teams can adapt this logic—for example, letting Storyblok auto-generate tags to save time.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eFlexibility is key: every decision (access checks, tag workflows) can be adjusted to align with project goals.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"real-world-implementation-challenges\"\u003eReal-World Implementation Challenges\u003c/h2\u003e\u003cp\u003eMigrating content between Drupal and Storyblok presents challenges that you, as the implementer, may encounter.\u003c/p\u003e\u003cp\u003eFor example, when dealing with large datasets, you may find that Drupal sites with thousands of nodes can quickly hit the rate limits enforced by Storyblok’s management API. In such cases, a batching mechanism for your requests is worth considering. Instead of processing every node at once, you can process a subset of records, wait for a short period of time, and then continue.\u003c/p\u003e\u003cp\u003eAlternatively, you could use the \u003ccode\u003ecreateBulk\u003c/code\u003e method of the Story API in the Management API, which allows you to handle multiple story creations with built-in rate limit handling and retries. Another potential hurdle is the conversion of complex field types, especially when Drupal’s nested structures or Paragraph fields need to be mapped to Storyblok’s more flexible block-based model.\u003c/p\u003e\u003cp\u003eOne approach is first to analyze the nesting depth and structure of the Drupal content, then flatten deeply nested elements into reusable Storyblok components while maintaining the correct hierarchy. For example, a \u003ccode\u003eparagraph\u003c/code\u003e field with embedded media and text can be split into blocks within Storyblok, with each component representing a logical section of content. By structuring data this way before migration, you ensure that content remains editable and properly structured in the new system.\u003c/p\u003e\u003cp\u003eData consistency is another aspect that you need to manage carefully. When migrating hundreds of records, partial failures are always risky. One approach to managing this is to log detailed information for each migration operation and implement a retry mechanism for failed operations.\u003c/p\u003e\u003cp\u003eFor example, wrapping API calls in a \u003ccode\u003etry-catch\u003c/code\u003e block and logging errors can be a practical way to ensure that no records are silently dropped. When dealing with fields such as taxonomy terms or tags created on the fly in Storyblok, you may run into duplication issues. A good practice is to perform a check before creating a new tag. This could involve maintaining a local cache of previously created tags and checking against them before sending a create request to the API.\u003c/p\u003e\u003cp\u003eThe same goes for images; a check could ensure you don’t upload the same asset twice.\u003c/p\u003e\u003ch2 id=\"lessons-learned-and-looking-forward\"\u003eLessons Learned And Looking Forward\u003c/h2\u003e\u003cp\u003eA \u003cstrong\u003ededicated API client\u003c/strong\u003e for Storyblok streamlined interactions, abstracting backend complexity while improving code maintainability. Early use of \u003cstrong\u003estructured data objects\u003c/strong\u003e to prepare content proved critical, enabling pre-emptive error detection and reducing API failures.\u003c/p\u003e\u003cp\u003eWe also ran into some challenges and see room for improvement:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eEncoding issues\u003c/strong\u003e in rich text (e.g., HTML entities) were resolved with a pre-processing step\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePerformance bottlenecks\u003c/strong\u003e with large text/images required memory optimization and refined request handling\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eEnhancements could include support for \u003cem\u003eDrupal Layout Builder\u003c/em\u003e, advanced validation layers, or dynamic asset management systems.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e💡 For deeper dives into our Management API client or migration strategies, reach out via \u003ca href=\"https://discord.gg/jKrbAMz\"\u003eDiscord\u003c/a\u003e, explore the \u003ca href=\"https://github.com/storyblok/php-management-api-client\"\u003ePHP Client repo\u003c/a\u003e, or connect with me on \u003ca href=\"https://hachyderm.io/@edodusi\"\u003eMastodon\u003c/a\u003e. Feedback and contributions are welcome!\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(il)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-04-02T12:00:00Z",
  "modifiedTime": "2025-04-02T12:00:00Z"
}
