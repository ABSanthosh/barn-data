{
  "id": "99f70c94-a8eb-476f-b40d-dc94859f731c",
  "title": "Integrations: From Simple Data Transfer To Modern Composable Architectures",
  "link": "https://smashingmagazine.com/2025/02/integrations-from-simple-data-transfer-to-composable-architectures/",
  "description": "In today’s web development landscape, the concept of a monolithic application has become increasingly rare. Modern applications are composed of multiple specialized services, each of which handles specific aspects of functionality. This shift didn’t happen overnight - it’s the result of decades of evolution in how we think about and implement data transfer between systems. Let’s explore this journey and see how it shapes modern architectures, particularly in the context of headless CMS solutions.",
  "author": "Edoardo Dusi",
  "published": "Tue, 04 Feb 2025 08:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 13707,
  "excerpt": "In today’s web development landscape, the concept of a monolithic application has become increasingly rare. Modern applications are composed of multiple specialized services, each of which handles specific aspects of functionality. This shift didn’t happen overnight - it’s the result of decades of evolution in how we think about and implement data transfer between systems. Let’s explore this journey and see how it shapes modern architectures, particularly in the context of headless CMS solutions.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "9 min readCoding, Headless, Apps, CMSIn today’s web development landscape, the concept of a monolithic application has become increasingly rare. Modern applications are composed of multiple specialized services, each of which handles specific aspects of functionality. This shift didn’t happen overnight — it’s the result of decades of evolution in how we think about and implement data transfer between systems. Let’s explore this journey and see how it shapes modern architectures, particularly in the context of headless CMS solutions.When computers first started talking to each other, the methods were remarkably simple. In the early days of the Internet, systems exchanged files via FTP or communicated via raw TCP/IP sockets. This direct approach worked well for simple use cases but quickly showed its limitations as applications grew more complex.# Basic socket server example import socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind(('localhost', 12345)) server_socket.listen(1) while True: connection, address = server_socket.accept() data = connection.recv(1024) # Process data connection.send(response) The real breakthrough in enabling complex communication between computers on a network came with the introduction of Remote Procedure Calls (RPC) in the 1980s. RPC allowed developers to call procedures on remote systems as if they were local functions, abstracting away the complexity of network communication. This pattern laid the foundation for many of the modern integration approaches we use today.At its core, RPC implements a client-server model where the client prepares and serializes a procedure call with parameters, sends the message to a remote server, the server deserializes and executes the procedure, and then sends the response back to the client.Here’s a simplified example using Python’s XML-RPC.# Server from xmlrpc.server import SimpleXMLRPCServer def calculate_total(items): return sum(items) server = SimpleXMLRPCServer((\"localhost\", 8000)) server.register_function(calculate_total) server.serve_forever() # Client import xmlrpc.client proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\") try: result = proxy.calculate_total([1, 2, 3, 4, 5]) except ConnectionError: print(\"Network error occurred\") RPC can operate in both synchronous (blocking) and asynchronous modes.Modern implementations such as gRPC support streaming and bi-directional communication. In the example below, we define a gRPC service called Calculator with two RPC methods, Calculate, which takes a Numbers message and returns a Result message, and CalculateStream, which sends a stream of Result messages in response.// protobuf service Calculator { rpc Calculate(Numbers) returns (Result); rpc CalculateStream(Numbers) returns (stream Result); } Modern Integrations: The Rise Of Web Services And SOAThe late 1990s and early 2000s saw the emergence of Web Services and Service-Oriented Architecture (SOA). SOAP (Simple Object Access Protocol) became the standard for enterprise integration, introducing a more structured approach to system communication.\u003c?xml version=\"1.0\"?\u003e \u003csoap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\u003e \u003csoap:Header\u003e \u003c/soap:Header\u003e \u003csoap:Body\u003e \u003cm:GetStockPrice xmlns:m=\"http://www.example.org/stock\"\u003e \u003cm:StockName\u003eIBM\u003c/m:StockName\u003e \u003c/m:GetStockPrice\u003e \u003c/soap:Body\u003e \u003c/soap:Envelope\u003e While SOAP provided robust enterprise features, its complexity, and verbosity led to the development of simpler alternatives, especially the REST APIs that dominate Web services communication today.But REST is not alone. Let’s have a look at some modern integration patterns.RESTful APIsREST (Representational State Transfer) has become the de facto standard for Web APIs, providing a simple, stateless approach to manipulating resources. Its simplicity and HTTP-based nature make it ideal for web applications.First defined by Roy Fielding in 2000 as an architectural style on top of the Web’s standard protocols, its constraints align perfectly with the goals of the modern Web, such as performance, scalability, reliability, and visibility: client and server separated by an interface and loosely coupled, stateless communication, cacheable responses.In modern applications, the most common implementations of the REST protocol are based on the JSON format, which is used to encode messages for requests and responses.// Request async function fetchUserData() { const response = await fetch('https://api.example.com/users/123'); const userData = await response.json(); return userData; } // Response { \"id\": \"123\", \"name\": \"John Doe\", \"_links\": { \"self\": { \"href\": \"/users/123\" }, \"orders\": { \"href\": \"/users/123/orders\" }, \"preferences\": { \"href\": \"/users/123/preferences\" } } } GraphQLGraphQL emerged from Facebook’s internal development needs in 2012 before being open-sourced in 2015. Born out of the challenges of building complex mobile applications, it addressed limitations in traditional REST APIs, particularly the issues of over-fetching and under-fetching data.At its core, GraphQL is a query language and runtime that provides a type system and declarative data fetching, allowing the client to specify exactly what it wants to fetch from the server.// graphql type User { id: ID! name: String! email: String! posts: [Post!]! } type Post { id: ID! title: String! content: String! author: User! publishDate: String! } query GetUserWithPosts { user(id: \"123\") { name posts(last: 3) { title publishDate } } } Often used to build complex UIs with nested data structures, mobile applications, or microservices architectures, it has proven effective at handling complex data requirements at scale and offers a growing ecosystem of tools.WebhooksModern applications often require real-time updates. For example, e-commerce apps need to update inventory levels when a purchase is made, or content management apps need to refresh cached content when a document is edited. Traditional request-response models can struggle to meet these demands because they rely on clients’ polling servers for updates, which is inefficient and resource-intensive.Webhooks and event-driven architectures address these needs more effectively. Webhooks let servers send real-time notifications to clients or other systems when specific events happen. This reduces the need for continuous polling. Event-driven architectures go further by decoupling application components. Services can publish and subscribe to events asynchronously, and this makes the system more scalable, responsive, and simpler.import fastify from 'fastify'; const server = fastify(); server.post('/webhook', async (request, reply) =\u003e { const event = request.body; if (event.type === 'content.published') { await refreshCache(); } return reply.code(200).send(); }); This is a simple Node.js function that uses Fastify to set up a web server. It responds to the endpoint /webhook, checks the type field of the JSON request, and refreshes a cache if the event is of type content.published.With all this background information and technical knowledge, it’s easier to picture the current state of web application development, where a single, monolithic app is no longer the answer to business needs, but a new paradigm has emerged: Composable Architecture.Composable Architecture And Headless CMSsThis evolution has led us to the concept of composable architecture, where applications are built by combining specialized services. This is where headless CMS solutions have a clear advantage, serving as the perfect example of how modern integration patterns come together.Headless CMS platforms separate content management from content presentation, allowing you to build specialized frontends relying on a fully-featured content backend. This decoupling facilitates content reuse, independent scaling, and the flexibility to use a dedicated technology or service for each part of the system.Take Storyblok as an example. Storyblok is a headless CMS designed to help developers build flexible, scalable, and composable applications. Content is exposed via API, REST, or GraphQL; it offers a long list of events that can trigger a webhook. Editors are happy with a great Visual Editor, where they can see changes in real time, and many integrations are available out-of-the-box via a marketplace.Imagine this ContentDeliveryService in your app, where you can interact with Storyblok’s REST API using the open source JS Client:import StoryblokClient from \"storyblok-js-client\"; class ContentDeliveryService { constructor(private storyblok: StoryblokClient) {} async getPageContent(slug: string) { const { data } = await this.storyblok.get(`cdn/stories/${slug}`, { version: 'published', resolve_relations: 'featured-products.products' }); return data.story; } async getRelatedContent(tags: string[]) { const { data } = await this.storyblok.get('cdn/stories', { version: 'published', with_tag: tags.join(',') }); return data.stories; } } The last piece of the puzzle is a real example of integration.Again, many are already available in the Storyblok marketplace, and you can easily control them from the dashboard. However, to fully leverage the Composable Architecture, we can use the most powerful tool in the developer’s hand: code.Let’s imagine a modern e-commerce platform that uses Storyblok as its content hub, Shopify for inventory and orders, Algolia for product search, and Stripe for payments.Once each account is set up and we have our access tokens, we could quickly build a front-end page for our store. This isn’t production-ready code, but just to get a quick idea, let’s use React to build the page for a single product that integrates our services.First, we should initialize our clients:import StoryblokClient from \"storyblok-js-client\"; import { algoliasearch } from \"algoliasearch\"; import Client from \"shopify-buy\"; const storyblok = new StoryblokClient({ accessToken: \"your_storyblok_token\", }); const algoliaClient = algoliasearch( \"your_algolia_app_id\", \"your_algolia_api_key\", ); const shopifyClient = Client.buildClient({ domain: \"your-shopify-store.myshopify.com\", storefrontAccessToken: \"your_storefront_access_token\", }); Given that we created a blok in Storyblok that holds product information such as the product_id, we could write a component that takes the productSlug, fetches the product content from Storyblok, the inventory data from Shopify, and some related products from the Algolia index:async function fetchProduct() { // get product from Storyblok const { data } = await storyblok.get(`cdn/stories/${productSlug}`); // fetch inventory from Shopify const shopifyInventory = await shopifyClient.product.fetch( data.story.content.product_id ); // fetch related products using Algolia const { hits } = await algoliaIndex.search(\"products\", { filters: `category:${data.story.content.category}`, }); } We could then set a simple component state:const [productData, setProductData] = useState(null); const [inventory, setInventory] = useState(null); const [relatedProducts, setRelatedProducts] = useState([]); useEffect(() =\u003e // ... // combine fetchProduct() with setState to update the state // ... fetchProduct(); }, [productSlug]); And return a template with all our data:\u003ch1\u003e{productData.content.title}\u003c/h1\u003e \u003cp\u003e{productData.content.description}\u003c/p\u003e \u003ch2\u003ePrice: ${inventory.variants[0].price}\u003c/h2\u003e \u003ch3\u003eRelated Products\u003c/h3\u003e \u003cul\u003e {relatedProducts.map((product) =\u003e ( \u003cli key={product.objectID}\u003e{product.name}\u003c/li\u003e ))} \u003c/ul\u003e We could then use an event-driven approach and create a server that listens to our shop events and processes the checkout with Stripe (credits to Manuel Spigolon for this tutorial):const stripe = require('stripe') module.exports = async function plugin (app, opts) { const stripeClient = stripe(app.config.STRIPE_PRIVATE_KEY) server.post('/create-checkout-session', async (request, reply) =\u003e { const session = await stripeClient.checkout.sessions.create({ line_items: [...], // from request.body mode: 'payment', success_url: \"https://your-site.com/success\", cancel_url: \"https://your-site.com/cancel\", }) return reply.redirect(303, session.url) }) // ... And with this approach, each service is independent of the others, which helps us achieve our business goals (performance, scalability, flexibility) with a good developer experience and a smaller and simpler application that’s easier to maintain.ConclusionThe integration between headless CMSs and modern web services represents the current and future state of high-performance web applications. By using specialized, decoupled services, developers can focus on business logic and user experience. A composable ecosystem is not only modular but also resilient to the evolving needs of the modern enterprise.These integrations highlight the importance of mastering API-driven architectures and understanding how different tools can harmoniously fit into a larger tech stack.In today’s digital landscape, success lies in choosing tools that offer flexibility and efficiency, adapt to evolving demands, and create applications that are future-proof against the challenges of tomorrow.If you want to dive deeper into the integrations you can build with Storyblok and other services, check out Storyblok’s integrations page. You can also take your projects further by creating your own plugins with Storyblok’s plugin development resources. (yk)",
  "image": "https://files.smashing.media/articles/integrations-from-simple-data-transfer-to-composable-architectures/integrations-from-simple-data-transfer-to-composable-architectures.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e9 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/headless\"\u003eHeadless\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/apps\"\u003eApps\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/cms\"\u003eCMS\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eIn today’s web development landscape, the concept of a monolithic application has become increasingly rare. Modern applications are composed of multiple specialized services, each of which handles specific aspects of functionality. This shift didn’t happen overnight — it’s the result of decades of evolution in how we think about and implement data transfer between systems. Let’s explore this journey and see how it shapes modern architectures, particularly in the context of headless CMS solutions.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eWhen computers first started talking to each other, the methods were remarkably simple. In the early days of the Internet, systems exchanged files via FTP or communicated via raw TCP/IP sockets. This direct approach worked well for simple use cases but quickly showed its limitations as applications grew more complex.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e# Basic socket server example\nimport socket\n\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind((\u0026#39;localhost\u0026#39;, 12345))\nserver_socket.listen(1)\n\nwhile True:\n    connection, address = server_socket.accept()\n    data = connection.recv(1024)\n    # Process data\n    connection.send(response)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe real breakthrough in enabling complex communication between computers on a network came with the introduction of \u003cstrong\u003eRemote Procedure Calls (RPC)\u003c/strong\u003e in the 1980s. RPC allowed developers to call procedures on remote systems as if they were local functions, abstracting away the complexity of network communication. This pattern laid the foundation for many of the modern integration approaches we use today.\u003c/p\u003e\u003cblockquote\u003eAt its core, RPC implements a client-server model where the client prepares and serializes a procedure call with parameters, sends the message to a remote server, the server deserializes and executes the procedure, and then sends the response back to the client.\u003c/blockquote\u003e\u003cp\u003eHere’s a simplified example using Python’s XML-RPC.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e# Server\nfrom xmlrpc.server import SimpleXMLRPCServer\n\ndef calculate_total(items):\n    return sum(items)\n\nserver = SimpleXMLRPCServer((\u0026#34;localhost\u0026#34;, 8000))\nserver.register_function(calculate_total)\nserver.serve_forever()\n\n# Client\nimport xmlrpc.client\n\nproxy = xmlrpc.client.ServerProxy(\u0026#34;http://localhost:8000/\u0026#34;)\ntry:\n    result = proxy.calculate_total([1, 2, 3, 4, 5])\nexcept ConnectionError:\n    print(\u0026#34;Network error occurred\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRPC can operate in both synchronous (blocking) and asynchronous modes.\u003c/p\u003e\u003cp\u003eModern implementations such as gRPC support streaming and bi-directional communication. In the example below, we define a gRPC service called \u003ccode\u003eCalculator\u003c/code\u003e with two RPC methods, \u003ccode\u003eCalculate\u003c/code\u003e, which takes a \u003ccode\u003eNumbers\u003c/code\u003e message and returns a \u003ccode\u003eResult\u003c/code\u003e message, and \u003ccode\u003eCalculateStream\u003c/code\u003e, which sends a stream of \u003ccode\u003eResult\u003c/code\u003e messages in response.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// protobuf\nservice Calculator {\n  rpc Calculate(Numbers) returns (Result);\n  rpc CalculateStream(Numbers) returns (stream Result);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"modern-integrations-the-rise-of-web-services-and-soa\"\u003eModern Integrations: The Rise Of Web Services And SOA\u003c/h2\u003e\u003cp\u003eThe late 1990s and early 2000s saw the emergence of \u003cstrong\u003eWeb Services\u003c/strong\u003e and \u003cstrong\u003eService-Oriented Architecture (SOA)\u003c/strong\u003e. SOAP (Simple Object Access Protocol) became the standard for enterprise integration, introducing a more structured approach to system communication.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt;\n\u0026lt;soap:Envelope xmlns:soap=\u0026#34;http://www.w3.org/2003/05/soap-envelope\u0026#34;\u0026gt;\n  \u0026lt;soap:Header\u0026gt;\n  \u0026lt;/soap:Header\u0026gt;\n  \u0026lt;soap:Body\u0026gt;\n    \u0026lt;m:GetStockPrice xmlns:m=\u0026#34;http://www.example.org/stock\u0026#34;\u0026gt;\n      \u0026lt;m:StockName\u0026gt;IBM\u0026lt;/m:StockName\u0026gt;\n    \u0026lt;/m:GetStockPrice\u0026gt;\n  \u0026lt;/soap:Body\u0026gt;\n\u0026lt;/soap:Envelope\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhile SOAP provided robust enterprise features, its complexity, and verbosity led to the development of simpler alternatives, especially the REST APIs that dominate Web services communication today.\u003c/p\u003e\u003cp\u003eBut REST is not alone. Let’s have a look at some modern integration patterns.\u003c/p\u003e\u003ch3 id=\"restful-apis\"\u003eRESTful APIs\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eREST (Representational State Transfer)\u003c/strong\u003e has become the de facto standard for Web APIs, providing a simple, stateless approach to manipulating resources. Its simplicity and HTTP-based nature make it ideal for web applications.\u003c/p\u003e\u003cp\u003eFirst defined by Roy Fielding in 2000 as an architectural style on top of the Web’s standard protocols, its constraints align perfectly with the goals of the modern Web, such as \u003cstrong\u003eperformance\u003c/strong\u003e, \u003cstrong\u003escalability\u003c/strong\u003e, \u003cstrong\u003ereliability\u003c/strong\u003e, and \u003cstrong\u003evisibility\u003c/strong\u003e: client and server separated by an interface and loosely coupled, stateless communication, cacheable responses.\u003c/p\u003e\u003cp\u003eIn modern applications, the most common implementations of the REST protocol are based on the JSON format, which is used to encode messages for requests and responses.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// Request\nasync function fetchUserData() {\n  const response = await fetch(\u0026#39;https://api.example.com/users/123\u0026#39;);\n  const userData = await response.json();\n  return userData;\n}\n\n// Response\n{\n  \u0026#34;id\u0026#34;: \u0026#34;123\u0026#34;,\n  \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;,\n  \u0026#34;_links\u0026#34;: {\n    \u0026#34;self\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;/users/123\u0026#34; },\n    \u0026#34;orders\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;/users/123/orders\u0026#34; },\n    \u0026#34;preferences\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;/users/123/preferences\u0026#34; }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"graphql\"\u003eGraphQL\u003c/h3\u003e\u003cp\u003eGraphQL emerged from Facebook’s internal development needs in 2012 before being open-sourced in 2015. Born out of the challenges of building complex mobile applications, it addressed limitations in traditional REST APIs, particularly the issues of over-fetching and under-fetching data.\u003c/p\u003e\u003cp\u003eAt its core, GraphQL is a query language and runtime that provides a type system and declarative data fetching, allowing the client to specify exactly what it wants to fetch from the server.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// graphql\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  publishDate: String!\n}\n\nquery GetUserWithPosts {\n  user(id: \u0026#34;123\u0026#34;) {\n    name\n    posts(last: 3) {\n      title\n      publishDate\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOften used to build complex UIs with nested data structures, mobile applications, or microservices architectures, it has proven effective at handling complex data requirements at scale and offers a growing ecosystem of tools.\u003c/p\u003e\u003ch3 id=\"webhooks\"\u003eWebhooks\u003c/h3\u003e\u003cp\u003eModern applications often require real-time updates. For example, e-commerce apps need to update inventory levels when a purchase is made, or content management apps need to refresh cached content when a document is edited. Traditional request-response models can struggle to meet these demands because they rely on clients’ polling servers for updates, which is inefficient and resource-intensive.\u003c/p\u003e\u003cp\u003eWebhooks and event-driven architectures address these needs more effectively. Webhooks let servers send real-time notifications to clients or other systems when specific events happen. This reduces the need for continuous polling. Event-driven architectures go further by decoupling application components. Services can publish and subscribe to events asynchronously, and this makes the system more scalable, responsive, and simpler.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport fastify from \u0026#39;fastify\u0026#39;;\n\nconst server = fastify();\nserver.post(\u0026#39;/webhook\u0026#39;, async (request, reply) =\u0026gt; {\n  const event = request.body;\n  \n  if (event.type === \u0026#39;content.published\u0026#39;) {\n    await refreshCache();\n  }\n  \n  return reply.code(200).send();\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is a simple Node.js function that uses Fastify to set up a web server. It responds to the endpoint \u003ccode\u003e/webhook\u003c/code\u003e, checks the \u003ccode\u003etype\u003c/code\u003e field of the JSON request, and refreshes a cache if the event is of type \u003ccode\u003econtent.published\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWith all this background information and technical knowledge, it’s easier to picture the current state of web application development, where \u003cstrong\u003ea single, monolithic app is no longer the answer to business needs\u003c/strong\u003e, but a new paradigm has emerged: Composable Architecture.\u003c/p\u003e\u003ch2 id=\"composable-architecture-and-headless-cmss\"\u003eComposable Architecture And Headless CMSs\u003c/h2\u003e\u003cp\u003eThis evolution has led us to the concept of composable architecture, where applications are built by \u003cstrong\u003ecombining specialized services\u003c/strong\u003e. This is where headless CMS solutions have a clear advantage, serving as the perfect example of how modern integration patterns come together.\u003c/p\u003e\u003cp\u003eHeadless CMS platforms separate content management from content presentation, allowing you to build specialized frontends relying on a fully-featured content backend. This decoupling facilitates \u003cstrong\u003econtent reuse\u003c/strong\u003e, \u003cstrong\u003eindependent scaling\u003c/strong\u003e, and the \u003cstrong\u003eflexibility\u003c/strong\u003e to use a dedicated technology or service for each part of the system.\u003c/p\u003e\u003cp\u003eTake \u003ca href=\"https://www.storyblok.com/?utm_source=smashing\u0026amp;utm_medium=sponsor\u0026amp;utm_campaign=DGM_DEV_SMA_TRA\u0026amp;utm_content=smashing-OSS\"\u003eStoryblok\u003c/a\u003e as an example. Storyblok is a headless CMS designed to help developers build flexible, scalable, and composable applications. Content is exposed via API, REST, or GraphQL; it offers a long list of events that can trigger a webhook. Editors are happy with a great Visual Editor, where they can see changes in real time, and many integrations are available out-of-the-box via a marketplace.\u003c/p\u003e\u003cp\u003eImagine this \u003ccode\u003eContentDeliveryService\u003c/code\u003e in your app, where you can interact with Storyblok’s REST API using the \u003ca href=\"https://github.com/storyblok/storyblok-js-client\"\u003eopen source JS Client\u003c/a\u003e:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eimport StoryblokClient from \u0026#34;storyblok-js-client\u0026#34;;\n\nclass ContentDeliveryService {\n  constructor(private storyblok: StoryblokClient) {}\n\n  async getPageContent(slug: string) {\n    const { data } = await this.storyblok.get(`cdn/stories/${slug}`, {\n      version: \u0026#39;published\u0026#39;,\n      resolve_relations: \u0026#39;featured-products.products\u0026#39;\n    });\n\n    return data.story;\n  }\n\n  async getRelatedContent(tags: string[]) {\n    const { data } = await this.storyblok.get(\u0026#39;cdn/stories\u0026#39;, {\n      version: \u0026#39;published\u0026#39;,\n      with_tag: tags.join(\u0026#39;,\u0026#39;)\n    });\n\n    return data.stories;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe last piece of the puzzle is a real example of integration.\u003c/p\u003e\u003cp\u003eAgain, many are already available in the Storyblok marketplace, and you can easily control them from the dashboard. However, to fully leverage the Composable Architecture, we can use the most powerful tool in the developer’s hand: code.\u003c/p\u003e\u003cp\u003eLet’s imagine a modern e-commerce platform that uses Storyblok as its content hub, Shopify for inventory and orders, Algolia for product search, and Stripe for payments.\u003c/p\u003e\u003cp\u003eOnce each account is set up and we have our access tokens, we could quickly build a front-end page for our store. This isn’t production-ready code, but just to get a quick idea, let’s use React to build the page for a single product that integrates our services.\u003c/p\u003e\u003cp\u003eFirst, we should initialize our clients:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport StoryblokClient from \u0026#34;storyblok-js-client\u0026#34;;\nimport { algoliasearch } from \u0026#34;algoliasearch\u0026#34;;\nimport Client from \u0026#34;shopify-buy\u0026#34;;\n\n\nconst storyblok = new StoryblokClient({\n  accessToken: \u0026#34;your_storyblok_token\u0026#34;,\n});\nconst algoliaClient = algoliasearch(\n  \u0026#34;your_algolia_app_id\u0026#34;,\n  \u0026#34;your_algolia_api_key\u0026#34;,\n);\nconst shopifyClient = Client.buildClient({\n  domain: \u0026#34;your-shopify-store.myshopify.com\u0026#34;,\n  storefrontAccessToken: \u0026#34;your_storefront_access_token\u0026#34;,\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGiven that we created a \u003ccode\u003eblok\u003c/code\u003e in Storyblok that holds product information such as the \u003ccode\u003eproduct_id\u003c/code\u003e, we could write a component that takes the \u003ccode\u003eproductSlug\u003c/code\u003e, fetches the product content from Storyblok, the inventory data from Shopify, and some related products from the Algolia index:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003easync function fetchProduct() {\n  // get product from Storyblok\n  const { data } = await storyblok.get(`cdn/stories/${productSlug}`);\n\n  // fetch inventory from Shopify\n  const shopifyInventory = await shopifyClient.product.fetch(\n    data.story.content.product_id\n  );\n\n  // fetch related products using Algolia\n  const { hits } = await algoliaIndex.search(\u0026#34;products\u0026#34;, {\n    filters: `category:${data.story.content.category}`,\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe could then set a simple component state:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst [productData, setProductData] = useState(null);\nconst [inventory, setInventory] = useState(null);\nconst [relatedProducts, setRelatedProducts] = useState([]);\n\nuseEffect(() =\u0026gt;\n  // ...\n  // combine fetchProduct() with setState to update the state\n  // ...\n\n  fetchProduct();\n}, [productSlug]);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd return a template with all our data:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;h1\u0026gt;{productData.content.title}\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;{productData.content.description}\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Price: ${inventory.variants[0].price}\u0026lt;/h2\u0026gt;\n\u0026lt;h3\u0026gt;Related Products\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n  {relatedProducts.map((product) =\u0026gt; (\n    \u0026lt;li key={product.objectID}\u0026gt;{product.name}\u0026lt;/li\u0026gt;\n  ))}\n\u0026lt;/ul\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe could then use an event-driven approach and create a server that listens to our shop events and processes the checkout with Stripe (credits to Manuel Spigolon for \u003ca href=\"https://backend.cafe/integrate-stripe-with-fastify\"\u003ethis tutorial\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst stripe = require(\u0026#39;stripe\u0026#39;)\n\nmodule.exports = async function plugin (app, opts) {\n  const stripeClient = stripe(app.config.STRIPE_PRIVATE_KEY)\n\n  server.post(\u0026#39;/create-checkout-session\u0026#39;, async (request, reply) =\u0026gt; {\n    const session = await stripeClient.checkout.sessions.create({\n      line_items: [...], // from request.body\n      mode: \u0026#39;payment\u0026#39;,\n      success_url: \u0026#34;https://your-site.com/success\u0026#34;,\n      cancel_url: \u0026#34;https://your-site.com/cancel\u0026#34;,\n    })\n\n    return reply.redirect(303, session.url)\n  })\n// ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAnd with this approach, each service is independent of the others, which helps us achieve our business goals (performance, scalability, flexibility) with a good developer experience and a smaller and simpler application that’s easier to maintain.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eThe integration between headless CMSs and modern web services represents the current and future state of high-performance web applications. By using specialized, decoupled services, developers can focus on business logic and user experience. A composable ecosystem is not only modular but also resilient to the evolving needs of the modern enterprise.\u003c/p\u003e\u003cp\u003eThese integrations highlight the importance of mastering API-driven architectures and understanding how different tools can harmoniously fit into a larger tech stack.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aIn%20today%e2%80%99s%20digital%20landscape,%20success%20lies%20in%20choosing%20tools%20that%20offer%20flexibility%20and%20efficiency,%20adapt%20to%20evolving%20demands,%20and%20create%20applications%20that%20are%20future-proof%20against%20the%20challenges%20of%20tomorrow.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f02%2fintegrations-from-simple-data-transfer-to-composable-architectures%2f\"\u003eIn today’s digital landscape, success lies in choosing tools that offer flexibility and efficiency, adapt to evolving demands, and create applications that are future-proof against the challenges of tomorrow.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eIf you want to dive deeper into the integrations you can build with Storyblok and other services, check out \u003ca href=\"https://www.storyblok.com/ecosystem/?utm_source=smashing\u0026amp;utm_medium=sponsor\u0026amp;utm_campaign=DGM_DEV_SMA_TRA\u0026amp;utm_content=smashing-OSS\"\u003eStoryblok’s integrations page\u003c/a\u003e. You can also take your projects further by creating your own plugins with \u003ca href=\"https://www.storyblok.com/docs/plugins/field-plugins/introduction/?utm_source=smashing\u0026amp;utm_medium=sponsor\u0026amp;utm_campaign=DGM_DEV_SMA_TRA\u0026amp;utm_content=smashing-OSS\"\u003eStoryblok’s plugin development\u003c/a\u003e resources.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-02-04T08:00:00Z",
  "modifiedTime": "2025-02-04T08:00:00Z"
}
