{
  "id": "aa8ae2e4-9dc5-480f-9301-60766b82155b",
  "title": "Build A Static RSS Reader To Fight Your Inner FOMO",
  "link": "https://smashingmagazine.com/2024/10/build-static-rss-reader-fight-fomo/",
  "description": "RSS is a classic technology that fetches content from websites and feeds it to anyone who subscribes to it with a URL. It’s based on XML, and we can use it to consume the feeds in our own apps. Karin Hendrikse demonstrates how to do exactly that with a static site you can use as your personal RSS reader.",
  "author": "Karin Hendrikse",
  "published": "Mon, 07 Oct 2024 13:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 12605,
  "excerpt": "RSS is a classic technology that fetches content from websites and feeds it to anyone who subscribes to it with a URL. It’s based on XML, and we can use it to consume the feeds in our own apps. Karin Hendrikse demonstrates how to do exactly that with a static site you can use as your personal RSS reader.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "10 min readRSS, JavaScript, TechniquesRSS is a classic technology that fetches content from websites and feeds it to anyone who subscribes to it with a URL. It’s based on XML, and we can use it to consume the feeds in our own apps. Karin Hendrikse demonstrates how to do exactly that with a static site you can use as your personal RSS reader.In a fast-paced industry like tech, it can be hard to deal with the fear of missing out on important news. But, as many of us know, there’s an absolutely huge amount of information coming in daily, and finding the right time and balance to keep up can be difficult, if not stressful. A classic piece of technology like an RSS feed is a delightful way of taking back ownership of our own time. In this article, we will create a static Really Simple Syndication (RSS) reader that will bring you the latest curated news only once (yes: once) a day.We’ll obviously work with RSS technology in the process, but we’re also going to combine it with some things that maybe you haven’t tried before, including Astro (the static site framework), TypeScript (for JavaScript goodies), a package called rss-parser (for connecting things together), as well as scheduled functions and build hooks provided by Netlify (although there are other services that do this).I chose these technologies purely because I really, really enjoy them! There may be other solutions out there that are more performant, come with more features, or are simply more comfortable to you — and in those cases, I encourage you to swap in whatever you’d like. The most important thing is getting the end result!The PlanHere’s how this will go. Astro generates the website. I made the intentional decision to use a static site because I want the different RSS feeds to be fetched only once during build time, and that’s something we can control each time the site is “rebuilt” and redeployed with updates. That’s where Netlify’s scheduled functions come into play, as they let us trigger rebuilds automatically at specific times. There is no need to manually check for updates and deploy them! Cron jobs can just as readily do this if you prefer a server-side solution.During the triggered rebuild, we’ll let the rss-parser package do exactly what it says it does: parse a list of RSS feeds that are contained in an array. The package also allows us to set a filter for the fetched results so that we only get ones from the past day, week, and so on. Personally, I only render the news from the last seven days to prevent content overload. We’ll get there!But first…RSS is a web feed technology that you can feed into a reader or news aggregator. Because RSS is standardized, you know what to expect when it comes to the feed’s format. That means we have a ton of fun possibilities when it comes to handling the data that the feed provides. Most news websites have their own RSS feed that you can subscribe to (this is Smashing Magazine’s RSS feed: https://www.smashingmagazine.com/feed/). An RSS feed is capable of updating every time a site publishes new content, which means it can be a quick source of the latest news, but we can tailor that frequency as well.RSS feeds are written in an Extensible Markup Language (XML) format and have specific elements that can be used within it. Instead of focusing too much on the technicalities here, I’ll give you a link to the RSS specification. Don’t worry; that page should be scannable enough for you to find the most pertinent information you need, like the kinds of elements that are supported and what they represent. For this tutorial, we’re only using the following elements: \u003ctitle\u003e, \u003clink\u003e, \u003cdescription\u003e, \u003citem\u003e, and \u003cpubDate\u003e. We’ll also let our RSS parser package do some of the work for us.Creating The State SiteWe’ll start by creating our Astro site! In your terminal run pnpm create astro@latest. You can use any package manager you want — I’m simply trying out pnpm for myself.After running the command, Astro’s chat-based helper, Houston, walks through some setup questions to get things started. astro Launch sequence initiated. dir Where should we create your new project? ./rss-buddy tmpl How would you like to start your new project? Include sample files ts Do you plan to write TypeScript? Yes use How strict should TypeScript be? Strict deps Install dependencies? Yes git Initialize a new git repository? Yes I like to use Astro’s sample files so I can get started quickly, but we’re going to clean them up a bit in the process. Let’s clean up the src/pages/index.astro file by removing everything inside of the \u003cmain\u003e\u003c/main\u003e tags. Then we’re good to go!From there, we can spin things by running pnpm start. Your terminal will tell you which localhost address you can find your site at.The src/pages/index.astro file is where we will make an array of RSS feeds we want to follow. We will be using Astro’s template syntax, so between the two code fences (—), create an array of feedSources and add some feeds. If you need inspiration, you can copy this:const feedSources = [ 'https://www.smashingmagazine.com/feed/', 'https://developer.mozilla.org/en-US/blog/rss.xml', // etc. ] Now we’ll install the rss-parser package in our project by running pnpm install rss-parser. This package is a small library that turns the XML that we get from fetching an RSS feed into JavaScript objects. This makes it easy for us to read our RSS feeds and manipulate the data any way we want.Once the package is installed, open the src/pages/index.astro file, and at the top, we’ll import the rss-parser and instantiate the Partner class.import Parser from 'rss-parser'; const parser = new Parser(); We use this parser to read our RSS feeds and (surprise!) parse them to JavaScript. We’re going to be dealing with a list of promises here. Normally, I would probably use Promise.all(), but the thing is, this is supposed to be a complicated experience. If one of the feeds doesn’t work for some reason, I’d prefer to simply ignore it.Why? Well, because Promise.all() rejects everything even if only one of its promises is rejected. That might mean that if one feed doesn’t behave the way I’d expect it to, my entire page would be blank when I grab my hot beverage to read the news in the morning. I do not want to start my day confronted by an error.Instead, I’ll opt to use Promise.allSettled(). This method will actually let all promises complete even if one of them fails. In our case, this means any feed that errors will just be ignored, which is perfect.Let’s add this to the src/pages/index.astro file:interface FeedItem { feed?: string; title?: string; link?: string; date?: Date; } const feedItems: FeedItem[] = []; await Promise.allSettled( feedSources.map(async (source) =\u003e { try { const feed = await parser.parseURL(source); feed.items.forEach((item) =\u003e { const date = item.pubDate ? new Date(item.pubDate) : undefined; feedItems.push({ feed: feed.title, title: item.title, link: item.link, date, }); }); } catch (error) { console.error(`Error fetching feed from ${source}:`, error); } }) ); This creates an array (or more) named feedItems. For each URL in the feedSources array we created earlier, the rss-parser retrieves the items and, yes, parses them into JavaScript. Then, we return whatever data we want! We’ll keep it simple for now and only return the following:The feed title,The title of the feed item,The link to the item,And the item’s published date.The next step is to ensure that all items are sorted by date so we’ll truly get the “latest” news. Add this small piece of code to our work:const sortedFeedItems = feedItems.sort((a, b) =\u003e (b.date ?? new Date()).getTime() - (a.date ?? new Date()).getTime()); Oh, and… remember when I said I didn’t want this RSS reader to render anything older than seven days? Let’s tackle that right now since we’re already in this code.We’ll make a new variable called sevenDaysAgo and assign it a date. We’ll then set that date to seven days ago and use that logic before we add a new item to our feedItems array.This is what the src/pages/index.astro file should now look like at this point:--- import Layout from '../layouts/Layout.astro'; import Parser from 'rss-parser'; const parser = new Parser(); const sevenDaysAgo = new Date(); sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7); const feedSources = [ 'https://www.smashingmagazine.com/feed/', 'https://developer.mozilla.org/en-US/blog/rss.xml', ] interface FeedItem { feed?: string; title?: string; link?: string; date?: Date; } const feedItems: FeedItem[] = []; await Promise.allSettled( feedSources.map(async (source) =\u003e { try { const feed = await parser.parseURL(source); feed.items.forEach((item) =\u003e { const date = item.pubDate ? new Date(item.pubDate) : undefined; if (date \u0026\u0026 date \u003e= sevenDaysAgo) { feedItems.push({ feed: feed.title, title: item.title, link: item.link, date, }); } }); } catch (error) { console.error(`Error fetching feed from ${source}:`, error); } }) ); const sortedFeedItems = feedItems.sort((a, b) =\u003e (b.date ?? new Date()).getTime() - (a.date ?? new Date()).getTime()); --- \u003cLayout title=\"Welcome to Astro.\"\u003e \u003cmain\u003e \u003c/main\u003e \u003c/Layout\u003e Rendering XML DataIt’s time to show our news articles on the Astro site! To keep this simple, we’ll format the items in an unordered list rather than some other fancy layout.All we need to do is update the \u003cLayout\u003e element in the file with the XML objects sprinkled in for a feed item’s title, URL, and publish date.\u003cLayout title=\"Welcome to Astro.\"\u003e \u003cmain\u003e {sortedFeedItems.map(item =\u003e ( \u003cul\u003e \u003cli\u003e \u003ca href={item.link}\u003e{item.title}\u003c/a\u003e \u003cp\u003e{item.feed}\u003c/p\u003e \u003cp\u003e{item.date}\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e ))} \u003c/main\u003e \u003c/Layout\u003e Go ahead and run pnpm start from the terminal. The page should display an unordered list of feed items. Of course, everything is styled at the moment, but luckily for you, you can make it look exactly like you want with CSS!And remember that there are even more fields available in the XML for each item if you want to display more information. If you run the following snippet in your DevTools console, you’ll see all of the fields you have at your disposal:feed.items.forEach(item =\u003e {} Scheduling Daily Static Site BuildsWe’re nearly done! The feeds are being fetched, and they are returning data back to us in JavaScript for use in our Astro page template. Since feeds are updated whenever new content is published, we need a way to fetch the latest items from it.We want to avoid doing any of this manually. So, let’s set this site on Netlify to gain access to their scheduled functions that trigger a rebuild and their build hooks that do the building. Again, other services do this, and you’re welcome to roll this work with another provider — I’m just partial to Netlify since I work there. In any case, you can follow Netlify’s documentation for setting up a new site.Once your site is hosted and live, you are ready to schedule your rebuilds. A build hook gives you a URL to use to trigger the new build, looking something like this:https://api.netlify.com/build_hooks/your-build-hook-id Let’s trigger builds every day at midnight. We’ll use Netlify’s scheduled functions. That’s really why I’m using Netlify to host this in the first place. Having them at the ready via the host greatly simplifies things since there’s no server work or complicated configurations to get this going. Set it and forget it!We’ll install @netlify/functions (instructions) to the project and then create the following file in the project’s root directory: netlify/functions/deploy.ts.This is what we want to add to that file:// netlify/functions/deploy.ts import type { Config } from '@netlify/functions'; const BUILD_HOOK = 'https://api.netlify.com/build_hooks/your-build-hook-id'; // replace me! export default async (req: Request) =\u003e { await fetch(BUILD_HOOK, { method: 'POST', }) }; export const config: Config = { schedule: '0 0 * * *', }; If you commit your code and push it, your site should re-deploy automatically. From that point on, it follows a schedule that rebuilds the site every day at midnight, ready for you to take your morning brew and catch up on everything that you think is important. (gg, yk)",
  "image": "https://files.smashing.media/articles/build-static-rss-reader-fight-fomo/build-static-rss-reader-fight-fomo.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e10 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/rss\"\u003eRSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/javascript\"\u003eJavaScript\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eRSS is a classic technology that fetches content from websites and feeds it to anyone who subscribes to it with a URL. It’s based on XML, and we can use it to consume the feeds in our own apps. Karin Hendrikse demonstrates how to do exactly that with a static site you can use as your personal RSS reader.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eIn a fast-paced industry like tech, it can be hard to deal with the fear of missing out on important news. But, as many of us know, there’s an absolutely huge amount of information coming in daily, and finding the right time and balance to keep up can be difficult, if not stressful. A classic piece of technology like \u003cstrong\u003ean RSS feed is a delightful way of taking back ownership of our own time\u003c/strong\u003e. In this article, we will create a static Really Simple Syndication (RSS) reader that will bring you the latest curated news only once (yes: \u003cem\u003eonce\u003c/em\u003e) a day.\u003c/p\u003e\u003cp\u003eWe’ll obviously work with RSS technology in the process, but we’re also going to combine it with some things that maybe you haven’t tried before, including \u003cstrong\u003eAstro\u003c/strong\u003e (the static site framework), \u003cstrong\u003eTypeScript\u003c/strong\u003e (for JavaScript goodies), a package called \u003cstrong\u003erss-parser\u003c/strong\u003e (for connecting things together), as well as \u003cstrong\u003escheduled functions\u003c/strong\u003e and \u003cstrong\u003ebuild hooks\u003c/strong\u003e provided by Netlify (although there are other services that do this).\u003c/p\u003e\u003cp\u003eI chose these technologies purely because I really, really enjoy them! There may be other solutions out there that are more performant, come with more features, or are simply more comfortable to you — and in those cases, I encourage you to swap in whatever you’d like. The most important thing is getting the end result!\u003c/p\u003e\u003ch2 id=\"the-plan\"\u003eThe Plan\u003c/h2\u003e\u003cp\u003eHere’s how this will go. Astro generates the website. I made the intentional decision to use a static site because I want the different RSS feeds to be fetched only once during build time, and that’s something we can control each time the site is “rebuilt” and redeployed with updates. That’s where Netlify’s scheduled functions come into play, as they let us trigger rebuilds automatically at specific times. There is no need to manually check for updates and deploy them! Cron jobs can just as readily do this if you prefer a server-side solution.\u003c/p\u003e\u003cp\u003eDuring the triggered rebuild, we’ll let the rss-parser package do exactly what it says it does: parse a list of RSS feeds that are contained in an array. The package also allows us to set a filter for the fetched results so that we only get ones from the past day, week, and so on. Personally, I only render the news from the last seven days to prevent content overload. We’ll get there!\u003c/p\u003e\u003cp\u003eBut first…\u003c/p\u003e\u003cp\u003eRSS is a web feed technology that you can feed into a reader or news aggregator. Because RSS is standardized, you know what to expect when it comes to the feed’s format. That means we have a ton of fun possibilities when it comes to handling the data that the feed provides. Most news websites have their own RSS feed that you can subscribe to (this is \u003cstrong\u003eSmashing Magazine’s RSS feed\u003c/strong\u003e: \u003ca href=\"https://www.smashingmagazine.com/feed/\"\u003ehttps://www.smashingmagazine.com/feed/\u003c/a\u003e). An RSS feed is capable of updating every time a site publishes new content, which means it can be a quick source of the latest news, but we can tailor that frequency as well.\u003c/p\u003e\u003cp\u003eRSS feeds are written in an Extensible Markup Language (XML) format and have specific elements that can be used within it. Instead of focusing too much on the technicalities here, I’ll give you a link to the \u003ca href=\"https://www.rssboard.org/rss-specification\"\u003eRSS specification\u003c/a\u003e. Don’t worry; that page should be scannable enough for you to find the most pertinent information you need, like the kinds of elements that are supported and what they represent. For this tutorial, we’re only using the following elements: \u003cstrong\u003e\u003ccode\u003e\u0026lt;title\u0026gt;\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e\u0026lt;description\u0026gt;\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003e\u0026lt;item\u0026gt;\u003c/code\u003e\u003c/strong\u003e, and \u003cstrong\u003e\u003ccode\u003e\u0026lt;pubDate\u0026gt;\u003c/code\u003e\u003c/strong\u003e. We’ll also let our RSS parser package do some of the work for us.\u003c/p\u003e\u003ch2 id=\"creating-the-state-site\"\u003eCreating The State Site\u003c/h2\u003e\u003cp\u003eWe’ll start by creating our Astro site! In your terminal run \u003ccode\u003epnpm create astro@latest\u003c/code\u003e. You can use any package manager you want — I’m simply trying out \u003ca href=\"https://pnpm.io\"\u003epnpm\u003c/a\u003e for myself.\u003c/p\u003e\u003cp\u003eAfter running the command, Astro’s chat-based helper, Houston, walks through some setup questions to get things started.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e astro   Launch sequence initiated.\n\n   dir   Where should we create your new project?\n         ./rss-buddy\n\n  tmpl   How would you like to start your new project?\n         Include sample files\n\n    ts   Do you plan to write TypeScript?\n         Yes\n\n   use   How strict should TypeScript be?\n         Strict\n\n  deps   Install dependencies?\n         Yes\n\n   git   Initialize a new git repository?\n         Yes\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI like to use Astro’s sample files so I can get started quickly, but we’re going to clean them up a bit in the process. Let’s clean up the \u003ccode\u003esrc/pages/index.astro\u003c/code\u003e file by removing everything inside of the \u003ccode\u003e\u0026lt;main\u0026gt;\u0026lt;/main\u0026gt;\u003c/code\u003e tags. Then we’re good to go!\u003c/p\u003e\u003cp\u003eFrom there, we can spin things by running \u003ccode\u003epnpm start\u003c/code\u003e. Your terminal will tell you which localhost address you can find your site at.\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003esrc/pages/index.astro\u003c/code\u003e file is where we will make an array of RSS feeds we want to follow. We will be using \u003ca href=\"https://docs.astro.build/en/basics/astro-syntax/\"\u003eAstro’s template syntax\u003c/a\u003e, so between the two code fences (—), create an array of \u003ccode\u003efeedSources\u003c/code\u003e and add some feeds. If you need inspiration, you can copy this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst feedSources = [\n  \u0026#39;https://www.smashingmagazine.com/feed/\u0026#39;,\n  \u0026#39;https://developer.mozilla.org/en-US/blog/rss.xml\u0026#39;,\n  // etc.\n]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we’ll install the \u003ca href=\"https://github.com/rbren/rss-parser\"\u003erss-parser package\u003c/a\u003e in our project by running \u003ccode\u003epnpm install rss-parser\u003c/code\u003e. This package is a small library that turns the XML that we get from fetching an RSS feed into JavaScript objects. This makes it easy for us to read our RSS feeds and manipulate the data any way we want.\u003c/p\u003e\u003cp\u003eOnce the package is installed, open the \u003ccode\u003esrc/pages/index.astro\u003c/code\u003e file, and at the top, we’ll import the rss-parser and instantiate the \u003ccode\u003ePartner\u003c/code\u003e class.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport Parser from \u0026#39;rss-parser\u0026#39;;\nconst parser = new Parser();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe use this parser to read our RSS feeds and (surprise!) \u003cem\u003eparse\u003c/em\u003e them to JavaScript. We’re going to be dealing with a list of promises here. Normally, I would probably use \u003ccode\u003ePromise.all()\u003c/code\u003e, but the thing is, this is supposed to be a complicated experience. If one of the feeds doesn’t work for some reason, I’d prefer to simply ignore it.\u003c/p\u003e\u003cp\u003eWhy? Well, because \u003ccode\u003ePromise.all()\u003c/code\u003e rejects everything even if only one of its promises is rejected. That might mean that if one feed doesn’t behave the way I’d expect it to, my entire page would be blank when I grab my hot beverage to read the news in the morning. I do not want to start my day confronted by an error.\u003c/p\u003e\u003cp\u003eInstead, I’ll opt to use \u003ccode\u003ePromise.allSettled()\u003c/code\u003e. This method will actually let all promises complete even if one of them fails. In our case, this means any feed that errors will just be ignored, which is perfect.\u003c/p\u003e\u003cp\u003eLet’s add this to the \u003ccode\u003esrc/pages/index.astro\u003c/code\u003e file:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003einterface FeedItem {\n  feed?: string;\n  title?: string;\n  link?: string;\n  date?: Date;\n}\n\nconst feedItems: FeedItem[] = [];\n\nawait Promise.allSettled(\n  feedSources.map(async (source) =\u0026gt; {\n    try {\n      const feed = await parser.parseURL(source);\n      feed.items.forEach((item) =\u0026gt; {\n        const date = item.pubDate ? new Date(item.pubDate) : undefined;\n        \n          feedItems.push({\n            feed: feed.title,\n            title: item.title,\n            link: item.link,\n            date,\n          });\n      });\n    } catch (error) {\n      console.error(`Error fetching feed from ${source}:`, error);\n    }\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis creates an array (or more) named \u003ccode\u003efeedItems\u003c/code\u003e. For each URL in the \u003ccode\u003efeedSources\u003c/code\u003e array we created earlier, the rss-parser retrieves the items and, yes, parses them into JavaScript. Then, we return whatever data we want! We’ll keep it simple for now and only return the following:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe feed title,\u003c/li\u003e\u003cli\u003eThe title of the feed item,\u003c/li\u003e\u003cli\u003eThe link to the item,\u003c/li\u003e\u003cli\u003eAnd the item’s published date.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe next step is to ensure that all items are sorted by date so we’ll truly get the “latest” news. Add this small piece of code to our work:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst sortedFeedItems = feedItems.sort((a, b) =\u0026gt; (b.date ?? new Date()).getTime() - (a.date ?? new Date()).getTime());\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOh, and… remember when I said I didn’t want this RSS reader to render anything older than seven days? Let’s tackle that right now since we’re already in this code.\u003c/p\u003e\u003cp\u003eWe’ll make a new variable called \u003ccode\u003esevenDaysAgo\u003c/code\u003e and assign it a date. We’ll then set that date to seven days ago and use that logic before we add a new item to our \u003ccode\u003efeedItems\u003c/code\u003e array.\u003c/p\u003e\u003cp\u003eThis is what the \u003ccode\u003esrc/pages/index.astro\u003c/code\u003e file should now look like at this point:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e---\nimport Layout from \u0026#39;../layouts/Layout.astro\u0026#39;;\nimport Parser from \u0026#39;rss-parser\u0026#39;;\nconst parser = new Parser();\n\nconst sevenDaysAgo = new Date();\nsevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n\nconst feedSources = [\n  \u0026#39;https://www.smashingmagazine.com/feed/\u0026#39;,\n  \u0026#39;https://developer.mozilla.org/en-US/blog/rss.xml\u0026#39;,\n]\n\ninterface FeedItem {\n  feed?: string;\n  title?: string;\n  link?: string;\n  date?: Date;\n}\n\nconst feedItems: FeedItem[] = [];\n\nawait Promise.allSettled(\n  feedSources.map(async (source) =\u0026gt; {\n    try {\n      const feed = await parser.parseURL(source);\n      feed.items.forEach((item) =\u0026gt; {\n        const date = item.pubDate ? new Date(item.pubDate) : undefined;\n        if (date \u0026amp;\u0026amp; date \u0026gt;= sevenDaysAgo) {\n          feedItems.push({\n            feed: feed.title,\n            title: item.title,\n            link: item.link,\n            date,\n          });\n        }\n      });\n    } catch (error) {\n      console.error(`Error fetching feed from ${source}:`, error);\n    }\n  })\n);\n\nconst sortedFeedItems = feedItems.sort((a, b) =\u0026gt; (b.date ?? new Date()).getTime() - (a.date ?? new Date()).getTime());\n\n---\n\n\u0026lt;Layout title=\u0026#34;Welcome to Astro.\u0026#34;\u0026gt;\n  \u0026lt;main\u0026gt;\n  \u0026lt;/main\u0026gt;\n\u0026lt;/Layout\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"rendering-xml-data\"\u003eRendering XML Data\u003c/h2\u003e\u003cp\u003eIt’s time to show our news articles on the Astro site! To keep this simple, we’ll format the items in an unordered list rather than some other fancy layout.\u003c/p\u003e\u003cp\u003eAll we need to do is update the \u003ccode\u003e\u0026lt;Layout\u0026gt;\u003c/code\u003e element in the file with the XML objects sprinkled in for a feed item’s title, URL, and publish date.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;Layout title=\u0026#34;Welcome to Astro.\u0026#34;\u0026gt;\n  \u0026lt;main\u0026gt;\n  {sortedFeedItems.map(item =\u0026gt; (\n    \u0026lt;ul\u0026gt;\n      \u0026lt;li\u0026gt;\n        \u0026lt;a href={item.link}\u0026gt;{item.title}\u0026lt;/a\u0026gt;\n        \u0026lt;p\u0026gt;{item.feed}\u0026lt;/p\u0026gt;\n        \u0026lt;p\u0026gt;{item.date}\u0026lt;/p\u0026gt;\n      \u0026lt;/li\u0026gt;\n    \u0026lt;/ul\u0026gt;\n  ))}\n  \u0026lt;/main\u0026gt;\n\u0026lt;/Layout\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGo ahead and run \u003ccode\u003epnpm start\u003c/code\u003e from the terminal. The page should display an unordered list of feed items. Of course, everything is styled at the moment, but luckily for you, you can make it look exactly like you want with CSS!\u003c/p\u003e\u003cp\u003eAnd remember that there are even \u003cstrong\u003emore fields available in the XML for each item\u003c/strong\u003e if you want to display more information. If you run the following snippet in your DevTools console, you’ll see all of the fields you have at your disposal:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efeed.items.forEach(item =\u0026gt; {}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"scheduling-daily-static-site-builds\"\u003eScheduling Daily Static Site Builds\u003c/h2\u003e\u003cp\u003eWe’re nearly done! The feeds are being fetched, and they are returning data back to us in JavaScript for use in our Astro page template. Since feeds are updated whenever new content is published, we need a way to fetch the latest items from it.\u003c/p\u003e\u003cp\u003eWe want to avoid doing any of this manually. So, let’s set this site on Netlify to gain access to their scheduled functions that trigger a rebuild and their build hooks that do the building. Again, other services do this, and you’re welcome to roll this work with another provider — I’m just partial to Netlify since I work there. In any case, you can follow Netlify’s documentation for \u003ca href=\"https://docs.netlify.com/welcome/add-new-site/#import-from-an-existing-repository\"\u003esetting up a new site\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eOnce your site is hosted and live, you are ready to schedule your rebuilds. A \u003ca href=\"https://docs.netlify.com/configure-builds/build-hooks/\"\u003ebuild hook\u003c/a\u003e gives you a URL to use to trigger the new build, looking something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ehttps://api.netlify.com/build_hooks/your-build-hook-id\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s trigger builds every day at midnight. We’ll use Netlify’s \u003ca href=\"https://docs.netlify.com/functions/scheduled-functions/\"\u003escheduled functions\u003c/a\u003e. That’s really why I’m using Netlify to host this in the first place. Having them at the ready via the host greatly simplifies things since there’s no server work or complicated configurations to get this going. Set it and forget it!\u003c/p\u003e\u003cp\u003eWe’ll install \u003ccode\u003e@netlify/functions\u003c/code\u003e (\u003ca href=\"https://docs.netlify.com/functions/get-started/\"\u003einstructions\u003c/a\u003e) to the project and then create the following file in the project’s root directory: \u003ccode\u003enetlify/functions/deploy.ts\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThis is what we want to add to that file:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// netlify/functions/deploy.ts\n\nimport type { Config } from \u0026#39;@netlify/functions\u0026#39;;\n\nconst BUILD_HOOK =\n  \u0026#39;https://api.netlify.com/build_hooks/your-build-hook-id\u0026#39;; // replace me!\n\nexport default async (req: Request) =\u0026gt; {\n  await fetch(BUILD_HOOK, {\n    method: \u0026#39;POST\u0026#39;,\n  })\n};\n\nexport const config: Config = {\n  schedule: \u0026#39;0 0 * * *\u0026#39;,\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you commit your code and push it, your site should re-deploy automatically. From that point on, it follows a schedule that rebuilds the site every day at midnight, ready for you to take your morning brew and catch up on everything that \u003cem\u003eyou\u003c/em\u003e think is important.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-10-07T13:00:00Z",
  "modifiedTime": "2024-10-07T13:00:00Z"
}
