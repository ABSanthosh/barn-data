{
  "id": "aae1c22e-1574-4401-9428-e4debe0ee930",
  "title": "CSS min() All The Things",
  "link": "https://smashingmagazine.com/2024/10/css-min-all-the-things/",
  "description": "Victor Ayomipo experiments with the CSS `min()` function, exploring its flexibility with different units to determine if it is the be-all, end-all for responsiveness. Discover the cautions he highlights against dogmatic approaches to web design based on his findings.",
  "author": "Victor Ayomipo",
  "published": "Thu, 17 Oct 2024 10:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 12339,
  "excerpt": "Victor Ayomipo experiments with the CSS `min()` function, exploring its flexibility with different units to determine if it is the be-all, end-all for responsiveness. Discover the cautions he highlights against dogmatic approaches to web design based on his findings.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "10 min readCSS, Tools, TechniquesVictor Ayomipo experiments with the CSS min() function, exploring its flexibility with different units to determine if it is the be-all, end-all for responsiveness. Discover the cautions he highlights against dogmatic approaches to web design based on his findings.Did you see this post that Chris Coyier published back in August? He experimented with CSS container query units, going all in and using them for every single numeric value in a demo he put together. And the result was‚Ä¶ not too bad, actually.See the Pen [Container Units for All Units [forked]](https://codepen.io/smashingmag/pen/ExqWXOQ) by Chris Coyier.See the Pen Container Units for All Units [forked] by Chris Coyier.What I found interesting about this is how it demonstrates the complexity of sizing things. We‚Äôre constrained to absolute and relative units in CSS, so we‚Äôre either stuck at a specific size (e.g., px) or computing the size based on sizing declared on another element (e.g., %, em, rem, vw, vh, and so on). Both come with compromises, so it‚Äôs not like there is a ‚Äúcorrect‚Äù way to go about things ‚Äî it‚Äôs about the element‚Äôs context ‚Äî and leaning heavily in any one direction doesn‚Äôt remedy that.I thought I‚Äôd try my own experiment but with the CSS min() function instead of container query units. Why? Well, first off, we can supply the function with any type of length unit we want, which makes the approach a little more flexible than working with one type of unit. But the real reason I wanted to do this is personal interest more than anything else.The DemoI won‚Äôt make you wait for the end to see how my min() experiment went:Taking website responsiveness to a whole new level üåê pic.twitter.com/pKmHl5d0Dy‚Äî Vayo (@vayospot) March 1, 2023We‚Äôll talk about that more after we walk through the details.A Little About min()The min() function takes two values and applies the smallest one, whichever one happens to be in the element‚Äôs context. For example, we can say we want an element to be as wide as 50% of whatever container it is in. And if 50% is greater than, say 200px, cap the width there instead.See the Pen [[forked]](https://codepen.io/smashingmag/pen/LYwWLMg) by Geoff Graham.See the Pen [forked] by Geoff Graham.So, min() is sort of like container query units in the sense that it is aware of how much available space it has in its container. But it‚Äôs different in that min() isn‚Äôt querying its container dimensions to compute the final value. We supply it with two acceptable lengths, and it determines which is best given the context. That makes min() (and max() for that matter) a useful tool for responsive layouts that adapt to the viewport‚Äôs size. It uses conditional logic to determine the ‚Äúbest‚Äù match, which means it can help adapt layouts without needing to reach for CSS media queries..element { width: min(200px, 50%); } /* Close to this: */ .element { width: 200px; @media (min-width: 600px) { width: 50%; } } The difference between min() and @media in that example is that we‚Äôre telling the browser to set the element‚Äôs width to 50% at a specific breakpoint of 600px. With min(), it switches things up automatically as the amount of available space changes, whatever viewport size that happens to be.When I use the min(), I think of it as having the ability to make smart decisions based on context. We don‚Äôt have to do the thinking or calculations to determine which value is used. However, using min() coupled with just any CSS unit isn‚Äôt enough. For instance, relative units work better for responsiveness than absolute units. You might even think of min() as setting a maximum value in that it never goes below the first value but also caps itself at the second value.I mentioned earlier that we could use any type of unit in min(). Let‚Äôs take the same approach that Chris did and lean heavily into a type of unit to see how min() behaves when it is used exclusively for a responsive layout. Specifically, we‚Äôll use viewport units as they are directly relative to the size of the viewport.Now, there are different flavors of viewport units. We can use the viewport‚Äôs width (vw) and height (vh). We also have the vmin and vmax units that are slightly more intelligent in that they evaluate an element‚Äôs width and height and apply either the smaller (vmin) or larger (vmax) of the two. So, if we declare 100vmax on an element, and that element is 500px wide by 250px tall, the unit computes to 500px.That is how I am approaching this experiment. What happens if we eschew media queries in favor of only using min() to establish a responsive layout and lean into viewport units to make it happen? We‚Äôll take it one piece at a time.Font SizingThere are various approaches for responsive type. Media queries are quickly becoming the ‚Äúold school‚Äù way of doing it:p { font-size: 1.1rem; } @media (min-width: 1200px) { p { font-size: 1.2rem; } } @media (max-width: 350px) { p { font-size: 0.9rem; } } Sure, this works, but what happens when the user uses a 4K monitor? Or a foldable phone? There are other tried and true approaches; in fact, clamp() is the prevailing go-to. But we‚Äôre leaning all-in on min(). As it happens, just one line of code is all we need to wipe out all of those media queries, substantially reducing our code:p { font-size: min(6vmin, calc(1rem + 0.23vmax)); } I‚Äôll walk you through those values‚Ä¶6vmin is essentially 6% of the browser‚Äôs width or height, whichever is smallest. This allows the font size to shrink as much as needed for smaller contexts.For calc(1rem + 0.23vmax), 1rem is the base font size, and 0.23vmax is a tiny fraction of the viewport‚Äòs width or height, whichever happens to be the largest.The calc() function adds those two values together. Since 0.23vmax is evaluated differently depending on which viewport edge is the largest, it‚Äôs crucial when it comes to scaling the font size between the two arguments. I‚Äôve tweaked it into something that scales gradually one way or the other rather than blowing things up as the viewport size increases.Finally, the min() returns the smallest value suitable for the font size of the current screen size.And speaking of how flexible the min() approach is, it can restrict how far the text grows. For example, we can cap this at a maximum font-size equal to 2rem as a third function parameter:p { font-size: min(6vmin, calc(1rem + 0.23vmax), 2rem); } This isn‚Äôt a silver bullet tactic. I‚Äôd say it‚Äôs probably best used for body text, like paragraphs. We might want to adjust things a smidge for headings, e.g., \u003ch1\u003e:h1 { font-size: min(7.5vmin, calc(2rem + 1.2vmax)); } We‚Äôve bumped up the minimum size from 6vmin to 7.5vmin so that it stays larger than the body text at any viewport size. Also, in the calc(), the base size is now 2rem, which is smaller than the default UA styles for \u003ch1\u003e. We‚Äôre using 1.2vmax as the multiplier this time, meaning it grows more than the body text, which is multiplied by a smaller value, .023vmax.This works for me. You can always tweak these values and see which works best for your use. Whatever the case, the font-size for this experiment is completely fluid and completely based on the min() function, adhering to my self-imposed constraint.Margin And PaddingSpacing is a big part of layout, responsive or not. We need margin and padding to properly situate elements alongside other elements and give them breathing room, both inside and outside their box.We‚Äôre going all-in with min() for this, too. We could use absolute units, like pixels, but those aren‚Äôt exactly responsive.min() can combine relative and absolute units so they are more effective. Let‚Äôs pair vmin with px this time:div { margin: min(10vmin, 30px); } 10vmin is likely to be smaller than 30px when viewed on a small viewport. That‚Äôs why I‚Äôm allowing the margin to shrink dynamically this time around. As the viewport size increases, whereby 10vmin exceeds 30px, min() caps the value at 30px, going no higher than that.Notice, too, that I didn‚Äôt reach for calc() this time. Margins don‚Äôt really need to grow indefinitely with screen size, as too much spacing between containers or elements generally looks awkward on larger screens. This concept also works extremely well for padding, but we don‚Äôt have to go there. Instead, it might be better to stick with a single unit, preferably em, since it is relative to the element‚Äôs font-size. We can essentially ‚Äúpass‚Äù the work that min() is doing on the font-size to the margin and padding properties because of that..card-info { font-size: min(6vmin, calc(1rem + 0.12vmax)); padding: 1.2em; } Now, padding scales with the font-size, which is powered by min().WidthsSetting width for a responsive design doesn‚Äôt have to be complicated, right? We could simply use a single percentage or viewport unit value to specify how much available horizontal space we want to take up, and the element will adjust accordingly. Though, container query units could be a happy path outside of this experiment.But we‚Äôre min() all the way!min() comes in handy when setting constraints on how much an element responds to changes. We can set an upper limit of 650px and, if the computed width tries to go larger, have the element settle at a full width of 100%:.container { width: min(100%, 650px); } Things get interesting with text width. When the width of a text box is too long, it becomes uncomfortable to read through the texts. There are competing theories about how many characters per line of text is best for an optimal reading experience. For the sake of argument, let‚Äôs say that number should be between 50-75 characters. In other words, we ought to pack no more than 75 characters on a line, and we can do that with the ch unit, which is based on the 0 character‚Äôs size for whatever font is in use.p { width: min(100%, 75ch); } This code basically says: get as wide as needed but never wider than 75 characters.Sizing Recipes Based On min()Over time, with a lot of tweaking and modifying of values, I have drafted a list of pre-defined values that I find work well for responsively styling different properties::root { --font-size-6x: min(7.5vmin, calc(2rem + 1.2vmax)); --font-size-5x: min(6.5vmin, calc(1.1rem + 1.2vmax)); --font-size-4x: min(4vmin, calc(0.8rem + 1.2vmax)); --font-size-3x: min(6vmin, calc(1rem + 0.12vmax)); --font-size-2x: min(4vmin, calc(0.85rem + 0.12vmax)); --font-size-1x: min(2vmin, calc(0.65rem + 0.12vmax)); --width-2x: min(100vw, 1300px); --width-1x: min(100%, 1200px); --gap-3x: min(5vmin, 1.5rem); --gap-2x: min(4.5vmin, 1rem); --size-10x: min(15vmin, 5.5rem); --size-9x: min(10vmin, 5rem); --size-8x: min(10vmin, 4rem); --size-7x: min(10vmin, 3rem); --size-6x: min(8.5vmin, 2.5rem); --size-5x: min(8vmin, 2rem); --size-4x: min(8vmin, 1.5rem); --size-3x: min(7vmin, 1rem); --size-2x: min(5vmin, 1rem); --size-1x: min(2.5vmin, 0.5rem); } This is how I approached my experiment because it helps me know what to reach for in a given situation:h1 { font-size: var(--font-size-6x); } .container { width: var(--width-2x); margin: var(--size-2x); } .card-grid { gap: var(--gap-3x); } There we go! We have a heading that scales flawlessly, a container that‚Äôs responsive and never too wide, and a grid with dynamic spacing ‚Äî all without a single media query. The --size- properties declared in the variable list are the most versatile, as they can be used for properties that require scaling, e.g., margins, paddings, and so on.The Final Result, AgainI shared a video of the result, but here‚Äôs a link to the demo.See the Pen [min() website [forked]](https://codepen.io/smashingmag/pen/wvVdPxL) by Vayo.See the Pen min() website [forked] by Vayo.So, is min() the be-all, end-all for responsiveness? Absolutely not. Neither is a diet consisting entirely of container query units. I mean, it‚Äôs cool that we can scale an entire webpage like this, but the web is never a one-size-fits-all beanie.If anything, I think this and what Chris demoed are warnings against dogmatic approaches to web design as a whole, not solely unique to responsive design. CSS features, including length units and functions, are tools in a larger virtual toolshed. Rather than getting too cozy with one feature or technique, explore the shed because you might find a better tool for the job. (gg, yk)",
  "image": "https://files.smashing.media/articles/css-min-all-the-things/css-min-all-the-things.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e10 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/css\"\u003eCSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/tools\"\u003eTools\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eVictor Ayomipo experiments with the CSS \u003ccode\u003emin()\u003c/code\u003e function, exploring its flexibility with different units to determine if it is the be-all, end-all for responsiveness. Discover the cautions he highlights against dogmatic approaches to web design based on his findings.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eDid you see \u003ca href=\"https://frontendmasters.com/blog/what-if-you-used-container-units-for-everything/\"\u003ethis post\u003c/a\u003e that Chris Coyier published back in August? He experimented with CSS container query units, going all in and using them for every single numeric value in a demo he put together. And \u003ca href=\"https://codepen.io/chriscoyier/pen/OJYKLXz\"\u003ethe result\u003c/a\u003e was‚Ä¶ not too bad, actually.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"ExqWXOQ\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Container Units for All Units [forked]](https://codepen.io/smashingmag/pen/ExqWXOQ) by \u003ca href=\"https://codepen.io/chriscoyier\"\u003eChris Coyier\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/ExqWXOQ\"\u003eContainer Units for All Units [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/chriscoyier\"\u003eChris Coyier\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWhat I found interesting about this is how it demonstrates the complexity of sizing things. We‚Äôre constrained to absolute and relative units in CSS, so we‚Äôre either stuck at a specific size (e.g., \u003ccode\u003epx\u003c/code\u003e) or computing the size based on sizing declared on another element (e.g., \u003ccode\u003e%\u003c/code\u003e, \u003ccode\u003eem\u003c/code\u003e, \u003ccode\u003erem\u003c/code\u003e, \u003ccode\u003evw\u003c/code\u003e, \u003ccode\u003evh\u003c/code\u003e, and so on). Both come with compromises, so it‚Äôs not like there is a ‚Äúcorrect‚Äù way to go about things ‚Äî it‚Äôs about the element‚Äôs context ‚Äî and leaning heavily in any one direction doesn‚Äôt remedy that.\u003c/p\u003e\u003cp\u003eI thought I‚Äôd try my own experiment but with the CSS \u003ccode\u003emin()\u003c/code\u003e function instead of container query units. Why? Well, first off, we can supply the function with \u003cstrong\u003eany type of length unit we want\u003c/strong\u003e, which makes the approach a little more flexible than working with one type of unit. But the real reason I wanted to do this is personal interest more than anything else.\u003c/p\u003e\u003ch2 id=\"the-demo\"\u003eThe Demo\u003c/h2\u003e\u003cp\u003eI won‚Äôt make you wait for the end to see how my \u003ccode\u003emin()\u003c/code\u003e experiment went:\u003c/p\u003e\u003cblockquote data-media-max-width=\"560\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eTaking website responsiveness to a whole new level üåê \u003ca href=\"https://t.co/pKmHl5d0Dy\"\u003epic.twitter.com/pKmHl5d0Dy\u003c/a\u003e\u003c/p\u003e‚Äî Vayo (@vayospot) \u003ca href=\"https://twitter.com/vayospot/status/1630863145014112257?ref_src=twsrc%5Etfw\"\u003eMarch 1, 2023\u003c/a\u003e\u003c/blockquote\u003e\u003cp\u003eWe‚Äôll talk about that more after we walk through the details.\u003c/p\u003e\u003ch2 id=\"a-little-about-min\"\u003eA Little About \u003ccode\u003emin()\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eThe \u003ccode\u003emin()\u003c/code\u003e function takes two values and applies the smallest one, whichever one happens to be in the element‚Äôs context. For example, we can say we want an element to be as wide as \u003ccode\u003e50%\u003c/code\u003e of whatever container it is in. And if \u003ccode\u003e50%\u003c/code\u003e is \u003cem\u003egreater\u003c/em\u003e than, say \u003ccode\u003e200px\u003c/code\u003e, cap the width there instead.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"LYwWLMg\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [[forked]](https://codepen.io/smashingmag/pen/LYwWLMg) by \u003ca href=\"https://codepen.io/geoffgraham\"\u003eGeoff Graham\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/LYwWLMg\"\u003e[forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/geoffgraham\"\u003eGeoff Graham\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eSo, \u003ccode\u003emin()\u003c/code\u003e is sort of like container query units in the sense that it is aware of how much available space it has in its container. But it‚Äôs different in that \u003ccode\u003emin()\u003c/code\u003e isn‚Äôt querying its container dimensions to compute the final value. We supply it with two acceptable lengths, and it determines which is best given the context. That makes \u003ccode\u003emin()\u003c/code\u003e (and \u003ccode\u003emax()\u003c/code\u003e for that matter) \u003cstrong\u003ea useful tool for responsive layouts that adapt to the viewport‚Äôs size\u003c/strong\u003e. It uses conditional logic to determine the ‚Äúbest‚Äù match, which means it can help adapt layouts without needing to reach for CSS media queries.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.element {\n  width: min(200px, 50%);\n}\n\n/* Close to this: */\n.element {\n  width: 200px;\n\n  @media (min-width: 600px) {\n    width: 50%;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe difference between \u003ccode\u003emin()\u003c/code\u003e and \u003ccode\u003e@media\u003c/code\u003e in that example is that we‚Äôre telling the browser to set the element‚Äôs width to \u003ccode\u003e50%\u003c/code\u003e at a specific \u003cem\u003ebreakpoint\u003c/em\u003e of \u003ccode\u003e600px\u003c/code\u003e. With \u003ccode\u003emin()\u003c/code\u003e, it switches things up automatically as the amount of available space changes, whatever viewport size that happens to be.\u003c/p\u003e\u003cp\u003eWhen I use the \u003ccode\u003emin()\u003c/code\u003e, I think of it as having the ability to make smart decisions based on context. We don‚Äôt have to do the thinking or calculations to determine which value is used. However, using \u003ccode\u003emin()\u003c/code\u003e coupled with just any CSS unit isn‚Äôt enough. For instance, relative units work better for responsiveness than absolute units. You might even think of \u003ccode\u003emin()\u003c/code\u003e as \u003ca href=\"https://css-tricks.com/min-max-and-clamp-are-css-magic/\"\u003esetting a \u003cem\u003emaximum\u003c/em\u003e value\u003c/a\u003e in that it never goes below the first value but also caps itself at the second value.\u003c/p\u003e\u003cp\u003eI mentioned earlier that we could use any type of unit in \u003ccode\u003emin()\u003c/code\u003e. Let‚Äôs take the same approach that Chris did and lean heavily into a type of unit to see how \u003ccode\u003emin()\u003c/code\u003e behaves when it is used exclusively for a responsive layout. Specifically, we‚Äôll use \u003cstrong\u003eviewport units\u003c/strong\u003e as they are directly relative to the size of the viewport.\u003c/p\u003e\u003cp\u003eNow, there are different flavors of viewport units. We can use the viewport‚Äôs width (\u003ccode\u003evw\u003c/code\u003e) and height (\u003ccode\u003evh\u003c/code\u003e). We also have the \u003ccode\u003evmin\u003c/code\u003e and \u003ccode\u003evmax\u003c/code\u003e units that are slightly more intelligent in that they evaluate an element‚Äôs width and height and apply either the smaller (\u003ccode\u003evmin\u003c/code\u003e) or larger (\u003ccode\u003evmax\u003c/code\u003e) of the two. So, if we declare \u003ccode\u003e100vmax\u003c/code\u003e on an element, and that element is \u003ccode\u003e500px\u003c/code\u003e wide by \u003ccode\u003e250px\u003c/code\u003e tall, the unit computes to \u003ccode\u003e500px\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThat is how I am approaching this experiment. What happens if we eschew media queries in favor of only using \u003ccode\u003emin()\u003c/code\u003e to establish a responsive layout and lean into viewport units to make it happen? We‚Äôll take it one piece at a time.\u003c/p\u003e\u003ch2 id=\"font-sizing\"\u003eFont Sizing\u003c/h2\u003e\u003cp\u003eThere are various approaches for responsive type. Media queries are quickly becoming the ‚Äúold school‚Äù way of doing it:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ep { font-size: 1.1rem; }\n\n@media (min-width: 1200px) {\n  p { font-size: 1.2rem; }\n}\n\n@media (max-width: 350px) {\n  p { font-size: 0.9rem; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSure, this works, but what happens when the user uses a 4K monitor? Or a foldable phone? There are other tried and true approaches; in fact, \u003ca href=\"https://www.smashingmagazine.com/2023/11/addressing-accessibility-concerns-fluid-type/\"\u003e\u003ccode\u003eclamp()\u003c/code\u003e is the prevailing go-to\u003c/a\u003e. But we‚Äôre leaning all-in on \u003ccode\u003emin()\u003c/code\u003e. As it happens, just one line of code is all we need to wipe out all of those media queries, substantially reducing our code:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ep { font-size: min(6vmin, calc(1rem + 0.23vmax)); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI‚Äôll walk you through those values‚Ä¶\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ccode\u003e6vmin\u003c/code\u003e is essentially 6% of the browser‚Äôs width or height, whichever is smallest. This allows the font size to shrink as much as needed for smaller contexts.\u003c/li\u003e\u003cli\u003eFor \u003ccode\u003ecalc(1rem + 0.23vmax)\u003c/code\u003e, \u003ccode\u003e1rem\u003c/code\u003e is the base font size, and \u003ccode\u003e0.23vmax\u003c/code\u003e is a tiny fraction of the viewport‚Äòs width or height, whichever happens to be the largest.\u003c/li\u003e\u003cli\u003eThe \u003ccode\u003ecalc()\u003c/code\u003e function adds those two values together. Since \u003ccode\u003e0.23vmax\u003c/code\u003e is evaluated differently depending on which viewport edge is the largest, it‚Äôs crucial when it comes to scaling the font size between the two arguments. I‚Äôve tweaked it into something that scales gradually one way or the other rather than blowing things up as the viewport size increases.\u003c/li\u003e\u003cli\u003eFinally, the \u003ccode\u003emin()\u003c/code\u003e returns the smallest value suitable for the font size of the current screen size.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eAnd speaking of how flexible the \u003ccode\u003emin()\u003c/code\u003e approach is, it can restrict how far the text grows. For example, we can cap this at a maximum \u003ccode\u003efont-size\u003c/code\u003e equal to \u003ccode\u003e2rem\u003c/code\u003e as a third function parameter:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ep { font-size: min(6vmin, calc(1rem + 0.23vmax), 2rem); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis isn‚Äôt a silver bullet tactic. I‚Äôd say it‚Äôs probably best used for body text, like paragraphs. We might want to adjust things a smidge for headings, e.g., \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eh1 { font-size: min(7.5vmin, calc(2rem + 1.2vmax)); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe‚Äôve bumped up the minimum size from \u003ccode\u003e6vmin\u003c/code\u003e to \u003ccode\u003e7.5vmin\u003c/code\u003e so that it stays larger than the body text at any viewport size. Also, in the \u003ccode\u003ecalc()\u003c/code\u003e, the base size is now \u003ccode\u003e2rem\u003c/code\u003e, which is smaller than the default UA styles for \u003ccode\u003e\u0026lt;h1\u0026gt;\u003c/code\u003e. We‚Äôre using \u003ccode\u003e1.2vmax\u003c/code\u003e as the multiplier this time, meaning it grows more than the body text, which is multiplied by a smaller value, \u003ccode\u003e.023vmax\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThis works for me. You can always tweak these values and see which works best for your use. Whatever the case, the \u003ccode\u003efont-size\u003c/code\u003e for this experiment is completely fluid and completely based on the \u003ccode\u003emin()\u003c/code\u003e function, adhering to my self-imposed constraint.\u003c/p\u003e\u003ch2 id=\"margin-and-padding\"\u003eMargin And Padding\u003c/h2\u003e\u003cp\u003eSpacing is a big part of layout, responsive or not. We need \u003ccode\u003emargin\u003c/code\u003e and \u003ccode\u003epadding\u003c/code\u003e to properly situate elements alongside other elements and give them breathing room, both inside and outside their box.\u003c/p\u003e\u003cp\u003eWe‚Äôre going all-in with \u003ccode\u003emin()\u003c/code\u003e for this, too. We could use absolute units, like pixels, but those aren‚Äôt exactly responsive.\u003c/p\u003e\u003cp\u003e\u003ccode\u003emin()\u003c/code\u003e can combine relative and absolute units so they are more effective. Let‚Äôs pair \u003ccode\u003evmin\u003c/code\u003e with \u003ccode\u003epx\u003c/code\u003e this time:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ediv { margin: min(10vmin, 30px); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e10vmin\u003c/code\u003e is likely to be smaller than \u003ccode\u003e30px\u003c/code\u003e when viewed on a small viewport. That‚Äôs why I‚Äôm allowing the margin to shrink dynamically this time around. As the viewport size increases, whereby \u003ccode\u003e10vmin\u003c/code\u003e exceeds \u003ccode\u003e30px\u003c/code\u003e, \u003ccode\u003emin()\u003c/code\u003e caps the value at \u003ccode\u003e30px\u003c/code\u003e, going no higher than that.\u003c/p\u003e\u003cp\u003eNotice, too, that I didn‚Äôt reach for \u003ccode\u003ecalc()\u003c/code\u003e this time. Margins don‚Äôt really need to grow indefinitely with screen size, as too much spacing between containers or elements generally looks awkward on larger screens. This concept also works extremely well for padding, but we don‚Äôt have to go there. Instead, it might be better to stick with a single unit, preferably \u003ccode\u003eem\u003c/code\u003e, since it is relative to the element‚Äôs \u003ccode\u003efont-size\u003c/code\u003e. We can essentially ‚Äúpass‚Äù the work that \u003ccode\u003emin()\u003c/code\u003e is doing on the \u003ccode\u003efont-size\u003c/code\u003e to the \u003ccode\u003emargin\u003c/code\u003e and \u003ccode\u003epadding\u003c/code\u003e properties because of that.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.card-info {\n  font-size: min(6vmin, calc(1rem + 0.12vmax));\n  padding: 1.2em;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, padding scales with the \u003ccode\u003efont-size\u003c/code\u003e, which is powered by \u003ccode\u003emin()\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"widths\"\u003eWidths\u003c/h2\u003e\u003cp\u003eSetting \u003ccode\u003ewidth\u003c/code\u003e for a responsive design doesn‚Äôt have to be complicated, right? We could simply use a single percentage or viewport unit value to specify how much available horizontal space we want to take up, and the element will adjust accordingly. Though, container query units could be a happy path outside of this experiment.\u003c/p\u003e\u003cp\u003eBut we‚Äôre \u003ccode\u003emin()\u003c/code\u003e all the way!\u003c/p\u003e\u003cp\u003e\u003ccode\u003emin()\u003c/code\u003e comes in handy when setting constraints on how much an element responds to changes. We can set an upper limit of \u003ccode\u003e650px\u003c/code\u003e and, if the computed width tries to go larger, have the element settle at a full width of \u003ccode\u003e100%\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.container { width: min(100%, 650px); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThings get interesting with text width. When the width of a text box is too long, it becomes uncomfortable to read through the texts. There are competing theories about how many characters per line of text is best for an optimal reading experience. For the sake of argument, let‚Äôs say that number should be between 50-75 characters. In other words, we ought to pack no more than 75 characters on a line, and we can do that with the \u003ccode\u003ech\u003c/code\u003e unit, which is based on the \u003ccode\u003e0\u003c/code\u003e character‚Äôs size for whatever font is in use.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ep {\n  width: min(100%, 75ch);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis code basically says: \u003cem\u003eget as wide as needed but never wider than 75 characters.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"sizing-recipes-based-on-min\"\u003eSizing Recipes Based On \u003ccode\u003emin()\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eOver time, with a lot of tweaking and modifying of values, I have drafted a list of pre-defined values that I find work well for responsively styling different properties:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e:root {\n  --font-size-6x: min(7.5vmin, calc(2rem + 1.2vmax));\n  --font-size-5x: min(6.5vmin, calc(1.1rem + 1.2vmax));\n  --font-size-4x: min(4vmin, calc(0.8rem + 1.2vmax));\n  --font-size-3x: min(6vmin, calc(1rem + 0.12vmax));\n  --font-size-2x: min(4vmin, calc(0.85rem + 0.12vmax));\n  --font-size-1x: min(2vmin, calc(0.65rem + 0.12vmax));\n  --width-2x: min(100vw, 1300px);\n  --width-1x: min(100%, 1200px);\n  --gap-3x: min(5vmin, 1.5rem);\n  --gap-2x: min(4.5vmin, 1rem);\n  --size-10x: min(15vmin, 5.5rem);\n  --size-9x: min(10vmin, 5rem);\n  --size-8x: min(10vmin, 4rem);\n  --size-7x: min(10vmin, 3rem);\n  --size-6x: min(8.5vmin, 2.5rem);\n  --size-5x: min(8vmin, 2rem);\n  --size-4x: min(8vmin, 1.5rem);\n  --size-3x: min(7vmin, 1rem);\n  --size-2x: min(5vmin, 1rem);\n  --size-1x: min(2.5vmin, 0.5rem);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is how I approached my experiment because it helps me know what to reach for in a given situation:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eh1 { font-size: var(--font-size-6x); }\n\n.container {\n  width: var(--width-2x);\n  margin: var(--size-2x);\n}\n\n.card-grid { gap: var(--gap-3x); }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere we go! We have a heading that scales flawlessly, a container that‚Äôs responsive and never too wide, and a grid with dynamic spacing ‚Äî all without a single media query. The \u003ccode\u003e--size-\u003c/code\u003e properties declared in the variable list are the most versatile, as they can be used for properties that require scaling, e.g., margins, paddings, and so on.\u003c/p\u003e\u003ch2 id=\"the-final-result-again\"\u003eThe Final Result, Again\u003c/h2\u003e\u003cp\u003eI shared a video of the result, but here‚Äôs a link to the demo.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"wvVdPxL\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [min() website [forked]](https://codepen.io/smashingmag/pen/wvVdPxL) by \u003ca href=\"https://codepen.io/vayospot\"\u003eVayo\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/wvVdPxL\"\u003emin() website [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/vayospot\"\u003eVayo\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eSo, is \u003ccode\u003emin()\u003c/code\u003e the be-all, end-all for responsiveness? Absolutely not. Neither is a diet consisting entirely of container query units. I mean, it‚Äôs cool that we can scale an entire webpage like this, but the web is never a one-size-fits-all beanie.\u003c/p\u003e\u003cp\u003eIf anything, I think this and what Chris demoed are \u003cstrong\u003ewarnings against dogmatic approaches to web design\u003c/strong\u003e as a whole, not solely unique to responsive design. CSS features, including length units and functions, are tools in a larger virtual toolshed. Rather than getting too cozy with one feature or technique, explore the shed because you might find a better tool for the job.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-10-17T10:00:00Z",
  "modifiedTime": "2024-10-17T10:00:00Z"
}
