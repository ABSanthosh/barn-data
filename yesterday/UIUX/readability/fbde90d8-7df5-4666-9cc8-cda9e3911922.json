{
  "id": "fbde90d8-7df5-4666-9cc8-cda9e3911922",
  "title": "Integrating Localization Into Design Systems",
  "link": "https://smashingmagazine.com/2025/05/integrating-localization-into-design-systems/",
  "description": "Learn how two designers tackled the challenges of building a localization-ready design system for a global audience. This case study dives into how Rebecca and Mark combined Figma Variables and design tokens to address multilingual design issues, such as text overflow, RTL layouts, and font inconsistencies.",
  "author": "Rebecca Hemstad \u0026 Mark Malek",
  "published": "Mon, 12 May 2025 10:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Authors",
  "length": 21990,
  "excerpt": "Learn how two designers tackled the challenges of building a localization-ready design system for a global audience. This case study dives into how Rebecca and Mark combined Figma Variables and design tokens to address multilingual design issues, such as text overflow, RTL layouts, and font inconsistencies.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "15 min readDesign Systems, Figma, Case Studies, LocalizationLearn how two designers tackled the challenges of building a localization-ready design system for a global audience. This case study dives into how Rebecca and Mark combined Figma Variables and design tokens to address multilingual design issues, such as text overflow, RTL layouts, and font inconsistencies. They share key lessons learned and the hurdles they faced — including Figma’s limitations — along with the solutions they developed to create dynamic, scalable designs that adapt seamlessly across languages, themes, and densities. If you’re navigating the complexities of internationalization in design systems, this article is for you.Mark and I work as product designers for SAS, a leader in analytics and artificial intelligence recognized globally for turning data into valuable insights. Our primary role is to support the token packages and component libraries for the SAS Filament Design System. SAS’ customer base is global, meaning people from diverse countries, cultures, and languages interact with products built with the Filament Design System.SAS designers use Figma libraries developed by the Filament Design System team to create UX specifications. These high-fidelity designs are typically crafted in English, unknowingly overlooking multilingual principles, which can result in layout issues, text overflow, and challenges with right-to-left (RTL) languages. These issues cascade into the application, ultimately creating usability issues for SAS customers. This highlights the need to prioritize localization from the start of the design process.With the introduction of Figma Variables, alongside the advancements in design tokens, we saw an opportunity for designers. We imagined a system where a Figma design could dynamically switch between themes, densities, and even languages.This would allow us to design and test multilingual capabilities more effectively, ensuring our design system was both flexible and adaptable.While researching localization integration for design systems, we realized a significant gap in existing documentation on supporting localization and internationalization in design tokens and Figma Variables. Many of the challenges we faced, such as managing typography across locales or adapting layouts dynamically, were undocumented or only partially addressed in available resources.Our story demonstrates how combining foundational principles of multilingual design with design tokens can help tackle the complexities of language switching in design systems. We are not arguing that our approach is the best, but given the lack of documentation available on the subject, we hope it will get the conversation started.But before we start, it’s essential to understand the distinction between Localization (L10n) and Internationalization (I18n).Localization (L10n) refers to the process of adapting designs for specific languages, regions, or cultures and involves the following:Translating text;Adjusting layouts to accommodate language-specific requirements, such as longer or shorter text strings or right-to-left (RTL) text for languages like Arabic;Ensuring visual elements are culturally appropriate and resonate with the target audience.Internationalization (I18n) is the preparation phase, ensuring designs are flexible and adaptable to different languages and regions. Key considerations in Figma include:Using placeholder text to represent dynamic content;Setting up constraints for dynamic resizing to handle text expansion or contraction;Supporting bi-directional text for languages that require RTL layouts.These concepts are not only foundational to multilingual design but also integral to delivering inclusive and accessible experiences to global users.Pre-Figma Setup: Building A FrameworkUnderstanding Our Design Token SystemBefore diving deeper, it’s crucial to understand that our design tokens are stored in JSON files. These JSON files are managed in an application we call “Token Depot,” hosted on our corporate GitHub.We utilize the Tokens Studio plugin (pro plan) to transform these JSON files into Figma libraries. For us, design tokens are synonymous with variables — we don’t create additional variables that only exist in Figma. However, we do create styles in Figma that serve as “recipe cards” for specific HTML elements. For instance, an H2 might include a combination of font-family, font-size, and font-weight.It’s important to note that our design token values are directly tied to CSS-based values.Initial Setup: Theme Switching And LocalizationIn 2022, we took on the massive task of refactoring all our token names to be more semantic. At that time, we were only concerned with theme switching in our products.Our tokens were re-categorized into the following groups:ColorBrand colors (SAS brand colors)Base colors (references to Brand colors)Typography (e.g., fonts, spacing, styles)Space (e.g., padding, margins)Size (e.g., icons, borders)Style (e.g., focus styles)Motion (e.g., animations)Shadow.Our first iteration of token groupings by type. (Large preview)In our early setup:A core folder contained JSON files for values unaffected by theme or brand.Brand folders included three JSON files (one for each theme). These were considered “English” by default.A separate languages folder contained overrides for other locales, stacked on top of brand files to replace specific token values.Our JSON files were configured with English as the default. Other locales were managed with a set of JSON files that included overrides for English. These overrides were minimal, focusing mainly on font and typography adjustments. For example, bold typefaces often create issues because many languages like Chinese, Japanese, or Korean (CJK languages) fonts lack distinct bold versions. Thus, we replaced the font-weight token value from 700 to 400 in our CJK locales.We also update the values for font-family, letter spacing, font-style, and font-variant tokens. In Figma, our application screens were originally designed in English, and in 2023, we only implemented theme-switching modes, not language options. Additionally, we created detailed lists to document which design tokens could be converted to Figma variables and which could not, as the initial release of variables supported only a limited set.Introducing Density SwitchingThe introduction of density switching in our products marked a significant turning point. This change allowed us to revisit and improve how we handled localization and token management. The first thing we had to figure out was the necessary token sorting. We ended up with the following list:Tokens Impact By Theme And DensityUnaffected by Theme or Density:ColorBrand colorsBase colorsMotionShadowSizeBorder sizeOutline sizeTypographyBase font sizeLetter spacing and word spacingOverflow, text, and word style tokens.Tokens Impacted by Density:TypographyFont sizesLine HeightFont spacingSizeBorder radiusIcon sizesSpaceBase spacing.Tokens Impacted by Theme:ColorsAction, body, container, dataviz, display, heading, highlight, icon, label, status, syntax, tag, text, thumbnail, and zero-statSizeBorder sizeTypographyFont-familyStyleAction (focus styles).With density, we expanded locale-specific value changes beyond font-family, letter spacing, font-style, and font-variant tokens to additionally include:Font sizesIcon sizesLine heightSpacingBorder radius.Revisiting our type scale and performing numerous calculations, we documented the required token value changes for all the locales across the density. This groundwork enabled us to tackle the restructuring of our JSON files effectively.Our updated JSON files were grouped by core, theme, and density modes. (Large preview)JSON File RestructuringIn our token repository, we:Updated the tokens in the core folder.Added a density folder and a language folder in each brand.After collaborating with our front-end development team, we decided to minimize the number of JSON files. Too many files introduce complexity and bugs and hinder performance. Instead of creating a JSON file for each language-density combination, we defined the following language categories:Language CategoriesWestern European and Slavic LanguagesPolish, English, French, German, and SpanishChinese LanguagesSimplified and traditional scriptsMiddle Eastern and East Asian LanguagesArabic, Hebrew, Japanese, Korean, Thai, and VietnameseGlobal DiverseAfrica, South Asia, Pacific, and Indigenous languages, Uralic, and Turkic groups.These categories became our JSON files, with one file per density level. Each file contained tokens for font size, icon size, line height, spacing, and border-radius values. For example, all Chinese locales shared consistent values regardless of font-family.To minimize performance burden, we divided languages into regions. (Large preview)In addition, we added a folder containing JSON files per locale, overriding core values and theme folders, such as font-family.Figma Setup: Bridging Tokens And DesignToken Studio ChallengesAfter restructuring our JSON files, we anticipated gaining support for typography variables in the Tokens Studio plugin. Instead, Tokens Studio released version 2.0, introducing a major shift in workflow. Previously, we imported JSON files directly into Figma and avoided pushing changes back through the plugin. Adjusting to the new version required us to relearn how to use the plugin effectively.Our first challenge was navigating the complexity of the import process. The $metadata.json and $themes.json files failed to overwrite correctly during imports, resulting in duplicate collections in Figma when exporting variables. Despite recreating the required theme structure within the plugin, the issue persisted. To resolve this, we deleted the existing $metadata.json and $themes.json files from the repository before pulling the updated GitHub repo into the plugin. However, even with this solution, we had to manually remove redundant collections that appeared during the export process.Once we successfully migrated our tokens from JSON files into Figma using the Tokens Studio plugin, we encountered our next challenge.Initially, we used only “English” and theme modes in Figma, relying primarily on styles since Figma’s early variable releases lacked support for typography variables. Now, with the goal of implementing theme, density, and language switching, we needed to leverage variables — including typography variables. While the token migration successfully brought in the token names as variable names and the necessary modes, some values were missing.Typography variables, though promising in concept, were underwhelming in practice. For example, Figma’s default line-height multiplier for “auto” was 1.2, below the WCAG minimum of 1.5. Additionally, our token values used line-height multipliers, which weren’t valid as Figma variable values. While a percentage-based line-height value is valid in CSS, Figma variables don’t support percentages.Our solution involved manually calculating pixel values for line heights across all typography sizes, locale categories, and densities. These values were entered as local variables in Figma, independent of the design token system. This allowed us to implement correct line-height changes for density and locale switches. The process, however, was labor-intensive, requiring the manual creation of hundreds of local variables. Furthermore, grouping font sizes and line heights into Figma styles required additional manual effort due to the lack of support for line-height multipliers or percentage-based variables.Examples:For CJK locales, medium and low density use a base font size of 16px, while high density uses 18px.Western European and Slavic languages use 14px for medium density, 16px for high, and 12px for low density.Additional ChallengesFigma vs. Web RenderingIn Figma, line height centers text visually within the text box. In CSS, it affects spacing differently depending on the box model. This mismatch required manual adjustments, especially in light of upcoming CSS properties like leading-trim.Letter-Spacing IssuesWhile CSS defaults to “normal” for letter-spacing, Figma requires numeric values. Locale-specific resets to “normal” couldn’t utilize variables, complicating implementation.Font-Family StacksExample stack for Chinese:font-family-primary: 'AnovaUI', '微软雅黑体', 'Microsoft YaHei New', '微软雅黑', 'Microsoft Yahei', '宋体', 'SimSun', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif.Starting with a Western font ensured proper rendering of Latin characters and symbols while maintaining brand consistency. However, Figma’s designs using only AnovaUI (SAS Brand Custom font) couldn’t preview locale-based substitutions via system fonts, complicating evaluations of mixed-content designs.Finally, as we prepared to publish our new library, we encountered yet another challenge: Figma Ghosts.What Are Figma Ghost Variables?Figma “ghost variables” refer to variables that remain in a Figma project even after they are no longer linked to any design tokens, themes, or components.These variables often arise due to incomplete deletions, improper imports, or outdated metadata files. Ghost variables may appear in Figma’s variable management panel but are effectively “orphaned,” as they are disconnected from any meaningful use or reference.Ghost variables found in Figma when importing json files. (Large preview)Why They Cause Issues for Designers:Clutter and ConfusionGhost variables make the variable list longer and harder to navigate. Designers might struggle to identify which variables are actively in use and which are obsolete.Redundant WorkDesigners might accidentally try to use these variables, leading to inefficiencies or design inconsistencies when the ghost variables don’t function as expected.Export and Sync ProblemsWhen exporting or syncing variables with a design system or repository, ghost variables can introduce errors, duplicates, or conflicts. This complicates maintaining alignment between the design system and Figma.Increased Maintenance OverheadDetecting and manually deleting ghost variables can be time-consuming, particularly in large-scale projects with extensive variable sets.Thematic InconsistenciesGhost variables can create inconsistencies across themes, as they might reference outdated or irrelevant styles, making it harder to ensure a unified look and feel.Addressing ghost variables requires careful management of design tokens and variables, often involving clean-up processes to ensure only relevant variables remain in the system.Cleaning Up Ghost VariablesTo avoid the issues in our Figma libraries, we first had to isolate ghost variables component by component. By selecting a symbol in Figma and navigating the applied variable modes, we had a good sense of which older versions of variables the symbol was still connected to. We found disconnected variables in the component library and our icon library, which resulted in compounded ghost variables across the system. We found that by traversing the layer panel, along with a fantastic plug-in called “Swap Variables,” we were able to remap all the ghost variables in our symbols.If we had not completed the clean-up step, designers would not be able to access the overrides for theme, density, and locale.Designing Symbols For LocalizationTo ensure Figma symbols support language swapping, we linked all text layers to our new variables, including font-family, font-size, and line height.We do not use Figma’s variable feature to define text strings for each locale (e.g., English, Spanish, French) because, given the sheer breadth and depth of our Products and solutions, it would simply be too daunting a task to undertake. For us, using an existing plug-in, such as “Translator,” gives us what we need.After ensuring all text layers were remapped to variables, along with the “Translator” plug-in, we were able to swap entire screens to a new language. This allowed us to start testing our symbols for unforeseen layout issues.We use the Translator plugin to test out translating our product mockups. (Large preview)We discovered that some symbols were not supporting text wrapping when needed (e.g., accommodating longer words in German or shorter ones in Japanese). We isolated those issues and updated them to auto-layout for flexible resizing. This approach ensured all our Figma symbols were scalable and adaptable for multilingual support.Delivering The SystemWith our component libraries set up to support localization, we were ready to deliver our component libraries to product designers. As a part of this step, we crafted a “Multilingual Design Cheat Sheet” to help designers understand how to set up their application mockups with Localization and Internationalization in mind.Multilingual Design Cheat Sheet:General PrinciplesDesign flexible layouts that can handle text wrapping and language-specific requirements such as right-to-left orientations.Use real content during design and development to identify localization issues such as spacing and wrapping.Research the cultural expectations of your target audience to avoid faux pas.Text \u0026 TypographyUse Filament Design Systems fonts to ensure support of all languages.Avoid custom fonts that lack bold or italic styles for non-Latin scripts like CJK languages.Reserve additional space for languages like German or Finnish.Avoid hardcoded widths for text containers and use auto-layout to ensure long text strings are readable.The Filament Design System tokens adjust line height per language; make sure you are using variables for line-height.Use bold sparingly, as Filament tokens override bold styling in some languages. Instead, opt for alternative emphasis methods (e.g., color or size).Layout \u0026 DesignMirror layouts for RTL languages (e.g., Arabic, Hebrew). Align text, icons, and navigation appropriately for the flow of the language.Use auto-layout to accommodate varying text lengths.Avoid embedding text in images to simplify localization.Allow ample spacing around text elements to prevent crowding.Language-Specific AdjustmentsAdapt formats based on locale (e.g., YYYY/MM/DD vs. MM/DD/YYYY).Use metric or imperial units based on the region.Test alignments and flows for LTR and RTL languages.Localization ReadinessAvoid idioms, cultural references, or metaphors that may not translate well.Provide space for localized images, if necessary.Use Figma translation plug-ins to test designs for localization readiness and use real translations rather than Lorem Ipsum.Test with native speakers for language-specific usability issues.Check mirrored layouts and interactions for usability in RTL languages.Lessons Learned And Future DirectionsLessons LearnedIn summary, building a localization-ready design system was a complex yet rewarding process that taught Mark and me several critical lessons:Localization and internationalization must be prioritized early.Ignoring multilingual principles in the early stages of design creates cascading issues that are costly to fix later.Semantic tokens are key.Refactoring our tokens to be more semantic streamlined the localization process, reducing complexity and improving maintainability.Figma variables are promising but limited.While Figma Variables introduced new possibilities, their current limitations — such as lack of percentage-based line-height values and manual setup requirements — highlight areas for improvement.Automation is essential.Manual efforts, such as recalculating and inputting values for typography and density-specific tokens, are time-intensive and prone to error. Plugins like “Translator” and “Swap Variables” proved invaluable in streamlining this work.Collaboration is crucial.Close coordination with front-end developers ensured that our JSON restructuring efforts aligned with performance and usability goals.Testing with real content is non-negotiable.Design issues like text wrapping, RTL mirroring, and font compatibility only became apparent when testing with real translations and flexible layouts.Future DirectionsAs we look ahead, our focus is on enhancing the Filament Design System to better support global audiences and simplify the localization process for designers:Automatic mirrored layouts for RTL languages.We plan to develop tools and workflows that enable seamless mirroring of layouts for right-to-left languages, ensuring usability for languages like Arabic and Hebrew.Improved figma integration.Advocacy for Figma enhancements, such as percentage-based line-height support and better handling of variable imports, will remain a priority.Advanced automation tools.Investing in more robust plugins and custom tools to automate the calculation and management of tokens across themes, densities, and locales will reduce manual overhead.Scalable localization testing framework.Establishing a framework for native speaker testing and real-world content validation will help us identify localization issues earlier in the design process.Expanding the multilingual design cheat sheet.We will continue to refine and expand the cheat sheet, incorporating feedback from designers to ensure it remains a valuable resource.Community engagement.By sharing our findings and lessons, we aim to contribute to the broader design community, fostering discussions around integrating localization and internationalization in design systems.Through these efforts, Mark and I hope to create a more inclusive, scalable, and efficient design system that meets the diverse needs of our global audience while empowering SAS designers to think beyond English-first designs.Further Reading On SmashingMag“Internationalization And Localization For Static Sites,” Sam Richard“CSS-Driven Internationalization In JavaScript,” Maksim Chemerisuk“How To Conduct Website Localization: Don’t Get Lost In Translation,” Julia Rozwens“12 Commandments Of Software Localization,” Zack Grossbart (yk)",
  "image": "https://files.smashing.media/articles/integrating-localization-into-design-systems/integrating-localization-into-design-systems.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e15 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/design-systems\"\u003eDesign Systems\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/figma\"\u003eFigma\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/case-studies\"\u003eCase Studies\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/localization\"\u003eLocalization\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eLearn how two designers tackled the challenges of building a localization-ready design system for a global audience. This case study dives into how Rebecca and Mark combined Figma Variables and design tokens to address multilingual design issues, such as text overflow, RTL layouts, and font inconsistencies. They share key lessons learned and the hurdles they faced — including Figma’s limitations — along with the solutions they developed to create dynamic, scalable designs that adapt seamlessly across languages, themes, and densities. If you’re navigating the complexities of internationalization in design systems, this article is for you.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eMark and I work as product designers for SAS, a leader in analytics and artificial intelligence recognized globally for turning data into valuable insights. Our primary role is to support the token packages and component libraries for the SAS Filament Design System. SAS’ customer base is global, meaning people from diverse countries, cultures, and languages interact with products built with the Filament Design System.\u003c/p\u003e\u003cp\u003eSAS designers use Figma libraries developed by the Filament Design System team to create UX specifications. These high-fidelity designs are typically crafted in English, unknowingly overlooking multilingual principles, which can result in layout issues, text overflow, and challenges with right-to-left (RTL) languages. These issues cascade into the application, ultimately creating \u003cstrong\u003eusability issues\u003c/strong\u003e for SAS customers. This highlights the need to prioritize \u003cstrong\u003elocalization\u003c/strong\u003e from the start of the design process.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aWith%20the%20introduction%20of%20Figma%20Variables,%20alongside%20the%20advancements%20in%20design%20tokens,%20we%20saw%20an%20opportunity%20for%20designers.%20We%20imagined%20a%20system%20where%20a%20Figma%20design%20could%20dynamically%20switch%20between%20themes,%20densities,%20and%20even%20languages.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f05%2fintegrating-localization-into-design-systems%2f\"\u003eWith the introduction of Figma Variables, alongside the advancements in design tokens, we saw an opportunity for designers. We imagined a system where a Figma design could dynamically switch between themes, densities, and even languages.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eThis would allow us to design and test multilingual capabilities more effectively, ensuring our design system was both \u003cstrong\u003eflexible\u003c/strong\u003e and \u003cstrong\u003eadaptable\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eWhile researching localization integration for design systems, we realized a significant gap in existing documentation on supporting localization and internationalization in design tokens and Figma Variables. Many of the challenges we faced, such as managing typography across locales or adapting layouts dynamically, were undocumented or only partially addressed in available resources.\u003c/p\u003e\u003cp\u003eOur story demonstrates how combining foundational principles of multilingual design with design tokens can help tackle the complexities of language switching in design systems. We are not arguing that our approach is the best, but given the lack of documentation available on the subject, we hope it will get the conversation started.\u003c/p\u003e\u003cp\u003eBut before we start, it’s essential to understand the distinction between Localization (L10n) and Internationalization (I18n).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLocalization (L10n)\u003c/strong\u003e refers to the process of adapting designs for specific languages, regions, or cultures and involves the following:\u003c/p\u003e\u003cul\u003e\u003cli\u003eTranslating text;\u003c/li\u003e\u003cli\u003eAdjusting layouts to accommodate language-specific requirements, such as longer or shorter text strings or right-to-left (RTL) text for languages like Arabic;\u003c/li\u003e\u003cli\u003eEnsuring visual elements are culturally appropriate and resonate with the target audience.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eInternationalization (I18n)\u003c/strong\u003e is the preparation phase, ensuring designs are flexible and adaptable to different languages and regions. Key considerations in Figma include:\u003c/p\u003e\u003cul\u003e\u003cli\u003eUsing placeholder text to represent dynamic content;\u003c/li\u003e\u003cli\u003eSetting up constraints for dynamic resizing to handle text expansion or contraction;\u003c/li\u003e\u003cli\u003eSupporting bi-directional text for languages that require RTL layouts.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese concepts are not only foundational to multilingual design but also integral to delivering inclusive and accessible experiences to global users.\u003c/p\u003e\u003ch2 id=\"pre-figma-setup-building-a-framework\"\u003ePre-Figma Setup: Building A Framework\u003c/h2\u003e\u003ch3 id=\"understanding-our-design-token-system\"\u003eUnderstanding Our Design Token System\u003c/h3\u003e\u003cp\u003eBefore diving deeper, it’s crucial to understand that our design tokens are stored in JSON files. These JSON files are managed in an application we call “Token Depot,” hosted on our corporate GitHub.\u003c/p\u003e\u003cp\u003eWe utilize the Tokens Studio plugin (pro plan) to transform these JSON files into Figma libraries. For us, design tokens are synonymous with variables — we don’t create additional variables that only exist in Figma. However, we do create styles in Figma that serve as “recipe cards” for specific HTML elements. For instance, an H2 might include a combination of font-family, font-size, and font-weight.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIt’s important to note\u003c/strong\u003e that our design token values are directly tied to CSS-based values.\u003c/p\u003e\u003ch3 id=\"initial-setup-theme-switching-and-localization\"\u003eInitial Setup: Theme Switching And Localization\u003c/h3\u003e\u003cp\u003eIn 2022, we took on the massive task of refactoring all our token names to be more \u003cstrong\u003esemantic\u003c/strong\u003e. At that time, we were only concerned with theme switching in our products.\u003c/p\u003e\u003cp\u003eOur tokens were re-categorized into the following groups:\u003c/p\u003e\u003cul\u003e\u003cli\u003eColor\u003cul\u003e\u003cli\u003eBrand colors (SAS brand colors)\u003c/li\u003e\u003cli\u003eBase colors (references to Brand colors)\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eTypography (e.g., fonts, spacing, styles)\u003c/li\u003e\u003cli\u003eSpace (e.g., padding, margins)\u003c/li\u003e\u003cli\u003eSize (e.g., icons, borders)\u003c/li\u003e\u003cli\u003eStyle (e.g., focus styles)\u003c/li\u003e\u003cli\u003eMotion (e.g., animations)\u003c/li\u003e\u003cli\u003eShadow.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png\" sizes=\"100vw\" alt=\"Groupings of token type.\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eOur first iteration of token groupings by type. (\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/token-categories.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eIn our early setup:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eA core folder contained JSON files for values unaffected by theme or brand.\u003c/li\u003e\u003cli\u003eBrand folders included three JSON files (one for each theme). These were considered “English” by default.\u003c/li\u003e\u003cli\u003eA separate languages folder contained overrides for other locales, stacked on top of brand files to replace specific token values.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOur JSON files were configured with English as the default. Other locales were managed with a set of JSON files that included overrides for English. These overrides were minimal, focusing mainly on font and typography adjustments. For example, bold typefaces often create issues because many languages like Chinese, Japanese, or Korean (CJK languages) fonts lack distinct bold versions. Thus, we replaced the font-weight token value from 700 to 400 in our CJK locales.\u003c/p\u003e\u003cp\u003eWe also update the values for font-family, letter spacing, font-style, and font-variant tokens. In Figma, our application screens were originally designed in English, and in 2023, we only implemented theme-switching modes, not language options. Additionally, we created detailed lists to document which design tokens could be converted to Figma variables and which could not, as the initial release of variables supported only a limited set.\u003c/p\u003e\u003ch3 id=\"introducing-density-switching\"\u003eIntroducing Density Switching\u003c/h3\u003e\u003cp\u003eThe introduction of \u003cstrong\u003edensity switching\u003c/strong\u003e in our products marked a significant turning point. This change allowed us to revisit and improve how we handled localization and token management. The first thing we had to figure out was the necessary token sorting. We ended up with the following list:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTokens Impact By Theme And Density\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cem\u003eUnaffected by Theme or Density:\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eColor\u003c/li\u003e\u003cli\u003eBrand colors\u003c/li\u003e\u003cli\u003eBase colors\u003c/li\u003e\u003cli\u003eMotion\u003c/li\u003e\u003cli\u003eShadow\u003c/li\u003e\u003cli\u003eSize\u003c/li\u003e\u003cli\u003eBorder size\u003c/li\u003e\u003cli\u003eOutline size\u003c/li\u003e\u003cli\u003eTypography\u003c/li\u003e\u003cli\u003eBase font size\u003c/li\u003e\u003cli\u003eLetter spacing and word spacing\u003c/li\u003e\u003cli\u003eOverflow, text, and word style tokens.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e\u003cem\u003eTokens Impacted by Density:\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eTypography\u003c/li\u003e\u003cli\u003eFont sizes\u003c/li\u003e\u003cli\u003eLine Height\u003c/li\u003e\u003cli\u003eFont spacing\u003c/li\u003e\u003cli\u003eSize\u003c/li\u003e\u003cli\u003eBorder radius\u003c/li\u003e\u003cli\u003eIcon sizes\u003c/li\u003e\u003cli\u003eSpace\u003c/li\u003e\u003cli\u003eBase spacing.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e\u003cem\u003eTokens Impacted by Theme:\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eColors\u003c/li\u003e\u003cli\u003eAction, body, container, dataviz, display, heading, highlight, icon, label, status, syntax, tag, text, thumbnail, and zero-stat\u003c/li\u003e\u003cli\u003eSize\u003c/li\u003e\u003cli\u003eBorder size\u003c/li\u003e\u003cli\u003eTypography\u003c/li\u003e\u003cli\u003eFont-family\u003c/li\u003e\u003cli\u003eStyle\u003c/li\u003e\u003cli\u003eAction (focus styles).\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWith density, we expanded locale-specific value changes beyond font-family, letter spacing, font-style, and font-variant tokens to additionally include:\u003c/p\u003e\u003cul\u003e\u003cli\u003eFont sizes\u003c/li\u003e\u003cli\u003eIcon sizes\u003c/li\u003e\u003cli\u003eLine height\u003c/li\u003e\u003cli\u003eSpacing\u003c/li\u003e\u003cli\u003eBorder radius.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRevisiting our type scale and performing numerous calculations, we documented the required token value changes for all the locales across the density. This groundwork enabled us to tackle the \u003cstrong\u003erestructuring of our JSON files\u003c/strong\u003e effectively.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png\" sizes=\"100vw\" alt=\"Groupings of token type by mode.\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eOur updated JSON files were grouped by core, theme, and density modes. (\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/tokens-impacted.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"json-file-restructuring\"\u003eJSON File Restructuring\u003c/h3\u003e\u003cp\u003eIn our token repository, we:\u003c/p\u003e\u003col\u003e\u003cli\u003eUpdated the tokens in the core folder.\u003c/li\u003e\u003cli\u003eAdded a density folder and a language folder in each brand.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eAfter collaborating with our front-end development team, we decided to minimize the number of JSON files. Too many files introduce complexity and bugs and hinder performance. Instead of creating a JSON file for each language-density combination, we defined the following language categories:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eLanguage Categories\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eWestern European and Slavic Languages\u003cul\u003e\u003cli\u003ePolish, English, French, German, and Spanish\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eChinese Languages\u003cul\u003e\u003cli\u003eSimplified and traditional scripts\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eMiddle Eastern and East Asian Languages\u003cul\u003e\u003cli\u003eArabic, Hebrew, Japanese, Korean, Thai, and Vietnamese\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eGlobal Diverse\u003cul\u003e\u003cli\u003eAfrica, South Asia, Pacific, and Indigenous languages, Uralic, and Turkic groups.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese categories became our JSON files, with one file per density level. Each file contained tokens for font size, icon size, line height, spacing, and border-radius values. For example, all Chinese locales shared consistent values regardless of font-family.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png\" sizes=\"100vw\" alt=\"Regional groupings of languages.\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eTo minimize performance burden, we divided languages into regions. (\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/language-groups.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIn addition, we added a folder containing JSON files per locale, overriding core values and theme folders, such as font-family.\u003c/p\u003e\u003ch2 id=\"figma-setup-bridging-tokens-and-design\"\u003eFigma Setup: Bridging Tokens And Design\u003c/h2\u003e\u003ch3 id=\"token-studio-challenges\"\u003eToken Studio Challenges\u003c/h3\u003e\u003cp\u003eAfter restructuring our JSON files, we anticipated gaining support for typography variables in the Tokens Studio plugin. Instead, Tokens Studio released version 2.0, introducing a major shift in workflow. Previously, we imported JSON files directly into Figma and avoided pushing changes back through the plugin. Adjusting to the new version required us to relearn how to use the plugin effectively.\u003c/p\u003e\u003cp\u003eOur first challenge was navigating the \u003cstrong\u003ecomplexity of the import process\u003c/strong\u003e. The \u003ccode\u003e$metadata.json\u003c/code\u003e and \u003ccode\u003e$themes.json\u003c/code\u003e files failed to overwrite correctly during imports, resulting in duplicate collections in Figma when exporting variables. Despite recreating the required theme structure within the plugin, the issue persisted. To resolve this, we deleted the existing \u003ccode\u003e$metadata.json\u003c/code\u003e and \u003ccode\u003e$themes.json\u003c/code\u003e files from the repository before pulling the updated GitHub repo into the plugin. However, even with this solution, we had to manually remove redundant collections that appeared during the export process.\u003c/p\u003e\u003cp\u003eOnce we successfully migrated our tokens from JSON files into Figma using the Tokens Studio plugin, we encountered our next challenge.\u003c/p\u003e\u003cp\u003eInitially, we used only “English” and theme modes in Figma, relying primarily on styles since Figma’s early variable releases lacked support for typography variables. Now, with the goal of implementing theme, density, and language switching, we needed to leverage variables — including typography variables. While the token migration successfully brought in the token names as variable names and the necessary modes, some values were missing.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTypography variables, though promising in concept, were underwhelming in practice.\u003c/strong\u003e For example, Figma’s default line-height multiplier for “auto” was 1.2, below the WCAG minimum of 1.5. Additionally, our token values used line-height multipliers, which weren’t valid as Figma variable values. While a percentage-based line-height value is valid in CSS, Figma variables don’t support percentages.\u003c/p\u003e\u003cp\u003eOur solution involved manually calculating pixel values for line heights across all typography sizes, locale categories, and densities. These values were entered as local variables in Figma, independent of the design token system. This allowed us to implement correct line-height changes for density and locale switches. The process, however, was labor-intensive, requiring the manual creation of hundreds of local variables. Furthermore, grouping font sizes and line heights into Figma styles required additional manual effort due to the lack of support for line-height multipliers or percentage-based variables.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExamples:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eFor CJK locales, medium and low density use a base font size of 16px, while high density uses 18px.\u003c/li\u003e\u003cli\u003eWestern European and Slavic languages use 14px for medium density, 16px for high, and 12px for low density.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"additional-challenges\"\u003eAdditional Challenges\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eFigma vs. Web Rendering\u003c/strong\u003e\u003cbr/\u003eIn Figma, line height centers text visually within the text box. In CSS, it affects spacing differently depending on the box model. This mismatch required manual adjustments, especially in light of upcoming CSS properties like \u003ccode\u003eleading-trim\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLetter-Spacing Issues\u003c/strong\u003e\u003cbr/\u003eWhile CSS defaults to “normal” for letter-spacing, Figma requires numeric values. Locale-specific resets to “normal” couldn’t utilize variables, complicating implementation.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFont-Family Stacks\u003c/strong\u003e\u003cul\u003e\u003cli\u003eExample stack for Chinese:\u003cbr/\u003e\u003ccode\u003efont-family-primary: \u0026#39;AnovaUI\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;微软雅黑体\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;Microsoft YaHei New\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;微软雅黑\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;Microsoft Yahei\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;宋体\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;SimSun\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;Helvetica Neue\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;Helvetica\u0026#39;\u003c/code\u003e, \u003ccode\u003e\u0026#39;Arial\u0026#39;\u003c/code\u003e, \u003ccode\u003esans-serif\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eStarting with a Western font ensured proper rendering of Latin characters and symbols while maintaining brand consistency. However, Figma’s designs using only AnovaUI (SAS Brand Custom font) couldn’t preview locale-based substitutions via system fonts, complicating evaluations of mixed-content designs.\u003c/p\u003e\u003cp\u003eFinally, as we prepared to publish our new library, we encountered yet another challenge: Figma Ghosts.\u003c/p\u003e\u003ch3 id=\"what-are-figma-ghost-variables\"\u003eWhat Are Figma Ghost Variables?\u003c/h3\u003e\u003cblockquote\u003eFigma “ghost variables” refer to variables that remain in a Figma project even after they are no longer linked to any design tokens, themes, or components.\u003c/blockquote\u003e\u003cp\u003eThese variables often arise due to incomplete deletions, improper imports, or outdated metadata files. Ghost variables may appear in Figma’s variable management panel but are effectively “orphaned,” as they are disconnected from any meaningful use or reference.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png\" sizes=\"100vw\" alt=\"Ghost variables demonstrated in Figma UI.\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eGhost variables found in Figma when importing json files. (\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/ghost-variables.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWhy They Cause Issues for Designers:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eClutter and Confusion\u003c/strong\u003e\u003cbr/\u003eGhost variables make the variable list longer and harder to navigate. Designers might struggle to identify which variables are actively in use and which are obsolete.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eRedundant Work\u003c/strong\u003e\u003cbr/\u003eDesigners might accidentally try to use these variables, leading to inefficiencies or design inconsistencies when the ghost variables don’t function as expected.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eExport and Sync Problems\u003c/strong\u003e\u003cbr/\u003eWhen exporting or syncing variables with a design system or repository, ghost variables can introduce errors, duplicates, or conflicts. This complicates maintaining alignment between the design system and Figma.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eIncreased Maintenance Overhead\u003c/strong\u003e\u003cbr/\u003eDetecting and manually deleting ghost variables can be time-consuming, particularly in large-scale projects with extensive variable sets.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eThematic Inconsistencies\u003c/strong\u003e\u003cbr/\u003eGhost variables can create inconsistencies across themes, as they might reference outdated or irrelevant styles, making it harder to ensure a unified look and feel.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAddressing ghost variables requires careful management of design tokens and variables, often involving clean-up processes to ensure only relevant variables remain in the system.\u003c/p\u003e\u003ch3 id=\"cleaning-up-ghost-variables\"\u003eCleaning Up Ghost Variables\u003c/h3\u003e\u003cp\u003eTo avoid the issues in our Figma libraries, we first had to isolate ghost variables component by component. By selecting a symbol in Figma and navigating the applied variable modes, we had a good sense of which older versions of variables the symbol was still connected to. We found disconnected variables in the component library and our icon library, which resulted in compounded ghost variables across the system. We found that by traversing the layer panel, along with a fantastic plug-in called “Swap Variables,” we were able to remap all the ghost variables in our symbols.\u003c/p\u003e\u003cp\u003eIf we had not completed the clean-up step, designers would not be able to access the overrides for theme, density, and locale.\u003c/p\u003e\u003ch3 id=\"designing-symbols-for-localization\"\u003eDesigning Symbols For Localization\u003c/h3\u003e\u003cp\u003eTo ensure Figma symbols support language swapping, we linked all text layers to our new variables, including font-family, font-size, and line height.\u003c/p\u003e\u003cp\u003eWe do not use Figma’s variable feature to define text strings for each locale (e.g., English, Spanish, French) because, given the sheer breadth and depth of our Products and solutions, it would simply be too daunting a task to undertake. For us, using an existing plug-in, such as “Translator,” gives us what we need.\u003c/p\u003e\u003cp\u003eAfter ensuring all text layers were remapped to variables, along with the “Translator” plug-in, we were able to swap entire screens to a new language. This allowed us to start \u003cstrong\u003etesting\u003c/strong\u003e our symbols for unforeseen layout issues.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png\" sizes=\"100vw\" alt=\"Figma plug in Translator. \"/\u003e\u003c/a\u003e\u003cfigcaption\u003eWe use the Translator plugin to test out translating our product mockups. (\u003ca href=\"https://files.smashing.media/articles/integrating-localization-into-design-systems/translator-plugin.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWe discovered that some symbols were not supporting text wrapping when needed (e.g., accommodating longer words in German or shorter ones in Japanese). We isolated those issues and updated them to auto-layout for flexible resizing. This approach ensured all our Figma symbols were scalable and adaptable for multilingual support.\u003c/p\u003e\u003ch3 id=\"delivering-the-system\"\u003eDelivering The System\u003c/h3\u003e\u003cp\u003eWith our component libraries set up to support localization, we were ready to deliver our component libraries to product designers. As a part of this step, we crafted a “Multilingual Design Cheat Sheet” to help designers understand how to set up their application mockups with Localization and Internationalization in mind.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMultilingual Design Cheat Sheet:\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eGeneral Principles\u003c/strong\u003e\u003cul\u003e\u003cli\u003eDesign flexible layouts that can handle text wrapping and language-specific requirements such as right-to-left orientations.\u003c/li\u003e\u003cli\u003eUse real content during design and development to identify localization issues such as spacing and wrapping.\u003c/li\u003e\u003cli\u003eResearch the cultural expectations of your target audience to avoid faux pas.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eText \u0026amp; Typography\u003c/strong\u003e\u003cul\u003e\u003cli\u003eUse Filament Design Systems fonts to ensure support of all languages.\u003c/li\u003e\u003cli\u003eAvoid custom fonts that lack bold or italic styles for non-Latin scripts like CJK languages.\u003c/li\u003e\u003cli\u003eReserve additional space for languages like German or Finnish.\u003c/li\u003e\u003cli\u003eAvoid hardcoded widths for text containers and use auto-layout to ensure long text strings are readable.\u003c/li\u003e\u003cli\u003eThe Filament Design System tokens adjust line height per language; make sure you are using variables for line-height.\u003c/li\u003e\u003cli\u003eUse bold sparingly, as Filament tokens override bold styling in some languages. Instead, opt for alternative emphasis methods (e.g., color or size).\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLayout \u0026amp; Design\u003c/strong\u003e\u003cul\u003e\u003cli\u003eMirror layouts for RTL languages (e.g., Arabic, Hebrew). Align text, icons, and navigation appropriately for the flow of the language.\u003c/li\u003e\u003cli\u003eUse auto-layout to accommodate varying text lengths.\u003c/li\u003e\u003cli\u003eAvoid embedding text in images to simplify localization.\u003c/li\u003e\u003cli\u003eAllow ample spacing around text elements to prevent crowding.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLanguage-Specific Adjustments\u003c/strong\u003e\u003cbr/\u003e\u003cul\u003e\u003cli\u003eAdapt formats based on locale (e.g., YYYY/MM/DD vs. MM/DD/YYYY).\u003c/li\u003e\u003cli\u003eUse metric or imperial units based on the region.\u003c/li\u003e\u003cli\u003eTest alignments and flows for LTR and RTL languages.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLocalization Readiness\u003c/strong\u003e\u003cbr/\u003e\u003cul\u003e\u003cli\u003eAvoid idioms, cultural references, or metaphors that may not translate well.\u003c/li\u003e\u003cli\u003eProvide space for localized images, if necessary.\u003c/li\u003e\u003cli\u003eUse Figma translation plug-ins to test designs for localization readiness and use real translations rather than Lorem Ipsum.\u003c/li\u003e\u003cli\u003eTest with native speakers for language-specific usability issues.\u003c/li\u003e\u003cli\u003eCheck mirrored layouts and interactions for usability in RTL languages.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"lessons-learned-and-future-directions\"\u003eLessons Learned And Future Directions\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eLessons Learned\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIn summary, building a localization-ready design system was a complex yet rewarding process that taught Mark and me several critical lessons:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eLocalization and internationalization must be prioritized early.\u003c/strong\u003e\u003cbr/\u003eIgnoring multilingual principles in the early stages of design creates cascading issues that are costly to fix later.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSemantic tokens are key.\u003c/strong\u003e\u003cbr/\u003eRefactoring our tokens to be more semantic streamlined the localization process, reducing complexity and improving maintainability.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFigma variables are promising but limited.\u003c/strong\u003e\u003cbr/\u003eWhile Figma Variables introduced new possibilities, their current limitations — such as lack of percentage-based line-height values and manual setup requirements — highlight areas for improvement.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAutomation is essential.\u003c/strong\u003e\u003cbr/\u003eManual efforts, such as recalculating and inputting values for typography and density-specific tokens, are time-intensive and prone to error. Plugins like “Translator” and “Swap Variables” proved invaluable in streamlining this work.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCollaboration is crucial.\u003c/strong\u003e\u003cbr/\u003eClose coordination with front-end developers ensured that our JSON restructuring efforts aligned with performance and usability goals.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eTesting with real content is non-negotiable.\u003c/strong\u003e\u003cbr/\u003eDesign issues like text wrapping, RTL mirroring, and font compatibility only became apparent when testing with real translations and flexible layouts.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eFuture Directions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAs we look ahead, our focus is on enhancing the Filament Design System to better support global audiences and simplify the localization process for designers:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eAutomatic mirrored layouts for RTL languages.\u003c/strong\u003e\u003cbr/\u003eWe plan to develop tools and workflows that enable seamless mirroring of layouts for right-to-left languages, ensuring usability for languages like Arabic and Hebrew.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eImproved figma integration.\u003c/strong\u003e\u003cbr/\u003eAdvocacy for Figma enhancements, such as percentage-based line-height support and better handling of variable imports, will remain a priority.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAdvanced automation tools.\u003c/strong\u003e\u003cbr/\u003eInvesting in more robust plugins and custom tools to automate the calculation and management of tokens across themes, densities, and locales will reduce manual overhead.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eScalable localization testing framework.\u003c/strong\u003e\u003cbr/\u003eEstablishing a framework for native speaker testing and real-world content validation will help us identify localization issues earlier in the design process.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eExpanding the multilingual design cheat sheet.\u003c/strong\u003e\u003cbr/\u003eWe will continue to refine and expand the cheat sheet, incorporating feedback from designers to ensure it remains a valuable resource.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCommunity engagement.\u003c/strong\u003e\u003cbr/\u003eBy sharing our findings and lessons, we aim to contribute to the broader design community, fostering discussions around integrating localization and internationalization in design systems.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThrough these efforts, Mark and I hope to create a more inclusive, scalable, and efficient design system that meets the diverse needs of our global audience while empowering SAS designers to think beyond English-first designs.\u003c/p\u003e\u003ch3 id=\"further-reading-on-smashingmag\"\u003eFurther Reading On SmashingMag\u003c/h3\u003e\u003cul\u003e\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2020/11/internationalization-localization-static-sites/\"\u003eInternationalization And Localization For Static Sites\u003c/a\u003e,” Sam Richard\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2014/06/css-driven-internationalization-in-javascript/\"\u003eCSS-Driven Internationalization In JavaScript\u003c/a\u003e,” Maksim Chemerisuk\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2014/12/how-to-conduct-website-localization/\"\u003eHow To Conduct Website Localization: Don’t Get Lost In Translation\u003c/a\u003e,” Julia Rozwens\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2012/07/12-commandments-software-localization/\"\u003e12 Commandments Of Software Localization\u003c/a\u003e,” Zack Grossbart\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2025-05-12T10:00:00Z",
  "modifiedTime": "2025-05-12T10:00:00Z"
}
