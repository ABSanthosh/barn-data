{
  "id": "13f08c0e-577c-4e19-a14a-b0af006373e4",
  "title": "How to Answer Like a Kotlin Expert: inline, noinline, crossinline, and reified Explained Simply",
  "link": "https://proandroiddev.com/how-to-answer-like-a-kotlin-expert-inline-noinline-crossinline-and-reified-explained-simply-6fd446584fa4?source=rss----c72404660798---4",
  "description": "",
  "author": "Shbazhenov",
  "published": "Fri, 13 Jun 2025 15:57:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "androiddev",
    "technical-interview",
    "android",
    "android-app-development"
  ],
  "byline": "Shbazhenov",
  "length": 3825,
  "excerpt": "Ever been asked in an interview what these Kotlin modifiers do — and felt unsure how to explain them clearly? This post will help you answer like a real expert, using simple words and strong…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Ever been asked in an interview what these Kotlin modifiers do — and felt unsure how to explain them clearly? This post will help you answer like a real expert, using simple words and strong examples.inline: Reduce Allocations, But at a CostNormally, when you pass a lambda to a function, Kotlin creates a new object and adds a function call. That works fine, but it adds runtime overhead.When you mark a function as inline, the compiler copies the function body (and the lambdas) directly into the place where it’s called.Result:Less memory allocation (no lambda objects)Better performance (no extra calls)But: Larger binary size — because the code is duplicated at every call siteKey point: It’s a trade-off — use inline when the function is small and performance-sensitive.noinline: Keep Lambda as a Real ObjectBy default, all lambdas inside an inline function are inlined. But what if you don’t want that?Use noinline to exclude a specific lambda from being inlined.Example:inline fun runTasks(task1: () -\u003e Unit, noinline task2: () -\u003e Unit) { task1() launchAsync(task2) // task2 is passed as a real object}Use noinline when:You need to pass the lambda somewhere elseYou want to store it in a variableYou want to avoid duplicating a large lambda across multiple call sitescrossinline: Prevent Non-Local ReturnsA non-local return means a return inside a lambda can exit the outer function — something only allowed inside inline functions.Example with non-local return:inline fun execute(block: () -\u003e Unit) { println(\"Start\") block() println(\"End\")}fun main() { execute { println(\"Before return\") return // Exits from main()! } println(\"After\") // ❌ This line won’t be reached}What if we pass the lambda elsewhere?Kotlin doesn’t allow non-local returns when the lambda is called in another context (like inside another function). That’s where crossinline comes in:inline fun safeExecute(crossinline block: () -\u003e Unit) { runOnUiThread { block() // Treated like a regular lambda now }}crossinline preserves performance by inlining the lambda, but disables non-local return, making it safe to call from other scopes (threads, coroutines, etc.).reified: Keep Generic Type Info at RuntimeIn the JVM, generics use type erasure — meaning the actual type of T is removed during compilation.This was done to:Keep backward compatibility with older Java versionsAvoid making the JVM more complexThat’s why this doesn’t work:fun \u003cT\u003e checkType(value: Any): Boolean { return value is T // ❌ Error: Cannot check for erased type}But when you make the function inline and use reified, Kotlin remembers the type:inline fun \u003creified T\u003e checkType(value: Any): Boolean { return value is T // ✅ Now this works!}Why reified Only Works with inlineThe trick is that inline copies the function body into the caller, which means the compiler knows the actual type of T at compile time.inline + reified = “copy-paste the function with the real type filled in”Without inline, the function is compiled on its own — and type T is erased before runtime.Quick Summaryinline — Reduces runtime overhead by inlining lambdas and function calls.noinline — Prevents a lambda from being inlined; use it when you want to pass or store the lambda.crossinline — Disables return from exiting the outer function while still inlining the lambda.reified — Allows you to use the actual type T at runtime (only in inline functions).When to Use (and When to Avoid)Use inline when:You want to remove lambda overheadYou need non-local returnThe function is small and used oftenAvoid inline when:The function is large or complexIt’s called only occasionallyYou’re optimizing for binary sizeIf you found this helpful, share it with someone preparing for Kotlin interviews — or let me know which part clicked best for you!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*fxHGf8cO27pJIsCTNJg00g.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@shbazhenov?source=post_page---byline--6fd446584fa4---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Shbazhenov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*hiI_stOtJ4Av1nxkxrYAXg.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f38b\"\u003eEver been asked in an interview what these Kotlin modifiers do — and felt unsure how to explain them clearly? This post will help you \u003cstrong\u003eanswer like a real expert\u003c/strong\u003e, using simple words and strong examples.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f79e\"\u003e\u003ccode\u003einline\u003c/code\u003e: Reduce Allocations, But at a Cost\u003c/h2\u003e\u003cp id=\"acb0\"\u003eNormally, when you pass a lambda to a function, Kotlin creates a new object and adds a function call. That works fine, but it adds \u003cstrong\u003eruntime overhead\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"6216\"\u003eWhen you mark a function as \u003ccode\u003einline\u003c/code\u003e, the compiler \u003cstrong\u003ecopies the function body (and the lambdas)\u003c/strong\u003e directly into the place where it’s called.\u003c/p\u003e\u003ch2 id=\"d882\"\u003eResult:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"8e0b\"\u003eLess memory allocation (no lambda objects)\u003c/li\u003e\u003cli id=\"f4fc\"\u003eBetter performance (no extra calls)\u003c/li\u003e\u003cli id=\"bcf3\"\u003eBut: \u003cstrong\u003eLarger binary size\u003c/strong\u003e — because the code is duplicated at every call site\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"771b\"\u003e\u003cstrong\u003e\u003cem\u003eKey point:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e It’s a trade-off — use \u003c/em\u003e\u003ccode\u003e\u003cem\u003einline\u003c/em\u003e\u003c/code\u003e\u003cem\u003e when the function is small and performance-sensitive.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c504\"\u003e\u003ccode\u003enoinline\u003c/code\u003e: Keep Lambda as a Real Object\u003c/h2\u003e\u003cp id=\"c18b\"\u003eBy default, all lambdas inside an \u003ccode\u003einline\u003c/code\u003e function are inlined. But what if you \u003cstrong\u003edon’t want\u003c/strong\u003e that?\u003c/p\u003e\u003cp id=\"8903\"\u003eUse \u003ccode\u003enoinline\u003c/code\u003e to \u003cstrong\u003eexclude a specific lambda\u003c/strong\u003e from being inlined.\u003c/p\u003e\u003ch2 id=\"3f42\"\u003eExample:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9324\"\u003einline fun runTasks(task1: () -\u0026gt; Unit, noinline task2: () -\u0026gt; Unit) {\u003cbr/\u003e    task1()\u003cbr/\u003e    launchAsync(task2) // task2 is passed as a real object\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1093\"\u003eUse \u003ccode\u003enoinline\u003c/code\u003e when:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"4c64\"\u003eYou need to pass the lambda somewhere else\u003c/li\u003e\u003cli id=\"152f\"\u003eYou want to store it in a variable\u003c/li\u003e\u003cli id=\"f0aa\"\u003eYou want to avoid duplicating a large lambda across multiple call sites\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"90c1\"\u003e\u003ccode\u003ecrossinline\u003c/code\u003e: Prevent Non-Local Returns\u003c/h2\u003e\u003cp id=\"b3bd\"\u003eA \u003cstrong\u003enon-local return\u003c/strong\u003e means a \u003ccode\u003ereturn\u003c/code\u003e inside a lambda can exit the \u003cstrong\u003eouter function\u003c/strong\u003e — something only allowed inside \u003ccode\u003einline\u003c/code\u003e functions.\u003c/p\u003e\u003ch2 id=\"d244\"\u003eExample with non-local return:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"7185\"\u003einline fun execute(block: () -\u0026gt; Unit) {\u003cbr/\u003e    println(\u0026#34;Start\u0026#34;)\u003cbr/\u003e    block()\u003cbr/\u003e    println(\u0026#34;End\u0026#34;)\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    execute {\u003cbr/\u003e        println(\u0026#34;Before return\u0026#34;)\u003cbr/\u003e        return // Exits from main()!\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;After\u0026#34;) // ❌ This line won’t be reached\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e00b\"\u003eWhat if we pass the lambda elsewhere?\u003c/h2\u003e\u003cp id=\"49ee\"\u003eKotlin doesn’t allow non-local returns when the lambda is called in another context (like inside another function). That’s where \u003ccode\u003ecrossinline\u003c/code\u003e comes in:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5074\"\u003einline fun safeExecute(crossinline block: () -\u0026gt; Unit) {\u003cbr/\u003e    runOnUiThread {\u003cbr/\u003e        block() // Treated like a regular lambda now\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"472a\"\u003e\u003ccode\u003ecrossinline\u003c/code\u003e \u003cstrong\u003epreserves performance\u003c/strong\u003e by inlining the lambda, but \u003cstrong\u003edisables non-local return\u003c/strong\u003e, making it safe to call from other scopes (threads, coroutines, etc.).\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2288\"\u003e\u003ccode\u003ereified\u003c/code\u003e: Keep Generic Type Info at Runtime\u003c/h2\u003e\u003cp id=\"5587\"\u003eIn the JVM, generics use \u003cstrong\u003etype erasure\u003c/strong\u003e — meaning the actual type of \u003ccode\u003eT\u003c/code\u003e is removed during compilation.\u003c/p\u003e\u003cp id=\"6c87\"\u003eThis was done to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3bf6\"\u003eKeep backward compatibility with older Java versions\u003c/li\u003e\u003cli id=\"0b03\"\u003eAvoid making the JVM more complex\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7061\"\u003eThat’s why this doesn’t work:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"39f7\"\u003efun \u0026lt;T\u0026gt; checkType(value: Any): Boolean {\u003cbr/\u003e    return value is T // ❌ Error: Cannot check for erased type\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b0d7\"\u003eBut when you make the function \u003ccode\u003einline\u003c/code\u003e and use \u003ccode\u003ereified\u003c/code\u003e, Kotlin remembers the type:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8837\"\u003einline fun \u0026lt;reified T\u0026gt; checkType(value: Any): Boolean {\u003cbr/\u003e    return value is T // ✅ Now this works!\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9843\"\u003eWhy \u003ccode\u003ereified\u003c/code\u003e Only Works with \u003ccode\u003einline\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"1180\"\u003eThe trick is that \u003ccode\u003einline\u003c/code\u003e copies the function body into the caller, which means the compiler knows the actual type of \u003ccode\u003eT\u003c/code\u003e at compile time.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"428b\"\u003e\u003ccode\u003e\u003cem\u003einline + reified\u003c/em\u003e\u003c/code\u003e\u003cem\u003e = “copy-paste the function with the real type filled in”\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"c50d\"\u003eWithout \u003ccode\u003einline\u003c/code\u003e, the function is compiled on its own — and type \u003ccode\u003eT\u003c/code\u003e is erased before runtime.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"ec2e\"\u003eQuick Summary\u003c/h2\u003e\u003cul\u003e\u003cli id=\"2ad1\"\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e — Reduces runtime overhead by inlining lambdas and function calls.\u003c/li\u003e\u003cli id=\"5fd9\"\u003e\u003ccode\u003e\u003cstrong\u003enoinline\u003c/strong\u003e\u003c/code\u003e — Prevents a lambda from being inlined; use it when you want to pass or store the lambda.\u003c/li\u003e\u003cli id=\"9910\"\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e — Disables \u003ccode\u003ereturn\u003c/code\u003e from exiting the outer function while still inlining the lambda.\u003c/li\u003e\u003cli id=\"882a\"\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e — Allows you to use the actual type \u003ccode\u003eT\u003c/code\u003e at runtime (only in \u003ccode\u003einline\u003c/code\u003e functions).\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e5cd\"\u003eWhen to Use (and When to Avoid)\u003c/h2\u003e\u003ch2 id=\"ec55\"\u003eUse \u003ccode\u003einline\u003c/code\u003e when:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"9db8\"\u003eYou want to remove lambda overhead\u003c/li\u003e\u003cli id=\"d926\"\u003eYou need non-local return\u003c/li\u003e\u003cli id=\"0a62\"\u003eThe function is small and used often\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e34e\"\u003eAvoid \u003ccode\u003einline\u003c/code\u003e when:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"157a\"\u003eThe function is large or complex\u003c/li\u003e\u003cli id=\"3ece\"\u003eIt’s called only occasionally\u003c/li\u003e\u003cli id=\"b112\"\u003eYou’re optimizing for binary size\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"e081\"\u003eIf you found this helpful, share it with someone preparing for Kotlin interviews — or let me know which part clicked best for you!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-12T14:34:23.824Z",
  "modifiedTime": null
}
