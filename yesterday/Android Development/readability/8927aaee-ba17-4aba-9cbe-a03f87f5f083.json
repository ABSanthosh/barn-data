{
  "id": "8927aaee-ba17-4aba-9cbe-a03f87f5f083",
  "title": "Android Use Cases: From Basic Implementation to Multi-Provider Systems",
  "link": "https://proandroiddev.com/android-use-cases-from-basic-implementation-to-multi-provider-systems-0dd8bf2eee03?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Tue, 11 Feb 2025 18:35:28 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "clean-code",
    "kotlin",
    "android",
    "androiddev",
    "android-app-development"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 27845,
  "excerpt": "SOLIDify and transform your Android codebase! Master Clean Architecture with practical Use Cases, smart Managers \u0026 bulletproof multi-provider systems.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "SOLIDify Your Android Architecture…1. IntroductionModern Kotlin (and Android) projects often embrace Clean Architecture to keep code well-structured and test-friendly. At its core, Clean Architecture emphasizes:Separating business logic from UI code, so each can change independently.Relying on interfaces or abstract classes to keep your system flexible and open to new implementations.Applying SOLID principles, including the Single Responsibility Principle (SRP), the Dependency Inversion Principle (DIP), and the Liskov Substitution Principle (LSP), to ensure your code remains maintainable as requirements grow.Where Use Cases fit in Clean Architecture?The Use Case is a key building block in this philosophy, representing one distinct operation that has a Single Responsibility to perform in your application.Just like other components in Clean Architecture, Use Cases follow the pattern where their interfaces are defined in the domain layer while their implementations reside in the data layer, serving multiple SOLID principles at once.Clean Architecture organizes these components into layers:The domain layer contains pure business logic, including Use Case interfaces and other abstractions. This is where we define what our Use Cases can do, without concerning ourselves with how they do it.The data layer provides concrete implementations, including Use Case implementations. This separation ensures we can modify how a Use Case works without touching its interface.The UI layer (or Presentation Layer) consumes the domain layer through dependency injection.As you can see, the Dependencies flow from the UI Layer to the Domain layer that contains business logic abstractions, and then the Data Layer dependencies are inverted to the Domain Layer in order to hide implementation details.That is exactly what the Dependency Inversion Principle (DIP) stands for which I extensively describe in this article, targeting Kotlin and the Android architecture, where I explain that Clean Architecture is DIP at scale.A common Dependency Inversion MisconceptionMany developers believe that the Dependency Inversion Principle (DIP) doesn’t truly invert dependency arrows as shown in architectural diagrams.They mistakenly think that dependencies should still point from the Domain Layer to the Data Layer, reasoning that we’re still using the Data Layer’s functionality through abstract calls instead of concrete calls.When using concretions, the arrows would indeed point from domain to data layer (domain → data), as the domain would depend directly on data layer implementations.However, DIP truly inverts this by having the domain layer define the interfaces that the data layer must implement. Now the arrows point inward (domain ← data), as the data layer depends on the domain’s abstractions. This is why we call it dependency “inversion” — we’ve literally inverted the direction of dependency!Article WalkthroughIn this article,we’ll begin by creating a simple, single Use Case, inject it with Koin, and demonstrate it in a ViewModel.Then, once we have multiple Use Cases for a domain feature, we’ll look at how to group them in a Manager class to avoid cluttering our ViewModels.Finally, we’ll walk through an example of how to handle multiple implementations of a single interface — think different payment providers — to showcase how LSP lets you swap or expand implementations without rewriting large chunks of your code.2. What Is a Use Case?A Use Case (also known as an Interactor) encapsulates one piece of business logic or one action your app performs. This is typically logic that:Shouldn’t be in your UI code, because mixing UI and business logic leads to difficulties in testing and maintenance.Doesn’t belong in your data-access layer (repositories, APIs), because that layer should focus on raw data operations rather than application-specific rules.By giving each operation its own Use Case, you achieve clarity, modularity, and testability. For instance, a FetchMemesUseCase does exactly one thing: fetch memes from some data source.Why Use Cases MatterImagine you’re building a new feature. Without Use Cases, you might code your logic straight into a ViewModel or an Activity. That may be fine for a tiny project, but as the application grows, you’ll end up with massive classes doing too much.Use Cases remove that complexity from the UI layer. They also make your domain logic more flexible. If you need to change how memes are fetched — maybe from a REST API to a local database — your UI code remains untouched, because the Use Case interface doesn’t change.Use Cases and DIPWhen you write a Use Case, you typically inject use-case abstractions (e.g., an interface for a repository), not concrete classes. This is Dependency Inversion in action: your Use Case depends on a repository interface rather than a specific implementation. That way, your business logic remains stable even if you swap a REST-based repository for a local database.Summary: Key Points on Use CasesSingle Responsibility: Each Use Case has one job.Simplicity: Avoids bloating UI or data layers with app-specific rules.Testability: Easy to unit-test because it’s UI-agnostic.DIP: Depends on interfaces, not concrete classes, for extensibility.3. Implementing a Simple Use CaseLet’s begin our scenario with a simple example: fetching memes. Although our final scenario will cover a more advanced example (payments), the process for building a simple Use Case remains the same.Creating the Interfaceinterface FetchMemesUseCase { suspend operator fun invoke(): List\u003cMeme\u003e}This says: “A class that implements FetchMemesUseCase must provide a suspend function called invoke that returns a list of Meme.”Using the operator fun invoke() syntax allows calling this Use Case just like a function (e.g., fetchMemesUseCase()).Implementing the Use Caseclass FetchMemesUseCaseImpl( private val memeRepository: MemeRepository) : FetchMemesUseCase { override suspend operator fun invoke(): List\u003cMeme\u003e { return memeRepository.fetchMemes() }}We inject a MemeRepository to handle the data operations.FetchMemesUseCaseImpl has no references to Activities, Fragments, or even ViewModels. This keeps it UI-agnostic, perfect for testing.Repository and Modelinterface MemeRepository { suspend fun fetchMemes(): List\u003cMeme\u003e}class MemeRepositoryImpl( private val memeApi: MemeApi) : MemeRepository { override suspend fun fetchMemes(): List\u003cMeme\u003e { return memeApi.getMemes() // Hypothetical network call }}data class Meme( val id: Int, val title: String, val imageUrl: String)Here, MemeRepositoryImpl focuses on fetching data from the memeApi. The rest of the app doesn’t care how fetchMemes() is fulfilled, as long as it returns a list of Meme.Summary: Simple Use Case ImplementationInterface-first approach: Start with an interface (e.g., FetchMemesUseCase)Implementation: Keep business logic separate from UI frameworks.Repository: Hides data-fetch details (API calls, DB queries).4. Injecting Use Cases with KoinKoin is a popular dependency injection library in Kotlin. It helps us declare how to build our classes without manually writing a bunch of boilerplate “wiring” code. This perfectly aligns with DIP, since we’ll configure Koin to inject interfaces rather than concrete implementations.Domain Moduleval domainModule = module { single\u003cMemeRepository\u003e { MemeRepositoryImpl(get()) } factory\u003cFetchMemesUseCase\u003e { FetchMemesUseCaseImpl(get()) }}Note: We declare a single instance (single) for MemeRepository but use factory for FetchMemesUseCase—depending on usage patterns, you might prefer one or the other.Why single for MemeRepository?Typically, a repository manages data sources (network, database) or caching. Having only one repository instance (single) prevents repeatedly creating resource-heavy connections or caches.Why factory for FetchMemesUseCase?Use Cases often perform quick actions and don’t hold much state. Defining them with factory means you get a new Use Case instance each time it’s injected, which is fine if it’s lightweight and stateless. In some apps, this helps ensure each usage starts fresh, avoiding any stale data or side effects if a Use Case had internal state.When to use single and when factory?In production code, repositories can be expensive or thread-sensitive, so you usually keep a single shared instance; whereas Use Cases might be ephemeral and can safely be a fresh instance each time.5. Using the Use Case in a ViewModelNow let’s see how we can invoke our Use Case from an Android ViewModel, keeping the ViewModel’s responsibility squarely in managing UI state.class MemeListViewModel( private val fetchMemesUseCase: FetchMemesUseCase) : ViewModel() { private val _memes = MutableStateFlow\u003cList\u003cMeme\u003e\u003e(emptyList()) val memes: StateFlow\u003cList\u003cMeme\u003e\u003e = _memes fun loadMemes() { viewModelScope.launch { try { // Thanks to operator fun invoke(), we call it like a function val memeList = fetchMemesUseCase() _memes.value = memeList } catch (e: Exception) { // Handle error gracefully } } }}Dependency Inversion remains intact; this ViewModel only depends on FetchMemesUseCase, an interface.6. Combining Similar Use Cases into a ManagerAs your app grows, you might have multiple Use Cases focused on the same domain — like fetching, deleting, or sharing memes. Injecting them all directly into a single ViewModel might feel unwieldy.Introducing a ManagerA Manager (sometimes called a facade) groups multiple Use Cases for a related domain. To further enforce DIP, we can define a Manager interface and a Manager implementation:// 1) Define the interfaceinterface MemeManager { // Direct delegations to Use Cases suspend fun fetchMemes(): List\u003cMeme\u003e suspend fun deleteMemes(ids: Set\u003cInt\u003e) suspend fun toggleFavorite(memeId: Int)}// 2) Provide a concrete implementationclass MemeManagerImpl( private val fetchMemesUseCase: FetchMemesUseCase, private val deleteMemesUseCase: DeleteMemesUseCase, private val toggleFavoriteUseCase: ToggleFavoriteUseCase) : MemeManager { override suspend fun fetchMemes(): List\u003cMeme\u003e { // Manager calls the underlying Use Case return fetchMemesUseCase() } override suspend fun deleteMemes(ids: Set\u003cInt\u003e) { deleteMemesUseCase(ids) } override suspend fun toggleFavorite(memeId: Int) { toggleFavoriteUseCase(memeId) }}By doing so, your ViewModel or DI system can rely on MemeManager (the interface), not the concrete MemeManagerImpl. This adheres to DIP at the \"manager\" layer as well.The Manager maintains Single Responsibility by focusing solely on delegating to domain-specific Use Cases. The Manager doesn't contain business logic (that belongs in Use Cases) or UI logic (that belongs in ViewModels) — it simply delegates operations to the appropriate Use Case.Through the interface, we expose all Use Case operations in a unified interface, allowing the ViewModel to work with a single dependency while remaining unaware of the concrete implementations.Using the Manager in the ViewModelclass MemeListViewModel( private val memeManager: MemeManager // We depend on the interface) : ViewModel() { fun loadMemes() { viewModelScope.launch { val memes = memeManager.fetchMemes() // ... } }}You can now inject MemeManager just like any other interface:val managerModule = module { factory\u003cMemeManager\u003e { MemeManagerImpl(get(), get(), get()) }}Combine this module with your other modules in Koin to complete the setup.Single Responsibility Stays IntactEach Use Case still has one job (fetch, delete, toggle). The Manager just wraps them together, simplifying the ViewModel’s constructor.Because you have a Manager interface, the higher-level code doesn’t depend on a concrete manager implementation — further ensuring DIP.Manager class DrawbacksHowever, be mindful that overusing Managers can sometimes hide complexity rather than reduce it. If a Manager tries to handle too many Use Cases, you might just shift bloat from your ViewModels into the Manager layer.Summary on the Manager PatternWe introduced the Manager pattern to bundle multiple Use Cases under one interface. This approach simplifies our ViewModels but also preserves clarity around each single-responsibility Use Case.Manager Pattern Pros:Fewer constructor params in ViewModelsSingle interface per domainClear separation of concernsSimple Delegation PatternTip: Keep a close eye on each Manager’s scope to ensure SRP isn’t violatedAnd don’t foget, according to Clean Architecture principles, the Manager should NOT contain business logic.Its job is to only- Group related Use Cases- Provide a simpler interface to the ViewModel- Handle orchestration between Use Cases if needed7. Multiple Implementations Example: Liskov Substitution Principle by exampleEven with a Manager approach, you may need to support multiple implementations of the same set of actions (charging, verifying, refunding). That’s where the Liskov Substitution Principle (LSP) truly shines: each provider (Stripe, PayPal, etc.) implements the same interfaces in their own way, and your higher-level code remains unchanged.Payments Example: Multiple Use Case Providers + Manager classLet’s look at a real-world scenario — a payment system that needs to support multiple payment providers (like PayPal, Stripe, Klarna, etc).To manage these different implementations efficiently, we’ll introduce a container pattern that groups related Use Cases for each provider. This approach allows us to handle providers that might not support all operations while maintaining a clean interface.The big thing here is we can pack several different implementations of the same Use Cases under different providers to the same Manager and still preserve all the SOLID Principles.Let’s see how this all comes together in the following diagram, which shows the complete architecture from ViewModel to concrete implementations which allows to scale or swap providers without rewriting large chunks of code:You can scale or swap providers without rewriting large chunks of code.The above diagram illustrates the complete architecture of our payment system:PaymentViewModel only depends on the PaymentManager interfacePaymentManagerImpl uses a Map to select the appropriate payment providerEach provider (Stripe, PayPal, Square) implements the same set of use cases differently for each providerThe architecture allows easy addition of new payment providers without changing existing codeNote: StripeChargeUseCase should be StripeChargePaymentUseCase and so on, but to make the graphic fit to the width of this article, deliberately removed the “Payment” keyword from all Use Case implementations.Let’s examine each component in detail…7.1 Defining Payment Use CasesWe’ll define three Use Case interfaces — charge, verify, refund — plus a model for the result:interface ChargePaymentUseCase { suspend operator fun invoke(amount: Double, currency: String): PaymentResult}interface VerifyPaymentUseCase { suspend operator fun invoke(paymentId: String): Boolean}interface RefundPaymentUseCase { suspend operator fun invoke(paymentId: String, amount: Double): PaymentResult}data class PaymentResult( val success: Boolean, val transactionId: String? = null, val errorMessage: String? = null)SRP: We have three different interfaces, each dedicated to a single action.This promotes the Single Responsibility Principle (SRP) by splitting each action into its own Use Case. It also aligns with the Interface Segregation Principle (ISP): you define only the functions from the interfaces that each action requires. For example, if a provider doesn’t need to implement verification, it can simply exclude the VerifyPaymentUseCase.A Note on ISPSome providers may not implement all actions (e.g., no verify). Thanks to Interface Segregation, each provider implements only the interfaces it needs. No client is forced to depend on methods it doesn’t use.7.2 Payment Provider ImplementationsNow, each payment provider implements these Use Cases according to its rules. Below are simplified Stripe and PayPal examples.Stripe Implementationclass StripeChargePaymentUseCase : ChargePaymentUseCase { override suspend fun invoke(amount: Double, currency: String): PaymentResult { // Hypothetical Stripe API call return PaymentResult( success = true, transactionId = \"stripe_tx_12345\" ) }}class StripeVerifyPaymentUseCase : VerifyPaymentUseCase { override suspend fun invoke(paymentId: String): Boolean { // Verify with Stripe return true }}class StripeRefundPaymentUseCase : RefundPaymentUseCase { override suspend fun invoke(paymentId: String, amount: Double): PaymentResult { // Refund via Stripe return PaymentResult(success = true, transactionId = \"stripe_ref_67890\") }}PayPal Implementationclass PayPalChargePaymentUseCase : ChargePaymentUseCase { override suspend fun invoke(amount: Double, currency: String): PaymentResult { // Hypothetical PayPal API call return PaymentResult( success = true, transactionId = \"paypal_tx_ABC\" ) }}class PayPalVerifyPaymentUseCase : VerifyPaymentUseCase { override suspend fun invoke(paymentId: String): Boolean { // Verify with PayPal return false // Let's say it fails }}class PayPalRefundPaymentUseCase : RefundPaymentUseCase { override suspend fun invoke(paymentId: String, amount: Double): PaymentResult { // Refund via PayPal return PaymentResult(success = false, errorMessage = \"Refund failed\") }}We can keep going with other providers, e.g., CreditCardChargePaymentUseCase.7.3 Grouping Provider-Specific Use Cases into a ContainerInstead of injecting three separate Use Cases (charge/verify/refund) per provider into a constructor, we can create a container for each provider’s Use Cases:class PaymentProviderUseCases( val charge: ChargePaymentUseCase, val verify: VerifyPaymentUseCase?, val refund: RefundPaymentUseCase?)verify and refund can be nullable (null) if that provider doesn’t support them.Example:val stripeUseCases = PaymentProviderUseCases( charge = StripeChargePaymentUseCase(), verify = StripeVerifyPaymentUseCase(), refund = StripeRefundPaymentUseCase())val paypalUseCases = PaymentProviderUseCases( charge = PayPalChargePaymentUseCase(), verify = PayPalVerifyPaymentUseCase(), refund = PayPalRefundPaymentUseCase())(Some providers might not implement one or more actions; those can be null.)Summary: Provider ContainersLess constructor clutter: One container per provider.Null-safety: If a provider doesn’t implement an action, set it to null.LSP: Each provider “slot” can be swapped with another that implements the same interfaces.7.4 PaymentManager Using a MapNow, define one PaymentManager interface that the ViewModel will use. It has methods for charge, verify, and refund:interface PaymentManager { suspend fun charge(providerName: String, amount: Double, currency: String): PaymentResult suspend fun verify(providerName: String, paymentId: String): Boolean suspend fun refund(providerName: String, paymentId: String, amount: Double): PaymentResult}PaymentManagerImpl:We pass in a Map\u003cString, PaymentProviderUseCases\u003e, keyed by provider name—e.g. \"stripe\", \"paypal\", \"creditcard\". This ensures:Cleaner Constructor: We have one map, not multiple fields for each use case.Scalability: Adding a new provider is as simple as adding an entry to the map.class PaymentManagerImpl( private val providers: Map\u003cString, PaymentProviderUseCases\u003e) : PaymentManager { override suspend fun charge(providerName: String, amount: Double, currency: String): PaymentResult { // Retrieve the right provider's container, or handle unknown provider val useCases = providers[providerName.lowercase()] ?: return PaymentResult(false, errorMessage = \"Unknown provider: $providerName\") // Call the provider-specific ChargePaymentUseCase return useCases.charge(amount, currency) } override suspend fun verify(providerName: String, paymentId: String): Boolean { val useCases = providers[providerName.lowercase()] ?: return false // If no verify use case, we decide to return false or handle differently val verifyUC = useCases.verify ?: return false return verifyUC(paymentId) } override suspend fun refund(providerName: String, paymentId: String, amount: Double): PaymentResult { val useCases = providers[providerName.lowercase()] ?: return PaymentResult(false, errorMessage = \"Unknown provider: $providerName\") // If no refund use case, return an error val refundUC = useCases.refund ?: return PaymentResult(false, errorMessage = \"Refund not supported for $providerName\") return refundUC(paymentId, amount) }}Key Benefit: We avoid big when statements in the ViewModel, and we can add new providers just by populating the map.This map-based approach keeps code organized, avoids huge parameter lists, and naturally supports LSP (each provider can supply any subset of use cases, as needed).Advantages:Cleaner constructor: You only inject one map, not six or nine separate Use Cases.Easier to add providers: Construct a new PaymentProviderUseCases for each provider and put it in the map.Aligns with DIP: PaymentManagerImpl depends on interfaces for the Use Cases and a map of providers, not on a big chain of when or if statements.7.5 Providing the PaymentManager in KoinA typical Koin module might look like this:val paymentModule = module { // PaymentProviderUseCases instances for each provider single { PaymentProviderUseCases( charge = StripeChargePaymentUseCase(), verify = StripeVerifyPaymentUseCase(), refund = StripeRefundPaymentUseCase() ) } bind PaymentProviderUseCases::class named \"stripe\" single { PaymentProviderUseCases( charge = PayPalChargePaymentUseCase(), verify = PayPalVerifyPaymentUseCase(), refund = PayPalRefundPaymentUseCase() ) } bind PaymentProviderUseCases::class named \"paypal\" // Create a map of providerName -\u003e PaymentProviderUseCases single\u003cMap\u003cString, PaymentProviderUseCases\u003e\u003e { mapOf( \"stripe\" to get\u003cPaymentProviderUseCases\u003e(qualifier = named(\"stripe\")), \"paypal\" to get\u003cPaymentProviderUseCases\u003e(qualifier = named(\"paypal\")) ) } // Finally, provide our PaymentManager single\u003cPaymentManager\u003e { PaymentManagerImpl(get()) }}Here, we bind each PaymentProviderUseCases with a qualifier (named \"stripe\", \"paypal\") to differentiate them in the container.Then we construct the map for the PaymentManagerImpl.Because PaymentManagerImpl depends on a Map\u003cString, PaymentProviderUseCases\u003e, Koin will use that map.(The exact syntax may vary slightly depending on your Koin version.)7.6 Using PaymentManager in a ViewModelBelow is an updated PaymentViewModel with code comments clarifying how it obtains the correct payment type from PaymentManager:class PaymentViewModel( // DIP: We depend on the PaymentManager interface, not a concrete class private val paymentManager: PaymentManager) : ViewModel() { // Live data or StateFlow to hold charge results private val _chargeResult = MutableStateFlow\u003cPaymentResult?\u003e(null) val chargeResult: StateFlow\u003cPaymentResult?\u003e = _chargeResult /** * Charge a given provider for a certain amount in a given currency. * The PaymentManager looks up the correct ProviderUseCases in its map and calls 'charge'. */ fun charge(providerName: String, amount: Double, currency: String) { viewModelScope.launch { val result = paymentManager.charge(providerName, amount, currency) // Update our state flow with the result _chargeResult.value = result } } /** * Similarly, 'verify' and 'refund' can be invoked, each calling PaymentManager * which routes to the right use case for the selected provider. */ // fun verify(...) { ... } // fun refund(...) { ... }}Calling charge(\"stripe\", 50.0, \"USD\") instructs the manager to look up \"stripe\" in its map, retrieve the container of Stripe use cases, and invoke charge.If \"stripe\" is not found, or if the container is missing a given use case, the manager returns an appropriate error.Now, each payment action (charge, verify, refund) reduces to a Use Case with its own provider-specific implementation. The manager simply looks up the correct PaymentProviderUseCases in the map and calls the appropriate method.Thanks to LSP, you can drop in any new provider with its own container of Use Cases. The ViewModel or higher-level code only depends on PaymentManager, reinforcing DIP and ISP.8. ConclusionThroughout this article, we constructed a scenario showcasing Clean Architecture and Use Cases:We began with a simple Use Case (fetching memes) to illustrate how business logic can be encapsulated and injected into a ViewModel via Koin.Then, we combined multiple domain-specific Use Cases into a Manager class (with an interface + implementation) to enforce DIP at the Manager layer, showing how to group functionality without overloading your ViewModels.Lastly, we took a real-world style example — multiple payment Use Cases — to demonstrate the Liskov Substitution Principle in practice. Each payment provider (Stripe, PayPal, etc.) implements charge, verify, and refund in its own way, allowing your app to scale or change its payment logic without major refactoring.Key TakeawaysUse Cases keep your business logic separate from UI concerns, boosting testability and clarity.Manager classes (or facades) can simplify how your UI interacts with multiple Use Cases. By defining a Manager interface, you ensure your higher-level code depends on abstractions (DIP) rather than a specific implementation.LSP ensures that if you design an interface (or set of Use Cases) carefully, any provider can be substituted in, whether you’re dealing with Stripe, PayPal, or any interchangeable set of services.ISP is maintained because no provider is forced to implement methods it doesn’t need; each provider can pick and choose the relevant actions (charge, verify, refund).DIP is upheld at every layer (Use Cases, Repositories, Managers, and ViewModels), making the system easy to test, mock, and extend.Next StepsAdd Tests: Write unit tests for each Use Case (e.g., StripeChargePaymentUseCaseTest, PayPalVerifyPaymentUseCaseTest), mocking external dependencies like the API client. Consider using different test scenarios (time-outs, partial failures, etc.) to catch edge cases in each provider.Refine Error Handling: Consider returning a sealed class or Result type to handle successes and failures elegantly (especially for payment flows). Realistically test them by simulating network or provider-specific errors.Handle Implementation Challenges: Pay attention to how you structure your modules and manage versioning or changes in external APIs. For example, if Stripe updates its payment flow, ensure your StripeChargePaymentUseCase is easy to update without breaking other providers.Explore Other Principles: Look into Interface Segregation to further refine your interfaces and keep them minimal. This can be especially important if future providers support only partial functionality.Adapt the Manager Approach: If your Manager starts to become too large, consider splitting it or using patterns like Strategy or Mediator. Evaluate whether a single Manager still makes sense or if your domain calls for multiple specialized Managers.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*l2Ta0VPNJKpohDzG2CIfQw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--0dd8bf2eee03--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*CPyc3y-sp02vMh239V_suQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--0dd8bf2eee03--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp id=\"3c3f\"\u003e\u003cstrong\u003e\u003cem\u003eSOLIDify Your Android Architecture…\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a763\"\u003e1. Introduction\u003c/h2\u003e\u003cp id=\"6d69\"\u003eModern \u003cstrong\u003eKotlin\u003c/strong\u003e (and \u003cstrong\u003eAndroid\u003c/strong\u003e) projects often embrace \u003cstrong\u003eClean Architecture\u003c/strong\u003e to keep code well-structured and \u003cstrong\u003etest-friendly\u003c/strong\u003e. At its core, Clean Architecture emphasizes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"05d5\"\u003e\u003cstrong\u003eSeparating business logic from UI code\u003c/strong\u003e, so each can change independently.\u003c/li\u003e\u003cli id=\"3ce3\"\u003eRelying on \u003cstrong\u003einterfaces\u003c/strong\u003e or \u003cstrong\u003eabstract classes\u003c/strong\u003e to keep your system \u003cstrong\u003eflexible\u003c/strong\u003e and \u003cstrong\u003eopen\u003c/strong\u003e to new implementations.\u003c/li\u003e\u003cli id=\"a8b6\"\u003eApplying \u003cstrong\u003eSOLID principles\u003c/strong\u003e, including the \u003ca href=\"https://itnext.io/the-single-responsibility-principle-srp-in-kotlin-deep-dive-34f478064848\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSingle Responsibility Principle (SRP)\u003c/strong\u003e\u003c/a\u003e, the \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDependency Inversion Principle (DIP)\u003c/strong\u003e\u003c/a\u003e, and the \u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLiskov Substitution Principle (LSP)\u003c/strong\u003e\u003c/a\u003e, to ensure your code remains maintainable as requirements grow.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2dbd\"\u003eWhere Use Cases fit in Clean Architecture?\u003c/h2\u003e\u003cp id=\"9948\"\u003eThe \u003cstrong\u003eUse Case\u003c/strong\u003e is a key building block in this philosophy, representing one distinct operation that has a \u003ca href=\"https://itnext.io/the-single-responsibility-principle-srp-in-kotlin-deep-dive-34f478064848\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSingle Responsibility\u003c/strong\u003e\u003c/a\u003e to perform in your application.\u003c/p\u003e\u003cp id=\"7f22\"\u003eJust like other components in Clean Architecture, Use Cases follow the pattern where their interfaces are defined in the domain layer while their implementations reside in the data layer, serving multiple SOLID principles at once.\u003c/p\u003e\u003cp id=\"aa66\"\u003e\u003cstrong\u003eClean Architecture\u003c/strong\u003e organizes these components into layers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a0bf\"\u003eThe \u003cstrong\u003edomain layer\u003c/strong\u003e contains pure business logic, including Use Case interfaces and other abstractions. This is where we define what our Use Cases can do, without concerning ourselves with how they do it.\u003c/li\u003e\u003cli id=\"f2e8\"\u003eThe \u003cstrong\u003edata layer\u003c/strong\u003e provides concrete implementations, including Use Case implementations. This separation ensures we can modify how a Use Case works without touching its interface.\u003c/li\u003e\u003cli id=\"1e58\"\u003eThe \u003cstrong\u003eUI layer\u003c/strong\u003e (or Presentation Layer) consumes the domain layer through dependency injection.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"51cc\"\u003eAs you can see, the Dependencies flow from the UI Layer to the Domain layer that contains business logic abstractions, and then the Data Layer dependencies are inverted to the Domain Layer in order to hide implementation details.\u003c/p\u003e\u003cp id=\"c153\"\u003eThat is exactly what the \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDependency Inversion Principle (DIP)\u003c/a\u003e stands for which I extensively describe in \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis article\u003c/a\u003e, targeting Kotlin and the Android architecture, where I explain that \u003cstrong\u003eClean Architecture is \u003c/strong\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e at scale\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"6160\"\u003eA common Dependency Inversion Misconception\u003c/h2\u003e\u003cp id=\"910c\"\u003eMany developers believe that the \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDependency Inversion Principle (DIP)\u003c/a\u003e doesn’t truly invert dependency arrows as shown in architectural diagrams.\u003c/p\u003e\u003cp id=\"5b7a\"\u003eThey mistakenly think that dependencies should still point from the Domain Layer to the Data Layer, reasoning that we’re still using the Data Layer’s functionality through abstract calls instead of concrete calls.\u003c/p\u003e\u003cp id=\"aef9\"\u003eWhen using concretions, the arrows would indeed point from domain to data layer (domain → data), as the domain would depend directly on data layer implementations.\u003c/p\u003e\u003cp id=\"ccc4\"\u003eHowever, \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDIP\u003c/a\u003e truly inverts this by having the domain layer define the interfaces that the data layer must implement. Now the arrows point inward (domain ← data), as the data layer depends on the domain’s abstractions. This is why we call it dependency “inversion” — we’ve literally inverted the direction of dependency!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9d01\"\u003eArticle Walkthrough\u003c/h2\u003e\u003cp id=\"f9a8\"\u003eIn this article,\u003c/p\u003e\u003cul\u003e\u003cli id=\"3e78\"\u003ewe’ll begin by creating a \u003cstrong\u003esimple, single Use Case\u003c/strong\u003e, inject it with \u003cstrong\u003eKoin\u003c/strong\u003e, and demonstrate it in a \u003cstrong\u003eViewModel\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"ed68\"\u003eThen, once we have multiple Use Cases for a domain feature, we’ll look at how to \u003cstrong\u003egroup\u003c/strong\u003e them in a \u003cstrong\u003eManager\u003c/strong\u003e class to \u003cstrong\u003eavoid cluttering\u003c/strong\u003e our ViewModels.\u003c/li\u003e\u003cli id=\"9a82\"\u003eFinally, we’ll walk through an example of how to handle \u003cstrong\u003emultiple implementations\u003c/strong\u003e of a single interface — think different payment providers — to showcase how \u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLSP\u003c/strong\u003e\u003c/a\u003e lets you swap or expand implementations \u003cstrong\u003ewithout rewriting\u003c/strong\u003e large chunks of your code.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7ae4\"\u003e2. What Is a Use Case?\u003c/h2\u003e\u003cp id=\"326b\"\u003eA \u003cstrong\u003eUse Case\u003c/strong\u003e (also known as an \u003cstrong\u003eInteractor\u003c/strong\u003e) encapsulates \u003cstrong\u003eone piece of business logic\u003c/strong\u003e or \u003cstrong\u003eone action\u003c/strong\u003e your app performs. This is typically logic that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0902\"\u003e\u003cstrong\u003eShouldn’t\u003c/strong\u003e be in your UI code, because mixing UI and business logic leads to \u003cstrong\u003edifficulties in testing\u003c/strong\u003e and \u003cstrong\u003emaintenance\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"0a1c\"\u003e\u003cstrong\u003eDoesn’t\u003c/strong\u003e belong in your data-access layer (repositories, APIs), because that layer should focus on \u003cstrong\u003eraw data operations\u003c/strong\u003e rather than \u003cstrong\u003eapplication-specific rules\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fb31\"\u003eBy giving each operation its own \u003cstrong\u003eUse Case\u003c/strong\u003e, you achieve \u003cstrong\u003eclarity\u003c/strong\u003e, \u003cstrong\u003emodularity\u003c/strong\u003e, and \u003cstrong\u003etestability\u003c/strong\u003e. For instance, a \u003ccode\u003eFetchMemesUseCase\u003c/code\u003e does exactly one thing: \u003cstrong\u003efetch memes\u003c/strong\u003e from some data source.\u003c/p\u003e\u003ch2 id=\"2703\"\u003eWhy Use Cases Matter\u003c/h2\u003e\u003cp id=\"72d3\"\u003eImagine you’re building a new feature. \u003cstrong\u003eWithout\u003c/strong\u003e Use Cases, you might code your logic straight into a \u003cstrong\u003eViewModel\u003c/strong\u003e or an \u003cstrong\u003eActivity\u003c/strong\u003e. That may be fine for a tiny project, but as the application grows, you’ll end up with \u003cstrong\u003emassive classes\u003c/strong\u003e doing \u003cstrong\u003etoo much\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"3564\"\u003eUse Cases remove that \u003cstrong\u003ecomplexity\u003c/strong\u003e from the UI layer. They also make your \u003cstrong\u003edomain logic\u003c/strong\u003e more \u003cstrong\u003eflexible\u003c/strong\u003e. If you need to \u003cstrong\u003echange how memes are fetched\u003c/strong\u003e — maybe from a REST API to a local database — your UI code remains untouched, because the Use Case \u003cstrong\u003einterface\u003c/strong\u003e doesn’t change.\u003c/p\u003e\u003ch2 id=\"67fa\"\u003e\u003cstrong\u003eUse Cases and DIP\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"ab04\"\u003eWhen you write a Use Case, you typically inject use-case \u003cstrong\u003eabstractions\u003c/strong\u003e (e.g., an interface for a repository), \u003cstrong\u003enot\u003c/strong\u003e concrete classes. This is \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDependency Inversion\u003c/strong\u003e\u003c/a\u003e in action: your Use Case depends on a repository interface rather than a specific implementation. That way, your business logic remains stable even if you swap a REST-based repository for a local database.\u003c/p\u003e\u003ch2 id=\"39ec\"\u003eSummary: Key Points on Use Cases\u003c/h2\u003e\u003cul\u003e\u003cli id=\"486b\"\u003e\u003cstrong\u003eSingle Responsibility\u003c/strong\u003e: Each Use Case has one job.\u003c/li\u003e\u003cli id=\"81a8\"\u003e\u003cstrong\u003eSimplicity\u003c/strong\u003e: Avoids bloating UI or data layers with app-specific rules.\u003c/li\u003e\u003cli id=\"f8ff\"\u003e\u003cstrong\u003eTestability\u003c/strong\u003e: Easy to unit-test because it’s UI-agnostic.\u003c/li\u003e\u003cli id=\"b69b\"\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e: Depends on interfaces, not concrete classes, for extensibility.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c03d\"\u003e3. Implementing a Simple Use Case\u003c/h2\u003e\u003cp id=\"5885\"\u003eLet’s begin our scenario with a \u003cstrong\u003esimple example\u003c/strong\u003e: \u003cstrong\u003efetching memes\u003c/strong\u003e. Although our final scenario will cover a more advanced example (payments), the process for building a simple Use Case remains the same.\u003c/p\u003e\u003ch2 id=\"bab0\"\u003e\u003cstrong\u003eCreating the Interface\u003c/strong\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"7ee5\"\u003einterface FetchMemesUseCase {\u003cbr/\u003e    suspend operator fun invoke(): List\u0026lt;Meme\u0026gt;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9e83\"\u003eThis says: “A class that implements \u003ccode\u003eFetchMemesUseCase\u003c/code\u003e must provide a \u003cstrong\u003esuspend\u003c/strong\u003e function called \u003ccode\u003einvoke\u003c/code\u003e that returns a list of \u003ccode\u003eMeme\u003c/code\u003e.”\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"da7b\"\u003e\u003cem\u003eUsing the \u003c/em\u003e\u003ccode\u003e\u003cem\u003eoperator fun invoke()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e syntax allows calling this Use Case just like a function (e.g., \u003c/em\u003e\u003ccode\u003e\u003cem\u003efetchMemesUseCase()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e).\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"1ee0\"\u003eImplementing the Use Case\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"98d3\"\u003eclass FetchMemesUseCaseImpl(\u003cbr/\u003e    private val memeRepository: MemeRepository\u003cbr/\u003e) : FetchMemesUseCase {\u003cp\u003e    override suspend operator fun invoke(): List\u0026lt;Meme\u0026gt; {\u003cbr/\u003e        return memeRepository.fetchMemes()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"184f\"\u003eWe \u003cstrong\u003einject\u003c/strong\u003e a \u003ccode\u003eMemeRepository\u003c/code\u003e to handle the data operations.\u003c/li\u003e\u003cli id=\"58da\"\u003e\u003ccode\u003eFetchMemesUseCaseImpl\u003c/code\u003e has \u003cstrong\u003eno references\u003c/strong\u003e to Activities, Fragments, or even ViewModels. This keeps it \u003cstrong\u003eUI-agnostic\u003c/strong\u003e, perfect for \u003cstrong\u003etesting\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6260\"\u003eRepository and Model\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"1b4a\"\u003einterface MemeRepository {\u003cbr/\u003e    suspend fun fetchMemes(): List\u0026lt;Meme\u0026gt;\u003cbr/\u003e}\u003cp\u003eclass MemeRepositoryImpl(\u003cbr/\u003e    private val memeApi: MemeApi\u003cbr/\u003e) : MemeRepository {\u003c/p\u003e\u003cp\u003e    override suspend fun fetchMemes(): List\u0026lt;Meme\u0026gt; {\u003cbr/\u003e        return memeApi.getMemes() // Hypothetical network call\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003edata class Meme(\u003cbr/\u003e    val id: Int,\u003cbr/\u003e    val title: String,\u003cbr/\u003e    val imageUrl: String\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0033\"\u003eHere, \u003ccode\u003eMemeRepositoryImpl\u003c/code\u003e focuses on \u003cstrong\u003efetching data\u003c/strong\u003e from the \u003ccode\u003ememeApi\u003c/code\u003e. The rest of the app doesn’t care \u003cstrong\u003ehow\u003c/strong\u003e \u003ccode\u003efetchMemes()\u003c/code\u003e is fulfilled, as long as it returns a list of \u003ccode\u003eMeme\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"a686\"\u003eSummary: Simple Use Case Implementation\u003c/h2\u003e\u003cul\u003e\u003cli id=\"ae00\"\u003e\u003cstrong\u003eInterface-first approach\u003c/strong\u003e: Start with an interface (e.g., \u003ccode\u003eFetchMemesUseCase\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"712c\"\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e: Keep business logic separate from UI frameworks.\u003c/li\u003e\u003cli id=\"3722\"\u003e\u003cstrong\u003eRepository\u003c/strong\u003e: Hides data-fetch details (API calls, DB queries).\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"747b\"\u003e4. Injecting Use Cases with Koin\u003c/h2\u003e\u003cp id=\"5f2b\"\u003e\u003ca href=\"https://insert-koin.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKoin\u003c/a\u003e is a popular \u003cstrong\u003edependency injection\u003c/strong\u003e library in Kotlin. It helps us \u003cstrong\u003edeclare\u003c/strong\u003e how to build our classes without manually writing a bunch of boilerplate “wiring” code. \u003cstrong\u003eThis perfectly aligns with \u003c/strong\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e, since we’ll configure Koin to inject \u003cstrong\u003einterfaces\u003c/strong\u003e rather than \u003cstrong\u003econcrete\u003c/strong\u003e implementations.\u003c/p\u003e\u003ch2 id=\"49ac\"\u003eDomain Module\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"79dc\"\u003eval domainModule = module {\u003cbr/\u003e    single\u0026lt;MemeRepository\u0026gt; { MemeRepositoryImpl(get()) }\u003cbr/\u003e    factory\u0026lt;FetchMemesUseCase\u0026gt; { FetchMemesUseCaseImpl(get()) }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5d96\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e We declare a single instance (\u003ccode\u003esingle\u003c/code\u003e) for \u003ccode\u003eMemeRepository\u003c/code\u003e but use \u003ccode\u003efactory\u003c/code\u003e for \u003ccode\u003eFetchMemesUseCase\u003c/code\u003e—depending on usage patterns, you might prefer one or the other.\u003c/p\u003e\u003cul\u003e\u003cli id=\"9778\"\u003e\u003cstrong\u003eWhy \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003esingle\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMemeRepository\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e?\u003c/strong\u003e\u003cbr/\u003eTypically, a repository manages data sources (network, database) or caching. Having only \u003cstrong\u003eone\u003c/strong\u003e repository instance (\u003ccode\u003esingle\u003c/code\u003e) prevents repeatedly creating resource-heavy connections or caches.\u003c/li\u003e\u003cli id=\"eade\"\u003e\u003cstrong\u003eWhy \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003efactory\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eFetchMemesUseCase\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e?\u003c/strong\u003e\u003cbr/\u003eUse Cases often perform quick actions and don’t hold much state. Defining them with \u003ccode\u003efactory\u003c/code\u003e means you get a \u003cstrong\u003enew\u003c/strong\u003e Use Case instance each time it’s injected, which is fine if it’s lightweight and stateless. In some apps, this helps ensure each usage starts fresh, avoiding any stale data or side effects if a Use Case had internal state.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"180b\"\u003e\u003cstrong\u003eWhen to use \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003esingle\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and when \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003efactory\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e?\u003c/strong\u003e\u003cbr/\u003eIn production code, repositories can be expensive or thread-sensitive, so you usually keep a single shared instance; whereas Use Cases might be ephemeral and can safely be a fresh instance each time.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f70c\"\u003e5. Using the Use Case in a ViewModel\u003c/h2\u003e\u003cp id=\"aa06\"\u003eNow let’s see how we can \u003cstrong\u003einvoke\u003c/strong\u003e our Use Case from an \u003cstrong\u003eAndroid \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eViewModel\u003c/strong\u003e\u003c/code\u003e, keeping the ViewModel’s responsibility squarely in managing UI state.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5b21\"\u003eclass MemeListViewModel(\u003cbr/\u003e    private val fetchMemesUseCase: FetchMemesUseCase\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    private val _memes = MutableStateFlow\u0026lt;List\u0026lt;Meme\u0026gt;\u0026gt;(emptyList())\u003cbr/\u003e    val memes: StateFlow\u0026lt;List\u0026lt;Meme\u0026gt;\u0026gt; = _memes\u003c/p\u003e\u003cp\u003e    fun loadMemes() {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            try {\u003cbr/\u003e                // Thanks to operator fun invoke(), we call it like a function\u003cbr/\u003e                val memeList = fetchMemesUseCase()\u003cbr/\u003e                _memes.value = memeList\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                // Handle error gracefully\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d7a\"\u003eDependency Inversion remains intact; this \u003ccode\u003eViewModel\u003c/code\u003e only depends on \u003ccode\u003eFetchMemesUseCase\u003c/code\u003e, an interface.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f20e\"\u003e6. Combining Similar Use Cases into a Manager\u003c/h2\u003e\u003cp id=\"9cdd\"\u003eAs your app grows, you might have \u003cstrong\u003emultiple Use Cases\u003c/strong\u003e focused on the \u003cstrong\u003esame domain\u003c/strong\u003e — like \u003cstrong\u003efetching\u003c/strong\u003e, \u003cstrong\u003edeleting\u003c/strong\u003e, or \u003cstrong\u003esharing\u003c/strong\u003e memes. Injecting them all directly into a single ViewModel might feel unwieldy.\u003c/p\u003e\u003ch2 id=\"2aaf\"\u003eIntroducing a Manager\u003c/h2\u003e\u003cp id=\"7a25\"\u003eA \u003cstrong\u003eManager\u003c/strong\u003e (sometimes called a \u003cstrong\u003efacade\u003c/strong\u003e) groups multiple Use Cases for a \u003cstrong\u003erelated\u003c/strong\u003e domain. To further \u003cstrong\u003eenforce \u003c/strong\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e, we can define a \u003cstrong\u003eManager interface\u003c/strong\u003e and a \u003cstrong\u003eManager implementation\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dac9\"\u003e// 1) Define the interface\u003cbr/\u003einterface MemeManager {\u003cbr/\u003e    // Direct delegations to Use Cases\u003cbr/\u003e    suspend fun fetchMemes(): List\u0026lt;Meme\u0026gt;\u003cbr/\u003e    suspend fun deleteMemes(ids: Set\u0026lt;Int\u0026gt;)\u003cbr/\u003e    suspend fun toggleFavorite(memeId: Int)\u003cbr/\u003e}\u003cp\u003e// 2) Provide a concrete implementation\u003cbr/\u003eclass MemeManagerImpl(\u003cbr/\u003e    private val fetchMemesUseCase: FetchMemesUseCase,\u003cbr/\u003e    private val deleteMemesUseCase: DeleteMemesUseCase,\u003cbr/\u003e    private val toggleFavoriteUseCase: ToggleFavoriteUseCase\u003cbr/\u003e) : MemeManager {\u003c/p\u003e\u003cp\u003e    override suspend fun fetchMemes(): List\u0026lt;Meme\u0026gt; {\u003cbr/\u003e        // Manager calls the underlying Use Case\u003cbr/\u003e        return fetchMemesUseCase()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun deleteMemes(ids: Set\u0026lt;Int\u0026gt;) {\u003cbr/\u003e        deleteMemesUseCase(ids)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun toggleFavorite(memeId: Int) {\u003cbr/\u003e        toggleFavoriteUseCase(memeId)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"34b7\"\u003eBy doing so, your \u003cstrong\u003eViewModel\u003c/strong\u003e or \u003cstrong\u003eDI\u003c/strong\u003e system can rely on \u003ccode\u003eMemeManager\u003c/code\u003e (the interface), not the concrete \u003ccode\u003eMemeManagerImpl\u003c/code\u003e. This adheres to \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e at the \u0026#34;manager\u0026#34; layer as well.\u003c/p\u003e\u003cp id=\"32bb\"\u003eThe Manager maintains \u003cstrong\u003eSingle Responsibility\u003c/strong\u003e by focusing solely on delegating to domain-specific Use Cases. The Manager doesn\u0026#39;t contain business logic (that belongs in Use Cases) or UI logic (that belongs in ViewModels) — it simply delegates operations to the appropriate Use Case.\u003c/p\u003e\u003cp id=\"8f42\"\u003eThrough the interface, we expose all Use Case operations in a unified interface, allowing the ViewModel to work with a single dependency while remaining unaware of the concrete implementations.\u003c/p\u003e\u003ch2 id=\"c27c\"\u003eUsing the Manager in the ViewModel\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"cb90\"\u003eclass MemeListViewModel(\u003cbr/\u003e    private val memeManager: MemeManager // We depend on the interface\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    fun loadMemes() {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            val memes = memeManager.fetchMemes()\u003cbr/\u003e            // ...\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0e7e\"\u003eYou can now \u003cstrong\u003einject\u003c/strong\u003e \u003ccode\u003eMemeManager\u003c/code\u003e just like any other interface:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2bda\"\u003eval managerModule = module {\u003cbr/\u003e    factory\u0026lt;MemeManager\u0026gt; { MemeManagerImpl(get(), get(), get()) }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8860\"\u003e\u003cem\u003eCombine this module with your other modules in Koin to complete the setup.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"94f3\"\u003eSingle Responsibility Stays Intact\u003c/h2\u003e\u003cp id=\"8145\"\u003eEach Use Case still has \u003cstrong\u003eone job\u003c/strong\u003e (fetch, delete, toggle). The Manager just wraps them together, simplifying the ViewModel’s constructor.\u003c/p\u003e\u003cp id=\"ac17\"\u003eBecause you have a \u003cstrong\u003eManager interface\u003c/strong\u003e, the higher-level code doesn’t depend on a concrete manager implementation — further ensuring \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDIP\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"694d\"\u003eManager class Drawbacks\u003c/h2\u003e\u003cp id=\"b859\"\u003eHowever, be mindful that \u003cstrong\u003eoverusing\u003c/strong\u003e Managers can sometimes hide complexity rather than reduce it. If a Manager tries to handle too many Use Cases, you might just shift bloat from your ViewModels \u003cem\u003einto\u003c/em\u003e the Manager layer.\u003c/p\u003e\u003ch2 id=\"95c0\"\u003eSummary on the Manager Pattern\u003c/h2\u003e\u003cp id=\"8b87\"\u003eWe introduced the Manager pattern to bundle multiple Use Cases under one interface. This approach simplifies our ViewModels but also preserves clarity around each \u003cstrong\u003esingle-responsibility\u003c/strong\u003e Use Case.\u003c/p\u003e\u003ch2 id=\"a9bd\"\u003e\u003cstrong\u003eManager Pattern Pros\u003c/strong\u003e:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"bc26\"\u003eFewer constructor params in ViewModels\u003c/li\u003e\u003cli id=\"0bb4\"\u003eSingle interface per domain\u003c/li\u003e\u003cli id=\"88dc\"\u003eClear separation of concerns\u003c/li\u003e\u003cli id=\"5ed9\"\u003eSimple Delegation Pattern\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9ac7\"\u003e\u003cstrong\u003eTip\u003c/strong\u003e: Keep a close eye on each Manager’s scope to ensure SRP isn’t violated\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"97fb\"\u003eAnd don’t foget, \u003cstrong\u003eaccording to Clean Architecture principles, the Manager should NOT contain business logic.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"8050\"\u003eIts job is to only\u003cbr/\u003e- Group related Use Cases\u003cbr/\u003e- Provide a simpler interface to the ViewModel\u003cbr/\u003e- Handle orchestration between Use Cases if needed\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b030\"\u003e7. Multiple Implementations Example: Liskov Substitution Principle by example\u003c/h2\u003e\u003cp id=\"3f27\"\u003eEven with a \u003cstrong\u003eManager\u003c/strong\u003e approach, you may need to support \u003cstrong\u003emultiple implementations\u003c/strong\u003e of the \u003cstrong\u003esame set of actions\u003c/strong\u003e (charging, verifying, refunding). That’s where the \u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLiskov Substitution Principle (LSP)\u003c/strong\u003e\u003c/a\u003e truly shines: each provider (Stripe, PayPal, etc.) implements the \u003cstrong\u003esame\u003c/strong\u003e interfaces in \u003cstrong\u003etheir own\u003c/strong\u003e way, and your higher-level code remains unchanged.\u003c/p\u003e\u003ch2 id=\"932d\"\u003ePayments Example: Multiple Use Case Providers + Manager class\u003c/h2\u003e\u003cp id=\"9a35\"\u003eLet’s look at a real-world scenario — a payment system that needs to support multiple payment providers (like PayPal, Stripe, Klarna, etc).\u003c/p\u003e\u003cp id=\"9672\"\u003eTo manage these different implementations efficiently, we’ll introduce a container pattern that groups related Use Cases for each provider. This approach allows us to handle providers that might not support all operations while maintaining a clean interface.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"457e\"\u003e\u003cstrong\u003eThe big thing here is we can pack several different implementations of the same Use Cases under different providers to the same Manager and still preserve all the SOLID Principles.\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e31b\"\u003eLet’s see how this all comes together in the following diagram, which shows the complete architecture from ViewModel to concrete implementations which allows to scale or swap providers without rewriting large chunks of code:\u003c/p\u003e\u003cp id=\"e8ee\"\u003eYou can scale or swap providers without rewriting large chunks of code.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1726\"\u003eThe above diagram illustrates the complete architecture of our payment system:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0a71\"\u003e\u003ccode\u003ePaymentViewModel\u003c/code\u003e only depends on the \u003ccode\u003ePaymentManager\u003c/code\u003e interface\u003c/li\u003e\u003cli id=\"195d\"\u003e\u003ccode\u003ePaymentManagerImpl\u003c/code\u003e uses a Map to select the appropriate payment provider\u003c/li\u003e\u003cli id=\"7580\"\u003eEach provider (Stripe, PayPal, Square) implements the same set of use cases differently for each provider\u003c/li\u003e\u003cli id=\"134f\"\u003eThe architecture allows easy addition of new payment providers without changing existing code\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"b382\"\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003ccode\u003eStripeChargeUseCase\u003c/code\u003e should be \u003ccode\u003eStripeChargePaymentUseCase\u003c/code\u003e and so on, but to make the graphic fit to the width of this article, deliberately removed the “Payment” keyword from all Use Case implementations.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"9514\"\u003eLet’s examine each component in detail…\u003c/p\u003e\u003ch2 id=\"44cc\"\u003e7.1 Defining Payment Use Cases\u003c/h2\u003e\u003cp id=\"3331\"\u003eWe’ll define three \u003cstrong\u003eUse Case\u003c/strong\u003e interfaces — \u003cstrong\u003echarge\u003c/strong\u003e, \u003cstrong\u003everify\u003c/strong\u003e, \u003cstrong\u003erefund\u003c/strong\u003e — plus a model for the result:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"94af\"\u003einterface ChargePaymentUseCase {\u003cbr/\u003e    suspend operator fun invoke(amount: Double, currency: String): PaymentResult\u003cbr/\u003e}\u003cp\u003einterface VerifyPaymentUseCase {\u003cbr/\u003e    suspend operator fun invoke(paymentId: String): Boolean\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einterface RefundPaymentUseCase {\u003cbr/\u003e    suspend operator fun invoke(paymentId: String, amount: Double): PaymentResult\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003edata class PaymentResult(\u003cbr/\u003e    val success: Boolean,\u003cbr/\u003e    val transactionId: String? = null,\u003cbr/\u003e    val errorMessage: String? = null\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7836\"\u003e\u003cstrong\u003e\u003cem\u003eSRP\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e: We have three different interfaces, each dedicated to a single action.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"20ae\"\u003eThis promotes the \u003ca href=\"https://itnext.io/the-single-responsibility-principle-srp-in-kotlin-deep-dive-34f478064848\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSingle Responsibility Principle (SRP)\u003c/strong\u003e\u003c/a\u003e by splitting each action into its own Use Case. It also aligns with the \u003cstrong\u003eI\u003c/strong\u003e\u003ca href=\"https://itnext.io/the-interface-segregation-principle-isp-solid-principles-deep-dive-in-kotlin-android-a3aed6d310e3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003enterface Segregation Principle (ISP)\u003c/strong\u003e\u003c/a\u003e: you define \u003cstrong\u003eonly\u003c/strong\u003e the functions from the interfaces that each action requires. For example, if a provider doesn’t need to implement verification, it can simply exclude the \u003ccode\u003eVerifyPaymentUseCase\u003c/code\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"3a3e\"\u003e\u003cstrong\u003eA Note on \u003c/strong\u003e\u003ca href=\"https://itnext.io/the-interface-segregation-principle-isp-solid-principles-deep-dive-in-kotlin-android-a3aed6d310e3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eISP\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"9a69\"\u003eSome providers may not implement all actions (e.g., no verify). Thanks to \u003ca href=\"https://itnext.io/the-interface-segregation-principle-isp-solid-principles-deep-dive-in-kotlin-android-a3aed6d310e3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eInterface Segregation\u003c/strong\u003e\u003c/a\u003e, each provider implements only the interfaces it needs. No client is forced to depend on methods it doesn’t use.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"99c7\"\u003e7.2 Payment Provider Implementations\u003c/h2\u003e\u003cp id=\"c616\"\u003eNow, each payment provider implements these Use Cases according to its rules. Below are simplified \u003cstrong\u003eStripe\u003c/strong\u003e and \u003cstrong\u003ePayPal\u003c/strong\u003e examples.\u003c/p\u003e\u003ch2 id=\"afb9\"\u003eStripe Implementation\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"fbe2\"\u003eclass StripeChargePaymentUseCase : ChargePaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(amount: Double, currency: String): PaymentResult {\u003cbr/\u003e        // Hypothetical Stripe API call\u003cbr/\u003e        return PaymentResult(\u003cbr/\u003e            success = true,\u003cbr/\u003e            transactionId = \u0026#34;stripe_tx_12345\u0026#34;\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003eclass StripeVerifyPaymentUseCase : VerifyPaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(paymentId: String): Boolean {\u003cbr/\u003e        // Verify with Stripe\u003cbr/\u003e        return true\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass StripeRefundPaymentUseCase : RefundPaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(paymentId: String, amount: Double): PaymentResult {\u003cbr/\u003e        // Refund via Stripe\u003cbr/\u003e        return PaymentResult(success = true, transactionId = \u0026#34;stripe_ref_67890\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"82d1\"\u003ePayPal Implementation\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0320\"\u003eclass PayPalChargePaymentUseCase : ChargePaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(amount: Double, currency: String): PaymentResult {\u003cbr/\u003e        // Hypothetical PayPal API call\u003cbr/\u003e        return PaymentResult(\u003cbr/\u003e            success = true,\u003cbr/\u003e            transactionId = \u0026#34;paypal_tx_ABC\u0026#34;\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003eclass PayPalVerifyPaymentUseCase : VerifyPaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(paymentId: String): Boolean {\u003cbr/\u003e        // Verify with PayPal\u003cbr/\u003e        return false // Let\u0026#39;s say it fails\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass PayPalRefundPaymentUseCase : RefundPaymentUseCase {\u003cbr/\u003e    override suspend fun invoke(paymentId: String, amount: Double): PaymentResult {\u003cbr/\u003e        // Refund via PayPal\u003cbr/\u003e        return PaymentResult(success = false, errorMessage = \u0026#34;Refund failed\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9e54\"\u003e\u003cem\u003eWe can keep going with other providers, e.g., \u003c/em\u003e\u003ccode\u003eCreditCardChargePaymentUseCase\u003c/code\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"9bb9\"\u003e7.3 Grouping Provider-Specific Use Cases into a Container\u003c/h2\u003e\u003cp id=\"9f49\"\u003eInstead of injecting three separate Use Cases (charge/verify/refund) per provider into a constructor, we can create a \u003cstrong\u003econtainer\u003c/strong\u003e for each provider’s Use Cases:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1a36\"\u003eclass PaymentProviderUseCases(\u003cbr/\u003e    val charge: ChargePaymentUseCase,\u003cbr/\u003e    val verify: VerifyPaymentUseCase?,\u003cbr/\u003e    val refund: RefundPaymentUseCase?\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"46b8\"\u003e\u003cstrong\u003everify\u003c/strong\u003e and \u003cstrong\u003erefund\u003c/strong\u003e can be nullable (\u003ccode\u003enull\u003c/code\u003e) if that provider doesn’t support them.\u003c/li\u003e\u003cli id=\"f194\"\u003eExample:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"9560\"\u003eval stripeUseCases = PaymentProviderUseCases(\u003cbr/\u003e    charge = StripeChargePaymentUseCase(),\u003cbr/\u003e    verify = StripeVerifyPaymentUseCase(),\u003cbr/\u003e    refund = StripeRefundPaymentUseCase()\u003cbr/\u003e)\u003cp\u003eval paypalUseCases = PaymentProviderUseCases(\u003cbr/\u003e    charge = PayPalChargePaymentUseCase(),\u003cbr/\u003e    verify = PayPalVerifyPaymentUseCase(),\u003cbr/\u003e    refund = PayPalRefundPaymentUseCase()\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"50b4\"\u003e\u003cem\u003e(Some providers might not implement one or more actions; those can be \u003c/em\u003e\u003ccode\u003e\u003cem\u003enull\u003c/em\u003e\u003c/code\u003e\u003cem\u003e.)\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"8d5c\"\u003eSummary: Provider Containers\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e2f6\"\u003e\u003cstrong\u003eLess constructor clutter\u003c/strong\u003e: One container per provider.\u003c/li\u003e\u003cli id=\"1663\"\u003e\u003cstrong\u003eNull-safety\u003c/strong\u003e: If a provider doesn’t implement an action, set it to \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"75c2\"\u003e\u003cstrong\u003eLSP\u003c/strong\u003e: Each provider “slot” can be swapped with another that implements the same interfaces.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e758\"\u003e7.4 PaymentManager Using a Map\u003c/h2\u003e\u003cp id=\"fc6f\"\u003eNow, define \u003cstrong\u003eone\u003c/strong\u003e \u003ccode\u003ePaymentManager\u003c/code\u003e interface that the ViewModel will use. It has methods for \u003ccode\u003e\u003cstrong\u003echarge\u003c/strong\u003e\u003c/code\u003e, \u003ccode\u003e\u003cstrong\u003everify\u003c/strong\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cstrong\u003erefund\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6f1f\"\u003einterface PaymentManager {\u003cbr/\u003e    suspend fun charge(providerName: String, amount: Double, currency: String): PaymentResult\u003cbr/\u003e    suspend fun verify(providerName: String, paymentId: String): Boolean\u003cbr/\u003e    suspend fun refund(providerName: String, paymentId: String, amount: Double): PaymentResult\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a637\"\u003e\u003ccode\u003ePaymentManagerImpl\u003c/code\u003e:\u003c/h2\u003e\u003cp id=\"c956\"\u003eWe pass in a \u003ccode\u003eMap\u0026lt;String, PaymentProviderUseCases\u0026gt;\u003c/code\u003e, keyed by \u003cstrong\u003eprovider name\u003c/strong\u003e—e.g. \u003ccode\u003e\u0026#34;stripe\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;paypal\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;creditcard\u0026#34;\u003c/code\u003e. This ensures:\u003c/p\u003e\u003col\u003e\u003cli id=\"9db6\"\u003e\u003cstrong\u003eCleaner Constructor\u003c/strong\u003e: We have \u003cstrong\u003eone\u003c/strong\u003e map, not multiple fields for each use case.\u003c/li\u003e\u003cli id=\"32b4\"\u003e\u003cstrong\u003eScalability\u003c/strong\u003e: Adding a new provider is as simple as adding an entry to the map.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"87e7\"\u003eclass PaymentManagerImpl(\u003cbr/\u003e    private val providers: Map\u0026lt;String, PaymentProviderUseCases\u0026gt;\u003cbr/\u003e) : PaymentManager {\u003cp\u003e    override suspend fun charge(providerName: String, amount: Double, currency: String): PaymentResult {\u003cbr/\u003e        // Retrieve the right provider\u0026#39;s container, or handle unknown provider\u003cbr/\u003e        val useCases = providers[providerName.lowercase()]\u003cbr/\u003e            ?: return PaymentResult(false, errorMessage = \u0026#34;Unknown provider: $providerName\u0026#34;)\u003c/p\u003e\u003cp\u003e        // Call the provider-specific ChargePaymentUseCase\u003cbr/\u003e        return useCases.charge(amount, currency)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun verify(providerName: String, paymentId: String): Boolean {\u003cbr/\u003e        val useCases = providers[providerName.lowercase()] ?: return false\u003c/p\u003e\u003cp\u003e        // If no verify use case, we decide to return false or handle differently\u003cbr/\u003e        val verifyUC = useCases.verify ?: return false\u003cbr/\u003e        return verifyUC(paymentId)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun refund(providerName: String, paymentId: String, amount: Double): PaymentResult {\u003cbr/\u003e        val useCases = providers[providerName.lowercase()]\u003cbr/\u003e            ?: return PaymentResult(false, errorMessage = \u0026#34;Unknown provider: $providerName\u0026#34;)\u003c/p\u003e\u003cp\u003e        // If no refund use case, return an error\u003cbr/\u003e        val refundUC = useCases.refund\u003cbr/\u003e            ?: return PaymentResult(false, errorMessage = \u0026#34;Refund not supported for $providerName\u0026#34;)\u003cbr/\u003e        return refundUC(paymentId, amount)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b5fc\"\u003e\u003cstrong\u003eKey Benefit\u003c/strong\u003e: We avoid big \u003ccode\u003ewhen\u003c/code\u003e statements in the \u003ccode\u003eViewModel\u003c/code\u003e, and we can add new providers \u003cem\u003ejust by populating the map\u003c/em\u003e.\u003c/p\u003e\u003cp id=\"761b\"\u003eThis \u003cstrong\u003emap-based\u003c/strong\u003e approach keeps code organized, avoids huge parameter lists, and naturally supports \u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLSP\u003c/a\u003e (each provider can supply \u003cstrong\u003eany\u003c/strong\u003e subset of use cases, as needed).\u003c/p\u003e\u003cp id=\"9276\"\u003e\u003cstrong\u003eAdvantages\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"08f6\"\u003e\u003cstrong\u003eCleaner constructor\u003c/strong\u003e: You only inject \u003cstrong\u003eone\u003c/strong\u003e map, not six or nine separate Use Cases.\u003c/li\u003e\u003cli id=\"3285\"\u003e\u003cstrong\u003eEasier to add providers\u003c/strong\u003e: Construct a new \u003ccode\u003ePaymentProviderUseCases\u003c/code\u003e for each provider and put it in the map.\u003c/li\u003e\u003cli id=\"c8e5\"\u003e\u003cstrong\u003eAligns with \u003c/strong\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e: \u003ccode\u003ePaymentManagerImpl\u003c/code\u003e depends on \u003cstrong\u003einterfaces\u003c/strong\u003e for the Use Cases and a map of providers, not on a big chain of \u003ccode\u003ewhen\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e statements.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"53e2\"\u003e7.5 Providing the PaymentManager in Koin\u003c/h2\u003e\u003cp id=\"5fee\"\u003eA typical Koin module might look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5aa5\"\u003eval paymentModule = module {\u003cbr/\u003e    // PaymentProviderUseCases instances for each provider\u003cbr/\u003e    single { \u003cbr/\u003e        PaymentProviderUseCases(\u003cbr/\u003e            charge = StripeChargePaymentUseCase(),\u003cbr/\u003e            verify = StripeVerifyPaymentUseCase(),\u003cbr/\u003e            refund = StripeRefundPaymentUseCase()\u003cbr/\u003e        )\u003cbr/\u003e    } bind PaymentProviderUseCases::class named \u0026#34;stripe\u0026#34;\u003cp\u003e    single { \u003cbr/\u003e        PaymentProviderUseCases(\u003cbr/\u003e            charge = PayPalChargePaymentUseCase(),\u003cbr/\u003e            verify = PayPalVerifyPaymentUseCase(),\u003cbr/\u003e            refund = PayPalRefundPaymentUseCase()\u003cbr/\u003e        )\u003cbr/\u003e    } bind PaymentProviderUseCases::class named \u0026#34;paypal\u0026#34;\u003c/p\u003e\u003cp\u003e    // Create a map of providerName -\u0026gt; PaymentProviderUseCases\u003cbr/\u003e    single\u0026lt;Map\u0026lt;String, PaymentProviderUseCases\u0026gt;\u0026gt; {\u003cbr/\u003e        mapOf(\u003cbr/\u003e            \u0026#34;stripe\u0026#34; to get\u0026lt;PaymentProviderUseCases\u0026gt;(qualifier = named(\u0026#34;stripe\u0026#34;)),\u003cbr/\u003e            \u0026#34;paypal\u0026#34; to get\u0026lt;PaymentProviderUseCases\u0026gt;(qualifier = named(\u0026#34;paypal\u0026#34;))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Finally, provide our PaymentManager\u003cbr/\u003e    single\u0026lt;PaymentManager\u0026gt; { PaymentManagerImpl(get()) }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"061f\"\u003eHere, we \u003cstrong\u003ebind\u003c/strong\u003e each \u003ccode\u003ePaymentProviderUseCases\u003c/code\u003e with a \u003cstrong\u003equalifier\u003c/strong\u003e (named \u003ccode\u003e\u0026#34;stripe\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;paypal\u0026#34;\u003c/code\u003e) to differentiate them in the container.\u003c/li\u003e\u003cli id=\"aee1\"\u003eThen we construct the \u003cstrong\u003emap\u003c/strong\u003e for the \u003ccode\u003ePaymentManagerImpl\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7985\"\u003eBecause \u003ccode\u003ePaymentManagerImpl\u003c/code\u003e depends on a \u003ccode\u003eMap\u0026lt;String, PaymentProviderUseCases\u0026gt;\u003c/code\u003e, Koin will use that map.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"02cf\"\u003e\u003cem\u003e(The exact syntax may vary slightly depending on your Koin version.)\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"30c5\"\u003e7.6 Using PaymentManager in a ViewModel\u003c/h2\u003e\u003cp id=\"bc8e\"\u003eBelow is an \u003cstrong\u003eupdated\u003c/strong\u003e \u003ccode\u003ePaymentViewModel\u003c/code\u003e with \u003cstrong\u003ecode comments\u003c/strong\u003e clarifying how it obtains the correct payment type from \u003ccode\u003ePaymentManager\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"96d0\"\u003eclass PaymentViewModel(\u003cbr/\u003e    // DIP: We depend on the PaymentManager interface, not a concrete class\u003cbr/\u003e    private val paymentManager: PaymentManager\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    // Live data or StateFlow to hold charge results\u003cbr/\u003e    private val _chargeResult = MutableStateFlow\u0026lt;PaymentResult?\u0026gt;(null)\u003cbr/\u003e    val chargeResult: StateFlow\u0026lt;PaymentResult?\u0026gt; = _chargeResult\u003c/p\u003e\u003cp\u003e    /**\u003cbr/\u003e     * Charge a given provider for a certain amount in a given currency.\u003cbr/\u003e     * The PaymentManager looks up the correct ProviderUseCases in its map and calls \u0026#39;charge\u0026#39;.\u003cbr/\u003e     */\u003cbr/\u003e    fun charge(providerName: String, amount: Double, currency: String) {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            val result = paymentManager.charge(providerName, amount, currency)\u003cbr/\u003e            // Update our state flow with the result\u003cbr/\u003e            _chargeResult.value = result\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        /**\u003cbr/\u003e     * Similarly, \u0026#39;verify\u0026#39; and \u0026#39;refund\u0026#39; can be invoked, each calling PaymentManager\u003cbr/\u003e     * which routes to the right use case for the selected provider.\u003cbr/\u003e     */\u003cbr/\u003e    // fun verify(...) { ... }\u003cbr/\u003e    // fun refund(...) { ... }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e9f8\"\u003e\u003cstrong\u003eCalling\u003c/strong\u003e \u003ccode\u003echarge(\u0026#34;stripe\u0026#34;, 50.0, \u0026#34;USD\u0026#34;)\u003c/code\u003e instructs the manager to \u003cstrong\u003elook up\u003c/strong\u003e \u003ccode\u003e\u0026#34;stripe\u0026#34;\u003c/code\u003e in its map, retrieve the container of Stripe use cases, and invoke \u003ccode\u003echarge\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e859\"\u003eIf \u003ccode\u003e\u0026#34;stripe\u0026#34;\u003c/code\u003e is not found, or if the container is missing a given use case, the manager returns an appropriate error.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"74e5\"\u003e\u003cstrong\u003eNow\u003c/strong\u003e, each payment action (charge, verify, refund) \u003cstrong\u003ereduces\u003c/strong\u003e to a \u003cstrong\u003eUse Case\u003c/strong\u003e with its own \u003cstrong\u003eprovider-specific\u003c/strong\u003e implementation. The manager simply \u003cstrong\u003elooks up\u003c/strong\u003e the correct \u003ccode\u003ePaymentProviderUseCases\u003c/code\u003e in the map and calls the appropriate method.\u003c/p\u003e\u003cp id=\"8596\"\u003eThanks to \u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLSP\u003c/strong\u003e\u003c/a\u003e, you can drop in any new provider with its own container of Use Cases. The \u003cstrong\u003eViewModel\u003c/strong\u003e or higher-level code only depends on \u003ccode\u003e\u003cstrong\u003ePaymentManager\u003c/strong\u003e\u003c/code\u003e, reinforcing \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e and \u003ca href=\"https://itnext.io/the-interface-segregation-principle-isp-solid-principles-deep-dive-in-kotlin-android-a3aed6d310e3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eISP\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"55f9\"\u003e8. Conclusion\u003c/h2\u003e\u003cp id=\"55e6\"\u003eThroughout this article, we \u003cstrong\u003econstructed\u003c/strong\u003e a scenario showcasing \u003cstrong\u003eClean Architecture\u003c/strong\u003e and \u003cstrong\u003eUse Cases\u003c/strong\u003e:\u003c/p\u003e\u003col\u003e\u003cli id=\"f467\"\u003eWe \u003cstrong\u003ebegan with a simple Use Case\u003c/strong\u003e (fetching memes) to illustrate how business logic can be encapsulated and injected into a \u003cstrong\u003eViewModel\u003c/strong\u003e via \u003cstrong\u003eKoin\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"fe54\"\u003eThen, we \u003cstrong\u003ecombined multiple\u003c/strong\u003e domain-specific Use Cases into a \u003cstrong\u003eManager\u003c/strong\u003e class (with an \u003cstrong\u003einterface\u003c/strong\u003e + \u003cstrong\u003eimplementation\u003c/strong\u003e) to enforce \u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e at the Manager layer, showing how to \u003cstrong\u003egroup functionality\u003c/strong\u003e without \u003cstrong\u003eoverloading\u003c/strong\u003e your ViewModels.\u003c/li\u003e\u003cli id=\"b504\"\u003eLastly, we took a \u003cstrong\u003ereal-world style\u003c/strong\u003e example — \u003cstrong\u003emultiple payment Use Cases\u003c/strong\u003e — to demonstrate the \u003cstrong\u003eLiskov Substitution Principle\u003c/strong\u003e in practice. Each payment provider (Stripe, PayPal, etc.) implements \u003cstrong\u003echarge, verify,\u003c/strong\u003e and \u003cstrong\u003erefund\u003c/strong\u003e in its own way, allowing your app to \u003cstrong\u003escale\u003c/strong\u003e or \u003cstrong\u003echange\u003c/strong\u003e its payment logic \u003cstrong\u003ewithout major refactoring\u003c/strong\u003e.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"ac72\"\u003eKey Takeaways\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6752\"\u003e\u003cstrong\u003eUse Cases\u003c/strong\u003e keep your \u003cstrong\u003ebusiness logic\u003c/strong\u003e separate from \u003cstrong\u003eUI concerns\u003c/strong\u003e, boosting \u003cstrong\u003etestability\u003c/strong\u003e and \u003cstrong\u003eclarity\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"eb56\"\u003e\u003cstrong\u003eManager classes (or facades)\u003c/strong\u003e can simplify how your UI interacts with multiple Use Cases. By defining a \u003cstrong\u003eManager interface\u003c/strong\u003e, you ensure your higher-level code depends on \u003cstrong\u003eabstractions\u003c/strong\u003e (\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDIP\u003c/a\u003e) rather than a specific implementation.\u003c/li\u003e\u003cli id=\"1d38\"\u003e\u003ca href=\"https://itnext.io/the-liskov-substitution-principle-lsp-in-kotlin-deep-dive-66b63d4ee244\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLSP\u003c/strong\u003e\u003c/a\u003e ensures that if you design an interface (or set of Use Cases) carefully, \u003cstrong\u003eany provider\u003c/strong\u003e can be substituted in, whether you’re dealing with Stripe, PayPal, or any interchangeable set of services.\u003c/li\u003e\u003cli id=\"1020\"\u003e\u003ca href=\"https://itnext.io/the-interface-segregation-principle-isp-solid-principles-deep-dive-in-kotlin-android-a3aed6d310e3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eISP\u003c/strong\u003e\u003c/a\u003e is maintained because no provider is \u003cstrong\u003eforced\u003c/strong\u003e to implement methods it doesn’t need; each provider can pick and choose the relevant actions (charge, verify, refund).\u003c/li\u003e\u003cli id=\"8524\"\u003e\u003ca href=\"https://itnext.io/the-dependency-inversion-principle-dip-solid-principles-deep-dive-in-kotlin-android-9b59883e5a7a\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e\u003c/a\u003e is upheld at \u003cstrong\u003eevery layer\u003c/strong\u003e (Use Cases, Repositories, Managers, and ViewModels), making the system easy to \u003cstrong\u003etest\u003c/strong\u003e, \u003cstrong\u003emock\u003c/strong\u003e, and \u003cstrong\u003eextend\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"53ac\"\u003eNext Steps\u003c/h2\u003e\u003cul\u003e\u003cli id=\"fc28\"\u003e\u003cstrong\u003eAdd Tests\u003c/strong\u003e: Write unit tests for each Use Case (e.g., \u003ccode\u003eStripeChargePaymentUseCaseTest\u003c/code\u003e, \u003ccode\u003ePayPalVerifyPaymentUseCaseTest\u003c/code\u003e), mocking external dependencies like the API client. Consider using different test scenarios (time-outs, partial failures, etc.) to catch edge cases in each provider.\u003c/li\u003e\u003cli id=\"7c43\"\u003e\u003cstrong\u003eRefine Error Handling\u003c/strong\u003e: Consider returning a sealed class or \u003ccode\u003eResult\u003c/code\u003e type to handle successes and failures elegantly (especially for payment flows). Realistically test them by simulating network or provider-specific errors.\u003c/li\u003e\u003cli id=\"72d2\"\u003e\u003cstrong\u003eHandle Implementation Challenges\u003c/strong\u003e: Pay attention to how you structure your modules and manage versioning or changes in external APIs. For example, if Stripe updates its payment flow, ensure your \u003ccode\u003eStripeChargePaymentUseCase\u003c/code\u003e is easy to update without breaking other providers.\u003c/li\u003e\u003cli id=\"3840\"\u003e\u003cstrong\u003eExplore Other Principles\u003c/strong\u003e: Look into Interface Segregation to further refine your interfaces and keep them minimal. This can be especially important if future providers support only partial functionality.\u003c/li\u003e\u003cli id=\"051a\"\u003e\u003cstrong\u003eAdapt the Manager Approach\u003c/strong\u003e: If your Manager starts to become too large, consider splitting it or using patterns like Strategy or Mediator. Evaluate whether a single Manager still makes sense or if your domain calls for multiple specialized Managers.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": "2025-02-11T18:35:28.236Z",
  "modifiedTime": null
}
