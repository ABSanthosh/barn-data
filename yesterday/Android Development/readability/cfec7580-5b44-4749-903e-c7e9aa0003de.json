{
  "id": "cfec7580-5b44-4749-903e-c7e9aa0003de",
  "title": "Extend your API‚Ää‚Äî‚Ääkeep Requests \u0026 Responses gzipped",
  "link": "https://proandroiddev.com/extend-your-api-keep-requests-responses-gzipped-66fbe32dd70c?source=rss----c72404660798---4",
  "description": "",
  "author": "Serhii Hryshyn",
  "published": "Sun, 16 Feb 2025 18:17:04 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android",
    "retrofit",
    "android-app-development",
    "compression"
  ],
  "byline": "Serhii Hryshyn",
  "length": 4988,
  "excerpt": "Hey there! Today, I want to talk about something simple but super useful ‚Äî setting up Gzip compression for your API client. Sounds interesting? Let‚Äôs dive in! Gzip is a tool that compresses and‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Marcus Urbenz on UnsplashHey there! Today, I want to talk about something simple but super useful ‚Äî setting up Gzip compression for your API client. Sounds interesting? Let‚Äôs dive in!First of all, what is Gzip?Gzip is a tool that compresses and decompresses data (originally files) using the Deflate algorithm. In plain terms, it helps reduce the size of data packets sent over the network by compressing them as much as possible.Note: Even though a gzipped string looks like a stream of unreadable bytes in the console, Gzip is only for request/response compression. If you‚Äôre looking for security and want to protect data in transit between your backend and client, you‚Äôll need cryptographic algorithms instead.Why do I need it?You might ask me: ‚ÄúWhy do I need this stuff, as everything works quickly enough?‚Äù. Just an example, what Gzip can do:Server Response Size in PostmanIn the example above, the original response size was nearly half a megabyte. But after compression, it shrank 8x smaller! I deliberately used a large dataset to show how significantly backend responses can be compressed, impacting data flow, network transmission, and overall performance.It‚Äôs important to note that Gzip doesn‚Äôt compress all data equally well:Small payloads may not compress efficiently;Different data types compress at different rates.Server Response Size in PostmanIn my case, the API returns JSON. In your case, you‚Äôll need to test based on your data structure.Less talk, more codeBy default, most backends don‚Äôt support Gzip (or any compression method) out of the box. That means both the client and the backend need to handle it explicitly. You‚Äôll also need to ensure that both sides send the right headers when processing requests.In case of Retrofit (I believe you are using it) we can add an Interceptor to do something with requests and responses:val clientBuilder = OkHttpClient.Builder().addInterceptor { chain -\u003e val request = chain.request() // doing something with request val response = chain.proceed(request) // and here we doing something with response return@addInterceptor response}val retrofit = Retrofit.Builder() .baseUrl(BuildConfig.BASE_API_URL) .client(clientBuilder.build()) .build()I have a feeling this isn‚Äôt the first Interceptor in your project, so I won‚Äôt go into too much detail about how they work üòâ.Here‚Äôs the full implementation of GzipInterceptor:import okhttp3.Interceptorimport okhttp3.Interceptor.Chainimport okhttp3.Responseimport okhttp3.ResponseBody.Companion.toResponseBodyimport okio.GzipSourceimport okio.bufferclass GzipInterceptor constructor(): Interceptor { override fun intercept(chain: Chain): Response { val originalRequest = chain.request() val compressedRequest = originalRequest.newBuilder() /// Add special headers to say the backend that we can handle Gzip .header(\"Accept-Encoding\", \"gzip, deflate\") .method(originalRequest.method, originalRequest.body) .build() val response = chain.proceed(compressedRequest) /// If our Response Gzipped, then decompress it, otherwise /// we just return the Response return if (isGzipped(response)) unzip(response) else response } private fun unzip(response: Response): Response { val body = response.body ?: return response /// Decompress response using okio.GzipSource val gzipSource = GzipSource(body.source()) val bodyString = gzipSource.buffer().readUtf8() val responseBody = bodyString.toResponseBody(body.contentType()) val strippedHeaders = response.headers.newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build() return response.newBuilder() .headers(strippedHeaders) .body(responseBody) .message(response.message) .build() } private fun isGzipped(response: Response): Boolean { val header = response.header(\"Content-Encoding\") return (header != null) \u0026\u0026 (\"gzip\" in header) }}Now add this Interceptor to your network client setup (I suggest to add it the last in the queue, then it will handle the response the first):val clientBuilder = OkHttpClient.Builder() /// our previous interceptors .addInterceptor(GzipInterceptor())What if I‚Äôm using Ktor‚Äôs HttpClient in a Kotlin Multiplatform project?You might ask me: ‚ÄúWhat if I‚Äôm using Ktor‚Äôs HttpClient in a Kotlin Multiplatform project?‚Äù No worries ‚Äî Ktor makes this easy with built-in plugins for both ‚Äî the client and the backend.First of all, we need to add Gradle dependency:implementation(\"io.ktor:ktor-client-encoding:$ktor_version\")And then we just set up gzip and deflate as plugins to our client:import io.ktor.client.*import io.ktor.client.engine.cio.*import io.ktor.client.plugins.contentencoding.*val client = HttpClient(CIO) { install(ContentEncoding) { gzip() deflate() }}And that‚Äôs it! Now you just need to test it and ship it to your users. That‚Äôs all for today ‚Äî thanks for reading! If you found this helpful, I‚Äôd appreciate a like, comment, and follow. üöÄ",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*dcManBjQ-8a4nQV-",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://sagrishin.medium.com/?source=post_page---byline--66fbe32dd70c---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Serhii Hryshyn\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*A6qSx919Y60XUSBzbY2c9w.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--66fbe32dd70c---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@marcusurbenz?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMarcus Urbenz\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f3ed\"\u003e\u003cspan\u003eH\u003c/span\u003eey there! Today, I want to talk about something simple but super useful ‚Äî setting up Gzip compression for your API client. Sounds interesting? Let‚Äôs dive in!\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"2414\"\u003eFirst of all, what is Gzip?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"805a\"\u003eGzip is a tool that compresses and decompresses data (originally files) using the Deflate algorithm. In plain terms, it helps reduce the size of data packets sent over the network by compressing them as much as possible.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"657e\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Even though a gzipped string looks like a stream of unreadable bytes in the console, Gzip is only for request/response compression. If you‚Äôre looking for security and want to protect data in transit between your backend and client, you‚Äôll need cryptographic algorithms instead.\u003c/p\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cp id=\"2034\"\u003e\u003cem\u003eWhy do I need it?\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"2150\"\u003eYou might ask me: ‚Äú\u003cem\u003eWhy do I need this stuff, as everything works quickly enough?\u003c/em\u003e‚Äù. Just an example, what Gzip can do:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eServer Response Size in Postman\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"092f\"\u003eIn the example above, the original response size was nearly half a megabyte. But after compression, it shrank \u003cstrong\u003e8x smaller\u003c/strong\u003e! I deliberately used a large dataset to show how significantly backend responses can be compressed, impacting data flow, network transmission, and overall performance.\u003c/p\u003e\u003cp id=\"5b4e\"\u003eIt‚Äôs important to note that Gzip doesn‚Äôt compress all data equally well:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6d11\"\u003eSmall payloads may not compress efficiently;\u003c/li\u003e\u003cli id=\"ef04\"\u003eDifferent data types compress at different rates.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eServer Response Size in Postman\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"6b16\"\u003eIn my case, the API returns JSON. In your case, you‚Äôll need to test based on your data structure.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c1e9\"\u003e\u003cstrong\u003eLess talk, more code\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"0bef\"\u003eBy default, most backends don‚Äôt support Gzip (or any compression method) out of the box. That means both the client and the backend need to handle it explicitly. You‚Äôll also need to ensure that both sides send the right headers when processing requests.\u003c/p\u003e\u003cp id=\"763d\"\u003eIn case of Retrofit (I believe you are using it) we can add an \u003ccode\u003eInterceptor\u003c/code\u003e to do something with requests and responses:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a0ac\"\u003eval clientBuilder = OkHttpClient.Builder().addInterceptor { chain -\u0026gt;\u003cbr/\u003e  val request = chain.request()\u003cbr/\u003e  // doing something with request\u003cbr/\u003e  val response = chain.proceed(request)\u003cbr/\u003e  // and here we doing something with response\u003cbr/\u003e  return@addInterceptor response\u003cbr/\u003e}\u003cp\u003eval retrofit = Retrofit.Builder()\u003cbr/\u003e  .baseUrl(BuildConfig.BASE_API_URL)\u003cbr/\u003e  .client(clientBuilder.build())\u003cbr/\u003e  .build()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"8c49\"\u003eI have a feeling this isn‚Äôt the first Interceptor in your project, so I won‚Äôt go into too much detail about how they work \u003cem\u003eüòâ\u003c/em\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"0c23\"\u003eHere‚Äôs the full implementation of GzipInterceptor:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7530\"\u003eimport okhttp3.Interceptor\u003cbr/\u003eimport okhttp3.Interceptor.Chain\u003cbr/\u003eimport okhttp3.Response\u003cbr/\u003eimport okhttp3.ResponseBody.Companion.toResponseBody\u003cbr/\u003eimport okio.GzipSource\u003cbr/\u003eimport okio.buffer\u003cp\u003eclass GzipInterceptor constructor(): Interceptor {\u003cbr/\u003e  override fun intercept(chain: Chain): Response {\u003cbr/\u003e    val originalRequest = chain.request()\u003cbr/\u003e    val compressedRequest = originalRequest.newBuilder()\u003cbr/\u003e      /// Add special headers to say the backend that we can handle Gzip\u003cbr/\u003e      .header(\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;gzip, deflate\u0026#34;)\u003cbr/\u003e      .method(originalRequest.method, originalRequest.body)\u003cbr/\u003e      .build()\u003cbr/\u003e    val response = chain.proceed(compressedRequest)\u003c/p\u003e\u003cp\u003e    /// If our Response Gzipped, then decompress it, otherwise\u003cbr/\u003e    /// we just return the Response\u003cbr/\u003e    return if (isGzipped(response)) unzip(response) else response\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  private fun unzip(response: Response): Response {\u003cbr/\u003e    val body = response.body ?: return response\u003c/p\u003e\u003cp\u003e    /// Decompress response using okio.GzipSource\u003cbr/\u003e    val gzipSource = GzipSource(body.source())\u003cbr/\u003e    val bodyString = gzipSource.buffer().readUtf8()\u003cbr/\u003e    val responseBody = bodyString.toResponseBody(body.contentType())\u003cbr/\u003e    val strippedHeaders = response.headers.newBuilder()\u003cbr/\u003e      .removeAll(\u0026#34;Content-Encoding\u0026#34;)\u003cbr/\u003e      .removeAll(\u0026#34;Content-Length\u0026#34;)\u003cbr/\u003e      .build()\u003c/p\u003e\u003cp\u003e    return response.newBuilder()\u003cbr/\u003e      .headers(strippedHeaders)\u003cbr/\u003e      .body(responseBody)\u003cbr/\u003e      .message(response.message)\u003cbr/\u003e      .build()\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  private fun isGzipped(response: Response): Boolean {\u003cbr/\u003e    val header = response.header(\u0026#34;Content-Encoding\u0026#34;)\u003cbr/\u003e    return (header != null) \u0026amp;\u0026amp; (\u0026#34;gzip\u0026#34; in header)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dac2\"\u003eNow add this \u003ccode\u003eInterceptor\u003c/code\u003e to your network client setup (I suggest to add it the last in the queue, then it will handle the response the first):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"53d5\"\u003eval clientBuilder = OkHttpClient.Builder()\u003cbr/\u003e  /// our previous interceptors\u003cbr/\u003e  .addInterceptor(GzipInterceptor())\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"c805\"\u003eWhat if I‚Äôm using Ktor‚Äôs HttpClient in a Kotlin Multiplatform project?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"988b\"\u003eYou might ask me: \u003cem\u003e‚ÄúWhat if I‚Äôm using Ktor‚Äôs HttpClient in a Kotlin Multiplatform project?‚Äù\u003c/em\u003e No worries ‚Äî Ktor makes this easy with built-in plugins for both ‚Äî the client and the backend.\u003c/p\u003e\u003cp id=\"8516\"\u003eFirst of all, we need to add Gradle \u003ccode\u003edependency\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"636c\"\u003eimplementation(\u0026#34;io.ktor:ktor-client-encoding:$ktor_version\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4eda\"\u003eAnd then we just set up \u003ccode\u003egzip\u003c/code\u003e and \u003ccode\u003edeflate\u003c/code\u003e as plugins to our client:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ea6d\"\u003eimport io.ktor.client.*\u003cbr/\u003eimport io.ktor.client.engine.cio.*\u003cbr/\u003eimport io.ktor.client.plugins.contentencoding.*\u003cp\u003eval client = HttpClient(CIO) {\u003cbr/\u003e    install(ContentEncoding) {\u003cbr/\u003e        gzip()\u003cbr/\u003e        deflate()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ccd\"\u003eAnd that‚Äôs it! Now you just need to test it and ship it to your users. That‚Äôs all for today ‚Äî thanks for reading! If you found this helpful, I‚Äôd appreciate a like, comment, and follow. üöÄ\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-02-14T11:44:50.507Z",
  "modifiedTime": null
}
