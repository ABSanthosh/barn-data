{
  "id": "d5ece055-c0cc-4225-9405-57d12d4309e0",
  "title": "Yes, That‚Äôs MVI: The Pattern‚Äôs Full History, Misconceptions, and Modern Android Form",
  "link": "https://proandroiddev.com/yes-that-is-mvi-674f810ca4fe?source=rss----c72404660798---4",
  "description": "",
  "author": "Eury P√©rez Beltr√©",
  "published": "Thu, 29 May 2025 19:33:27 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "redux",
    "kotlin",
    "mvi",
    "architecture"
  ],
  "byline": "Eury P√©rez Beltr√©",
  "length": 14747,
  "excerpt": "Uncover MVI‚Äôs true origins, how it differs from Redux and MVVM, and why most Android implementations are valid‚Äîdespite common misconceptions.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Behind every tradition lies a reason ‚Äî and behind that, a story.‚Äì AnonymousWelcome to this article! My goal is to help you truly understand what the real MVI pattern is, why I‚Äôm confident in my perspective, and where this pattern originally comes from. But before you dive in, a quick warning:üìù This article comprises an extensive and deep research on the history and evolution of the MVI architectural pattern as well as the opinion of the author. Be ready to identify facts from opinions üòâTable of ContentsIntroduction: Beyond the BuzzwordArchitectural Precursors: Patterns That Led to MVIThe Origin of MVI: How the Pattern Took ShapeThe Problem: The MVI MisconceptionMVI in Android: How Does It Really Look?Final Thoughts: My Personal Take1. Introduction: Beyond the BuzzwordMVI has earned its place as a powerful architectural pattern in Android development, offering clarity and predictability in managing state and UI complexity. When applied thoughtfully, it provides a strong mental model that helps developers build maintainable and scalable apps.Yet, a faction I call the ‚ÄúMVI Police üëÆ‚Äù insists that only strict MVU or Redux-style implementations count as real MVI, dismissing other valid approaches as mislabeling. This narrow view overlooks MVI‚Äôs true origins and the practical ways it can be adapted to different contexts without losing its core principles.In this article, we‚Äôll explore MVI‚Äôs roots, the problems it was designed to solve, and how embracing its spirit ‚Äî rather than rigid rules ‚Äî can empower developers to write clean, effective architecture. After all, good architecture is about solving problems, not following dogma.2. Architectural Precursors: Patterns That Led to MVIMVI was not introduced in a paper nor a book we can refer to, like other design patterns. It was the result of a thoughtful process by its creator, who hold a case against the existing solutions on his time (1, 2, 3).While many assume MVI is a direct descendant of Redux (2015) or Elm‚Äôs MVU (2011), its true conceptual roots lie in two earlier patterns: Model‚ÄìView‚ÄìController (MVC) and Flux according to this blog post from 2014 by Andr√© Staltz (the creator of cycle.js and the MVI pattern).Model-View-Controller (MVC) ‚Äî Circa 1979One of the earliest and most influential architectural patterns, MVC separated an application into three main components:Model: Manages the data and business logicView: Responsible for rendering UI elementsController: Handles user input and updates the Model accordinglySource: cycle.js.orgAndr√© Staltz revisited MVC through the lens of reactive programming. In his 2014 blog post ‚ÄúReactive MVC and the Virtual DOM‚Äù, he proposed a modern rethinking of MVC tailored for stream-based UIs. In this reimagining:The Intent replaces the Controller: it captures user interactions as streams of events.The Model reacts to these streams to update application state.The View renders the state reactively.He called this restructured architecture Model‚ÄìView‚ÄìIntent (MVI), making it the first formal mention of the pattern. This version of MVC respected unidirectional data flow while aligning naturally with observable-based systems like RxJS.Flux (MVC) ‚Äî May 2014Shortly before Staltz‚Äôs blog post, Facebook had introduced Flux alongside React. While React focused on UI rendering, Flux introduced a new architecture for managing data flow:Actions describe what happened.Dispatcher routes actions to stores.Stores hold application state and update in response to actions.Views listen for store changes and re-render.source: reactjs.orgFlux‚Äôs most important innovation was unidirectional and circular data flow, which brought order to the chaos of shared mutable state in UI apps. Staltz recognized this innovation but criticized how Flux often mixed imperative and reactive paradigms. Still, the principle of keeping state changes predictable and linear became a key part of MVI.In MVI, Staltz adopted Flux‚Äôs unidirectional data flow but simplified it. He removed the Dispatcher, avoided imperative stores, and instead used observables to directly model user intent, state, and UI rendering as pure, reactive transformations. In his own words:‚ÄúThe combo React/Flux is clearly inspired by Reactive Programming principles, but the API and architecture are an unjustified mix of Interactive and Reactive patterns‚Ä¶ we can do better.‚Äù3. The Origin of MVI: How the Pattern Took ShapeThe MVI pattern was introduced in the javascript framework cycle.js by its creator Andr√© Staltz around the year 2014, one year before Redux came to existence.The MVI Pattern in PracticeModel-View-Intent (MVI) is a reactive UI architecture pattern that enforces a single, immutable state (the Model), a unidirectional flow of Intents (user actions) into the system, and a View that renders each state.Model holds the app state.View renders the state.Intent replaces the Controller as a stream of user interactions.The MVI CycleYou can read the definition of MVI as well as its components directly from its creator in this blog post about architectural patterns he wrote back in 2015.Flux‚Äôs focus on immutable state and unidirectional flow influenced MVI‚Äôs design, which formalizes the flow: user intents ‚Üí state changes ‚Üí UI rendering. This synthesis of ideas from classic MVC, Flux, and reactive programming principles gave birth to MVI ‚Äî not as a derivative of Redux (which arrived later) or Elm, but as a distinct architecture tailored for reactive systems.Code ExamplesIn a blog post Hannes Dorfmann gave his interpretation of the earliest ideas of Andr√© Staltz about MVI and he expressed the idea as a math expression:source: hannesdorfmann.comThis expression is great to understand how the MVI components are intertwined and represent a dependency to each other: The intent is passed to the Model which generates a new State that is provided to the View to render it. This mathematical expression condenses the spirit of MVI.The cycle.js implementation for this would be something like:You can see this math expression literally represented in lines 44‚Äì46.This looks good, but how does the idea actually translate to Kotlin?Well, not so fast, we'll come to that. For now, let's continue our unveiling journey‚Ä¶4. The Problem: The MVI MisconceptionAs the MVI pattern gained popularity in the Android ecosystem, particularly with the rise of Jetpack Compose, coroutines, and unidirectional state management, a wave of skepticism emerged. Some developers ‚Äî jokingly referred to as the MVI Police ‚Äî began questioning whether many Kotlin/Android implementations could truly be called ‚ÄúMVI.‚ÄùThe MVI \u0026 Redux MisconceptionOne of the most common misconceptions is that MVI is just Redux under a different name, or that MVI was directly inspired by Redux. But as you‚Äôve seen in the previous sections, this isn‚Äôt historically accurate: MVI was introduced in 2014 by Andr√© Staltz, in his Reactive MVC blog post, several months before Redux was released in late 2015 by Dan Abramov.That said, it‚Äôs easy to understand where the confusion comes from. MVI and Redux do share several core ideas ‚Äî but not because MVI was derived from Redux. Instead, both were independently influenced by the same underlying architecture: Flux.These similarities include:MVI treats user intents similarly to Redux actions.MVI models state as immutable and evolving over time, like Redux‚Äôs store.MVI uses reducers to derive new state from previous state and user input.However, within these similarities lie key architectural differences:By now you should agree on that a Kotlin/Android MVI implementation doesn't need to strictly follow the Redux design pattern.The MVI \u0026 MVVM MisconceptionAnother common misconception is that many popular MVI implementations are simply MVVM with a single state data class and a sealed interface for intents. To clarify this, let‚Äôs first revisit the fundamentals of what a design pattern truly is.According to the seminal 1994 book Design Patterns: Elements of Reusable Object-Oriented Software by the Gang of Four:‚ÄúA design pattern systematically names, motivates, and explains a general design that addresses a recurring design problem in object-oriented systems.‚Äù‚ÄúA design pattern is a general repeatable solution to a commonly occurring problem in software design. It is not a finished design that can be transformed directly into code but is a description or template for how to solve a problem that can be used in many different situations.‚ÄùMuch like patterns found in nature ‚Äî whether numerical, visual, or otherwise ‚Äî mutating or modifying an existing pattern often results in a new, distinct pattern:So, are developers following the MVI trend actually doing MVVM without realizing it? To untangle this, let‚Äôs compare the similarities and differences between the two patterns, much like we did in the previous section.To keep opinions grounded, we‚Äôll reference a well-regarded Microsoft article ‚Äî the creators of MVVM back in 2005.Both patterns share several traits:Clear separation of concernsUse of observable streams to update the UIEmployment of ViewModels (especially on Android)However, when we examine the details side-by-side, it becomes clear that despite these surface similarities, MVI and MVVM differ fundamentally in key ways ‚Äî showing how evolving a pattern can lead to a brand-new architectural approach.As software development often teaches us, things that look similar at first glance can diverge significantly once you look closer.A clean and simple MVVM implementation in Android would look something like this:This idea is supported by this diagram created by the Android team a while back in an effort to suggest an architectural pattern for the apps:Note the multiple LiveData instances in the viewModel. Now to see an MVI example, let's jump to the next section.5. MVI in Android: How Does It Really Look?After our deep dive and comparisons with related patterns, we can confidently identify the core characteristics that define a true MVI implementation :Single immutable State object: This state is decentralized and typically resides within the ViewModel.UI interactions as Intents: All user actions are represented as data streams, often sealed classes or interfaces.Reducer function: A pure function that takes the previous state and an Intent, then returns a new State (Old State + Intent ‚Üí New State).Unidirectional data flow: The architecture strictly respects the flow from Intent ‚Üí Model ‚Üí State ‚Üí View.Side-effects handled separately: Effects like navigation, network calls, or showing messages are modeled distinctly and processed outside the reducer.I can already hear some objections, but let‚Äôs put theory aside and see how this looks in code.The MVI Components as modelsFor our example, we‚Äôll define three essential components:UserUiState: The immutable state model exposed as a Kotlin Flow.UserIntent: Represents all possible user actions within the UI.UserSideEffect: Defines side-effects that happen outside the pure state update logic.The ViewModel Role in MVIIn an Android MVI feature, the ViewModel is responsible for:Exposing the state as an immutable, observable stream.Exposing side effects as a separate immutable stream.Providing a public function to accept and process Intents, applying the reducer logic to update the state accordingly.As you‚Äôve probably realized by now, this closely resembles the very implementations that some have criticized as being ‚Äúnot real MVI.‚Äù But the historical context and evidence compiled throughout this article suggest otherwise: the community has been getting it right all along. Perhaps it‚Äôs time for the MVI Police to revisit their own definition of the pattern.üìù Note: I don‚Äôt recommend this side effects implementation, but I‚Äôm keeping it simple for educational purposes. I will write a new blog post to explain why this is not recommended and what alternatives you have.6. Final Thoughts: My Personal TakeEven though I never aligned with the ‚ÄúMVI Police‚Äù way of thinking, I realized I lacked solid information to support my views. This extensive investigation taught me several valuable lessons ‚Äî some not even about design patterns or software engineering. I‚Äôd like to share a few with you:In both software development and life, what sounds logical to you isn‚Äôt always true.Concepts have a history and evolve over time; recognizing that process is crucial.Before telling someone they‚Äôre wrong just because you believe your way is the only right way, think twice ‚Äî sometimes even thrice. Multiple valid approaches can coexist.On the technical side, the biggest takeaway is really about soft skills:A design pattern is a recurring solution to a common problem. If that solution changes significantly, it becomes a new pattern.Yes, changes like using a single immutable data class for state, a sealed interface for intents, and a reducer function inside the ViewModel can justify defining a distinct pattern.Yes, you can tweak/personalize a pattern and still avoid telling the other people yours is the \"real\" or \"best\" implementation.History matters. Many people who claim MVI was inspired by Redux may not even realize that MVI existed first.Lastly, MVI implementations must not include a global store like Redux. Doing so means it‚Äôs not MVI. (Yes, I‚Äôm looking at you, MVI Police ‚Äî bring it on! üöì)The MVI creator didn‚Äôt even like Redux in the first placeMVI is simple and straight to the point. Redux not so much‚Ä¶At the end of the day, what truly matters is understanding the why behind these patterns, respecting their evolution, and applying them thoughtfully to solve real problems. Let‚Äôs embrace the diversity of ideas instead of policing the ‚Äúright way.‚Äù This approach will foster healthier discussions and ultimately better software.Follow me on Medium and LinkedIn to know when I write the article to show you how I personally leverage MVI in my projects.If this article helped you, clap, comment and share üòâSources:https://staltz.com/cycleconf17/#/step-1https://www.futurice.com/blog/reactive-mvc-and-the-virtual-domhttps://staltz.com/bloghttps://staltz.com/unidirectional-user-interface-architectureshttps://staltz.com/nothing-new-in-react-and-flux-except-one-thinghttps://staltz.com/some-problems-with-react-reduxhttps://hannesdorfmann.com/android/model-view-intent/https://redux.js.org/understanding/history-and-design/history-of-reduxhttps://legacy.reactjs.org/blog/2014/07/30/flux-actions-and-the-dispatcher.htmlhttps://learn.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-appshttps://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-patternhttps://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*ZC5YKog0LMH-dqSw6Os21Q.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://euryperez.dev/?source=post_page---byline--674f810ca4fe---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Eury P√©rez Beltr√©\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*4htHjTsCHwTAKGca7Rwm9A.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp id=\"619a\"\u003eBehind every tradition lies a reason ‚Äî and behind that, a story.\u003cbr/\u003e‚Äì Anonymous\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9d5c\"\u003eWelcome to this article! My goal is to help you truly understand what the real MVI pattern is, why I‚Äôm confident in my perspective, and where this pattern originally comes from. But before you dive in, a quick warning:\u003c/p\u003e\u003cp id=\"4223\"\u003e\u003cem\u003eüìù This article comprises an extensive and deep research on the history and evolution of the MVI architectural pattern as well as the opinion of the author. Be ready to identify facts from opinions üòâ\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"e117\"\u003eTable of Contents\u003c/h2\u003e\u003col\u003e\u003cli id=\"7c6d\"\u003eIntroduction: \u003cem\u003eBeyond the Buzzword\u003c/em\u003e\u003c/li\u003e\u003cli id=\"d6b2\"\u003eArchitectural Precursors: \u003cem\u003ePatterns That Led to MVI\u003c/em\u003e\u003c/li\u003e\u003cli id=\"ec96\"\u003eThe Origin of MVI: \u003cem\u003eHow the Pattern Took Shape\u003c/em\u003e\u003c/li\u003e\u003cli id=\"c15a\"\u003eThe Problem: \u003cem\u003eThe MVI Misconception\u003c/em\u003e\u003c/li\u003e\u003cli id=\"27ca\"\u003eMVI in Android: \u003cem\u003eHow Does It Really Look?\u003c/em\u003e\u003c/li\u003e\u003cli id=\"a915\"\u003eFinal Thoughts: \u003cem\u003eMy Personal Take\u003c/em\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"c7d0\"\u003e1. Introduction: Beyond the Buzzword\u003c/h2\u003e\u003cp id=\"d065\"\u003eMVI has earned its place as a powerful architectural pattern in Android development, offering clarity and predictability in managing state and UI complexity. When applied thoughtfully, it provides a strong mental model that helps developers build maintainable and scalable apps.\u003c/p\u003e\u003cp id=\"e43e\"\u003eYet, a faction I call the \u003cem\u003e‚ÄúMVI Police üëÆ‚Äù\u003c/em\u003e insists that only strict MVU or Redux-style implementations count as real MVI, dismissing other valid approaches as mislabeling. This narrow view overlooks MVI‚Äôs true origins and the practical ways it can be adapted to different contexts without losing its core principles.\u003c/p\u003e\u003cp id=\"13c0\"\u003eIn this article, we‚Äôll explore MVI‚Äôs roots, the problems it was designed to solve, and how embracing its spirit ‚Äî rather than rigid rules ‚Äî can empower developers to write clean, effective architecture. After all, good architecture is about solving problems, not following dogma.\u003c/p\u003e\u003ch2 id=\"c467\"\u003e2. Architectural Precursors: Patterns That Led to MVI\u003c/h2\u003e\u003cp id=\"8316\"\u003eMVI was not introduced in a paper nor a book we can refer to, like other design patterns. It was the result of a thoughtful process by its creator, who hold a case against the existing solutions on his time (\u003ca href=\"https://staltz.com/some-problems-with-react-redux\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e1\u003c/a\u003e, \u003ca href=\"https://staltz.com/nothing-new-in-react-and-flux-except-one-thing\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e2\u003c/a\u003e, \u003ca href=\"https://staltz.com/unidirectional-user-interface-architectures/#:~:text=Model-Vie\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e3\u003c/a\u003e).\u003c/p\u003e\u003cp id=\"680e\"\u003eWhile many assume MVI is a direct descendant of Redux (2015) or Elm‚Äôs MVU (2011), its true conceptual roots lie in two earlier patterns: \u003cstrong\u003eModel‚ÄìView‚ÄìController (MVC)\u003c/strong\u003e and \u003cstrong\u003eFlux \u003c/strong\u003eaccording to \u003ca href=\"https://www.futurice.com/blog/reactive-mvc-and-the-virtual-dom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis blog post\u003c/a\u003e from 2014 by Andr√© Staltz (the creator of cycle.js and the MVI pattern).\u003c/p\u003e\u003ch2 id=\"6951\"\u003eModel-View-Controller (MVC) ‚Äî Circa 1979\u003c/h2\u003e\u003cp id=\"f999\"\u003eOne of the earliest and most influential architectural patterns, \u003cstrong\u003eMVC\u003c/strong\u003e separated an application into three main components:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ed0f\"\u003e\u003cstrong\u003eModel:\u003c/strong\u003e Manages the data and business logic\u003c/li\u003e\u003cli id=\"17c1\"\u003e\u003cstrong\u003eView:\u003c/strong\u003e Responsible for rendering UI elements\u003c/li\u003e\u003cli id=\"383a\"\u003e\u003cstrong\u003eController:\u003c/strong\u003e Handles user input and updates the Model accordingly\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eSource: cycle.js.org\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4993\"\u003eAndr√© Staltz revisited MVC through the lens of \u003cstrong\u003ereactive programming\u003c/strong\u003e. In his 2014 blog post \u003ca href=\"https://www.futurice.com/blog/reactive-mvc-and-the-virtual-dom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e‚ÄúReactive MVC and the Virtual DOM‚Äù\u003c/a\u003e, he proposed a modern rethinking of MVC tailored for stream-based UIs. In this reimagining:\u003c/p\u003e\u003cul\u003e\u003cli id=\"cc78\"\u003eThe \u003cstrong\u003eIntent\u003c/strong\u003e replaces the Controller: it captures user interactions as \u003cstrong\u003estreams of events\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"a2a6\"\u003eThe \u003cstrong\u003eModel\u003c/strong\u003e reacts to these streams to update application state.\u003c/li\u003e\u003cli id=\"c36e\"\u003eThe \u003cstrong\u003eView\u003c/strong\u003e renders the state reactively.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a8a5\"\u003eHe called this restructured architecture \u003cstrong\u003eModel‚ÄìView‚ÄìIntent (MVI)\u003c/strong\u003e, making it the first formal mention of the pattern. This version of MVC respected unidirectional data flow while aligning naturally with observable-based systems like RxJS.\u003c/p\u003e\u003ch2 id=\"0924\"\u003eFlux (MVC) ‚Äî May 2014\u003c/h2\u003e\u003cp id=\"225c\"\u003eShortly before Staltz‚Äôs blog post, Facebook had introduced \u003cstrong\u003eFlux\u003c/strong\u003e alongside \u003cstrong\u003eReact\u003c/strong\u003e. While React focused on UI rendering, Flux introduced a new architecture for managing data flow:\u003c/p\u003e\u003cul\u003e\u003cli id=\"32c6\"\u003e\u003cstrong\u003eActions\u003c/strong\u003e describe what happened.\u003c/li\u003e\u003cli id=\"42da\"\u003e\u003cstrong\u003eDispatcher\u003c/strong\u003e routes actions to stores.\u003c/li\u003e\u003cli id=\"1d6b\"\u003e\u003cstrong\u003eStores\u003c/strong\u003e hold application state and update in response to actions.\u003c/li\u003e\u003cli id=\"0bbc\"\u003e\u003cstrong\u003eViews\u003c/strong\u003e listen for store changes and re-render.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003esource: reactjs.org\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a07f\"\u003eFlux‚Äôs most important innovation was \u003cstrong\u003eunidirectional and circular data flow\u003c/strong\u003e, which brought order to the chaos of shared mutable state in UI apps. Staltz recognized this innovation but criticized how Flux often mixed \u003cstrong\u003eimperative\u003c/strong\u003e and \u003cstrong\u003ereactive \u003c/strong\u003eparadigms. Still, the principle of keeping state changes predictable and linear became a key part of MVI.\u003c/p\u003e\u003cp id=\"9884\"\u003eIn MVI, Staltz adopted \u003cstrong\u003eFlux‚Äôs unidirectional data flow\u003c/strong\u003e but simplified it. He removed the Dispatcher, avoided imperative stores, and instead used \u003cstrong\u003eobservables\u003c/strong\u003e to directly model user intent, state, and UI rendering as pure, reactive transformations. In his own words:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"cca1\"\u003e‚ÄúThe combo React/Flux is clearly inspired by Reactive Programming principles, but the API and architecture are an unjustified mix of Interactive and Reactive patterns‚Ä¶ we can do better.‚Äù\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"7893\"\u003e3. The Origin of MVI: How the Pattern Took Shape\u003c/h2\u003e\u003cp id=\"debc\"\u003eThe MVI pattern was introduced in the javascript framework cycle.js by its creator Andr√© Staltz around the year 2014, \u003ca href=\"https://redux.js.org/understanding/history-and-design/history-of-redux#2015-the-birth-of-redux\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eone year before\u003c/a\u003e Redux came to existence.\u003c/p\u003e\u003ch2 id=\"6115\"\u003eThe MVI Pattern in Practice\u003c/h2\u003e\u003cp id=\"050c\"\u003eModel-View-Intent (MVI) is a reactive UI architecture pattern that enforces a single, immutable \u003cem\u003estate\u003c/em\u003e (\u003cstrong\u003ethe Model\u003c/strong\u003e), a unidirectional flow of \u003cstrong\u003e\u003cem\u003eIntents\u003c/em\u003e\u003c/strong\u003e (user actions) into the system, and a \u003cstrong\u003eView\u003c/strong\u003e that renders each state.\u003c/p\u003e\u003cul\u003e\u003cli id=\"d09f\"\u003e\u003cstrong\u003eModel\u003c/strong\u003e holds the app state.\u003c/li\u003e\u003cli id=\"de1f\"\u003e\u003cstrong\u003eView\u003c/strong\u003e renders the state.\u003c/li\u003e\u003cli id=\"896a\"\u003e\u003cstrong\u003eIntent\u003c/strong\u003e replaces the Controller as a stream of user interactions.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe MVI\u003cstrong\u003e Cycle\u003c/strong\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c978\"\u003eYou can read the definition of MVI as well as its components directly from its creator in this \u003ca href=\"https://staltz.com/unidirectional-user-interface-architectures/#:~:text=Model-View-Intent\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eblog post\u003c/a\u003e about architectural patterns he wrote back in 2015.\u003c/p\u003e\u003cp id=\"eafb\"\u003eFlux‚Äôs focus on immutable state and unidirectional flow influenced MVI‚Äôs design, which formalizes the flow: user intents ‚Üí state changes ‚Üí UI rendering. This synthesis of ideas from classic MVC, Flux, and reactive programming principles gave birth to MVI ‚Äî not as a derivative of Redux (which arrived later) or Elm, but as a distinct architecture tailored for reactive systems.\u003c/p\u003e\u003ch2 id=\"c8ee\"\u003eCode Examples\u003c/h2\u003e\u003cp id=\"1a8b\"\u003eIn a \u003ca href=\"https://hannesdorfmann.com/android/model-view-intent/#:~:text=mathematical\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eblog post\u003c/a\u003e Hannes Dorfmann gave his interpretation of the earliest ideas of Andr√© Staltz about MVI and he expressed the idea as a math expression:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003esource: hannesdorfmann.com\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1a70\"\u003eThis expression is great to understand how the MVI components are intertwined and represent a dependency to each other: \u003cstrong\u003eThe intent\u003c/strong\u003e is passed to the \u003cstrong\u003eModel\u003c/strong\u003e which generates a new \u003cstrong\u003eState\u003c/strong\u003e that is provided to the \u003cstrong\u003eView\u003c/strong\u003e to render it. This mathematical expression condenses the spirit of MVI.\u003c/p\u003e\u003cp id=\"0457\"\u003eThe cycle.js implementation for this would be something like:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"60c5\"\u003eYou can see this math expression literally represented in lines 44‚Äì46.\u003c/p\u003e\u003cp id=\"15b0\"\u003eThis looks good, but how does the idea actually translate to Kotlin?\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4843\"\u003eWell, not so fast, we\u0026#39;ll come to that. For now, let\u0026#39;s continue our unveiling journey‚Ä¶\u003c/p\u003e\u003ch2 id=\"2022\"\u003e4. The Problem: The MVI Misconception\u003c/h2\u003e\u003cp id=\"734a\"\u003eAs the \u003cstrong\u003eMVI pattern gained popularity in the Android ecosystem\u003c/strong\u003e, particularly with the rise of Jetpack Compose, coroutines, and unidirectional state management, a wave of skepticism emerged. Some developers ‚Äî jokingly referred to as the \u003cem\u003eMVI Police\u003c/em\u003e ‚Äî began questioning whether many Kotlin/Android implementations could truly be called ‚ÄúMVI.‚Äù\u003c/p\u003e\u003ch2 id=\"bae6\"\u003eThe MVI \u0026amp; Redux Misconception\u003c/h2\u003e\u003cp id=\"8381\"\u003eOne of the most common misconceptions is that \u003cstrong\u003eMVI is just Redux under a different name\u003c/strong\u003e, or that MVI was directly inspired by Redux. But as you‚Äôve seen in the previous sections, \u003cstrong\u003ethis isn‚Äôt historically accurate\u003c/strong\u003e: MVI was introduced in 2014 by Andr√© Staltz, in his \u003ca href=\"https://www.futurice.com/blog/reactive-mvc-and-the-virtual-dom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eReactive MVC\u003c/a\u003e blog post, \u003cstrong\u003eseveral months before Redux was \u003c/strong\u003e\u003ca href=\"https://redux.js.org/understanding/history-and-design/history-of-redux#2015-the-birth-of-redux\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003ereleased in late 2015\u003c/strong\u003e\u003c/a\u003e by Dan Abramov.\u003c/p\u003e\u003cp id=\"082f\"\u003eThat said, it‚Äôs easy to understand where the confusion comes from. MVI and Redux do share several core ideas ‚Äî but not because MVI was derived from Redux. Instead, \u003cstrong\u003eboth were independently influenced by the same underlying architecture: Flux\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"0790\"\u003eThese similarities include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e436\"\u003eMVI treats \u003cstrong\u003euser intents\u003c/strong\u003e similarly to \u003cstrong\u003eRedux actions\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"4cac\"\u003eMVI models \u003cstrong\u003estate\u003c/strong\u003e as immutable and evolving over time, like Redux‚Äôs \u003cstrong\u003estore\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"4e6d\"\u003eMVI uses \u003cstrong\u003ereducers\u003c/strong\u003e to derive new state from previous state and user input.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9878\"\u003eHowever, within these similarities lie key \u003cstrong\u003earchitectural differences\u003c/strong\u003e:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"97cc\"\u003eBy now you should agree on that a Kotlin/Android \u003cstrong\u003eMVI\u003c/strong\u003e implementation doesn\u0026#39;t need to \u003cstrong\u003estrictly follow\u003c/strong\u003e the Redux design pattern.\u003c/p\u003e\u003ch2 id=\"bbf0\"\u003eThe MVI \u0026amp; MVVM Misconception\u003c/h2\u003e\u003cp id=\"539f\"\u003eAnother common misconception is that many popular MVI implementations are simply \u003cstrong\u003eMVVM with a single state data class and a sealed interface for intents\u003c/strong\u003e. To clarify this, let‚Äôs first revisit the fundamentals of what a design pattern truly is.\u003c/p\u003e\u003cp id=\"47ee\"\u003eAccording to the seminal 1994 book \u003cem\u003eDesign Patterns: Elements of Reusable Object-Oriented Software\u003c/em\u003e by the \u003cstrong\u003eGang of Four\u003c/strong\u003e:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"3dd0\"\u003e‚ÄúA design pattern \u003cstrong\u003esystematically\u003c/strong\u003e names, motivates, and explains a general design that addresses a \u003cstrong\u003erecurring design problem\u003c/strong\u003e in object-oriented systems.‚Äù\u003c/p\u003e\u003cp id=\"540a\"\u003e‚ÄúA design pattern is a \u003cstrong\u003egeneral repeatable solution \u003c/strong\u003eto a commonly occurring problem in software design. It is not a finished design that can be transformed directly into code but is a \u003cstrong\u003edescription or template for how to solve a problem\u003c/strong\u003e that can be used in many different situations.‚Äù\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"79f8\"\u003eMuch like patterns found in nature ‚Äî whether numerical, visual, or otherwise ‚Äî mutating or modifying an existing pattern often results in a new, distinct pattern:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3f1b\"\u003eSo, are developers following the MVI trend actually doing MVVM without realizing it? To untangle this, let‚Äôs compare the similarities and differences between the two patterns, much like we did in the previous section.\u003c/p\u003e\u003cp id=\"d706\"\u003eTo keep opinions grounded, we‚Äôll reference a well-regarded \u003ca href=\"https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern#:~:text=to%20properties%20on%20a%20ViewModel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMicrosoft article \u003c/a\u003e‚Äî \u003ca href=\"https://learn.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe creators of MVVM\u003c/a\u003e back in 2005.\u003c/p\u003e\u003cp id=\"5c94\"\u003eBoth patterns share several traits:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6394\"\u003eClear \u003cstrong\u003eseparation of concerns\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"d331\"\u003eUse of \u003cstrong\u003eobservable streams\u003c/strong\u003e to update the UI\u003c/li\u003e\u003cli id=\"1808\"\u003eEmployment of \u003cstrong\u003eViewModels\u003c/strong\u003e (especially on Android)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c3ba\"\u003eHowever, when we examine the details side-by-side, it becomes clear that despite these surface similarities, MVI and MVVM differ fundamentally in key ways ‚Äî showing how evolving a pattern can lead to a brand-new architectural approach.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d289\"\u003eAs software development often teaches us, things that look similar at first glance can diverge significantly once you look closer.\u003c/p\u003e\u003cp id=\"f263\"\u003eA clean and simple MVVM implementation in Android would look something like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"59bf\"\u003eThis idea is supported by this diagram created by the Android team a while back in an effort to suggest an architectural pattern for the apps:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2ddb\"\u003eNote the multiple \u003cem\u003eLiveData\u003c/em\u003e instances in the viewModel. Now to see an MVI example, let\u0026#39;s jump to the next section.\u003c/p\u003e\u003ch2 id=\"ab15\"\u003e5. MVI in Android: How Does It Really Look?\u003c/h2\u003e\u003cp id=\"7260\"\u003eAfter our deep dive and comparisons with related patterns, we can confidently identify the core characteristics that define a true MVI implementation :\u003c/p\u003e\u003cul\u003e\u003cli id=\"6724\"\u003e\u003cstrong\u003eSingle immutable State object:\u003c/strong\u003e This state is decentralized and typically resides within the ViewModel.\u003c/li\u003e\u003cli id=\"0ebc\"\u003e\u003cstrong\u003eUI interactions as Intents:\u003c/strong\u003e All user actions are represented as data streams, often sealed classes or interfaces.\u003c/li\u003e\u003cli id=\"0aa6\"\u003e\u003cstrong\u003eReducer function:\u003c/strong\u003e A pure function that takes the previous state and an Intent, then returns a new State (\u003ccode\u003eOld State + Intent ‚Üí New State\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"d60e\"\u003e\u003cstrong\u003eUnidirectional data flow:\u003c/strong\u003e The architecture strictly respects the flow from \u003ccode\u003eIntent ‚Üí Model ‚Üí State ‚Üí View\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c9cb\"\u003e\u003cstrong\u003eSide-effects handled separately:\u003c/strong\u003e Effects like navigation, network calls, or showing messages are modeled distinctly and processed outside the reducer.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4033\"\u003eI can already hear some objections, but let‚Äôs put theory aside and see how this looks in code.\u003c/p\u003e\u003ch2 id=\"bff6\"\u003eThe MVI Components as models\u003c/h2\u003e\u003cp id=\"ad7f\"\u003eFor our example, we‚Äôll define three essential components:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7d47\"\u003e\u003ccode\u003e\u003cstrong\u003eUserUiState\u003c/strong\u003e\u003c/code\u003e: The immutable state model exposed as a Kotlin Flow.\u003c/li\u003e\u003cli id=\"99bf\"\u003e\u003ccode\u003e\u003cstrong\u003eUserIntent\u003c/strong\u003e\u003c/code\u003e: Represents all possible user actions within the UI.\u003c/li\u003e\u003cli id=\"635b\"\u003e\u003ccode\u003e\u003cstrong\u003eUserSideEffect\u003c/strong\u003e\u003c/code\u003e: Defines side-effects that happen outside the pure state update logic.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5e39\"\u003eThe ViewModel Role in MVI\u003c/h2\u003e\u003cp id=\"7472\"\u003eIn an Android MVI feature, the ViewModel is responsible for:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ccb6\"\u003eExposing the \u003cstrong\u003estate\u003c/strong\u003e as an immutable, observable stream.\u003c/li\u003e\u003cli id=\"e072\"\u003eExposing \u003cstrong\u003eside effects\u003c/strong\u003e as a separate immutable stream.\u003c/li\u003e\u003cli id=\"13a0\"\u003eProviding a public function to \u003cstrong\u003eaccept and process Intents\u003c/strong\u003e, applying the reducer logic to update the state accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ae74\"\u003eAs you‚Äôve probably realized by now, this closely resembles the very implementations that some have criticized as being ‚Äú\u003cem\u003enot real MVI.\u003c/em\u003e‚Äù But the historical context and evidence compiled throughout this article suggest otherwise: the community has been getting it right all along. Perhaps it‚Äôs time for the \u003cem\u003eMVI Police\u003c/em\u003e to revisit their own definition of the pattern.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"ea7d\"\u003eüìù Note: I don‚Äôt recommend this side effects implementation, but I‚Äôm keeping it simple for educational purposes. I will write a new blog post to explain why this is not recommended and what alternatives you have.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"1d60\"\u003e6. Final Thoughts: My Personal Take\u003c/h2\u003e\u003cp id=\"1e20\"\u003eEven though I never aligned with the ‚Äú\u003cem\u003eMVI Police\u003c/em\u003e‚Äù way of thinking, I realized I lacked solid information to support my views. This extensive investigation taught me several valuable lessons ‚Äî some not even about design patterns or software engineering. I‚Äôd like to share a few with you:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7212\"\u003eIn both software development and life, what \u003cstrong\u003esounds logical to you\u003c/strong\u003e isn‚Äôt always true.\u003c/li\u003e\u003cli id=\"25c2\"\u003eConcepts have a \u003cstrong\u003ehistory and evolve over time\u003c/strong\u003e; recognizing that process is crucial.\u003c/li\u003e\u003cli id=\"3668\"\u003eBefore telling someone they‚Äôre wrong just because \u003cem\u003eyou\u003c/em\u003e believe your way is the only right way, \u003cstrong\u003ethink twice ‚Äî sometimes even thrice\u003c/strong\u003e. Multiple valid approaches can coexist.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e0e7\"\u003eOn the technical side, the\u003cstrong\u003e biggest takeaway\u003c/strong\u003e is really about soft skills:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ae08\"\u003eA design pattern is a \u003cstrong\u003erecurring solution to a common problem\u003c/strong\u003e. If that solution changes significantly, it becomes a \u003cem\u003enew\u003c/em\u003e pattern.\u003c/li\u003e\u003cli id=\"2040\"\u003eYes, changes like using a single immutable data class for state, a sealed interface for intents, and a reducer function inside the ViewModel \u003cstrong\u003ecan justify defining a distinct pattern\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"6894\"\u003eYes, you can tweak/personalize a pattern and still avoid telling the other people yours is the \u0026#34;real\u0026#34; or \u0026#34;best\u0026#34; implementation.\u003c/li\u003e\u003cli id=\"0cbe\"\u003e\u003cstrong\u003eHistory matters\u003c/strong\u003e. Many people who claim MVI was inspired by Redux may not even realize that \u003cstrong\u003eMVI existed first\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"19ea\"\u003eLastly, MVI implementations \u003cstrong\u003emust not\u003c/strong\u003e include a global store like Redux. Doing so means it‚Äôs not MVI. (Yes, I‚Äôm looking at you, MVI Police ‚Äî bring it on! üöì)\u003c/li\u003e\u003cli id=\"e903\"\u003eThe MVI creator didn‚Äôt even like Redux in the first place\u003c/li\u003e\u003cli id=\"f813\"\u003eMVI is simple and straight to the point. Redux not so much‚Ä¶\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4356\"\u003eAt the end of the day, what truly matters is understanding the \u003cem\u003ewhy\u003c/em\u003e behind these patterns, \u003cstrong\u003erespecting their evolution\u003c/strong\u003e, and applying them thoughtfully to \u003cstrong\u003esolve real problems\u003c/strong\u003e. Let‚Äôs embrace the diversity of ideas instead of policing the ‚Äúright way.‚Äù This approach will foster \u003cstrong\u003ehealthier discussions\u003c/strong\u003e and ultimately better software.\u003c/p\u003e\u003cp id=\"a569\"\u003eFollow me on Medium and \u003ca href=\"http://linkedin.com/in/euryperez/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e to know when I write the article to show you how I personally leverage MVI in my projects.\u003c/p\u003e\u003cp id=\"dffd\"\u003eIf this article helped you, clap, comment and share üòâ\u003c/p\u003e\u003cp id=\"ae9a\"\u003e\u003cstrong\u003eSources:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5cb5\"\u003e\u003ca href=\"https://staltz.com/cycleconf17/#/step-1\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://staltz.com/cycleconf17/#/step-1\u003c/a\u003e\u003c/li\u003e\u003cli id=\"41fa\"\u003e\u003ca href=\"https://www.futurice.com/blog/reactive-mvc-and-the-virtual-dom\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.futurice.com/blog/reactive-mvc-and-the-virtual-dom\u003c/a\u003e\u003c/li\u003e\u003cli id=\"7c6b\"\u003e\u003ca href=\"https://staltz.com/blog\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://staltz.com/blog\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6880\"\u003e\u003ca href=\"https://staltz.com/unidirectional-user-interface-architectures\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://staltz.com/unidirectional-user-interface-architectures\u003c/a\u003e\u003c/li\u003e\u003cli id=\"a3d1\"\u003e\u003ca href=\"https://staltz.com/nothing-new-in-react-and-flux-except-one-thing\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://staltz.com/nothing-new-in-react-and-flux-except-one-thing\u003c/a\u003e\u003c/li\u003e\u003cli id=\"0f82\"\u003e\u003ca href=\"https://staltz.com/some-problems-with-react-redux\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://staltz.com/some-problems-with-react-redux\u003c/a\u003e\u003c/li\u003e\u003cli id=\"b369\"\u003e\u003ca href=\"https://hannesdorfmann.com/android/model-view-intent/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://hannesdorfmann.com/android/model-view-intent/\u003c/a\u003e\u003c/li\u003e\u003cli id=\"3cdc\"\u003e\u003ca href=\"https://redux.js.org/understanding/history-and-design/history-of-redux#2015-the-birth-of-redux\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://redux.js.org/understanding/history-and-design/history-of-redux\u003c/a\u003e\u003c/li\u003e\u003cli id=\"b2e5\"\u003e\u003ca href=\"https://legacy.reactjs.org/blog/2014/07/30/flux-actions-and-the-dispatcher.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://legacy.reactjs.org/blog/2014/07/30/flux-actions-and-the-dispatcher.html\u003c/a\u003e\u003c/li\u003e\u003cli id=\"0cd6\"\u003e\u003ca href=\"https://learn.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://learn.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\u003c/a\u003e\u003c/li\u003e\u003cli id=\"20f1\"\u003e\u003ca href=\"https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern\u003c/a\u003e\u003c/li\u003e\u003cli id=\"c891\"\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-05-29T11:29:09.716Z",
  "modifiedTime": null
}
