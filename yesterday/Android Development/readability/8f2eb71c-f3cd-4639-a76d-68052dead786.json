{
  "id": "8f2eb71c-f3cd-4639-a76d-68052dead786",
  "title": "Managing state across navigation in Jetpack Compose",
  "link": "https://proandroiddev.com/managing-state-across-navigation-in-jetpack-compose-7ff5a9f49864?source=rss----c72404660798---4",
  "description": "",
  "author": "Dmitry Glazunov",
  "published": "Mon, 30 Jun 2025 09:26:16 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "software-development",
    "jetpack-compose",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Dmitry Glazunov",
  "length": 5767,
  "excerpt": "Jetpack Compose gets rid of a lot of XML boilerplate but managing state between screens still trips up even experienced developers. This piece builds on my previous article, “Common pitfalls in…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Use ViewModel when the screen owns the stateIf your screen performs API calls, holds UI state, or drives interactions, let a ViewModel manage it:@Composablefun ProfileScreen(viewModel: ProfileViewModel) { val state by viewModel.uiState.collectAsState() // Render screen}Get the ViewModel from your NavHost:composable(\"profile/{userId}\") { val viewModel: ProfileViewModel = hiltViewModel() ProfileScreen(viewModel)}Avoid setting viewModel: ProfileViewModel = hiltViewModel() as a default parameter. It ties your composable to Hilt implicitly and hinders previewing or reusing it.Use SavedStateHandle for navigation argumentsIf your screen depends on route arguments (userId, noteId), don't parse them in the composable. Let your ViewModel extract them once:@HiltViewModelclass ProfileViewModel( savedStateHandle: SavedStateHandle) : ViewModel() { private val userId: String = checkNotNull(savedStateHandle[\"userId\"])}This way, your screen becomes stateless and resilient to recomposition or configuration changes.Use CompositionLocal for cross-cutting or session stateNeed to share state like authentication, theme, or feature flags across many screens?Use CompositionLocal, but with caution:val localSession = staticCompositionLocalOf\u003cSession\u003e { error(\"No session provided\")}@Composablefun AppContent(session: Session) { CompositionLocalProvider(LocalSession provides session) { NavHost(...) { /* screens here */ } }}@Composablefun HomeScreen() { val session = LocalSession.current Text(\"Hello, ${session.username}\")}Don’t use CompositionLocal to bypass navigation scoping or pass ViewModels around. It’s for ambient context, not state lifting.Keep state across navigation and configuration changesWhile using ViewModel, SavedStateHandle, and CompositionLocal covers many state management scenarios in Compose navigation, you can further strengthen your architecture by ensuring state is preserved across configuration changes and back stack navigation.Use rememberSaveable for transient UI stateUnlike remember, rememberSaveable persists state across configuration changes and process recreation. It’s a simple way to preserve user input and UI state without additional plumbing.@Composablefun SearchScreen() { var query by rememberSaveable { mutableStateOf(\"\") } TextField( value = query, onValueChange = { query = it }, label = { Text(\"Search\") } )}Use this when you need to keep user input, scroll positions, or simple selections across rotations or process death without adding ViewModel.Use rememberNavBackStack (Navigation 3+) for the back stack stateIf you’re using Navigation 3, rememberNavBackStack allows you to observe and manage your navigation back stack declaratively while preserving each screen’s state when navigating back. This is especially useful in bottom navigation or nested navigation graphs.@Composablefun AppNavigation() { val navController = rememberNavController() val backStack = rememberNavBackStack(navController) Scaffold( bottomBar = { BottomBar(navController, backStack) } ) { padding -\u003e NavHost(navController, startDestination = \"home\", Modifier.padding(padding)) { composable(\"home\") { HomeScreen() } composable(\"settings\") { SettingsScreen() } } }}This helps preserve state like scroll position or filters when switching between tabs or bottom navigation items.Sharing state between screensWhen multiple screens need to access shared state — for example, during a checkout process — hoist the ViewModel to a higher navigation level:navigation(startDestination = \"cart\", route = \"checkout\") { composable(\"cart\") { val viewModel: CheckoutViewModel = hiltViewModel( rememberNavController().getBackStackEntry(\"checkout\") ) CartScreen(viewModel) } composable(\"payment\") { val viewModel: CheckoutViewModel = hiltViewModel( rememberNavController().getBackStackEntry(\"checkout\") ) PaymentScreen(viewModel) }}This ensures both screens share the same instance of CheckoutViewModel, keeping the cart data, shipping info, and in-progress transaction state consistent across the flow.This pattern also works well for onboarding flows, profile editors with tabs, or any case where screens represent steps in a single business process.Avoid these navigation-state pitfallsRe-initializing ViewModels per screenAvoid creating a new ViewModel inside every composable. If screens belong to the same flow, use navGraphViewModel (or hiltViewModel(navBackStackEntry = ...)) to share state.Default ViewModel parameters in composablesDon’t use default parameters like viewModel: ProfileViewModel = hiltViewModel() inside your screen functions. This couples your composables to DI and breaks testing and previews. Inject the ViewModel from outside instead.Overusing CompositionLocal as global stateCompositionLocal is powerful, but don’t treat it as a dumping ground for all shared state. Prefer ViewModels for managing screen or flow-level state with proper lifecycle awareness.ConclusionState management in Jetpack Compose navigation is less about picking the “right” tool and more about understanding scopes, lifecycles, and composition boundaries. Whether you’re working with ViewModel, SavedStateHandle, or CompositionLocal, each has its place — and its pitfalls.Keep your navigation logic clean, your state ownership explicit, and your composables testable. By lifting state to the right level and resisting the urge to over-couple screens to DI or global context, you’ll end up with a navigation setup that’s both scalable and resilient.Got your own pattern or pain point to share? Drop it in the comments — no edge case is too small to share.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*38dpzVFZDRFojxri6Eu2kg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"d39c\"\u003eUse ViewModel when the screen owns the state\u003c/h2\u003e\u003cp id=\"6a70\"\u003eIf your screen performs API calls, holds UI state, or drives interactions, let a \u003ccode\u003eViewModel\u003c/code\u003e manage it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0077\"\u003e@Composable\u003cbr/\u003efun ProfileScreen(viewModel: ProfileViewModel) {\u003cbr/\u003e    val state by viewModel.uiState.collectAsState()\u003cbr/\u003e    // Render screen\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b0a8\"\u003eGet the \u003ccode\u003eViewModel\u003c/code\u003e from your \u003ccode\u003eNavHost\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fa9e\"\u003ecomposable(\u0026#34;profile/{userId}\u0026#34;) {\u003cbr/\u003e    val viewModel: ProfileViewModel = hiltViewModel()\u003cbr/\u003e    ProfileScreen(viewModel)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bcce\"\u003eAvoid setting \u003ccode\u003eviewModel: ProfileViewModel = hiltViewModel()\u003c/code\u003e as a default parameter. It ties your composable to Hilt implicitly and hinders previewing or reusing it.\u003c/p\u003e\u003ch2 id=\"cba0\"\u003eUse \u003ccode\u003eSavedStateHandle\u003c/code\u003e for navigation arguments\u003c/h2\u003e\u003cp id=\"c1f0\"\u003eIf your screen depends on route arguments (\u003ccode\u003euserId\u003c/code\u003e, \u003ccode\u003enoteId\u003c/code\u003e), don\u0026#39;t parse them in the composable. Let your \u003ccode\u003eViewModel\u003c/code\u003e extract them once:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bab2\"\u003e@HiltViewModel\u003cbr/\u003eclass ProfileViewModel(\u003cbr/\u003e    savedStateHandle: SavedStateHandle\u003cbr/\u003e) : ViewModel() {\u003cbr/\u003e    private val userId: String = checkNotNull(savedStateHandle[\u0026#34;userId\u0026#34;])\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d3e9\"\u003eThis way, your screen becomes stateless and resilient to recomposition or configuration changes.\u003c/p\u003e\u003ch2 id=\"252a\"\u003eUse \u003ccode\u003eCompositionLocal\u003c/code\u003e for cross-cutting or session state\u003c/h2\u003e\u003cp id=\"0a28\"\u003eNeed to share state like authentication, theme, or feature flags across many screens?\u003c/p\u003e\u003cp id=\"4013\"\u003eUse \u003ccode\u003eCompositionLocal\u003c/code\u003e, but with caution:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a6dd\"\u003eval localSession = staticCompositionLocalOf\u0026lt;Session\u0026gt; {\u003cbr/\u003e    error(\u0026#34;No session provided\u0026#34;)\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun AppContent(session: Session) {\u003cbr/\u003e    CompositionLocalProvider(LocalSession provides session) {\u003cbr/\u003e        NavHost(...) { /* screens here */ }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun HomeScreen() {\u003cbr/\u003e    val session = LocalSession.current\u003cbr/\u003e    Text(\u0026#34;Hello, ${session.username}\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ed20\"\u003eDon’t use \u003ccode\u003eCompositionLocal\u003c/code\u003e to bypass navigation scoping or pass ViewModels around. It’s for ambient context, not state lifting.\u003c/p\u003e\u003ch2 id=\"5c56\"\u003eKeep state across navigation and configuration changes\u003c/h2\u003e\u003cp id=\"4158\"\u003eWhile using \u003ccode\u003eViewModel\u003c/code\u003e, \u003ccode\u003eSavedStateHandle\u003c/code\u003e, and \u003ccode\u003eCompositionLocal\u003c/code\u003e covers many state management scenarios in Compose navigation, you can further strengthen your architecture by ensuring state is preserved across configuration changes and back stack navigation.\u003c/p\u003e\u003cp id=\"48d1\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erememberSaveable\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for transient UI state\u003c/strong\u003e\u003cbr/\u003eUnlike \u003ccode\u003eremember\u003c/code\u003e, \u003ccode\u003erememberSaveable\u003c/code\u003e persists state across configuration changes and process recreation. It’s a simple way to preserve user input and UI state without additional plumbing.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7b3f\"\u003e@Composable\u003cbr/\u003efun SearchScreen() {\u003cbr/\u003e    var query by rememberSaveable { mutableStateOf(\u0026#34;\u0026#34;) }\u003cp\u003e    TextField(\u003cbr/\u003e        value = query,\u003cbr/\u003e        onValueChange = { query = it },\u003cbr/\u003e        label = { Text(\u0026#34;Search\u0026#34;) }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b893\"\u003eUse this when you need to keep user input, scroll positions, or simple selections across rotations or process death without adding ViewModel.\u003c/p\u003e\u003cp id=\"0eb6\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erememberNavBackStack\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e (Navigation 3+) for the back stack state\u003c/strong\u003e\u003cbr/\u003eIf you’re using Navigation 3, \u003ccode\u003erememberNavBackStack\u003c/code\u003e allows you to observe and manage your navigation back stack declaratively while preserving each screen’s state when navigating back. This is especially useful in bottom navigation or nested navigation graphs.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"530e\"\u003e@Composable\u003cbr/\u003efun AppNavigation() {\u003cbr/\u003e    val navController = rememberNavController()\u003cbr/\u003e    val backStack = rememberNavBackStack(navController)\u003cp\u003e    Scaffold(\u003cbr/\u003e        bottomBar = { BottomBar(navController, backStack) }\u003cbr/\u003e    ) { padding -\u0026gt;\u003cbr/\u003e        NavHost(navController, startDestination = \u0026#34;home\u0026#34;, Modifier.padding(padding)) {\u003cbr/\u003e            composable(\u0026#34;home\u0026#34;) { HomeScreen() }\u003cbr/\u003e            composable(\u0026#34;settings\u0026#34;) { SettingsScreen() }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"089a\"\u003eThis helps preserve state like scroll position or filters when switching between tabs or bottom navigation items.\u003c/p\u003e\u003ch2 id=\"3d10\"\u003eSharing state between screens\u003c/h2\u003e\u003cp id=\"b5fa\"\u003eWhen multiple screens need to access shared state — for example, during a checkout process — hoist the \u003ccode\u003eViewModel\u003c/code\u003e to a higher navigation level:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"07d0\"\u003enavigation(startDestination = \u0026#34;cart\u0026#34;, route = \u0026#34;checkout\u0026#34;) {\u003cbr/\u003e    composable(\u0026#34;cart\u0026#34;) {\u003cbr/\u003e        val viewModel: CheckoutViewModel = hiltViewModel(\u003cbr/\u003e            rememberNavController().getBackStackEntry(\u0026#34;checkout\u0026#34;)\u003cbr/\u003e        )\u003cbr/\u003e        CartScreen(viewModel)\u003cbr/\u003e    }\u003cbr/\u003e    composable(\u0026#34;payment\u0026#34;) {\u003cbr/\u003e        val viewModel: CheckoutViewModel = hiltViewModel(\u003cbr/\u003e            rememberNavController().getBackStackEntry(\u0026#34;checkout\u0026#34;)\u003cbr/\u003e        )\u003cbr/\u003e        PaymentScreen(viewModel)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"170b\"\u003eThis ensures both screens share the same instance of \u003ccode\u003eCheckoutViewModel\u003c/code\u003e, keeping the cart data, shipping info, and in-progress transaction state consistent across the flow.\u003cbr/\u003eThis pattern also works well for onboarding flows, profile editors with tabs, or any case where screens represent steps in a single business process.\u003c/p\u003e\u003ch2 id=\"f4fb\"\u003eAvoid these navigation-state pitfalls\u003c/h2\u003e\u003cp id=\"7556\"\u003e\u003cstrong\u003eRe-initializing ViewModels per screen\u003c/strong\u003e\u003cbr/\u003eAvoid creating a new ViewModel inside every composable. If screens belong to the same flow, use \u003ccode\u003enavGraphViewModel\u003c/code\u003e (or \u003ccode\u003ehiltViewModel(navBackStackEntry = ...)\u003c/code\u003e) to share state.\u003c/p\u003e\u003cp id=\"8bd3\"\u003e\u003cstrong\u003eDefault ViewModel parameters in composables\u003c/strong\u003e\u003cbr/\u003eDon’t use default parameters like \u003ccode\u003eviewModel: ProfileViewModel = hiltViewModel()\u003c/code\u003e inside your screen functions. This couples your composables to DI and breaks testing and previews. Inject the ViewModel from outside instead.\u003c/p\u003e\u003cp id=\"81f7\"\u003e\u003cstrong\u003eOverusing CompositionLocal as global state\u003c/strong\u003e\u003cbr/\u003e\u003ccode\u003eCompositionLocal\u003c/code\u003e is powerful, but don’t treat it as a dumping ground for all shared state. Prefer ViewModels for managing screen or flow-level state with proper lifecycle awareness.\u003c/p\u003e\u003ch2 id=\"2781\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"ca73\"\u003eState management in Jetpack Compose navigation is less about picking the “right” tool and more about understanding scopes, lifecycles, and composition boundaries. Whether you’re working with \u003ccode\u003eViewModel\u003c/code\u003e, \u003ccode\u003eSavedStateHandle\u003c/code\u003e, or \u003ccode\u003eCompositionLocal\u003c/code\u003e, each has its place — and its pitfalls.\u003c/p\u003e\u003cp id=\"3955\"\u003eKeep your navigation logic clean, your state ownership explicit, and your composables testable. By lifting state to the right level and resisting the urge to over-couple screens to DI or global context, you’ll end up with a navigation setup that’s both scalable and resilient.\u003c/p\u003e\u003cp id=\"006a\"\u003eGot your own pattern or pain point to share? Drop it in the comments — no edge case is too small to share.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-06-30T09:26:16.53Z",
  "modifiedTime": null
}
