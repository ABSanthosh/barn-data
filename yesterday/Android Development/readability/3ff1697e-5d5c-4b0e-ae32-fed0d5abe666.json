{
  "id": "3ff1697e-5d5c-4b0e-ae32-fed0d5abe666",
  "title": "Easiest Way to Create a Shimmer Effect in Jetpack Compose",
  "link": "https://proandroiddev.com/easiest-way-to-create-a-shimmer-effect-in-jetpack-compose-b56eae5e311e?source=rss----c72404660798---4",
  "description": "",
  "author": "",
  "published": "Mon, 14 Jul 2025 18:49:49 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "jetpack-compose",
    "shimmer-effect",
    "ui",
    "kotlin"
  ],
  "byline": "@tawhidmonowar",
  "length": 5352,
  "excerpt": "If you’ve ever scrolled through YouTube, LinkedIn, or any modern mobile app, you’ve seen the shimmer effect — a placeholder animation that gives users visual feedback while content loads. It’s…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "If you’ve ever scrolled through YouTube, LinkedIn, or any modern mobile app, you’ve seen the shimmer effect — a placeholder animation that gives users visual feedback while content loads. It’s subtle, smooth, and makes your app feel more responsive.In Jetpack Compose, you don’t need a library or complicated setup to achieve this. All it takes is one Kotlin extension function. In this post, I’ll walk you through a simple Modifier.shimmer() extension that you can apply to any composable. You’ll also learn how to toggle shimmer using a loading state.Creating a Shimmer ModifierHere’s a custom extension you can apply to any composable to give it a shimmer effect:@Composablefun Modifier.shimmer(cornerRadius: Dp = 0.dp): Modifier { val shimmerColors = listOf( Color.LightGray.copy(alpha = 0.3f), Color.White.copy(alpha = 0.6f), Color.LightGray.copy(alpha = 0.3f) ) val transition = rememberInfiniteTransition(label = \"Shimmer\") val translateAnim by transition.animateFloat( initialValue = -400f, targetValue = 1200f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 1600, // slower = smoother easing = FastOutSlowInEasing // smoother easing ) ), label = \"Translate\" ) return this.drawWithCache { val brush = Brush.linearGradient( colors = shimmerColors, start = Offset(translateAnim, 0f), // wider gradient end = Offset(translateAnim + size.width / 1.5f, size.height) ) val cornerPx = cornerRadius.toPx() onDrawWithContent { drawRoundRect( brush = brush, cornerRadius = CornerRadius(cornerPx, cornerPx), size = size ) } }}This modifier uses rememberInfiniteTransition() to animate a moving light across a gradient. The drawWithCache block is used for better performance since the brush can be reused. The result is a soft, moving light across your UI component, giving the appearance of loading.Applying the Shimmer EffectLet’s create a simple loading card using the modifier:@Composablefun LoadingCard() { Box( modifier = Modifier .fillMaxWidth() .height(120.dp) .padding(16.dp) .shimmer() )}You can use this on any UI component — Image, Surface, Box, or even wrap entire rows or lists.Making It Smarter with isLoadingOf course, we don’t want to apply a shimmer all the time. Let’s make it conditional with an isLoading flag.First, extend the modifier like this:@Composablefun Modifier.shimmer(cornerRadius: Dp = 0.dp, isLoading: Boolean): Modifier { return if (isLoading) this.shimmer(cornerRadius = cornerRadius) else this}Now, in your composable, you can control when shimmer appears:@Composablefun ArticleCard(isLoading: Boolean) { Box( modifier = Modifier .fillMaxWidth() .height(120.dp) .padding(16.dp) .shimmer(isLoading = isLoading, cornerRadius = 12.dp) ) { if (!isLoading) { Text( text = \"Understanding Jetpack Compose State\", modifier = Modifier.align(Alignment.Center) ) } }}This is perfect when you’re loading data from an API or a ViewModel. As soon as the data is available, isLoading becomes false, and real content replaces the shimmer placeholder.Reusable Wrapper ComposableYou can also create a reusable composable to wrap any content in a shimmer effect. Here’s a simple ShimmerItem:@Composablefun ShimmerItem(isLoading: Boolean, content: @Composable () -\u003e Unit) { Box(modifier = Modifier.shimmer(isLoading)) { if (!isLoading) content() }}Use it like this:ShimmerItem(isLoading = true) { Text(\"Loaded text\", modifier = Modifier.padding(16.dp))}This way, you can easily apply shimmer to any component in your UI tree without duplicating code.Full Example with a List: Let’s put this all together in a LazyColumn:@Composablefun ArticleList(isLoading: Boolean) { LazyColumn(modifier = Modifier.fillMaxSize()) { items(5) { ArticleCard(isLoading = isLoading) } }}If isLoading is true, you’ll see shimmer cards. When the data is loaded, the real content will show up.Customizing the LookWant to make the shimmer effect match your brand? Just update the gradient colors. For example:val shimmerColors = listOf( Color(0xFFE0E0E0), Color(0xFFBDBDBD), Color(0xFFE0E0E0))Or make the animation vertical instead of diagonal by adjusting the gradient’s start and end offsets.You can also add rounded corners to the shimmer by Just pass the desired Dp value to the cornerRadius parameter:Modifier.shimmer(cornerRadius = 12.dp)This makes it feel more like a card or a chip.Final ResultConclusionShimmer is one of those tiny UX details that makes a big difference. It shows users that your app is working, even when content isn’t ready. With Jetpack Compose, you don’t need to pull in an external library or create a custom layout — you can get it done with a few lines of Kotlin.Whether you’re building a loading feed, a profile screen, or a settings page, this shimmer effect can make your app feel more polished and professional. And the best part? It’s reusable, customizable, and 100% Compose-native.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*GMsLeKpSsBe9-JPonwTceg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://tawhidmonowar.medium.com/?source=post_page---byline--b56eae5e311e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"@tawhidmonowar\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*rKscW__X1roS2ouMePN8wg.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a4c1\"\u003eIf you’ve ever scrolled through YouTube, LinkedIn, or any modern mobile app, you’ve seen the \u003cstrong\u003eshimmer effect\u003c/strong\u003e — a placeholder animation that gives users visual feedback while content loads. It’s subtle, smooth, and makes your app feel more responsive.\u003c/p\u003e\u003cp id=\"b39a\"\u003eIn Jetpack Compose, you don’t need a library or complicated setup to achieve this. All it takes is \u003cstrong\u003eone Kotlin extension function\u003c/strong\u003e. In this post, I’ll walk you through a simple \u003ccode\u003eModifier.shimmer()\u003c/code\u003e extension that you can apply to any composable. You’ll also learn how to toggle shimmer using a \u003ccode\u003eloading\u003c/code\u003e state.\u003c/p\u003e\u003ch2 id=\"7ac2\"\u003e\u003cstrong\u003eCreating a Shimmer Modifier\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"def8\"\u003eHere’s a custom extension you can apply to any composable to give it a shimmer effect:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0377\"\u003e@Composable\u003cbr/\u003efun Modifier.shimmer(cornerRadius: Dp = 0.dp): Modifier {\u003cbr/\u003e    val shimmerColors = listOf(\u003cbr/\u003e        Color.LightGray.copy(alpha = 0.3f),\u003cbr/\u003e        Color.White.copy(alpha = 0.6f),\u003cbr/\u003e        Color.LightGray.copy(alpha = 0.3f)\u003cbr/\u003e    )\u003cp\u003e    val transition = rememberInfiniteTransition(label = \u0026#34;Shimmer\u0026#34;)\u003cbr/\u003e    val translateAnim by transition.animateFloat(\u003cbr/\u003e        initialValue = -400f,\u003cbr/\u003e        targetValue = 1200f,\u003cbr/\u003e        animationSpec = infiniteRepeatable(\u003cbr/\u003e            animation = tween(\u003cbr/\u003e                durationMillis = 1600, // slower = smoother\u003cbr/\u003e                easing = FastOutSlowInEasing // smoother easing\u003cbr/\u003e            )\u003cbr/\u003e        ),\u003cbr/\u003e        label = \u0026#34;Translate\u0026#34;\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    return this.drawWithCache {\u003cbr/\u003e        val brush = Brush.linearGradient(\u003cbr/\u003e            colors = shimmerColors,\u003cbr/\u003e            start = Offset(translateAnim, 0f),\u003cbr/\u003e            // wider gradient\u003cbr/\u003e            end = Offset(translateAnim + size.width / 1.5f, size.height)\u003cbr/\u003e        )\u003cbr/\u003e        val cornerPx = cornerRadius.toPx()\u003cbr/\u003e        onDrawWithContent {\u003cbr/\u003e            drawRoundRect(\u003cbr/\u003e                brush = brush,\u003cbr/\u003e                cornerRadius = CornerRadius(cornerPx, cornerPx),\u003cbr/\u003e                size = size\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ff45\"\u003eThis modifier uses \u003ccode\u003erememberInfiniteTransition()\u003c/code\u003e to animate a moving light across a gradient. The \u003ccode\u003edrawWithCache\u003c/code\u003e block is used for better performance since the brush can be reused. The result is a soft, moving light across your UI component, giving the appearance of loading.\u003c/p\u003e\u003ch2 id=\"0a71\"\u003eApplying the Shimmer Effect\u003c/h2\u003e\u003cp id=\"7d7c\"\u003eLet’s create a simple loading card using the modifier:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df63\"\u003e@Composable\u003cbr/\u003efun LoadingCard() {\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .height(120.dp)\u003cbr/\u003e            .padding(16.dp)\u003cbr/\u003e            .shimmer()\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"19f9\"\u003eYou can use this on any UI component — \u003ccode\u003eImage\u003c/code\u003e, \u003ccode\u003eSurface\u003c/code\u003e, \u003ccode\u003eBox\u003c/code\u003e, or even wrap entire rows or lists.\u003c/p\u003e\u003ch2 id=\"afbc\"\u003eMaking It Smarter with \u003ccode\u003eisLoading\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"fc02\"\u003eOf course, we don’t want to apply a shimmer all the time. Let’s make it conditional with an \u003ccode\u003eisLoading\u003c/code\u003e flag.\u003c/p\u003e\u003cp id=\"d7d0\"\u003eFirst, extend the modifier like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0987\"\u003e@Composable\u003cbr/\u003efun Modifier.shimmer(cornerRadius: Dp = 0.dp, isLoading: Boolean): Modifier {\u003cbr/\u003e    return if (isLoading) this.shimmer(cornerRadius = cornerRadius) else this\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"90a9\"\u003eNow, in your composable, you can control when shimmer appears:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0095\"\u003e@Composable\u003cbr/\u003efun ArticleCard(isLoading: Boolean) {\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .height(120.dp)\u003cbr/\u003e            .padding(16.dp)\u003cbr/\u003e            .shimmer(isLoading = isLoading, cornerRadius = 12.dp)\u003cbr/\u003e    ) {\u003cbr/\u003e        if (!isLoading) {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = \u0026#34;Understanding Jetpack Compose State\u0026#34;,\u003cbr/\u003e                modifier = Modifier.align(Alignment.Center)\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"890f\"\u003eThis is perfect when you’re loading data from an API or a ViewModel. As soon as the data is available, \u003ccode\u003eisLoading\u003c/code\u003e becomes false, and real content replaces the shimmer placeholder.\u003c/p\u003e\u003ch2 id=\"969e\"\u003eReusable Wrapper Composable\u003c/h2\u003e\u003cp id=\"bb93\"\u003eYou can also create a reusable composable to wrap any content in a shimmer effect. Here’s a simple \u003ccode\u003eShimmerItem\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d248\"\u003e@Composable\u003cbr/\u003efun ShimmerItem(isLoading: Boolean, content: @Composable () -\u0026gt; Unit) {\u003cbr/\u003e    Box(modifier = Modifier.shimmer(isLoading)) {\u003cbr/\u003e        if (!isLoading) content()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9eb5\"\u003eUse it like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"af42\"\u003eShimmerItem(isLoading = true) {\u003cbr/\u003e    Text(\u0026#34;Loaded text\u0026#34;, modifier = Modifier.padding(16.dp))\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"066f\"\u003eThis way, you can easily apply shimmer to any component in your UI tree without duplicating code.\u003c/p\u003e\u003cp id=\"09ff\"\u003eFull Example with a List: Let’s put this all together in a \u003ccode\u003eLazyColumn\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5710\"\u003e@Composable\u003cbr/\u003efun ArticleList(isLoading: Boolean) {\u003cbr/\u003e    LazyColumn(modifier = Modifier.fillMaxSize()) {\u003cbr/\u003e        items(5) {\u003cbr/\u003e            ArticleCard(isLoading = isLoading)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3728\"\u003eIf \u003ccode\u003eisLoading\u003c/code\u003e is true, you’ll see shimmer cards. When the data is loaded, the real content will show up.\u003c/p\u003e\u003ch2 id=\"f42b\"\u003eCustomizing the Look\u003c/h2\u003e\u003cp id=\"a43b\"\u003eWant to make the shimmer effect match your brand? Just update the gradient colors. For example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"870b\"\u003eval shimmerColors = listOf(\u003cbr/\u003e    Color(0xFFE0E0E0),\u003cbr/\u003e    Color(0xFFBDBDBD),\u003cbr/\u003e    Color(0xFFE0E0E0)\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3eca\"\u003eOr make the animation vertical instead of diagonal by adjusting the gradient’s \u003ccode\u003estart\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e offsets.\u003c/p\u003e\u003cp id=\"6ec7\"\u003eYou can also add rounded corners to the shimmer by Just pass the desired \u003ccode\u003eDp\u003c/code\u003e value to the \u003ccode\u003ecornerRadius\u003c/code\u003e parameter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"afd6\"\u003eModifier.shimmer(cornerRadius = 12.dp)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"05ba\"\u003eThis makes it feel more like a card or a chip.\u003c/p\u003e\u003ch2 id=\"2a1e\"\u003eFinal Result\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1850\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"8882\"\u003eShimmer is one of those tiny UX details that makes a big difference. It shows users that your app is working, even when content isn’t ready. With Jetpack Compose, you don’t need to pull in an external library or create a custom layout — you can get it done with a few lines of Kotlin.\u003c/p\u003e\u003cp id=\"22a4\"\u003eWhether you’re building a loading feed, a profile screen, or a settings page, this shimmer effect can make your app feel more polished and professional. And the best part? It’s reusable, customizable, and 100% Compose-native.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-07-14T18:49:49.891Z",
  "modifiedTime": null
}
