{
  "id": "dbfa188a-4d05-4052-bea2-9a930637b762",
  "title": "Analyzing App Startup and Shutdown in Android 15: New Update",
  "link": "https://proandroiddev.com/analyzing-app-startup-and-shutdown-in-android-15-new-update-7605369ae891?source=rss----c72404660798---4",
  "description": "",
  "author": "Tomáš Repčík",
  "published": "Thu, 17 Oct 2024 16:11:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "android",
    "android-app-development",
    "programming",
    "mobile-app-development"
  ],
  "byline": "Tomáš Repčík",
  "length": 9743,
  "excerpt": "Android 11 introduced ApplicationExitInfo, from which you can get historical reasons why the app was turned off / killed. Android 15 implemented new ApplicationStartInfo can be used to analyze the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Using Android 15 new ApplicationStartInfoAndroid 11 introduced ApplicationExitInfo, from which you can get historical reasons why the app was turned off / killed.Android 15 implemented new ApplicationStartInfo can be used to analyze the causes of why and how the app was launched.With both kinds of data, you can track how the users use the app. You can check if no issues are persisting in the app with exit data and now also how the app is started.ApplicationStartInfoAs it was outlined, the ApplicationStartInfo was introduced with Android 15, so it will be available only for devices running API 35 and higher. So make sure to use appropriate version handling or mark all the methods with @RequiresApi(api = Build.VERSION_CODES.VANILLA_ICE_CREAM).To access history start data, you need to do the following:val activityManager: ActivityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManagerval startInfos = activityManager.getHistoricalProcessStartReasons(maxNumberOfInstances)Get ActivityManager from system services and with its help, you can pull as many historical data as they are available at storage with your maximum number of required instances.Available data:Start reason — the reason why the app started — notification, user clicked on launcher icon, alarm, …Startup state — the start-up state at which the app is currently — error, started, first frameStart type — the starting state of the app — cold boot, warm boot, …Launch mode — how the current activity is reused or replaced — singleInstance, singleTask, singleTop, standard, …Forced stopped — if the launch is the first one, since the app was forced stoppedIntent — intent used to launch the activityStartup Times — map of timestamps for events during the startup in nanosecondsval startType = startInfo.startTypeval startReason = startInfo.reasonval startUpState = startInfo.startupStateval launchMode = startInfo.launchModeval startTimestamp = startInfo.startupTimestampsval wasForceStopped = startInfo.wasForceStopped()val startIntent = startInfo.intentMost of the values are integers, which are defined as static integer constants under ApplicationStartInfo.Add callbackYou can add a callback function to receive info when the app is fully started up and receive startup info right away without querying the history. It returns a list of ApplicationStartInfo.val executor = context.mainExecutoractivityManager.addApplicationStartInfoCompletionListener(executor) { // access the ApplicationStartInfo via `it`}Add your eventsYou can add your events to the history with the use of your set of constants, which must be bigger than 20 and less or equal to 30 based on the documentation.Time is in nanoseconds.val currentTimeInNanos = System.nanoTime()activityManager.addStartInfoTimestamp(25, timestamp)System.nanoTime() does not reference Unix epoch, but if you have 2 or more timestamps, it gives you more granular view on performance.ApplicationExitInfoTo make this article complete, Android provides a way to receive information about how the app was ended. It returns a list of ApplicationExitInfo.val exitInfos = activityManager.getHistoricalProcessExitReasons(packageName, 0, maxNum)It works almost in the same way, but you need to provide the package name from context, and process ID (PID), which you can leave 0 for all records and a maximum number of exit reasons to receive.Available data:Exit reason — why the app was stoppedDescription — human readable reason, why the app stoppedExit Importance — how important the app was, when it was stopped — foreground, dozing, …Stop time — timestamp in milliseconds, when the app was stoppedExit reasons are once again mostly static constant integers defined in ApplicationExitInfo and ActivityManager.RunningAppProcessInfo.Example usageMost of the states and reasons are integers defined in appropriate classes as static constants, so we usually want to use when statement to classify the result.I prefer using enums since integers do not define constraints and statements cannot be exhaustive. Moreover, you can still nicely serialize them with the use of Kotlin’s serialization.Example for starting reason:enum class StartReason { START_REASON_ALARM, START_REASON_BACKUP, START_REASON_BOOT_COMPLETE, START_REASON_BROADCAST, START_REASON_CONTENT_PROVIDER, START_REASON_JOB, START_REASON_LAUNCHER, START_REASON_LAUNCHER_RECENTS, START_REASON_OTHER, START_REASON_PUSH, START_REASON_SERVICE, START_REASON_START_ACTIVITY; companion object { fun fromValue(value: Int): StartReason = when (value) { ApplicationStartInfo.START_REASON_ALARM -\u003e START_REASON_ALARM ApplicationStartInfo.START_REASON_BACKUP -\u003e START_REASON_BACKUP ApplicationStartInfo.START_REASON_BOOT_COMPLETE -\u003e START_REASON_BOOT_COMPLETE ApplicationStartInfo.START_REASON_BROADCAST -\u003e START_REASON_BROADCAST ApplicationStartInfo.START_REASON_CONTENT_PROVIDER -\u003e START_REASON_CONTENT_PROVIDER ApplicationStartInfo.START_REASON_JOB -\u003e START_REASON_JOB ApplicationStartInfo.START_REASON_LAUNCHER -\u003e START_REASON_LAUNCHER ApplicationStartInfo.START_REASON_LAUNCHER_RECENTS -\u003e START_REASON_LAUNCHER_RECENTS ApplicationStartInfo.START_REASON_OTHER -\u003e START_REASON_OTHER ApplicationStartInfo.START_REASON_PUSH -\u003e START_REASON_PUSH ApplicationStartInfo.START_REASON_SERVICE -\u003e START_REASON_SERVICE ApplicationStartInfo.START_REASON_START_ACTIVITY -\u003e START_REASON_START_ACTIVITY else -\u003e throw IllegalArgumentException(\"Unknown start reason value: $value\") } }}Similarly, we can create a data class to map timestamps from starting information:data class StartupTimestamps( val applicationOnCreate: Long? = null, val bindApplication: Long? = null, val firstFrame: Long? = null, val fork: Long? = null, val fullyDrawn: Long? = null, val initialRenderThreadFrame: Long? = null, val launch: Long? = null, val reservedRangeDeveloper: Long? = null, val reservedRangeDeveloperStart: Long? = null, val reservedRangeSystem: Long? = null, val surfaceFlingerCompositionComplete: Long? = null) { companion object { fun fromMap(timestampMap: Map\u003cInt, Long\u003e): StartupTimestamps = StartupTimestamps( applicationOnCreate = timestampMap[ApplicationStartInfo.START_TIMESTAMP_APPLICATION_ONCREATE], bindApplication = timestampMap[ApplicationStartInfo.START_TIMESTAMP_BIND_APPLICATION], firstFrame = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FIRST_FRAME], fork = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FORK], fullyDrawn = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FULLY_DRAWN], initialRenderThreadFrame = timestampMap[ApplicationStartInfo.START_TIMESTAMP_INITIAL_RENDERTHREAD_FRAME], launch = timestampMap[ApplicationStartInfo.START_TIMESTAMP_LAUNCH], reservedRangeDeveloper = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER], reservedRangeDeveloperStart = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER_START], reservedRangeSystem = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_SYSTEM], surfaceFlingerCompositionComplete = timestampMap[ApplicationStartInfo.START_TIMESTAMP_SURFACEFLINGER_COMPOSITION_COMPLETE] ) }}Or we can define exit reasons:enum class ExitReason { REASON_ANR, REASON_CRASH, REASON_CRASH_NATIVE, REASON_DEPENDENCY_DIED, REASON_EXCESSIVE_RESOURCE_USAGE, REASON_EXIT_SELF, REASON_FREEZER, REASON_INITIALIZATION_FAILURE, REASON_LOW_MEMORY, REASON_OTHER, REASON_PACKAGE_STATE_CHANGE, REASON_PACKAGE_UPDATED, REASON_PERMISSION_CHANGE, REASON_SIGNALED, REASON_UNKNOWN, REASON_USER_REQUESTED, REASON_USER_STOPPED; companion object { fun fromValue(value: Int): ExitReason = when (value) { ApplicationExitInfo.REASON_ANR -\u003e REASON_ANR ApplicationExitInfo.REASON_CRASH -\u003e REASON_CRASH ApplicationExitInfo.REASON_CRASH_NATIVE -\u003e REASON_CRASH_NATIVE ApplicationExitInfo.REASON_DEPENDENCY_DIED -\u003e REASON_DEPENDENCY_DIED ApplicationExitInfo.REASON_EXCESSIVE_RESOURCE_USAGE -\u003e REASON_EXCESSIVE_RESOURCE_USAGE ApplicationExitInfo.REASON_EXIT_SELF -\u003e REASON_EXIT_SELF ApplicationExitInfo.REASON_FREEZER -\u003e REASON_FREEZER ApplicationExitInfo.REASON_INITIALIZATION_FAILURE -\u003e REASON_INITIALIZATION_FAILURE ApplicationExitInfo.REASON_LOW_MEMORY -\u003e REASON_LOW_MEMORY ApplicationExitInfo.REASON_OTHER -\u003e REASON_OTHER ApplicationExitInfo.REASON_PACKAGE_STATE_CHANGE -\u003e REASON_PACKAGE_STATE_CHANGE ApplicationExitInfo.REASON_PACKAGE_UPDATED -\u003e REASON_PACKAGE_UPDATED ApplicationExitInfo.REASON_PERMISSION_CHANGE -\u003e REASON_PERMISSION_CHANGE ApplicationExitInfo.REASON_SIGNALED -\u003e REASON_SIGNALED ApplicationExitInfo.REASON_UNKNOWN -\u003e REASON_UNKNOWN ApplicationExitInfo.REASON_USER_REQUESTED -\u003e REASON_USER_REQUESTED ApplicationExitInfo.REASON_USER_STOPPED -\u003e REASON_USER_STOPPED else -\u003e throw IllegalArgumentException(\"Unknown exit reason value: $value\") } }}Feel free to replace the throw with some default value, if you want to.Similarly, to other parameters, you can create further enums or other data classes to your pleasure. For further details visit the Android documentation below.For a full example app, visit my repository:Thanks for reading and remember to follow!More Android stories:Android development",
  "image": "https://miro.medium.com/v2/resize:fit:512/1*wfWz1HYP41TNFQDnWPtiow.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"d9e7\"\u003eUsing Android 15 new ApplicationStartInfo\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://tomas-repcik.medium.com/?source=post_page-----7605369ae891--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Tomáš Repčík\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*QX6LD5rc1fKOUgo0ANp0kw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----7605369ae891--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"be7f\"\u003eAndroid 11 introduced \u003ccode\u003eApplicationExitInfo\u003c/code\u003e, from which you can get historical reasons why the app was turned off / killed.\u003c/p\u003e\u003cp id=\"89d4\"\u003eAndroid 15 implemented new \u003ccode\u003eApplicationStartInfo\u003c/code\u003e can be used to analyze the causes of why and how the app was launched.\u003c/p\u003e\u003cp id=\"c33c\"\u003eWith both kinds of data, you can track how the users use the app. You can check if no issues are persisting in the app with exit data and now also how the app is started.\u003c/p\u003e\u003ch2 id=\"bcd4\"\u003eApplicationStartInfo\u003c/h2\u003e\u003cp id=\"6ab7\"\u003eAs it was outlined, the \u003ccode\u003eApplicationStartInfo\u003c/code\u003e was introduced with Android 15, so it will be available only for devices running API 35 and higher. So make sure to use appropriate version handling or mark all the methods with \u003ccode\u003e@RequiresApi(api = Build.VERSION_CODES.VANILLA_ICE_CREAM)\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"fa50\"\u003eTo access history start data, you need to do the following:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ead2\"\u003eval activityManager: ActivityManager =\u003cbr/\u003e        context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager\u003cbr/\u003eval startInfos = activityManager.getHistoricalProcessStartReasons(maxNumberOfInstances)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"534a\"\u003eGet \u003ccode\u003eActivityManager\u003c/code\u003e from system services and with its help, you can pull as many historical data as they are available at storage with your maximum number of required instances.\u003c/p\u003e\u003ch2 id=\"7a35\"\u003eAvailable data:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"ba4b\"\u003e\u003cstrong\u003eStart reason\u003c/strong\u003e — the reason why the app started — notification, user clicked on launcher icon, alarm, …\u003c/li\u003e\u003cli id=\"9061\"\u003e\u003cstrong\u003eStartup state\u003c/strong\u003e — the start-up state at which the app is currently — error, started, first frame\u003c/li\u003e\u003cli id=\"9b65\"\u003e\u003cstrong\u003eStart type\u003c/strong\u003e — the starting state of the app — cold boot, warm boot, …\u003c/li\u003e\u003cli id=\"9357\"\u003e\u003cstrong\u003eLaunch mode\u003c/strong\u003e — how the current activity is reused or replaced — singleInstance, singleTask, singleTop, standard, …\u003c/li\u003e\u003cli id=\"fd1a\"\u003e\u003cstrong\u003eForced stopped\u003c/strong\u003e — if the launch is the first one, since the app was forced stopped\u003c/li\u003e\u003cli id=\"e7fe\"\u003e\u003cstrong\u003eIntent\u003c/strong\u003e — intent used to launch the activity\u003c/li\u003e\u003cli id=\"9004\"\u003e\u003cstrong\u003eStartup Times\u003c/strong\u003e — map of timestamps for events during the startup in \u003cstrong\u003enanoseconds\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"1724\"\u003eval startType = startInfo.startType\u003cbr/\u003eval startReason = startInfo.reason\u003cbr/\u003eval startUpState = startInfo.startupState\u003cbr/\u003eval launchMode = startInfo.launchMode\u003cbr/\u003eval startTimestamp = startInfo.startupTimestamps\u003cbr/\u003eval wasForceStopped = startInfo.wasForceStopped()\u003cbr/\u003eval startIntent = startInfo.intent\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ab4c\"\u003eMost of the values are integers, which are defined as static integer constants under \u003ccode\u003eApplicationStartInfo\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"18bc\"\u003eAdd callback\u003c/h2\u003e\u003cp id=\"c613\"\u003eYou can add a callback function to receive info when the app is fully started up and receive startup info right away without querying the history. It returns a list of \u003ccode\u003eApplicationStartInfo\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d205\"\u003eval executor = context.mainExecutor\u003cbr/\u003eactivityManager.addApplicationStartInfoCompletionListener(executor) {\u003cbr/\u003e  // access the ApplicationStartInfo via `it`\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"25c0\"\u003eAdd your events\u003c/h2\u003e\u003cp id=\"b4e5\"\u003eYou can add your events to the history with the use of your set of constants, which must be bigger than 20 and less or equal to 30 based on the \u003ca href=\"https://developer.android.com/reference/android/app/ActivityManager#addStartInfoTimestamp(int,%20long)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"2ff3\"\u003eTime is in nanoseconds.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0d23\"\u003eval currentTimeInNanos = System.nanoTime()\u003cbr/\u003eactivityManager.addStartInfoTimestamp(25, timestamp)\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"d9df\"\u003e\u003ccode\u003e\u003cem\u003eSystem.nanoTime()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e does not reference Unix epoch, but if you have 2 or more timestamps, it gives you more granular view on performance.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"fc5b\"\u003eApplicationExitInfo\u003c/h2\u003e\u003cp id=\"fab3\"\u003eTo make this article complete, Android provides a way to receive information about how the app was ended. It returns a list of \u003ccode\u003eApplicationExitInfo\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7a71\"\u003eval exitInfos = activityManager.getHistoricalProcessExitReasons(packageName, 0, maxNum)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3b6a\"\u003eIt works almost in the same way, but you need to provide the package name from context, and process ID (PID), which you can leave 0 for all records and a maximum number of exit reasons to receive.\u003c/p\u003e\u003ch2 id=\"451b\"\u003eAvailable data:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6b33\"\u003e\u003cstrong\u003eExit reason\u003c/strong\u003e — why the app was stopped\u003c/li\u003e\u003cli id=\"9704\"\u003e\u003cstrong\u003eDescription\u003c/strong\u003e — human readable reason, why the app stopped\u003c/li\u003e\u003cli id=\"f9ba\"\u003e\u003cstrong\u003eExit Importance\u003c/strong\u003e — how important the app was, when it was stopped — foreground, dozing, …\u003c/li\u003e\u003cli id=\"963f\"\u003e\u003cstrong\u003eStop time\u003c/strong\u003e — timestamp in milliseconds, when the app was stopped\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b932\"\u003eExit reasons are once again mostly static constant integers defined in \u003ccode\u003eApplicationExitInfo\u003c/code\u003e and \u003ccode\u003eActivityManager.RunningAppProcessInfo\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"9b37\"\u003eExample usage\u003c/h2\u003e\u003cp id=\"3fc0\"\u003eMost of the states and reasons are integers defined in appropriate classes as static constants, so we usually want to use \u003ccode\u003ewhen\u003c/code\u003e statement to classify the result.\u003c/p\u003e\u003cp id=\"a593\"\u003eI prefer using enums since integers do not define constraints and statements cannot be exhaustive. Moreover, you can still nicely serialize them with the use of Kotlin’s serialization.\u003c/p\u003e\u003cp id=\"fc9b\"\u003eExample for starting reason:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fffb\"\u003eenum class StartReason {\u003cbr/\u003e    START_REASON_ALARM,\u003cbr/\u003e    START_REASON_BACKUP,\u003cbr/\u003e    START_REASON_BOOT_COMPLETE,\u003cbr/\u003e    START_REASON_BROADCAST,\u003cbr/\u003e    START_REASON_CONTENT_PROVIDER,\u003cbr/\u003e    START_REASON_JOB,\u003cbr/\u003e    START_REASON_LAUNCHER,\u003cbr/\u003e    START_REASON_LAUNCHER_RECENTS,\u003cbr/\u003e    START_REASON_OTHER,\u003cbr/\u003e    START_REASON_PUSH,\u003cbr/\u003e    START_REASON_SERVICE,\u003cbr/\u003e    START_REASON_START_ACTIVITY;\u003cp\u003e    companion object {\u003cbr/\u003e        fun fromValue(value: Int): StartReason = when (value) {\u003cbr/\u003e            ApplicationStartInfo.START_REASON_ALARM -\u0026gt; START_REASON_ALARM\u003cbr/\u003e            ApplicationStartInfo.START_REASON_BACKUP -\u0026gt; START_REASON_BACKUP\u003cbr/\u003e            ApplicationStartInfo.START_REASON_BOOT_COMPLETE -\u0026gt; START_REASON_BOOT_COMPLETE\u003cbr/\u003e            ApplicationStartInfo.START_REASON_BROADCAST -\u0026gt; START_REASON_BROADCAST\u003cbr/\u003e            ApplicationStartInfo.START_REASON_CONTENT_PROVIDER -\u0026gt; START_REASON_CONTENT_PROVIDER\u003cbr/\u003e            ApplicationStartInfo.START_REASON_JOB -\u0026gt; START_REASON_JOB\u003cbr/\u003e            ApplicationStartInfo.START_REASON_LAUNCHER -\u0026gt; START_REASON_LAUNCHER\u003cbr/\u003e            ApplicationStartInfo.START_REASON_LAUNCHER_RECENTS -\u0026gt; START_REASON_LAUNCHER_RECENTS\u003cbr/\u003e            ApplicationStartInfo.START_REASON_OTHER -\u0026gt; START_REASON_OTHER\u003cbr/\u003e            ApplicationStartInfo.START_REASON_PUSH -\u0026gt; START_REASON_PUSH\u003cbr/\u003e            ApplicationStartInfo.START_REASON_SERVICE -\u0026gt; START_REASON_SERVICE\u003cbr/\u003e            ApplicationStartInfo.START_REASON_START_ACTIVITY -\u0026gt; START_REASON_START_ACTIVITY\u003cbr/\u003e            else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown start reason value: $value\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"24d6\"\u003eSimilarly, we can create a data class to map timestamps from starting information:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"db6d\"\u003edata class StartupTimestamps(\u003cbr/\u003e    val applicationOnCreate: Long? = null,\u003cbr/\u003e    val bindApplication: Long? = null,\u003cbr/\u003e    val firstFrame: Long? = null,\u003cbr/\u003e    val fork: Long? = null,\u003cbr/\u003e    val fullyDrawn: Long? = null,\u003cbr/\u003e    val initialRenderThreadFrame: Long? = null,\u003cbr/\u003e    val launch: Long? = null,\u003cbr/\u003e    val reservedRangeDeveloper: Long? = null,\u003cbr/\u003e    val reservedRangeDeveloperStart: Long? = null,\u003cbr/\u003e    val reservedRangeSystem: Long? = null,\u003cbr/\u003e    val surfaceFlingerCompositionComplete: Long? = null\u003cbr/\u003e) {\u003cbr/\u003e    companion object {\u003cbr/\u003e        fun fromMap(timestampMap: Map\u0026lt;Int, Long\u0026gt;): StartupTimestamps = StartupTimestamps(\u003cbr/\u003e            applicationOnCreate = timestampMap[ApplicationStartInfo.START_TIMESTAMP_APPLICATION_ONCREATE],\u003cbr/\u003e            bindApplication = timestampMap[ApplicationStartInfo.START_TIMESTAMP_BIND_APPLICATION],\u003cbr/\u003e            firstFrame = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FIRST_FRAME],\u003cbr/\u003e            fork = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FORK],\u003cbr/\u003e            fullyDrawn = timestampMap[ApplicationStartInfo.START_TIMESTAMP_FULLY_DRAWN],\u003cbr/\u003e            initialRenderThreadFrame = timestampMap[ApplicationStartInfo.START_TIMESTAMP_INITIAL_RENDERTHREAD_FRAME],\u003cbr/\u003e            launch = timestampMap[ApplicationStartInfo.START_TIMESTAMP_LAUNCH],\u003cbr/\u003e            reservedRangeDeveloper = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER],\u003cbr/\u003e            reservedRangeDeveloperStart = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_DEVELOPER_START],\u003cbr/\u003e            reservedRangeSystem = timestampMap[ApplicationStartInfo.START_TIMESTAMP_RESERVED_RANGE_SYSTEM],\u003cbr/\u003e            surfaceFlingerCompositionComplete = timestampMap[ApplicationStartInfo.START_TIMESTAMP_SURFACEFLINGER_COMPOSITION_COMPLETE]\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c533\"\u003eOr we can define exit reasons:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"af42\"\u003eenum class ExitReason {\u003cbr/\u003e    REASON_ANR,\u003cbr/\u003e    REASON_CRASH,\u003cbr/\u003e    REASON_CRASH_NATIVE,\u003cbr/\u003e    REASON_DEPENDENCY_DIED,\u003cbr/\u003e    REASON_EXCESSIVE_RESOURCE_USAGE,\u003cbr/\u003e    REASON_EXIT_SELF,\u003cbr/\u003e    REASON_FREEZER,\u003cbr/\u003e    REASON_INITIALIZATION_FAILURE,\u003cbr/\u003e    REASON_LOW_MEMORY,\u003cbr/\u003e    REASON_OTHER,\u003cbr/\u003e    REASON_PACKAGE_STATE_CHANGE,\u003cbr/\u003e    REASON_PACKAGE_UPDATED,\u003cbr/\u003e    REASON_PERMISSION_CHANGE,\u003cbr/\u003e    REASON_SIGNALED,\u003cbr/\u003e    REASON_UNKNOWN,\u003cbr/\u003e    REASON_USER_REQUESTED,\u003cbr/\u003e    REASON_USER_STOPPED;\u003cp\u003e    companion object {\u003cbr/\u003e        fun fromValue(value: Int): ExitReason = when (value) {\u003cbr/\u003e            ApplicationExitInfo.REASON_ANR -\u0026gt; REASON_ANR\u003cbr/\u003e            ApplicationExitInfo.REASON_CRASH -\u0026gt; REASON_CRASH\u003cbr/\u003e            ApplicationExitInfo.REASON_CRASH_NATIVE -\u0026gt; REASON_CRASH_NATIVE\u003cbr/\u003e            ApplicationExitInfo.REASON_DEPENDENCY_DIED -\u0026gt; REASON_DEPENDENCY_DIED\u003cbr/\u003e            ApplicationExitInfo.REASON_EXCESSIVE_RESOURCE_USAGE -\u0026gt; REASON_EXCESSIVE_RESOURCE_USAGE\u003cbr/\u003e            ApplicationExitInfo.REASON_EXIT_SELF -\u0026gt; REASON_EXIT_SELF\u003cbr/\u003e            ApplicationExitInfo.REASON_FREEZER -\u0026gt; REASON_FREEZER\u003cbr/\u003e            ApplicationExitInfo.REASON_INITIALIZATION_FAILURE -\u0026gt; REASON_INITIALIZATION_FAILURE\u003cbr/\u003e            ApplicationExitInfo.REASON_LOW_MEMORY -\u0026gt; REASON_LOW_MEMORY\u003cbr/\u003e            ApplicationExitInfo.REASON_OTHER -\u0026gt; REASON_OTHER\u003cbr/\u003e            ApplicationExitInfo.REASON_PACKAGE_STATE_CHANGE -\u0026gt; REASON_PACKAGE_STATE_CHANGE\u003cbr/\u003e            ApplicationExitInfo.REASON_PACKAGE_UPDATED -\u0026gt; REASON_PACKAGE_UPDATED\u003cbr/\u003e            ApplicationExitInfo.REASON_PERMISSION_CHANGE -\u0026gt; REASON_PERMISSION_CHANGE\u003cbr/\u003e            ApplicationExitInfo.REASON_SIGNALED -\u0026gt; REASON_SIGNALED\u003cbr/\u003e            ApplicationExitInfo.REASON_UNKNOWN -\u0026gt; REASON_UNKNOWN\u003cbr/\u003e            ApplicationExitInfo.REASON_USER_REQUESTED -\u0026gt; REASON_USER_REQUESTED\u003cbr/\u003e            ApplicationExitInfo.REASON_USER_STOPPED -\u0026gt; REASON_USER_STOPPED\u003cbr/\u003e            else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown exit reason value: $value\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"a928\"\u003eFeel free to replace the throw with some default value, if you want to.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"ecbb\"\u003eSimilarly, to other parameters, you can create further enums or other data classes to your pleasure. For further details visit the Android documentation below.\u003c/p\u003e\u003cp id=\"98e3\"\u003eFor a full example app, visit my repository:\u003c/p\u003e\u003cp id=\"89bb\"\u003e\u003cstrong\u003eThanks for reading and remember to follow!\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"6948\"\u003e\u003cstrong\u003eMore Android stories:\u003c/strong\u003e\u003c/p\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Tomáš Repčík\" src=\"https://miro.medium.com/v2/resize:fill:40:40/1*QX6LD5rc1fKOUgo0ANp0kw.png\" width=\"20\" height=\"20\" loading=\"lazy\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ch2\u003eAndroid development\u003c/h2\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-10-17T16:11:21.184Z",
  "modifiedTime": null
}
