{
  "id": "0eb0dc9d-025b-47ff-bf3e-c4d7510bd2ba",
  "title": "From Biology to Code: How Android‚Äôs Zygote Enables Fast and Efficient App Launching",
  "link": "https://proandroiddev.com/android-zygote-internals-app-performance-7f9a8d78b236?source=rss----c72404660798---4",
  "description": "",
  "author": "Mehdi Yari",
  "published": "Thu, 24 Jul 2025 16:52:53 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "zygote",
    "android",
    "android-internals",
    "android-app-development",
    "performance"
  ],
  "byline": "Mehdi Yari",
  "length": 8191,
  "excerpt": "This article dives into how Android‚Äôs Zygote works under the hood to boost app launch performance and optimize memory and battery use | Mehdi Yari",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "From Biology to Code: How Android‚Äôs Zygote Enables Fast and Efficient App LaunchingZoom image will be displayedAndroid ZygoteI‚Äôm the kind of engineer who‚Äôs always been curious about how the human body works. To me, it‚Äôs like the most advanced software ever built, full of interdependent systems, logic, and design patterns, all orchestrated by a mate called brain, which handles parallel tasks, memory, and decision-making all at once.Many ideas in software engineering are inspired by biology. One great example is the Zygote, a concept that exists both in nature and in Android. In biology, a zygote is the first cell formed when a sperm and an egg unite. It carries a complete DNA blueprint, like two config files merged into one unique setup, containing everything needed to bootstrap a full human system.From there, the cell divides and replicates, running a biological ‚Äúbuild process‚Äù that becomes me and you, a multi-threaded, self-healing, distributed system. Like parallel threads in software, your body runs many tasks at once: your heart beats, lungs breathe, and brain processes information at the same time, all working smoothly.Android‚Äôs Zygote works similarly, with some differences in detail: it‚Äôs a pre-initialised process that forks to create every app, saving time and resources. One origin, many clones, just like life itself.The Origin of Android‚Äôs Zygote: History and the Minds Behind ItWhen the Android team chose Java as the main programming language, they faced a challenge: existing Java VMs weren‚Äôt optimised for the Android kernel(Linux Kernel with some patches running on a mobile device). Since many Java VMs exist for different platforms, each focusing on different priorities like garbage collection or performance, the team needed a VM tailored for mobile. Ben and his team developed Dalvik, a virtual machine designed for Android that runs .dex files. It prioritises mobile performance factors, including lower battery consumption and efficient execution.They then faced a new problem: each time an app launched, it had to load the shared classes and framework code, graphic drivers, libraries, shared text resources, and other resources from scratch, consuming memory, CPU, and battery. For any software engineer, this was a performance bottleneck that needed solving.Dan Bornstein (ex-Virtual Machinist at Google) and his team came up with a solution inspired by biology and named it Zygote, which I think is a brilliant and clever choice. Their idea was to have a single process that preloads all of the components mentioned above in advance. Then, when a system app needs to open or when a user launches an app, the system simply forks this pre-initialised process. The newly created app process inherits all the preloaded resources, resulting in faster startup times, lower memory and CPU usage, and ultimately, reduced battery consumption.Dalvik hasn‚Äôt been used since Android 5.0, when it was replaced by ART for good reasons, which I won‚Äôt dive into here. But both virtual machines, Dalvik and ART, rely on Zygote to start app processes.The Inner Workings of Zygote in AndroidZoom image will be displayedZygote Process Lifecycle in Android System BootOnce Android boots up, and the Linux kernel along with other low-level components are loaded, theinit.cpp process starts the Zygote process based on the init.rc configuration. At this stage, the Android Runtime is initialised, and Zygote opens a socket to listen for fork requests from the system.Zygote‚Äôs entry point is a native binary called app_process, written in C++. This binary has several responsibilities: starting the Zygote process, launching standalone command-line apps, and initialising the Android Runtime, depending on the arguments it receives. Since Zygote itself is implemented in Java, app_process First loads the Android Runtime and then calls the main() method of com.android.internal.os.ZygoteInit to launch the Zygote process.Below are the three main phases that happen after the system service calls this main function:1. Hook PhaseDuring this phase, the ZygoteInit class uses the ZygoteHooks to provide lifecycle hooks at the start and end of the Zygote initialisation. These hooks perform tasks such as:Suspending thread creationPausing and Resuming the JIT compilerCleaning up fork-specific resourcesetcThese hooks ensure that the runtime environment is stable and optimised for forking processes.2. Preload PhaseHere, ZygoteInit Preloads various classes, libraries, and resources that will be efficiently shared by all forked processes. Key preload functions include:Key preload functions in ZygoteInit that load shared resources.3. Post-Preload and Listening PhaseAfter the preload phase is done, ZygoteHooksturn things like the JIT compiler back on and let any paused threads continue.Then, Zygote enters a loop using runSelectLoop(), where it waits for commands from the Activity Manager Service. When a new app needs to start, Zygote gets the request, creates a copy of itself (called forking), sets up the app main thread, and tells the upstream to start the app main activity.Almost every Android app you use, and important system parts like System UI and services, get started this way. It‚Äôs like a ‚Äúcopy-paste‚Äù trick that helps Android launch apps faster and saves memory by sharing all the heavy stuff already loaded. It‚Äôs Android‚Äôs way of saying, ‚ÄúWhy do extra work when you can just clone and chill?‚ÄúHow Zygote Starts Your AppZoom image will be displayedAndroid App Launch Flow: From User Tap to App StartI explained how a human Zygote works; it doesn‚Äôt start from zero every time, it just copies a ready-made set of instructions(DNA) to grow a whole person. Android does something very similar. üòÑIn the diagram above, you can see what happens when someone taps your app icon. The system kicks off a chain of events, starting with the Launcher, then moving through ActivityTaskManagerService, ActivityStarter, ActivityManagerService, ProcessList, and finally reaching the star of the show: Zygote.At this point, Android doesn‚Äôt build everything from scratch. Instead, Zygote forks, basically making a clone of itself for the requested application, already packed with preloaded stuff. It creates a fresh app process, all set up and ready to go. That new app process prepares the main thread, and ActivityManagerService gives it a little push: ‚ÄúAlright mate, you‚Äôre up!‚Äù The app‚Äôs main activity starts, and your app's main screen comes alive.That‚Äôs also why, when your app Crashes/ANRs, you see ZygoteInit.main sitting at the bottom of the stack trace, simply because it‚Äôs the one that gave birth to your app process. üß¨ üë∂ üì±Fatal Exception: android.app.RemoteServiceException: Bad notification for startForeground at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2220) at android.os.Handler.dispatchMessage(Handler.java:109) at android.os.Looper.loop(Looper.java:166) at android.app.ActivityThread.main(ActivityThread.java:7555) at java.lang.reflect.Method.invoke(Method.java) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:469) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:963)Conclusion:In this post, we looked at how the early Android team took inspiration from biology to solve a big problem: loading everything from scratch for each app. Their clever idea was to use a shared process (called Zygote) that‚Äôs already loaded and ready to go, so apps can start faster. We saw how this works in the AOSP codes and learned where the name came from.Most of what I shared comes from digging through AOSP, books, and chatting with a few folks who were around during the early days of Android‚Äôs Dalvik and ART.If you like what you‚Äôve read and you‚Äôre someone who wants to work on open, interesting projects in a caring environment, check out our full list of open roles at Delivery Hero here ‚Äî from Backend to Frontend and everything in between. We‚Äôd love to have you on board for an amazing journey ahead. Also, if you love Android like me, feel free to follow me on Medium, check out my GitHub, or connect on LinkedIn. Always happy to meet curious engineers.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*tK-c9UHEpzo5fzaiogiOkg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"b3f2\" data-testid=\"storyTitle\"\u003eFrom Biology to Code: How Android‚Äôs Zygote Enables Fast and Efficient App Launching\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\" role=\"tooltip\"\u003e\u003ca href=\"https://mehdiyari.medium.com/?source=post_page---byline--7f9a8d78b236---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Mehdi Yari\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*Pt2tB41qyephjGI8XIgX2w.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003eAndroid Zygote\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"48b9\"\u003eI‚Äôm the kind of engineer who‚Äôs always been curious about how the human body works. To me, it‚Äôs like the most advanced software ever built, full of interdependent systems, logic, and design patterns, all orchestrated by a mate called brain, which handles parallel tasks, memory, and decision-making all at once.\u003c/p\u003e\u003cp id=\"ed40\"\u003eMany ideas in software engineering are inspired by biology. One great example is the Zygote\u003cstrong\u003e, \u003c/strong\u003ea concept that exists both in nature and in Android. In biology, a zygote is the first cell formed when a sperm and an egg unite. It carries a complete DNA blueprint, like two config files merged into one unique setup, containing everything needed to bootstrap a full human system.\u003c/p\u003e\u003cp id=\"d5cd\"\u003eFrom there, the cell divides and replicates, running a biological ‚Äúbuild process‚Äù that becomes me and you, a multi-threaded, self-healing, distributed system. Like parallel threads in software, your body runs many tasks at once: your heart beats, lungs breathe, and brain processes information at the same time, all working smoothly.\u003c/p\u003e\u003cp id=\"6f66\"\u003eAndroid‚Äôs Zygote works similarly, with some differences in detail: it‚Äôs a pre-initialised process that forks to create every app, saving time and resources. One origin, many clones, just like life itself.\u003c/p\u003e\u003ch2 id=\"5593\"\u003eThe Origin of Android‚Äôs Zygote: History and the Minds Behind It\u003c/h2\u003e\u003cp id=\"c715\"\u003eWhen the Android team chose Java as the main programming language, they faced a challenge: existing Java VMs weren‚Äôt optimised for the Android kernel(Linux Kernel with some patches running on a mobile device). Since many Java VMs exist for different platforms, each focusing on different priorities like garbage collection or performance, the team needed a VM tailored for mobile. Ben and his team developed Dalvik, a virtual machine designed for Android that runs \u003ccode\u003e.dex\u003c/code\u003e files. It prioritises mobile performance factors, including lower battery consumption and efficient execution.\u003c/p\u003e\u003cp id=\"e0a4\"\u003eThey then faced a new problem: each time an app launched, it had to load the shared classes and framework code, graphic drivers, libraries, shared text resources, and other resources from scratch, consuming memory, CPU, and battery. For any software engineer, this was a performance bottleneck that needed solving.\u003c/p\u003e\u003cp id=\"851e\"\u003eDan Bornstein (ex-Virtual Machinist at Google) and his team came up with a solution inspired by biology and named it Zygote, which I think is a brilliant and clever choice. Their idea was to have a single process that preloads all of the components mentioned above in advance. Then, when a system app needs to open or when a user launches an app, the system simply \u003ca href=\"https://en.wikipedia.org/wiki/Fork_(system_call)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eforks\u003c/a\u003e this pre-initialised process. The newly created app process inherits all the preloaded resources, resulting in faster startup times, lower memory and CPU usage, and ultimately, reduced battery consumption.\u003c/p\u003e\u003cp id=\"c555\"\u003eDalvik hasn‚Äôt been used since Android 5.0, when it was replaced by ART for good reasons, which I won‚Äôt dive into here. But both virtual machines, Dalvik and ART, rely on Zygote to start app processes.\u003c/p\u003e\u003ch2 id=\"0d54\"\u003eThe Inner Workings of Zygote in Android\u003c/h2\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003eZygote Process Lifecycle in Android System Boot\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"fa6a\"\u003eOnce Android boots up, and the Linux kernel along with other low-level components are loaded, the\u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/init.cpp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003einit.cpp\u003c/a\u003e\u003c/code\u003e process starts the Zygote process based on the \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:system/core/rootdir/init.rc\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003einit.rc\u003c/a\u003e\u003c/code\u003e configuration. At this stage, the Android Runtime is initialised, and Zygote opens a socket to listen for fork requests from the system.\u003c/p\u003e\u003cp id=\"a77d\"\u003eZygote‚Äôs entry point is a native binary called \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/cmds/app_process/app_main.cpp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eapp_process\u003c/a\u003e\u003c/code\u003e, written in C++. This binary has several responsibilities: starting the Zygote process, launching standalone command-line apps, and initialising the Android Runtime, depending on the arguments it receives. Since Zygote itself is implemented in Java, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/cmds/app_process/app_main.cpp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eapp_process\u003c/a\u003e\u003c/code\u003e First loads the Android Runtime and then calls the \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java;bpv=1;bpt=1;l=817\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emain()\u003c/a\u003e\u003c/code\u003e method of \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecom.android.internal.os.ZygoteInit\u003c/a\u003e\u003c/code\u003e to launch the Zygote process.\u003c/p\u003e\u003cp id=\"f625\"\u003eBelow are the three main phases that happen after the system service calls this main function:\u003c/p\u003e\u003ch2 id=\"3550\"\u003e1. Hook Phase\u003c/h2\u003e\u003cp id=\"f73b\"\u003eDuring this phase, the \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZygoteInit\u003c/a\u003e\u003c/code\u003e class uses the \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZygoteHooks\u003c/a\u003e\u003c/code\u003e to provide lifecycle hooks at the start and end of the Zygote initialisation. These hooks perform tasks such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a193\"\u003eSuspending thread creation\u003c/li\u003e\u003cli id=\"d6eb\"\u003ePausing and Resuming the JIT compiler\u003c/li\u003e\u003cli id=\"c0c4\"\u003eCleaning up fork-specific resources\u003c/li\u003e\u003cli id=\"9089\"\u003eetc\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"481e\"\u003eThese hooks ensure that the runtime environment is stable and optimised for forking processes.\u003c/p\u003e\u003ch2 id=\"ed57\"\u003e2. Preload Phase\u003c/h2\u003e\u003cp id=\"1176\"\u003eHere, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZygoteInit\u003c/a\u003e\u003c/code\u003e Preloads various classes, libraries, and resources that will be efficiently shared by all forked processes. Key preload functions include:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eKey preload functions in ZygoteInit that load shared resources.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"7b38\"\u003e3. Post-Preload and Listening Phase\u003c/h2\u003e\u003cp id=\"f036\"\u003eAfter the preload phase is done, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZygoteHooks\u003c/a\u003e\u003c/code\u003eturn things like the JIT compiler back on and let any paused threads continue.\u003c/p\u003e\u003cp id=\"6bbb\"\u003eThen, Zygote enters a loop using \u003ccode\u003erunSelectLoop()\u003c/code\u003e, where it waits for commands from the Activity Manager Service. When a new app needs to start, Zygote gets the request, creates a \u003ca href=\"https://en.wikipedia.org/wiki/Fork_(system_call)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecopy of itself (called forking)\u003c/a\u003e, sets up the app main thread, and tells the upstream to start the app main activity.\u003c/p\u003e\u003cp id=\"63d4\"\u003eAlmost every Android app you use, and important system parts like System UI and services, get started this way. It‚Äôs like a ‚Äúcopy-paste‚Äù trick that helps Android launch apps faster and saves memory by sharing all the heavy stuff already loaded. It‚Äôs Android‚Äôs way of saying, ‚ÄúWhy do extra work when you can just clone and chill?‚Äú\u003c/p\u003e\u003ch2 id=\"d705\"\u003eHow Zygote Starts Your App\u003c/h2\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003eAndroid App Launch Flow: From User Tap to App Start\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a012\"\u003eI explained how a human Zygote works; it doesn‚Äôt start from zero every time, it just copies a ready-made set of instructions(DNA) to grow a whole person. Android does something very similar. üòÑ\u003c/p\u003e\u003cp id=\"493f\"\u003eIn the diagram above, you can see what happens when someone taps your app icon. The system kicks off a chain of events, starting with the Launcher, then moving through \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eActivityTaskManagerService\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eActivityStarter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eActivityManagerService\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/services/core/java/com/android/server/am/ProcessList.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eProcessList\u003c/a\u003e\u003c/code\u003e, and finally reaching the star of the show: Zygote.\u003c/p\u003e\u003cp id=\"bc2c\"\u003eAt this point, Android doesn‚Äôt build everything from scratch. Instead, Zygote \u003ca href=\"https://en.wikipedia.org/wiki/Fork_(system_call)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eforks\u003c/a\u003e, basically making a clone of itself for the requested application, already packed with preloaded stuff. It creates a fresh app process, all set up and ready to go. That new app process prepares the main thread, and \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eActivityManagerService\u003c/a\u003e\u003c/code\u003e gives it a little push: ‚ÄúAlright mate, you‚Äôre up!‚Äù The app‚Äôs main activity starts, and your app\u0026#39;s main screen comes alive.\u003c/p\u003e\u003cp id=\"fa5d\"\u003eThat‚Äôs also why, when your app Crashes/ANRs, you see \u003ccode\u003e\u003ca href=\"https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java;bpv=1;bpt=1;l=817\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZygoteInit.main\u003c/a\u003e\u003c/code\u003e sitting at the bottom of the stack trace, simply because it‚Äôs the one that gave birth to your app process. üß¨ üë∂ üì±\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fc97\"\u003eFatal Exception: android.app.RemoteServiceException: Bad notification for startForeground\u003cbr/\u003e       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2220)\u003cbr/\u003e       at android.os.Handler.dispatchMessage(Handler.java:109)\u003cbr/\u003e       at android.os.Looper.loop(Looper.java:166)\u003cbr/\u003e       at android.app.ActivityThread.main(ActivityThread.java:7555)\u003cbr/\u003e       at java.lang.reflect.Method.invoke(Method.java)\u003cbr/\u003e       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:469)\u003cbr/\u003e       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:963)\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0927\"\u003eConclusion:\u003c/h2\u003e\u003cp id=\"fdc0\"\u003eIn this post, we looked at how the early Android team took inspiration from biology to solve a big problem: loading everything from scratch for each app. Their clever idea was to use a shared process (called Zygote) that‚Äôs already loaded and ready to go, so apps can start faster. We saw how this works in the AOSP codes and learned where the name came from.\u003c/p\u003e\u003cp id=\"8afc\"\u003eMost of what I shared comes from digging through AOSP, books, and chatting with a few folks who were around during the early days of Android‚Äôs Dalvik and ART.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"7cf2\"\u003eIf you like what you‚Äôve read and you‚Äôre someone who wants to work on open, interesting projects in a caring environment, check out our full list of open roles at Delivery Hero \u003ca href=\"https://careers.deliveryhero.com/jobs?options=248\u0026amp;page=1\u0026amp;utm_campaign=202405_EB_techblog\u0026amp;utm_medium=blog-post\u0026amp;utm_source=tech-blog\u0026amp;utm_content=baseline-profiles\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere \u003c/a\u003e‚Äî from Backend to Frontend and everything in between. We‚Äôd love to have you on board for an amazing journey ahead. \u003cbr/\u003eAlso, if you love Android like me, feel free to follow me on \u003ca href=\"https://mehdiyari.medium.com/\" rel=\"noopener\"\u003eMedium\u003c/a\u003e, check out my \u003ca href=\"https://github.com/mehdiyari\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e, or connect on \u003ca href=\"https://www.linkedin.com/in/mehdiyari01/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e. Always happy to meet curious engineers.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-07-24T16:52:53.095Z",
  "modifiedTime": null
}
