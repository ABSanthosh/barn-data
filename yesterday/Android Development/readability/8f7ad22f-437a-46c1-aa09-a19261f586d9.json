{
  "id": "8f7ad22f-437a-46c1-aa09-a19261f586d9",
  "title": "Drawing custom text spans in Compose UI",
  "link": "https://saket.me/compose-custom-text-spans/",
  "description": "While exploring how text paragraphs are rendered in Compose UI, I nerd sniped myself into porting squiggly underlines from Sam Ruston’s Buzzkill app. Sam’s animation was implemented using TextView custom spans, but Compose UI does not offer any alternatives for them yet. While our friends at Google are prototyping text modifiers (first, second), I figured […] The post Drawing custom text spans in Compose UI appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Tue, 12 Jul 2022 15:49:24 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android"
  ],
  "byline": "Saket Narayan",
  "length": 5476,
  "excerpt": "Exploring how squiggly underlines and rounded corners can be drawn without any official APIs for drawing custom spans.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "While exploring how text paragraphs are rendered in Compose UI, I nerd sniped myself into porting squiggly underlines from Sam Ruston’s Buzzkill app. Sam’s animation was implemented using TextView custom spans, but Compose UI does not offer any alternatives for them yet. While our friends at Google are prototyping text modifiers (first, second), I figured I could draw them manually in the meantime. My plan was to, Annotate my text that will be underlined. Calculate layout coordinates for the underlined text. Draw squiggles between those coordinates directly on Canvas. I was able to start by using withAnnotation() offered by buildAnnotatedString(). Unlike SpannedString in the View land, AnnotatedString does not accept arbitrary objects for drawing custom spans. This will certainly be a roadblock for custom spans that require metadata, but plain strings were sufficient for my usecase. val text = buildAnnotatedString { append(\"I'll be alright as long as there's light from a \") withAnnotation(\"squiggles\", annotation = \"ignored\") { withStyle(SpanStyle(color = Color.Purple)) { append(\"neon moon\") } } } My next step was to find layout coordinates for my annotated text so that I could decorate them with underlines. I was able to use TextLayoutResult for this: var onDraw: DrawScope.() -\u003e Unit by remember { mutableStateOf({}) } Text( modifier = Modifier.drawBehind { onDraw() } text = text, onTextLayout = { layoutResult -\u003e val annotation = text.getStringAnnotations(\"squiggles\", …).first() val textBounds = layoutResult.getBoundingBoxes(annotation.start..annotation.end) onDraw = { for (bound in textBounds) { val underline = bound.copy(top = bound.bottom - 4.sp.toPx()) drawRect( color = Color.Purple, topLeft = underline.topLeft, size = underline.size, ) } } } ) TextLayoutResult#getBoundingBoxes() actually doesn’t exist yet. Until Google adds an official API (issuetracker), I’m using a custom implementation that iterates through each line and reads their bounds using TextLayoutResult#getLineLeft/Top/Right/Bottom() APIs. Here’s my code if anyone’s curious. Once the coordinates were found, it was time to draw squiggles. I was able to pretty much copy-paste Sam Ruston’s maths that builds waves by connecting points generated using Math.sin(). drawPath( color = Color.Purple, - topLeft = underline.topLeft, - size = underline.size + path = buildSquigglesFor(bound) ) /** * _....._ _....._ ᐃ * ,=\" \"=. ,=\" \"=. amplitude * ,\" \". ,\" \". │ *,\" \"., ,,\" \"., ᐁ *\"\"\"\"\"\"\"\"\"\"|\"\"\"\"\"\"\"\"\"\"|.\"\"\"\"\"\"\"\"\"|\"\"\"\"\"\"\"\"\".|\"\"\"\"\"\"\"\"\"\"|\"\"\"\"\"\"\"\"\"\"| * \". .\" * \"._ _,\" * \"-.....-\" *ᐊ--------------- Wavelength --------------ᐅ */ private fun DrawScope.buildSquigglesFor(bound: Rect, waveOffset: Float = 0f): Path { val wavelength = 16.sp.toPx() val amplitude = 1.sp.toPx() val segmentWidth = wavelength / SEGMENTS_PER_WAVELENGTH val numOfPoints = ceil(bound.width / segmentWidth).toInt() + 1 // I'm creating a new Path object for brevity, but you'll // want to cache it somewhere to reuse across draw frames. return Path().apply { var pointX = bound.left for (point in 0..numOfPoints) { val proportionOfWavelength = (pointX - bound.left) / wavelength val radiansX = proportionOfWavelength * 2 * Math.PI val offsetY = bound.bottom + (sin(radiansX + waveOffset) * amplitude) when (point) { 0 -\u003e moveTo(pointX, offsetY) else -\u003e lineTo(pointX, offsetY) } pointX += segmentWidth } } } For animating the squiggles, I noticed that Sam’s code was invalidating the Canvas on every animation frame infinitely. I was able to use InfiniteTransition to mimic that in Compose UI: val animationProgress by rememberInfiniteTransition().animateFloat( initialValue = 0f, targetValue = 1f, animationSpec = infiniteRepeatable( animation = tween(1_000, easing = LinearEasing), repeatMode = Restart ) ) drawPath( color = Color.Purple, - path = buildSquigglesFor(bound) + path = buildSquigglesFor(bound, waveOffset = 2 * Math.PI * animationProgress) ) Another interaction that I really like in Buzzkill is how errors are indicated by changing squiggles to red. I was able to recreate that in one line using animate*AsState(): - val waveLength = 16.sp + val waveLength by animateSpAsState(targetValue = if (isError) 120.sp else 16.sp) That was fun! The above code can be used for so much more. For example, I was also able to draw text with round corner backgrounds, which is something Compose UI should really support out of the box (issuetracker). drawRoundRect( color = Color.Purple.copy(alpha = 0.3f), topLeft = bound.topLeft, size = bound.size, style = Fill ) drawRoundRect( color = Color.Purple.copy(alpha = 0.6f), topLeft = bound.topLeft, size = bound.size, style = Stroke(width = 1.sp.toPx()) ) If you’re interested in adding squiggly underlines or round corner backgrounds to your app, I packaged all my code into a tiny library that you can (almost) drop into your existing code: https://github.com/saket/ExtendedSpans.",
  "image": "https://saket.me/wp-content/uploads/2022/07/compose_custom_spans_cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eWhile exploring how text paragraphs are rendered in Compose UI, I nerd sniped myself into porting \u003ca href=\"https://twitter.com/saketme/status/1310073763019530242\"\u003esquiggly underlines\u003c/a\u003e from Sam Ruston’s Buzzkill app. Sam’s animation was implemented using \u003ccode\u003eTextView\u003c/code\u003e custom spans, but Compose UI does not offer any alternatives for them yet. While our friends at Google are prototyping text modifiers (\u003ca href=\"https://android-review.googlesource.com/c/platform/frameworks/support/+/2045124/1/compose/foundation/foundation/samples/src/main/java/androidx/compose/foundation/samples/TextChildrenSample.kt\"\u003efirst\u003c/a\u003e, \u003ca href=\"https://android-review.googlesource.com/c/platform/frameworks/support/+/2025223/3/compose/foundation/foundation/integration-tests/foundation-demos/src/main/java/androidx/compose/foundation/demos/text/InteractiveText.kt\"\u003esecond\u003c/a\u003e), I figured I could draw them manually in the meantime.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMy plan was to,\u003c/span\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cspan\u003eAnnotate my text that will be underlined.\u003c/span\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cspan\u003eCalculate layout coordinates for the underlined text.\u003c/span\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cspan\u003eDraw squiggles between those coordinates directly on \u003c/span\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eCanvas\u003c/code\u003e\u003c/span\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eI was able to start by using \u003ccode\u003ewithAnnotation()\u003c/code\u003e offered by \u003ccode\u003ebuildAnnotatedString()\u003c/code\u003e. Unlike \u003ccode\u003eSpannedString\u003c/code\u003e in the \u003ccode\u003eView\u003c/code\u003e land, \u003ccode\u003eAnnotatedString\u003c/code\u003e does not accept arbitrary objects for drawing custom spans. This will certainly be a roadblock for custom spans that require metadata, but plain strings were sufficient for my usecase\u003cspan\u003e. \u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval text = buildAnnotatedString {\n  append(\u0026#34;I\u0026#39;ll be alright as long as there\u0026#39;s light from a \u0026#34;)\n  withAnnotation(\u0026#34;squiggles\u0026#34;, annotation = \u0026#34;ignored\u0026#34;) {\n    withStyle(SpanStyle(color = Color.Purple)) {\n      append(\u0026#34;neon moon\u0026#34;)\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan\u003eMy next step was to find layout coordinates for my annotated text so that I could decorate them with underlines. I was able to use \u003c/span\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eTextLayoutResult\u003c/code\u003e\u003c/span\u003e\u003cspan\u003e for this:\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar onDraw: DrawScope.() -\u0026gt; Unit by remember { mutableStateOf({}) }\n\nText(\n  modifier = Modifier.drawBehind { onDraw() }\n  text = text,\n  onTextLayout = { layoutResult -\u0026gt;\n    val annotation = text.getStringAnnotations(\u0026#34;squiggles\u0026#34;, …).first()\n    val textBounds = layoutResult.getBoundingBoxes(annotation.start..annotation.end)\n    onDraw = {\n      for (bound in textBounds) {\n        val underline = bound.copy(top = bound.bottom - 4.sp.toPx())\n        drawRect(\n          color = Color.Purple,\n          topLeft = underline.topLeft,\n          size = underline.size,\n        )\n      }\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2022/07/straight-underline.png\" alt=\"\" width=\"1010\" height=\"704\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eTextLayoutResult#getBoundingBoxes()\u003c/code\u003e\u003c/span\u003e\u003cspan\u003e actually doesn’t exist yet. Until Google adds an official API (\u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://issuetracker.google.com/u/1/issues/237289433\"\u003e\u003cspan\u003eissuetracker\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e), I’m using a custom implementation that iterates through each line and reads their bounds using \u003c/span\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eTextLayoutResult#getLineLeft/Top/Right/Bottom()\u003c/code\u003e\u003c/span\u003e\u003cspan\u003e APIs. Here’s \u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://github.com/saket/ExtendedSpans/blob/68f225a48f8df43cfaa171555b52eba4bce8d838/extendedspans/src/main/kotlin/me/saket/extendedspans/ExtendedSpanPainter.kt#L27:L85\"\u003e\u003cspan\u003emy code\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e if anyone’s curious.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOnce the coordinates were found, it was time to draw squiggles. I was able to pretty much \u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://github.com/saket/ExtendedSpans/blob/68f225a48f8df43cfaa171555b52eba4bce8d838/extendedspans/src/main/kotlin/me/saket/extendedspans/SquigglyUnderlineSpanPainter.kt#L129:L149\"\u003e\u003cspan\u003ecopy-paste\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e Sam Ruston’s maths that builds waves by connecting points generated using \u003c/span\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eMath.sin()\u003c/code\u003e\u003c/span\u003e\u003cspan\u003e. \u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e drawPath(\n   color = Color.Purple,\n-  topLeft = underline.topLeft,\n-  size = underline.size\n+  path = buildSquigglesFor(bound)\n )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n *       _....._                                     _....._         ᐃ\n *    ,=\u0026#34;       \u0026#34;=.                               ,=\u0026#34;       \u0026#34;=.   amplitude\n *  ,\u0026#34;             \u0026#34;.                           ,\u0026#34;             \u0026#34;.    │\n *,\u0026#34;                 \u0026#34;.,                     ,,\u0026#34;                 \u0026#34;., ᐁ\n *\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;|\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;|.\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;|\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;.|\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;|\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;|\n *                       \u0026#34;.               .\u0026#34;\n *                         \u0026#34;._         _,\u0026#34;\n *                            \u0026#34;-.....-\u0026#34;\n *ᐊ--------------- Wavelength --------------ᐅ\n */\nprivate fun DrawScope.buildSquigglesFor(bound: Rect, waveOffset: Float = 0f): Path {\n  val wavelength = 16.sp.toPx()\n  val amplitude = 1.sp.toPx()\n  \n  val segmentWidth = wavelength / SEGMENTS_PER_WAVELENGTH\n  val numOfPoints = ceil(bound.width / segmentWidth).toInt() + 1\n  \n  // I\u0026#39;m creating a new Path object for brevity, but you\u0026#39;ll \n  // want to cache it somewhere to reuse across draw frames.\n  return Path().apply {\n    var pointX = bound.left\n    for (point in 0..numOfPoints) {\n      val proportionOfWavelength = (pointX - bound.left) / wavelength\n      val radiansX = proportionOfWavelength * 2 * Math.PI\n      val offsetY = bound.bottom + (sin(radiansX + waveOffset) * amplitude)\n\n      when (point) {\n        0 -\u0026gt; moveTo(pointX, offsetY)\n        else -\u0026gt; lineTo(pointX, offsetY)\n      }\n      pointX += segmentWidth\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2022/07/squiggly-underline.png\" alt=\"\" width=\"1010\" height=\"704\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eFor animating the squiggles, I noticed that Sam’s code was invalidating the \u003ccode\u003eCanvas\u003c/code\u003e on every animation frame infinitely. I was able to use \u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://developer.android.com/jetpack/compose/animation#rememberinfinitetransition\"\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eInfiniteTransition\u003c/code\u003e\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e to mimic that in Compose UI: \u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval animationProgress by rememberInfiniteTransition().animateFloat(\n  initialValue = 0f,\n  targetValue = 1f,\n  animationSpec = infiniteRepeatable(\n    animation = tween(1_000, easing = LinearEasing),\n    repeatMode = Restart\n  )\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e drawPath(\n   color = Color.Purple,\n-  path = buildSquigglesFor(bound)   \n+  path = buildSquigglesFor(bound, waveOffset = 2 * Math.PI * animationProgress)\n )\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cspan\u003eAnother interaction that I really like in Buzzkill is how errors are indicated by \u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://twitter.com/saketme/status/1314763755000037377\"\u003e\u003cspan\u003echanging squiggles to red\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e. I was able to recreate that in one line using \u003c/span\u003e\u003cspan spellcheck=\"false\"\u003e\u003ccode\u003eanimate*AsState()\u003c/code\u003e\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e- val waveLength = 16.sp\n+ val waveLength by animateSpAsState(targetValue = if (isError) 120.sp else 16.sp)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cspan\u003eThat was fun! \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe above code can be used for so much more. For example, I was also able to draw text with round corner backgrounds, which is something Compose UI should really support out of the box (\u003c/span\u003e\u003cspan\u003e\u003ca href=\"https://issuetracker.google.com/u/1/issues/237095661\"\u003e\u003cspan\u003eissuetracker\u003c/span\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edrawRoundRect(\n  color = Color.Purple.copy(alpha = 0.3f),\n  topLeft = bound.topLeft,\n  size = bound.size,\n  style = Fill\n)\ndrawRoundRect(\n  color = Color.Purple.copy(alpha = 0.6f),\n  topLeft = bound.topLeft,\n  size = bound.size,\n  style = Stroke(width = 1.sp.toPx())\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2022/07/round-corner-background.png\" alt=\"\" width=\"1010\" height=\"704\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIf you’re interested in adding squiggly underlines or round corner backgrounds to your app, I packaged all my code into a tiny library that you can (almost) drop into your existing code:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan spellcheck=\"false\"\u003e\u003ca href=\"https://github.com/saket/ExtendedSpans\"\u003ehttps://github.com/saket/ExtendedSpans\u003c/a\u003e\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/p\u003e\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2022-07-12T15:49:24Z",
  "modifiedTime": "2023-08-11T16:31:40Z"
}
