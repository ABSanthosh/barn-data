{
  "id": "19487c42-8429-49a3-9bb9-7e18bc84aff2",
  "title": "Understanding the Coroutine Lifecycle in Kotlin",
  "link": "https://proandroiddev.com/understanding-the-coroutine-lifecycle-in-kotlin-378d619908ac?source=rss----c72404660798---4",
  "description": "",
  "author": "Rahul Ray",
  "published": "Sun, 27 Oct 2024 19:17:15 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "android-app-development",
    "android",
    "programming",
    "coding"
  ],
  "byline": "Rahul Ray",
  "length": 13618,
  "excerpt": "Kotlin’s coroutines offer a powerful way to manage concurrency and asynchronous programming. However, to use them effectively, it’s crucial to understand the lifecycle of a coroutine. In this blog…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Diagram from kotlinlang.orgKotlin’s coroutines offer a powerful way to manage concurrency and asynchronous programming. However, to use them effectively, it’s crucial to understand the lifecycle of a coroutine. In this blog post, we’ll explore the coroutine lifecycle, focusing on the states of a coroutine’s Job, how they transition between states, and practical examples to illustrate each state, including the effects of launching nested coroutines. Additionally, we’ll discuss best practices and modifications.What is a Coroutine?Coroutines are lightweight threads that allow you to perform asynchronous tasks without blocking the main thread. They provide a way to write non-blocking code that is easy to read and maintain. In Kotlin, coroutines are structured around the concept of jobs.What is a Job?A Job is a handle to a coroutine. It represents its lifecycle and allows you to manage its execution, including starting, cancelling, and checking its status. The Job provides several states that a coroutine can be in during its lifecycle.Coroutine Job Lifecycle StatesThe lifecycle of a coroutine’s Job includes the following states:New: The coroutine is created but not yet started.Active: The coroutine is currently running.Completing: The coroutine is finishing its work.Completed: The coroutine has finished its execution successfully.Cancelling: The coroutine is in the process of being cancelled.Cancelled: The coroutine has been cancelled and will not complete.Job Lifecycle Flow DiagramTo visualize the transitions between these states, consider the following flow diagram: wait children +-----+ start +--------+ complete +-------------+ finish +-----------+ | New | -----\u003e | Active | --------\u003e | Completing | -------\u003e | Completed | +-----+ +--------+ +-------------+ +-----------+ | cancel / fail | | +----------------+ | | V V +------------+ finish +-----------+ | Cancelling | --------------------------------\u003e | Cancelled | +------------+ +-----------+ (Diagram from kotlinlang.org)State Transitions Explained1. NewThe New state is where a coroutine starts its lifecycle. A coroutine is created but not yet running.Example:fun main() { val job = GlobalScope.launch { println(\"Coroutine is starting...\") } println(\"Job state (New): ${job.isActive}\")}// OUTPUT:// Job state (New): false2. ActiveWhen the coroutine begins its execution, it transitions to the Active state. In this state, the coroutine can perform its designated tasks.Example:fun main() = runBlocking { val job = launch { println(\"Coroutine is active now!\") delay(1000) // Simulating work } println(\"Job state (Active): ${job.isActive}\") job.join()}// OUTPUT:// Coroutine is active now!// Job state (Active): true3. CompletingAs the coroutine finishes its tasks, it enters the Completing state. This state indicates that the coroutine is about to finish its execution.Example:fun main() = runBlocking { val job = launch { println(\"Coroutine is working...\") delay(1000) // Simulating work println(\"Coroutine is completing...\") } // Register callback job.invokeOnCompletion { println(\"Job completed: ${if (it == null) \"successfully\" else \"failed or cancelled\"}\") } job.join()}// OUTPUT:// Coroutine is working...// Coroutine is completing...// Job completed: successfully4. CompletedOnce the coroutine finishes its execution, it transitions to the Completed state. The coroutine has successfully executed its tasks.Example:fun main() = runBlocking { val job = launch { println(\"Task started...\") delay(1000) // Simulating work } job.join() println(\"Job state (Completed): ${job.isCompleted}\") }// OUTPUT:// Task started...// Job state (Completed): true5. CancellingIf a coroutine is cancelled, it enters the Cancelling state. In this state, the coroutine is in the process of being stopped, and any ongoing work should be cleaned up.Example:fun main() = runBlocking { val job = launch { try { repeat(5) { i -\u003e println(\"Coroutine is working... $i\") delay(500) // Simulating work } } finally { println(\"Coroutine is cancelled\") } } // Register callback job.invokeOnCompletion { cause -\u003e println(\"Job completed: ${if (cause == null) \"successfully\" else \"failed or cancelled: ${cause.message}\"}\") } delay(1000) // Let the coroutine run for a bit println(\"Cancelling the coroutine...\") job.cancel() // Cancelling the coroutine job.join() // Wait for the coroutine to ensure we see the invokeOnCompletion output}// OUTPUT:// Coroutine is working... 0// Coroutine is working... 1// Cancelling the coroutine...// Coroutine is cancelled// Job completed: failed or cancelled: CancellationException6. CancelledAfter the cancellation is complete, the coroutine reaches the Cancelled state. At this point, the coroutine has stopped its execution and will not complete its tasks.Example:fun main() = runBlocking { val job = launch { println(\"Starting coroutine...\") delay(2000) // Simulating a long task } // Register callback job.invokeOnCompletion { println(\"Job completed: ${if (it == null) \"successfully\" else \"failed or cancelled\"}\") } delay(500) // Let it run for a bit job.cancel() // Cancelling the coroutine println(\"Job state (Cancelled): ${job.isCancelled}\") // Should be true job.join() // Wait for the coroutine to ensure we see the invokeOnCompletion output}// OUTPUT:// Starting coroutine...// Job state (Cancelled): true// Job completed: failed or cancelled: CancellationExceptionCoroutine ScopesA CoroutineScope defines the scope within which coroutines can be launched. It helps manage the lifecycle of coroutines and enforces structured concurrency. When a scope is cancelled, all coroutines launched within that scope are also cancelled. The most common coroutine scopes are:GlobalScope: Launches coroutines that live for the entire lifetime of the application.CoroutineScope: A user-defined scope that can be tied to specific components (like activities or fragments in Android).DispatchersDispatchers define the thread or thread pool that the coroutine will run on. Common dispatchers include:Dispatchers.Main: Used for UI operations and runs on the main thread.Dispatchers.IO: Optimized for I/O operations, like network calls or reading files.Dispatchers.Default: Used for CPU-intensive tasks.The choice of dispatcher affects how coroutines execute and interact with the rest of the application, impacting their lifecycle and performance.Handling Failures and Exceptions in CoroutinesManaging failures and exceptions is crucial for building robust applications. Coroutines provide structured mechanisms for handling exceptions that may arise during asynchronous operations. Here are some important concepts and practices for managing exceptions in coroutines:1. Exception PropagationBy default, exceptions thrown in a coroutine are propagated to the parent coroutine. If a parent coroutine catches an exception, the child coroutine will be cancelled, and the exception will be passed up the coroutine hierarchy.Example:fun main() = runBlocking { val parentJob = launch { try { launch { throw Exception(\"Child coroutine failed\") } } catch (e: Exception) { println(\"Caught exception in parent: ${e.message}\") } } parentJob.join()}// OUTPUT:// Caught exception in parent: Child coroutine failed2. Using supervisorScopeWhen using supervisorScope, you can handle failures of child coroutines independently. If one child coroutine fails, it does not cancel the other child coroutines or the parent coroutine.Example:fun main() = runBlocking { supervisorScope { val child1 = launch { println(\"Child 1 started\") delay(1000) println(\"Child 1 completed\") } val child2 = launch { println(\"Child 2 started\") throw Exception(\"Child 2 failed\") } val child3 = launch { println(\"Child 3 started\") delay(1000) println(\"Child 3 completed\") } } println(\"Parent coroutine continues...\")}// OUTPUT:// Child 1 started// Child 2 started// Child 3 started// Child 1 completed// Child 3 completed// Parent coroutine continues...3. CoroutineExceptionHandlerYou can use CoroutineExceptionHandler to handle uncaught exceptions at the coroutine level. This handler can be passed as part of the coroutine context to manage exceptions that are not caught within the coroutine.Example:fun main() = runBlocking { val exceptionHandler = CoroutineExceptionHandler { _, exception -\u003e println(\"Caught exception: ${exception.message}\") } val job = launch(exceptionHandler) { throw Exception(\"Coroutine failed\") } job.join()}// OUTPUT:// Caught exception: Coroutine failed4. Cleaning Up ResourcesWhen a coroutine fails or is cancelled, it is important to clean up any resources (like closing files or releasing locks). Use the finally block to ensure that cleanup code runs regardless of whether an exception occurs.Example:fun main() = runBlocking { val job = launch { try { println(\"Coroutine started...\") delay(1000) throw Exception(\"Something went wrong\") } finally { println(\"Cleaning up resources...\") } } job.join() // Wait for the coroutine to finish}// OUTPUT:// Coroutine started...// Cleaning up resources...Effects of Launching Nested CoroutinesNested coroutines can affect the lifecycle and behavior of parent coroutines, especially in terms of cancellation and completion. When you launch a coroutine inside another coroutine (nested coroutine), it inherits the lifecycle of its parent. This means that if the parent coroutine is cancelled, the nested coroutine will also be cancelled unless it is launched in a different context or scope.Example of Nested Coroutinesfun main() = runBlocking { val parentJob = launch { println(\"Parent coroutine started on ${Thread.currentThread().name}\") val childJob = launch(Dispatchers.Default) { println(\"Child coroutine started on ${Thread.currentThread().name}\") delay(2000) // Simulating work println(\"Child coroutine completed\") } delay(1000) // Let the child coroutine run for a bit println(\"Cancelling the parent coroutine...\") cancel() // Cancelling the parent coroutine } // Register callback parentJob.invokeOnCompletion { cause -\u003e println(\"Parent job completed: ${if (cause == null) \"successfully\" else \"failed or cancelled: ${cause.message}\"}\") } parentJob.join() // Wait for the parent coroutine to finish}// OUTPUT:// Parent coroutine started on main// Child coroutine started on DefaultDispatcher-worker-1// Cancelling the parent coroutine...// Parent job completed: failed or cancelled: CancellationExceptionIn this example, when the parent coroutine is cancelled, the child coroutine is also cancelled, demonstrating the inherited lifecycle behavior of nested coroutines.Does a Job Go into Completed State After Cancelling?Yes, a Job transitions to the Completed state after being cancelled. Here’s how you can verify that:fun main() = runBlocking { val job = launch { println(\"Coroutine is working...\") delay(1000) // Simulating work } job.cancel() job.join() println(\"Job completed state: ${job.isCompleted}\")}// OUTPUT:// Coroutine is working...// Job completed state: trueBest Practices and Suggestions1. Use Structured ConcurrencyAlways launch coroutines within a specific scope, ensuring that they are tied to the lifecycle of the component that creates them. This prevents memory leaks and ensures proper cancellation.2. Prefer CoroutineScope Over GlobalScopeUse CoroutineScope for managing coroutines tied to specific components (e.g., activities, fragments) instead of GlobalScope, which can lead to uncontrolled coroutine lifetimes.3. Handle ExceptionsImplement exception handling within coroutines to manage failures gracefully. Use try-catch blocks or coroutine exception handlers to catch and handle exceptions effectively.4. Use SupervisorScope When NecessaryWhen dealing with nested coroutines, consider using supervisorScope to prevent failures in one child coroutine from affecting others.5. Monitor Coroutine StatesUtilize invokeOnCompletion and check the states of jobs to manage the lifecycle and handle any necessary cleanup or state checks.6. Avoid Blocking CallsMake sure not to block the coroutine dispatcher with long-running tasks. Use withContext to switch contexts if needed.ConclusionUnderstanding the lifecycle of coroutines, including the effects of nested coroutines and the role of supervisorScope, is essential for writing robust asynchronous code in Kotlin. By managing parent-child relationships and handling cancellations and failures effectively, you can create efficient and reliable applications.Whether you’re using invokeOnCompletion for cleanup, managing nested coroutines, or utilizing structured concurrency, Kotlin's coroutines provide powerful tools for handling concurrency with ease.That’s it for this blog. Let’s connect on LinkedIn and Twitter",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*sdb3Y6ckQGLcuekR8RD4Ew.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://rahul9650ray.medium.com/?source=post_page-----378d619908ac--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Rahul Ray\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*UcWvM8PK5gRHTME0JM1dsQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----378d619908ac--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eDiagram from kotlinlang.org\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"651a\"\u003eKotlin’s coroutines offer a powerful way to manage concurrency and asynchronous programming. However, to use them effectively, it’s crucial to understand the lifecycle of a coroutine. In this blog post, we’ll explore the coroutine lifecycle, focusing on the states of a coroutine’s Job, how they transition between states, and practical examples to illustrate each state, including the effects of launching nested coroutines. Additionally, we’ll discuss best practices and modifications.\u003c/p\u003e\u003ch2 id=\"ee95\"\u003eWhat is a Coroutine?\u003c/h2\u003e\u003cp id=\"9953\"\u003eCoroutines are lightweight threads that allow you to perform asynchronous tasks without blocking the main thread. They provide a way to write non-blocking code that is easy to read and maintain. In Kotlin, coroutines are structured around the concept of jobs.\u003c/p\u003e\u003ch2 id=\"90b1\"\u003eWhat is a Job?\u003c/h2\u003e\u003cp id=\"c0d0\"\u003eA Job is a handle to a coroutine. It represents its lifecycle and allows you to manage its execution, including starting, cancelling, and checking its status. The Job provides several states that a coroutine can be in during its lifecycle.\u003c/p\u003e\u003ch2 id=\"cf4b\"\u003eCoroutine Job Lifecycle States\u003c/h2\u003e\u003cp id=\"363b\"\u003eThe lifecycle of a coroutine’s Job includes the following states:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f4d6\"\u003e\u003cstrong\u003eNew\u003c/strong\u003e: The coroutine is created but not yet started.\u003c/li\u003e\u003cli id=\"4803\"\u003e\u003cstrong\u003eActive\u003c/strong\u003e: The coroutine is currently running.\u003c/li\u003e\u003cli id=\"1082\"\u003e\u003cstrong\u003eCompleting\u003c/strong\u003e: The coroutine is finishing its work.\u003c/li\u003e\u003cli id=\"5815\"\u003e\u003cstrong\u003eCompleted\u003c/strong\u003e: The coroutine has finished its execution successfully.\u003c/li\u003e\u003cli id=\"f113\"\u003e\u003cstrong\u003eCancelling\u003c/strong\u003e: The coroutine is in the process of being cancelled.\u003c/li\u003e\u003cli id=\"8a4b\"\u003e\u003cstrong\u003eCancelled\u003c/strong\u003e: The coroutine has been cancelled and will not complete.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"59b2\"\u003eJob Lifecycle Flow Diagram\u003c/h2\u003e\u003cp id=\"a6d7\"\u003eTo visualize the transitions between these states, consider the following flow diagram:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f6a6\"\u003e                                wait children\u003cbr/\u003e +-----+ start  +--------+ complete   +-------------+  finish  +-----------+\u003cbr/\u003e | New | -----\u0026gt; | Active | --------\u0026gt; | Completing  | -------\u0026gt; | Completed |\u003cbr/\u003e +-----+        +--------+            +-------------+          +-----------+\u003cbr/\u003e                   |  cancel / fail     |\u003cbr/\u003e                   |   +----------------+\u003cbr/\u003e                   |   |\u003cbr/\u003e                   V   V\u003cbr/\u003e             +------------+                           finish  +-----------+\u003cbr/\u003e             | Cancelling | --------------------------------\u0026gt; | Cancelled |\u003cbr/\u003e             +------------+                                   +-----------+\u003cp\u003e                      (Diagram from kotlinlang.org)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7e67\"\u003eState Transitions Explained\u003c/h2\u003e\u003ch2 id=\"c541\"\u003e1. New\u003c/h2\u003e\u003cp id=\"84f9\"\u003eThe New state is where a coroutine starts its lifecycle. A coroutine is created but not yet running.\u003c/p\u003e\u003cp id=\"7c18\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"25c1\"\u003efun main() {\u003cbr/\u003e    val job = GlobalScope.launch {\u003cbr/\u003e        println(\u0026#34;Coroutine is starting...\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;Job state (New): ${job.isActive}\u0026#34;)\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Job state (New): false\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"266d\"\u003e2. Active\u003c/h2\u003e\u003cp id=\"bf0d\"\u003eWhen the coroutine begins its execution, it transitions to the Active state. In this state, the coroutine can perform its designated tasks.\u003c/p\u003e\u003cp id=\"077f\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"51af\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        println(\u0026#34;Coroutine is active now!\u0026#34;)\u003cbr/\u003e        delay(1000) // Simulating work\u003cbr/\u003e    }\u003cp\u003e        println(\u0026#34;Job state (Active): ${job.isActive}\u0026#34;)\u003cbr/\u003e    job.join()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Coroutine is active now!\u003cbr/\u003e// Job state (Active): true\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1103\"\u003e3. Completing\u003c/h2\u003e\u003cp id=\"963b\"\u003eAs the coroutine finishes its tasks, it enters the Completing state. This state indicates that the coroutine is about to finish its execution.\u003c/p\u003e\u003cp id=\"77a1\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0946\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        println(\u0026#34;Coroutine is working...\u0026#34;)\u003cbr/\u003e        delay(1000) // Simulating work\u003cbr/\u003e        println(\u0026#34;Coroutine is completing...\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    // Register callback\u003cbr/\u003e    job.invokeOnCompletion { \u003cbr/\u003e        println(\u0026#34;Job completed: ${if (it == null) \u0026#34;successfully\u0026#34; else \u0026#34;failed or cancelled\u0026#34;}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    job.join()\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Coroutine is working...\u003cbr/\u003e// Coroutine is completing...\u003cbr/\u003e// Job completed: successfully\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"481f\"\u003e4. Completed\u003c/h2\u003e\u003cp id=\"e7cf\"\u003eOnce the coroutine finishes its execution, it transitions to the Completed state. The coroutine has successfully executed its tasks.\u003c/p\u003e\u003cp id=\"ede7\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9bb8\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        println(\u0026#34;Task started...\u0026#34;)\u003cbr/\u003e        delay(1000) // Simulating work\u003cbr/\u003e    }\u003cp\u003e        job.join()\u003cbr/\u003e    println(\u0026#34;Job state (Completed): ${job.isCompleted}\u0026#34;) \u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Task started...\u003cbr/\u003e// Job state (Completed): true\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4eaa\"\u003e5. Cancelling\u003c/h2\u003e\u003cp id=\"5270\"\u003eIf a coroutine is cancelled, it enters the Cancelling state. In this state, the coroutine is in the process of being stopped, and any ongoing work should be cleaned up.\u003c/p\u003e\u003cp id=\"c1aa\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1acf\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        try {\u003cbr/\u003e            repeat(5) { i -\u0026gt;\u003cbr/\u003e                println(\u0026#34;Coroutine is working... $i\u0026#34;)\u003cbr/\u003e                delay(500) // Simulating work\u003cbr/\u003e            }\u003cbr/\u003e        } finally {\u003cbr/\u003e            println(\u0026#34;Coroutine is cancelled\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    // Register callback\u003cbr/\u003e    job.invokeOnCompletion { cause -\u0026gt;\u003cbr/\u003e        println(\u0026#34;Job completed: ${if (cause == null) \u0026#34;successfully\u0026#34; else \u0026#34;failed or cancelled: ${cause.message}\u0026#34;}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    delay(1000) // Let the coroutine run for a bit\u003cbr/\u003e    println(\u0026#34;Cancelling the coroutine...\u0026#34;)\u003cbr/\u003e    job.cancel() // Cancelling the coroutine\u003cbr/\u003e    job.join() // Wait for the coroutine to ensure we see the invokeOnCompletion output\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Coroutine is working... 0\u003cbr/\u003e// Coroutine is working... 1\u003cbr/\u003e// Cancelling the coroutine...\u003cbr/\u003e// Coroutine is cancelled\u003cbr/\u003e// Job completed: failed or cancelled: CancellationException\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"67e6\"\u003e6. Cancelled\u003c/h2\u003e\u003cp id=\"7dda\"\u003eAfter the cancellation is complete, the coroutine reaches the Cancelled state. At this point, the coroutine has stopped its execution and will not complete its tasks.\u003c/p\u003e\u003cp id=\"dbcb\"\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bfb9\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        println(\u0026#34;Starting coroutine...\u0026#34;)\u003cbr/\u003e        delay(2000) // Simulating a long task\u003cbr/\u003e    }\u003cbr/\u003e    // Register callback\u003cbr/\u003e    job.invokeOnCompletion { \u003cbr/\u003e        println(\u0026#34;Job completed: ${if (it == null) \u0026#34;successfully\u0026#34; else \u0026#34;failed or cancelled\u0026#34;}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    delay(500) // Let it run for a bit\u003cbr/\u003e    job.cancel() // Cancelling the coroutine\u003cbr/\u003e    println(\u0026#34;Job state (Cancelled): ${job.isCancelled}\u0026#34;) // Should be true\u003cbr/\u003e    job.join() // Wait for the coroutine to ensure we see the invokeOnCompletion output\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Starting coroutine...\u003cbr/\u003e// Job state (Cancelled): true\u003cbr/\u003e// Job completed: failed or cancelled: CancellationException\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"cf26\"\u003eCoroutine Scopes\u003c/h2\u003e\u003cp id=\"2aa1\"\u003eA CoroutineScope defines the scope within which coroutines can be launched. It helps manage the lifecycle of coroutines and enforces structured concurrency. When a scope is cancelled, all coroutines launched within that scope are also cancelled. The most common coroutine scopes are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"56be\"\u003e\u003cstrong\u003eGlobalScope\u003c/strong\u003e: Launches coroutines that live for the entire lifetime of the application.\u003c/li\u003e\u003cli id=\"0cd4\"\u003e\u003cstrong\u003eCoroutineScope\u003c/strong\u003e: A user-defined scope that can be tied to specific components (like activities or fragments in Android).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"85b3\"\u003eDispatchers\u003c/h2\u003e\u003cp id=\"eed1\"\u003eDispatchers define the thread or thread pool that the coroutine will run on. Common dispatchers include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9c8d\"\u003e\u003cstrong\u003eDispatchers.Main\u003c/strong\u003e: Used for UI operations and runs on the main thread.\u003c/li\u003e\u003cli id=\"6421\"\u003e\u003cstrong\u003eDispatchers.IO\u003c/strong\u003e: Optimized for I/O operations, like network calls or reading files.\u003c/li\u003e\u003cli id=\"f9b6\"\u003e\u003cstrong\u003eDispatchers.Default\u003c/strong\u003e: Used for CPU-intensive tasks.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b331\"\u003eThe choice of dispatcher affects how coroutines execute and interact with the rest of the application, impacting their lifecycle and performance.\u003c/p\u003e\u003ch2 id=\"1bfe\"\u003eHandling Failures and Exceptions in Coroutines\u003c/h2\u003e\u003cp id=\"29df\"\u003eManaging failures and exceptions is crucial for building robust applications. Coroutines provide structured mechanisms for handling exceptions that may arise during asynchronous operations. Here are some important concepts and practices for managing exceptions in coroutines:\u003c/p\u003e\u003ch2 id=\"f2cc\"\u003e1. Exception Propagation\u003c/h2\u003e\u003cp id=\"4950\"\u003eBy default, exceptions thrown in a coroutine are propagated to the parent coroutine. If a parent coroutine catches an exception, the child coroutine will be cancelled, and the exception will be passed up the coroutine hierarchy.\u003c/p\u003e\u003cp id=\"7f37\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa06\"\u003efun main() = runBlocking {\u003cbr/\u003e    val parentJob = launch {\u003cbr/\u003e        try {\u003cbr/\u003e            launch {\u003cbr/\u003e                throw Exception(\u0026#34;Child coroutine failed\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            println(\u0026#34;Caught exception in parent: ${e.message}\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    parentJob.join()\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Caught exception in parent: Child coroutine failed\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e092\"\u003e2. Using \u003ccode\u003esupervisorScope\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"d644\"\u003eWhen using \u003ccode\u003esupervisorScope\u003c/code\u003e, you can handle failures of child coroutines independently. If one child coroutine fails, it does not cancel the other child coroutines or the parent coroutine.\u003c/p\u003e\u003cp id=\"2ce6\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5036\"\u003efun main() = runBlocking {\u003cbr/\u003e    supervisorScope {\u003cbr/\u003e        val child1 = launch {\u003cbr/\u003e            println(\u0026#34;Child 1 started\u0026#34;)\u003cbr/\u003e            delay(1000)\u003cbr/\u003e            println(\u0026#34;Child 1 completed\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        val child2 = launch {\u003cbr/\u003e            println(\u0026#34;Child 2 started\u0026#34;)\u003cbr/\u003e            throw Exception(\u0026#34;Child 2 failed\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        val child3 = launch {\u003cbr/\u003e            println(\u0026#34;Child 3 started\u0026#34;)\u003cbr/\u003e            delay(1000)\u003cbr/\u003e            println(\u0026#34;Child 3 completed\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;Parent coroutine continues...\u0026#34;)\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Child 1 started\u003cbr/\u003e// Child 2 started\u003cbr/\u003e// Child 3 started\u003cbr/\u003e// Child 1 completed\u003cbr/\u003e// Child 3 completed\u003cbr/\u003e// Parent coroutine continues...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1b5b\"\u003e3. \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"52b6\"\u003eYou can use \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e to handle uncaught exceptions at the coroutine level. This handler can be passed as part of the coroutine context to manage exceptions that are not caught within the coroutine.\u003c/p\u003e\u003cp id=\"c020\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb1a\"\u003efun main() = runBlocking {\u003cbr/\u003e    val exceptionHandler = CoroutineExceptionHandler { _, exception -\u0026gt;\u003cbr/\u003e        println(\u0026#34;Caught exception: ${exception.message}\u0026#34;)\u003cbr/\u003e    }\u003cp\u003e    val job = launch(exceptionHandler) {\u003cbr/\u003e        throw Exception(\u0026#34;Coroutine failed\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    job.join()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Caught exception: Coroutine failed\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"656f\"\u003e4. Cleaning Up Resources\u003c/h2\u003e\u003cp id=\"aa10\"\u003eWhen a coroutine fails or is cancelled, it is important to clean up any resources (like closing files or releasing locks). Use the \u003ccode\u003efinally\u003c/code\u003e block to ensure that cleanup code runs regardless of whether an exception occurs.\u003c/p\u003e\u003cp id=\"8e90\"\u003e\u003cstrong\u003eExample\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9500\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        try {\u003cbr/\u003e            println(\u0026#34;Coroutine started...\u0026#34;)\u003cbr/\u003e            delay(1000)\u003cbr/\u003e            throw Exception(\u0026#34;Something went wrong\u0026#34;)\u003cbr/\u003e        } finally {\u003cbr/\u003e            println(\u0026#34;Cleaning up resources...\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    job.join() // Wait for the coroutine to finish\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Coroutine started...\u003cbr/\u003e// Cleaning up resources...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"dbc3\"\u003eEffects of Launching Nested Coroutines\u003c/h2\u003e\u003cp id=\"0a0b\"\u003eNested coroutines can affect the lifecycle and behavior of parent coroutines, especially in terms of cancellation and completion. When you launch a coroutine inside another coroutine (nested coroutine), it inherits the lifecycle of its parent. This means that if the parent coroutine is cancelled, the nested coroutine will also be cancelled unless it is launched in a different context or scope.\u003c/p\u003e\u003ch2 id=\"6701\"\u003eExample of Nested Coroutines\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0f26\"\u003efun main() = runBlocking {\u003cbr/\u003e    val parentJob = launch {\u003cbr/\u003e        println(\u0026#34;Parent coroutine started on ${Thread.currentThread().name}\u0026#34;)\u003cbr/\u003e        val childJob = launch(Dispatchers.Default) {\u003cbr/\u003e            println(\u0026#34;Child coroutine started on ${Thread.currentThread().name}\u0026#34;)\u003cbr/\u003e            delay(2000) // Simulating work\u003cbr/\u003e            println(\u0026#34;Child coroutine completed\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        delay(1000) // Let the child coroutine run for a bit\u003cbr/\u003e        println(\u0026#34;Cancelling the parent coroutine...\u0026#34;)\u003cbr/\u003e        cancel() // Cancelling the parent coroutine\u003cbr/\u003e    }\u003cbr/\u003e    // Register callback\u003cbr/\u003e    parentJob.invokeOnCompletion { cause -\u0026gt;\u003cbr/\u003e        println(\u0026#34;Parent job completed: ${if (cause == null) \u0026#34;successfully\u0026#34; else \u0026#34;failed or cancelled: ${cause.message}\u0026#34;}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    parentJob.join() // Wait for the parent coroutine to finish\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Parent coroutine started on main\u003cbr/\u003e// Child coroutine started on DefaultDispatcher-worker-1\u003cbr/\u003e// Cancelling the parent coroutine...\u003cbr/\u003e// Parent job completed: failed or cancelled: CancellationException\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"baaf\"\u003eIn this example, when the parent coroutine is cancelled, the child coroutine is also cancelled, demonstrating the inherited lifecycle behavior of nested coroutines.\u003c/p\u003e\u003ch2 id=\"0d6b\"\u003eDoes a Job Go into Completed State After Cancelling?\u003c/h2\u003e\u003cp id=\"a7ce\"\u003eYes, a Job transitions to the Completed state after being cancelled. Here’s how you can verify that:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"47b8\"\u003efun main() = runBlocking {\u003cbr/\u003e    val job = launch {\u003cbr/\u003e        println(\u0026#34;Coroutine is working...\u0026#34;)\u003cbr/\u003e        delay(1000) // Simulating work\u003cbr/\u003e    }\u003cbr/\u003e    job.cancel()\u003cbr/\u003e    job.join() \u003cbr/\u003e    println(\u0026#34;Job completed state: ${job.isCompleted}\u0026#34;)\u003cbr/\u003e}\u003cp\u003e// OUTPUT:\u003cbr/\u003e// Coroutine is working...\u003cbr/\u003e// Job completed state: true\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8d5b\"\u003eBest Practices and Suggestions\u003c/h2\u003e\u003ch2 id=\"e813\"\u003e1. Use Structured Concurrency\u003c/h2\u003e\u003cp id=\"804e\"\u003eAlways launch coroutines within a specific scope, ensuring that they are tied to the lifecycle of the component that creates them. This prevents memory leaks and ensures proper cancellation.\u003c/p\u003e\u003ch2 id=\"f0e7\"\u003e2. Prefer CoroutineScope Over GlobalScope\u003c/h2\u003e\u003cp id=\"ed80\"\u003eUse \u003ccode\u003eCoroutineScope\u003c/code\u003e for managing coroutines tied to specific components (e.g., activities, fragments) instead of \u003ccode\u003eGlobalScope\u003c/code\u003e, which can lead to uncontrolled coroutine lifetimes.\u003c/p\u003e\u003ch2 id=\"34de\"\u003e3. Handle Exceptions\u003c/h2\u003e\u003cp id=\"fb53\"\u003eImplement exception handling within coroutines to manage failures gracefully. Use \u003ccode\u003etry-catch\u003c/code\u003e blocks or coroutine exception handlers to catch and handle exceptions effectively.\u003c/p\u003e\u003ch2 id=\"f651\"\u003e4. Use SupervisorScope When Necessary\u003c/h2\u003e\u003cp id=\"25fd\"\u003eWhen dealing with nested coroutines, consider using \u003ccode\u003esupervisorScope\u003c/code\u003e to prevent failures in one child coroutine from affecting others.\u003c/p\u003e\u003ch2 id=\"d822\"\u003e5. Monitor Coroutine States\u003c/h2\u003e\u003cp id=\"33e0\"\u003eUtilize \u003ccode\u003einvokeOnCompletion\u003c/code\u003e and check the states of jobs to manage the lifecycle and handle any necessary cleanup or state checks.\u003c/p\u003e\u003ch2 id=\"d08c\"\u003e6. Avoid Blocking Calls\u003c/h2\u003e\u003cp id=\"173b\"\u003eMake sure not to block the coroutine dispatcher with long-running tasks. Use \u003ccode\u003ewithContext\u003c/code\u003e to switch contexts if needed.\u003c/p\u003e\u003ch2 id=\"28d1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"4051\"\u003eUnderstanding the lifecycle of coroutines, including the effects of nested coroutines and the role of \u003ccode\u003esupervisorScope\u003c/code\u003e, is essential for writing robust asynchronous code in Kotlin. By managing parent-child relationships and handling cancellations and failures effectively, you can create efficient and reliable applications.\u003c/p\u003e\u003cp id=\"7250\"\u003eWhether you’re using \u003ccode\u003einvokeOnCompletion\u003c/code\u003e for cleanup, managing nested coroutines, or utilizing structured concurrency, Kotlin\u0026#39;s coroutines provide powerful tools for handling concurrency with ease.\u003c/p\u003e\u003cp id=\"ba99\"\u003eThat’s it for this blog. Let’s connect on \u003ca href=\"https://www.linkedin.com/in/raystatic/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e and \u003ca href=\"https://twitter.com/raystatic_\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eTwitter\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-10-25T23:29:59.443Z",
  "modifiedTime": null
}
