{
  "id": "54098801-c6a1-4058-8566-0ef8cc472373",
  "title": "Kotlin Value Class: Type Safety Without Runtime Overhead",
  "link": "https://proandroiddev.com/kotlin-value-class-type-safety-without-runtime-overhead-de028b175e1f?source=rss----c72404660798---4",
  "description": "",
  "author": "Shakarim Bazhenov",
  "published": "Wed, 25 Jun 2025 13:25:47 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "java",
    "interview-questions",
    "kotlin",
    "interview"
  ],
  "byline": "Shakarim Bazhenov",
  "length": 3986,
  "excerpt": "Kotlin’s value class lets you create type-safe wrappers around primitive values with no runtime cost in most scenarios. It's one of Kotlin’s most powerful tools for writing expressive, safe, and…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin’s value class lets you create type-safe wrappers around primitive values with no runtime cost in most scenarios. It's one of Kotlin’s most powerful tools for writing expressive, safe, and efficient code — especially when your domain model deserves more than just raw String and Int.What Is a Value Class?A value class wraps exactly one property, and the Kotlin compiler replaces instances of this class with the underlying value at runtime, wherever possible — this is known as inlining.@JvmInlinevalue class UserId(val value: String)At runtime, this behaves like a String, but it’s not interchangeable with other Strings. The type system will enforce correct usage.Why Use Value Classes?Type SafetyAvoid mixing unrelated values — for example, UserId should never be confused with Email.ExpressivenessInstead of vague String parameters, your functions now clearly describe intent:fun sendEmail(to: Email) // ✅ clearPerformanceIn most use cases, value classes avoid object allocation on the heap, reducing memory pressure and improving runtime performance.How Inlining WorksLet’s say you have:fun greet(userId: UserId) = println(userId.value)The compiler rewrites it as:fun greet(userId: String) = println(userId)So there’s no UserId object at runtime — just the underlying String. That’s why we call it a zero-cost abstraction.What You Can Do with Value ClassesAs of Kotlin 1.9+, value classes support:✅ init blocks for validation✅ Secondary constructors✅ Computed properties (with get() only)✅ Functions inside the class✅ Generic parameters✅ Interface implementation (but not class inheritance)Example@JvmInlinevalue class Email(val value: String) { init { require(value.contains(\"@\")) { \"Invalid email format\" } } constructor(local: String, domain: String) : this(\"$local@$domain\") val domain: String get() = value.substringAfter(\"@\")}When Does Boxing Happen?Sometimes, Kotlin needs to wrap your value class into an object. This is called boxing.Boxing occurs in:nullable value classes: val u: UserId?generics: List\u003cUserId\u003e, fun \u003cT\u003e doSomething(value: T)reflectionJava interopIn these cases, the compiler wraps your value into an actual object with one field.@JvmInline Is Always Required on JVMThis is non-negotiable:On JVM targets (including Android), every value class must be annotated with @JvmInline@JvmInlinevalue class Token(val value: String) // ✅ RequiredIf you omit the annotation, the compiler will reject it:Inline classes are only supported with the @JvmInline annotationWhat About Other Platforms?Kotlin supports multiple platforms — and this requirement only applies to JVM:Kotlin/JVM (Android, backend) → @JvmInline is requiredKotlin/JS (JavaScript) → @JvmInline is not neededKotlin/Native (iOS, macOS, embedded, etc.) → @JvmInline is not neededIn Android Studio or any other JVM project, you always need to annotate your value class.Common Use CasesSome great examples where value classes shine:Identifiers: UserId, ProductId, TokenDomain-specific types: Email, PhoneNumber, PasswordUnits and measurements: Meters, Duration, TemperatureMoney and rates: Amount, Currency, PercentageThese are all often modeled with simple String or Int, but wrapping them in a value class brings safety and clarity.SummaryTo wrap it up, Kotlin value classes offer:Type safety: no more accidental swapping of String argumentsPerformance: no heap allocation in most casesExpressiveness: domain modeling that reads like EnglishPredictable boxing: you know when it happens (nullable, generics, reflection)Mandatory @JvmInline: always required on JVMFinal ThoughtsKotlin’s value class is one of the cleanest tools for writing safe, expressive, and efficient code — and it’s shockingly underused.If you’re modeling identifiers, measurements, or business rules, and still relying on String and Int, it’s time to upgrade to value classes.Just remember: ✅ On JVM (including Android), you must annotate every value class with @JvmInline — even if boxing occurs.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*cYwdxCB4gLJO3DyK23zg9w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@shbazhenov?source=post_page---byline--de028b175e1f---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Shakarim Bazhenov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*hiI_stOtJ4Av1nxkxrYAXg.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a839\"\u003eKotlin’s \u003ccode\u003evalue class\u003c/code\u003e lets you create type-safe wrappers around primitive values with \u003cstrong\u003eno runtime cost in most scenarios\u003c/strong\u003e. It\u0026#39;s one of Kotlin’s most powerful tools for writing expressive, safe, and efficient code — especially when your domain model deserves more than just raw \u003ccode\u003eString\u003c/code\u003e and \u003ccode\u003eInt\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"76a8\"\u003eWhat Is a Value Class?\u003c/h2\u003e\u003cp id=\"43de\"\u003eA \u003ccode\u003evalue class\u003c/code\u003e wraps \u003cstrong\u003eexactly one property\u003c/strong\u003e, and the Kotlin compiler replaces instances of this class with the underlying value \u003cstrong\u003eat runtime\u003c/strong\u003e, wherever possible — this is known as \u003cstrong\u003einlining\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"46f4\"\u003e@JvmInline\u003cbr/\u003evalue class UserId(val value: String)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b889\"\u003eAt runtime, this behaves like a \u003ccode\u003eString\u003c/code\u003e, but it’s not interchangeable with other \u003ccode\u003eString\u003c/code\u003es. The type system will enforce correct usage.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a186\"\u003eWhy Use Value Classes?\u003c/h2\u003e\u003ch2 id=\"4350\"\u003eType Safety\u003c/h2\u003e\u003cp id=\"8887\"\u003eAvoid mixing unrelated values — for example, \u003ccode\u003eUserId\u003c/code\u003e should never be confused with \u003ccode\u003eEmail\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"ef44\"\u003eExpressiveness\u003c/h2\u003e\u003cp id=\"b4c9\"\u003eInstead of vague \u003ccode\u003eString\u003c/code\u003e parameters, your functions now clearly describe intent:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4e17\"\u003efun sendEmail(to: Email) // ✅ clear\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c10f\"\u003ePerformance\u003c/h2\u003e\u003cp id=\"6c0e\"\u003eIn most use cases, value classes avoid object allocation on the heap, reducing memory pressure and improving runtime performance.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d615\"\u003eHow Inlining Works\u003c/h2\u003e\u003cp id=\"aaaf\"\u003eLet’s say you have:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa31\"\u003efun greet(userId: UserId) = println(userId.value)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d9e\"\u003eThe compiler rewrites it as:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"399c\"\u003efun greet(userId: String) = println(userId)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"20e3\"\u003eSo there’s \u003cstrong\u003eno \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eUserId\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e object at runtime\u003c/strong\u003e — just the underlying \u003ccode\u003eString\u003c/code\u003e. That’s why we call it a \u003cstrong\u003ezero-cost abstraction\u003c/strong\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c06a\"\u003eWhat You Can Do with Value Classes\u003c/h2\u003e\u003cp id=\"2b8a\"\u003eAs of Kotlin 1.9+, value classes support:\u003c/p\u003e\u003cul\u003e\u003cli id=\"484f\"\u003e✅ \u003ccode\u003einit\u003c/code\u003e blocks for validation\u003c/li\u003e\u003cli id=\"60ac\"\u003e✅ Secondary constructors\u003c/li\u003e\u003cli id=\"d221\"\u003e✅ Computed properties (with \u003ccode\u003eget()\u003c/code\u003e only)\u003c/li\u003e\u003cli id=\"c33c\"\u003e✅ Functions inside the class\u003c/li\u003e\u003cli id=\"90ca\"\u003e✅ Generic parameters\u003c/li\u003e\u003cli id=\"222b\"\u003e✅ Interface implementation (but not class inheritance)\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2cbd\"\u003eExample\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"7c3d\"\u003e@JvmInline\u003cbr/\u003evalue class Email(val value: String) {\u003cbr/\u003e    init {\u003cbr/\u003e        require(value.contains(\u0026#34;@\u0026#34;)) { \u0026#34;Invalid email format\u0026#34; }\u003cbr/\u003e    }\u003cp\u003e    constructor(local: String, domain: String) : this(\u0026#34;$local@$domain\u0026#34;)\u003c/p\u003e\u003cp\u003e    val domain: String\u003cbr/\u003e        get() = value.substringAfter(\u0026#34;@\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7e7c\"\u003eWhen Does Boxing Happen?\u003c/h2\u003e\u003cp id=\"d768\"\u003eSometimes, Kotlin needs to wrap your value class into an object. This is called \u003cstrong\u003eboxing\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"322e\"\u003eBoxing occurs in:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"c193\"\u003e\u003ccode\u003enullable\u003c/code\u003e value classes: \u003ccode\u003eval u: UserId?\u003c/code\u003e\u003c/li\u003e\u003cli id=\"c107\"\u003e\u003ccode\u003egenerics\u003c/code\u003e: \u003ccode\u003eList\u0026lt;UserId\u0026gt;\u003c/code\u003e, \u003ccode\u003efun \u0026lt;T\u0026gt; doSomething(value: T)\u003c/code\u003e\u003c/li\u003e\u003cli id=\"252f\"\u003e\u003ccode\u003ereflection\u003c/code\u003e\u003c/li\u003e\u003cli id=\"b7ed\"\u003e\u003ccode\u003eJava interop\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f9e7\"\u003eIn these cases, the compiler wraps your value into an actual object with one field.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2906\"\u003e\u003ccode\u003e@JvmInline\u003c/code\u003e Is Always Required on JVM\u003c/h2\u003e\u003cp id=\"ab14\"\u003eThis is \u003cstrong\u003enon-negotiable\u003c/strong\u003e:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"6357\"\u003e\u003cem\u003eOn \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eJVM targets\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e (including Android), every \u003c/em\u003e\u003ccode\u003e\u003cem\u003evalue class\u003c/em\u003e\u003c/code\u003e\u003cem\u003e \u003c/em\u003e\u003cstrong\u003e\u003cem\u003emust\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e be annotated with \u003c/em\u003e\u003ccode\u003e\u003cem\u003e@JvmInline\u003c/em\u003e\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"10c5\"\u003e@JvmInline\u003cbr/\u003evalue class Token(val value: String) // ✅ Required\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e0c0\"\u003eIf you omit the annotation, the compiler will reject it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7b28\"\u003eInline classes are only supported with the @JvmInline annotation\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5298\"\u003eWhat About Other Platforms?\u003c/h2\u003e\u003cp id=\"8ae9\"\u003eKotlin supports multiple platforms — and this requirement only applies to JVM:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bbd6\"\u003e\u003cstrong\u003eKotlin/JVM (Android, backend)\u003c/strong\u003e → \u003ccode\u003e@JvmInline\u003c/code\u003e is required\u003c/li\u003e\u003cli id=\"8a48\"\u003e\u003cstrong\u003eKotlin/JS (JavaScript)\u003c/strong\u003e → \u003ccode\u003e@JvmInline\u003c/code\u003e is not needed\u003c/li\u003e\u003cli id=\"6900\"\u003e\u003cstrong\u003eKotlin/Native (iOS, macOS, embedded, etc.)\u003c/strong\u003e → \u003ccode\u003e@JvmInline\u003c/code\u003e is not needed\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b0fa\"\u003eIn Android Studio or any other JVM project, you always need to annotate your value class.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"90e4\"\u003eCommon Use Cases\u003c/h2\u003e\u003cp id=\"d1a6\"\u003eSome great examples where value classes shine:\u003c/p\u003e\u003cul\u003e\u003cli id=\"dfe4\"\u003e\u003cstrong\u003eIdentifiers\u003c/strong\u003e: \u003ccode\u003eUserId\u003c/code\u003e, \u003ccode\u003eProductId\u003c/code\u003e, \u003ccode\u003eToken\u003c/code\u003e\u003c/li\u003e\u003cli id=\"4aee\"\u003e\u003cstrong\u003eDomain-specific types\u003c/strong\u003e: \u003ccode\u003eEmail\u003c/code\u003e, \u003ccode\u003ePhoneNumber\u003c/code\u003e, \u003ccode\u003ePassword\u003c/code\u003e\u003c/li\u003e\u003cli id=\"090b\"\u003e\u003cstrong\u003eUnits and measurements\u003c/strong\u003e: \u003ccode\u003eMeters\u003c/code\u003e, \u003ccode\u003eDuration\u003c/code\u003e, \u003ccode\u003eTemperature\u003c/code\u003e\u003c/li\u003e\u003cli id=\"6f50\"\u003e\u003cstrong\u003eMoney and rates\u003c/strong\u003e: \u003ccode\u003eAmount\u003c/code\u003e, \u003ccode\u003eCurrency\u003c/code\u003e, \u003ccode\u003ePercentage\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5a41\"\u003eThese are all often modeled with simple \u003ccode\u003eString\u003c/code\u003e or \u003ccode\u003eInt\u003c/code\u003e, but wrapping them in a value class brings safety and clarity.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"89d5\"\u003eSummary\u003c/h2\u003e\u003cp id=\"78e0\"\u003eTo wrap it up, Kotlin value classes offer:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1669\"\u003e\u003cstrong\u003eType safety\u003c/strong\u003e: no more accidental swapping of \u003ccode\u003eString\u003c/code\u003e arguments\u003c/li\u003e\u003cli id=\"acd4\"\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e: no heap allocation in most cases\u003c/li\u003e\u003cli id=\"2c59\"\u003e\u003cstrong\u003eExpressiveness\u003c/strong\u003e: domain modeling that reads like English\u003c/li\u003e\u003cli id=\"a501\"\u003e\u003cstrong\u003ePredictable boxing\u003c/strong\u003e: you know when it happens (nullable, generics, reflection)\u003c/li\u003e\u003cli id=\"95d0\"\u003e\u003cstrong\u003eMandatory \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e@JvmInline\u003c/strong\u003e\u003c/code\u003e: always required on JVM\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"71b7\"\u003eFinal Thoughts\u003c/h2\u003e\u003cp id=\"2b73\"\u003eKotlin’s \u003ccode\u003evalue class\u003c/code\u003e is one of the cleanest tools for writing safe, expressive, and efficient code — and it’s shockingly underused.\u003c/p\u003e\u003cp id=\"f038\"\u003eIf you’re modeling identifiers, measurements, or business rules, and still relying on \u003ccode\u003eString\u003c/code\u003e and \u003ccode\u003eInt\u003c/code\u003e, it’s time to upgrade to value classes.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"393c\"\u003e\u003cem\u003eJust remember: ✅ On JVM (including Android), \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eyou must annotate\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e every value class with \u003c/em\u003e\u003ccode\u003e\u003cem\u003e@JvmInline\u003c/em\u003e\u003c/code\u003e\u003cem\u003e — even if boxing occurs.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-04-20T13:17:10.621Z",
  "modifiedTime": null
}
