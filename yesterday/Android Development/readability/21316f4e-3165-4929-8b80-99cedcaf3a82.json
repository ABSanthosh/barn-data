{
  "id": "21316f4e-3165-4929-8b80-99cedcaf3a82",
  "title": "Avoid using mutable collections in the data class constructor in Kotlin",
  "link": "https://proandroiddev.com/avoid-using-mutable-collections-in-the-data-class-constructor-in-kotlin-53d17897114e?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Sun, 22 Jun 2025 17:51:20 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "androiddev",
    "kotlin",
    "android",
    "kotlin-beginners"
  ],
  "byline": "Anatolii Frolov",
  "length": 5334,
  "excerpt": "In my previous articles, I showed how using var, Array, or a lambda in the constructor of a Kotlin data class can lead to unexpected behavior and subtle bugs. These issues often relate to howâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In my previous articles, I showed how using var, Array, or a lambda in the constructor of a Kotlin data class can lead to unexpected behavior and subtle bugs.These issues often relate to how equals(), hashCode(), and copy() work under the hood â€” especially in collections, diffing, or recomposition logic.Avoid using var in the data class constructor in KotlinAvoid using var in the data class constructor in Kotlin â€“ now with Jetpack ComposeAvoid using Array in the data class constructor in KotlinAvoid using lambda in the data class constructor in KotlinAfter reading the first article, it might seem like switching from var to val is enough to make a data class safe. And in many cases, thatâ€™s true.But if a val holds a mutable collection â€” such as MutableList or MutableMap â€” the object is still not truly immutable.Its internal state can change over time, which leads to the same kind of problems: broken equality, unexpected behavior in maps or sets, and incorrect assumptions when copying or caching.In this article, weâ€™ll look at why using mutable collections in the constructor of a Kotlin data class can be just as problematic â€” and how to avoid these hidden issues.Using data classes as map keysIn most real-world code, keys in a Map are simple types like String, Int, or UUID.Theyâ€™re easy to compare, have stable hash codes, and behave predictably.But Kotlin (and Java) doesnâ€™t restrict what you can use as a key â€” any object with proper equals() and hashCode() can be used.For example, a data class instance:data class User(val id: String, val name: String)val premiumUser = User(\"42\", \"Mike\")val regularUser1 = User(\"17\", \"Alice\")val regularUser2 = User(\"23\", \"Bob\")val userMap = hashMapOf( premiumUser to \"Premium user\", regularUser1 to \"Free tier\", regularUser2 to \"Free tier\")println(userMap[premiumUser])println(userMap[regularUser1])println(userMap[regularUser2])Output:Premium userFree tierFree tierThanks to auto-generated equals() and hashCode(), this works out of the box.Iâ€™m not suggesting you should use data classes as map keys everywhere â€” in most cases, primitives are a better choice.But itâ€™s important to understand how equality works, and what can go wrong when the objectâ€™s internal state changes â€” even if all properties are marked val.Mutable collections break equalityIn the previous example, we saw how a data class can be used as a map key â€” and everything works as expected, as long as the object stays the same.Now letâ€™s look at a less obvious case:when the constructor contains a val that points to a mutable collection, like MutableList.data class Cart(val items: MutableList\u003cString\u003e)val cart1 = Cart(mutableListOf(\"Milk\", \"Bread\"))val cart2 = Cart(mutableListOf(\"Cheese\", \"Wine\"))val cartMap = hashMapOf( cart1 to \"Weekly groceries\", cart2 to \"Dinner items\")// Before mutationprintln(cartMap[cart1])println(cartMap[cart2])// Mutate one cartcart1.items.add(\"Eggs\")// After mutationprintln(cartMap[cart1])println(cartMap[cart2])Output:Weekly groceriesDinner itemsnullDinner itemsThis happens because MutableList is included in the auto-generated equals() and hashCode() implementations.Once we modify the list, the hash code changes â€” and the map can no longer find the original key.Itâ€™s not obvious at first, because everything works until a mutation happens.But this makes the code fragile: we shouldnâ€™t allow internal state changes to affect how objects behave in collections.Even if the property is declared as val, using a mutable structure creates a hidden risk.That risk grows in code that relies on hash-based structures like Map, Set, or caching layers.What to use insteadWhen working with Map or Set, itâ€™s safest to use primitives like String, Int, or UUID as keys.If you decide to use a data class as a key, make sure that:All constructor properties are declared as valThese properties are truly immutable â€” not just by reference, but also by behaviorThat means avoiding MutableList, MutableMap, or other mutable types in the constructor.This helps ensure that the auto-generated equals() and hashCode() remain stable, even if the object is reused across different parts of the app.Itâ€™s also a solid design rule in general:constructor properties in a data class should not contain mutable state.This makes the class easier to reason about, and safer to use in collections, cache layers, or UI state comparisons.ConclusionUsing val in a data class constructor doesnâ€™t guarantee immutability â€”not if the value itself is mutable.Collections like MutableList or MutableMap can still be modified after the object is created.If those values are part of equals() or hashCode(), this can break map lookups, set behavior, and other collection logic.To keep data classes predictable, avoid placing mutable state in the constructor â€” even if itâ€™s wrapped in a val.This reduces the risk of subtle bugs and makes your models safer to use in real-world scenarios like caching, state diffing, or hash-based collections.If you learned something new or found this breakdown useful, feel free to leave a clap â€” it helps others discover the article.You can also follow me on Medium for more posts about Kotlin, Android development, and practical engineering topics.Anatolii FrolovSenior Android DeveloperWriting honest, real-world Kotlin \u0026 Jetpack Compose insights.ðŸ“¬ Follow me on Medium",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*DspXYw_6Y2o166RhXQE7jQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@af2905g?source=post_page---byline--53d17897114e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anatolii Frolov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PUwz5znLfXDNlKnDndJggA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"999d\"\u003eIn my previous articles, I showed how using \u003ccode\u003evar\u003c/code\u003e, \u003ccode\u003eArray\u003c/code\u003e, or a \u003ccode\u003elambda\u003c/code\u003e in the constructor of a Kotlin data class can lead to unexpected behavior and subtle bugs.\u003c/p\u003e\u003cp id=\"16ae\"\u003eThese issues often relate to how \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and \u003ccode\u003ecopy()\u003c/code\u003e work under the hood â€” especially in collections, diffing, or recomposition logic.\u003c/p\u003e\u003cul\u003e\u003cli id=\"8d68\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003eAvoid using var in the data class constructor in Kotlin\u003c/a\u003e\u003c/li\u003e\u003cli id=\"c895\"\u003e\u003ca rel=\"noopener ugc nofollow\" href=\"https://proandroiddev.com/avoid-using-var-in-the-data-class-constructor-in-kotlin-now-with-jetpack-compose-e0ebaf5445b6\" target=\"_blank\" data-discover=\"true\"\u003eAvoid using var in the data class constructor in Kotlin â€“ now with Jetpack Compose\u003c/a\u003e\u003c/li\u003e\u003cli id=\"3f22\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95\" rel=\"noopener\"\u003eAvoid using Array in the data class constructor in Kotlin\u003c/a\u003e\u003c/li\u003e\u003cli id=\"211f\"\u003e\u003ca href=\"https://medium.com/proandroiddev/avoid-using-lambda-in-the-data-class-constructor-in-kotlin-a7d952de25c9\" rel=\"noopener\"\u003eAvoid using lambda in the data class constructor in Kotlin\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ee94\"\u003eAfter reading the first article, it might seem like switching from \u003ccode\u003evar\u003c/code\u003e to \u003ccode\u003eval\u003c/code\u003e is enough to make a data class safe. And in many cases, thatâ€™s true.\u003c/p\u003e\u003cp id=\"5f9b\"\u003eBut if a \u003ccode\u003eval\u003c/code\u003e holds a mutable collection â€” such as \u003ccode\u003eMutableList\u003c/code\u003e or \u003ccode\u003eMutableMap\u003c/code\u003e â€” the object is still not truly immutable.\u003cbr/\u003eIts internal state can change over time, which leads to the same kind of problems: broken equality, unexpected behavior in maps or sets, and incorrect assumptions when copying or caching.\u003c/p\u003e\u003cp id=\"c170\"\u003eIn this article, weâ€™ll look at why using mutable collections in the constructor of a Kotlin data class can be just as problematic â€” and how to avoid these hidden issues.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bf36\"\u003eUsing data classes as map keys\u003c/h2\u003e\u003cp id=\"e8c2\"\u003eIn most real-world code, keys in a \u003ccode\u003eMap\u003c/code\u003e are simple types like \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e, or \u003ccode\u003eUUID\u003c/code\u003e.\u003cbr/\u003eTheyâ€™re easy to compare, have stable hash codes, and behave predictably.\u003c/p\u003e\u003cp id=\"79fe\"\u003eBut Kotlin (and Java) doesnâ€™t restrict what you can use as a key â€” any object with proper \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e can be used.\u003c/p\u003e\u003cp id=\"d9bd\"\u003eFor example, a data class instance:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f6e2\"\u003edata class User(val id: String, val name: String)\u003cp\u003eval premiumUser = User(\u0026#34;42\u0026#34;, \u0026#34;Mike\u0026#34;)\u003cbr/\u003eval regularUser1 = User(\u0026#34;17\u0026#34;, \u0026#34;Alice\u0026#34;)\u003cbr/\u003eval regularUser2 = User(\u0026#34;23\u0026#34;, \u0026#34;Bob\u0026#34;)\u003c/p\u003e\u003cp\u003eval userMap = hashMapOf(\u003cbr/\u003e    premiumUser to \u0026#34;Premium user\u0026#34;,\u003cbr/\u003e    regularUser1 to \u0026#34;Free tier\u0026#34;,\u003cbr/\u003e    regularUser2 to \u0026#34;Free tier\u0026#34;\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003eprintln(userMap[premiumUser])\u003cbr/\u003eprintln(userMap[regularUser1])\u003cbr/\u003eprintln(userMap[regularUser2])\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b009\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e1c7\"\u003ePremium user\u003cbr/\u003eFree tier\u003cbr/\u003eFree tier\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a51d\"\u003eThanks to auto-generated \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e, this works out of the box.\u003c/p\u003e\u003cp id=\"87f3\"\u003eIâ€™m not suggesting you should use data classes as map keys everywhere â€” in most cases, primitives are a better choice.\u003cbr/\u003eBut itâ€™s important to understand how equality works, and what can go wrong when the objectâ€™s internal state changes â€” even if all properties are marked \u003ccode\u003eval\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5bcb\"\u003eMutable collections break equality\u003c/h2\u003e\u003cp id=\"db47\"\u003eIn the previous example, we saw how a data class can be used as a map key â€” and everything works as expected, as long as the object stays the same.\u003c/p\u003e\u003cp id=\"61d4\"\u003eNow letâ€™s look at a less obvious case:\u003cbr/\u003ewhen the constructor contains a \u003ccode\u003eval\u003c/code\u003e that points to a mutable collection, like \u003ccode\u003eMutableList\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"16fa\"\u003edata class Cart(val items: MutableList\u0026lt;String\u0026gt;)\u003cp\u003eval cart1 = Cart(mutableListOf(\u0026#34;Milk\u0026#34;, \u0026#34;Bread\u0026#34;))\u003cbr/\u003eval cart2 = Cart(mutableListOf(\u0026#34;Cheese\u0026#34;, \u0026#34;Wine\u0026#34;))\u003c/p\u003e\u003cp\u003eval cartMap = hashMapOf(\u003cbr/\u003e    cart1 to \u0026#34;Weekly groceries\u0026#34;,\u003cbr/\u003e    cart2 to \u0026#34;Dinner items\u0026#34;\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003e// Before mutation\u003cbr/\u003eprintln(cartMap[cart1])\u003cbr/\u003eprintln(cartMap[cart2])\u003c/p\u003e\u003cp\u003e// Mutate one cart\u003cbr/\u003ecart1.items.add(\u0026#34;Eggs\u0026#34;)\u003c/p\u003e\u003cp\u003e// After mutation\u003cbr/\u003eprintln(cartMap[cart1])\u003cbr/\u003eprintln(cartMap[cart2])\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f1e9\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0fbb\"\u003eWeekly groceries\u003cbr/\u003eDinner items\u003cbr/\u003enull\u003cbr/\u003eDinner items\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5e9b\"\u003eThis happens because \u003ccode\u003eMutableList\u003c/code\u003e is included in the auto-generated \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e implementations.\u003c/p\u003e\u003cp id=\"abed\"\u003eOnce we modify the list, the hash code changes â€” and the map can no longer find the original key.\u003c/p\u003e\u003cp id=\"9645\"\u003eItâ€™s not obvious at first, because everything works until a mutation happens.\u003cbr/\u003eBut this makes the code fragile: we shouldnâ€™t allow internal state changes to affect how objects behave in collections.\u003c/p\u003e\u003cp id=\"8090\"\u003eEven if the property is declared as \u003ccode\u003eval\u003c/code\u003e, using a mutable structure creates a hidden risk.\u003cbr/\u003eThat risk grows in code that relies on hash-based structures like \u003ccode\u003eMap\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, or caching layers.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"019f\"\u003eWhat to use instead\u003c/h2\u003e\u003cp id=\"1e7b\"\u003eWhen working with \u003ccode\u003eMap\u003c/code\u003e or \u003ccode\u003eSet\u003c/code\u003e, itâ€™s safest to use primitives like \u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e, or \u003ccode\u003eUUID\u003c/code\u003e as keys.\u003c/p\u003e\u003cp id=\"cd6f\"\u003eIf you decide to use a data class as a key, make sure that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3cfb\"\u003eAll constructor properties are declared as \u003ccode\u003eval\u003c/code\u003e\u003c/li\u003e\u003cli id=\"cec7\"\u003eThese properties are \u003cstrong\u003etruly immutable\u003c/strong\u003e â€” not just by reference, but also by behavior\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7e2b\"\u003eThat means avoiding \u003ccode\u003eMutableList\u003c/code\u003e, \u003ccode\u003eMutableMap\u003c/code\u003e, or other mutable types in the constructor.\u003c/p\u003e\u003cp id=\"bac1\"\u003eThis helps ensure that the auto-generated \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e remain stable, even if the object is reused across different parts of the app.\u003c/p\u003e\u003cp id=\"13c8\"\u003eItâ€™s also a solid design rule in general:\u003cbr/\u003e\u003cstrong\u003econstructor properties in a data class should not contain mutable state\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"8947\"\u003eThis makes the class easier to reason about, and safer to use in collections, cache layers, or UI state comparisons.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e770\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"f9ed\"\u003eUsing \u003ccode\u003eval\u003c/code\u003e in a data class constructor doesnâ€™t guarantee immutability â€”\u003cbr/\u003enot if the value itself is mutable.\u003c/p\u003e\u003cp id=\"c14f\"\u003eCollections like \u003ccode\u003eMutableList\u003c/code\u003e or \u003ccode\u003eMutableMap\u003c/code\u003e can still be modified after the object is created.\u003cbr/\u003eIf those values are part of \u003ccode\u003eequals()\u003c/code\u003e or \u003ccode\u003ehashCode()\u003c/code\u003e, this can break map lookups, set behavior, and other collection logic.\u003c/p\u003e\u003cp id=\"6739\"\u003eTo keep data classes predictable, avoid placing mutable state in the constructor â€” even if itâ€™s wrapped in a \u003ccode\u003eval\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"8978\"\u003eThis reduces the risk of subtle bugs and makes your models safer to use in real-world scenarios like caching, state diffing, or hash-based collections.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"2e8f\"\u003eIf you learned something new or found this breakdown useful, feel free to leave a clap â€” it helps others discover the article.\u003cbr/\u003eYou can also follow me on Medium for more posts about Kotlin, Android development, and practical engineering topics.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d234\"\u003e\u003cstrong\u003eAnatolii Frolov\u003c/strong\u003e\u003cbr/\u003eSenior Android Developer\u003cbr/\u003eWriting honest, real-world Kotlin \u0026amp; Jetpack Compose insights.\u003cbr/\u003eðŸ“¬ \u003ca href=\"https://medium.com/@af2905g\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-06-22T17:51:20.581Z",
  "modifiedTime": null
}
