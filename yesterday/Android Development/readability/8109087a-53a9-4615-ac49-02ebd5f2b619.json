{
  "id": "8109087a-53a9-4615-ac49-02ebd5f2b619",
  "title": "Creating a responsive dashboard layout for JetLagged with Jetpack Compose",
  "link": "http://android-developers.googleblog.com/2024/10/creating-responsive-dashboard-layout-for-jetlagged-jetpack-compose.html",
  "description": "",
  "author": "Android Developers",
  "published": "2024-10-15T09:00:00.001-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "adaptive layouts",
    "adaptive UI",
    "How-To Guide",
    "Jetpack Compose",
    "tutorial"
  ],
  "byline": "",
  "length": 12571,
  "excerpt": "Use Flow layouts, WindowSizeClasses, movableContentOf, and LookaheadScope to achieve a fluid and adaptable UI that adjusts to different screen sizes.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Rebecca Franks - Developer Relations Engineer This blog post is part of our series: Adaptive Spotlight Week where we provide resources—blog posts, videos, sample code, and more—all designed to help you adapt your apps to phones, foldables, tablets, ChromeOS and even cars. You can read more in the overview of the Adaptive Spotlight Week, which will be updated throughout the week. We’ve heard the news, creating adaptive layouts in Jetpack Compose is easier than ever. As a declarative UI toolkit, Jetpack Compose is well suited for designing and implementing layouts that adjust themselves to render content differently across a variety of sizes. By using logic coupled with Window Size Classes, Flow layouts, movableContentOf and LookaheadScope, we can ensure fluid responsive layouts in Jetpack Compose. Following the release of the JetLagged sample at Google I/O 2023, we decided to add more examples to it. Specifically, we wanted to demonstrate how Compose can be used to create a beautiful dashboard-like layout. This article shows how we’ve achieved this. Responsive design in Jetlagged where items animate positions automatically Use FlowRow and FlowColumn to build layouts that respond to different screen sizes Using Flow layouts ( FlowRow and FlowColumn ) make it much easier to implement responsive, reflowing layouts that respond to screen sizes and automatically flow content to a new line when the available space in a row or column is full. In the JetLagged example, we use a FlowRow, with a maxItemsInEachRow set to 3. This ensures we maximize the space available for the dashboard, and place each individual card in a row or column where space is used wisely, and on mobile devices, we mostly have 1 card per row, only if the items are smaller are there two visible per row. Some cards leverage Modifiers that don’t specify an exact size, therefore allowing the cards to grow to fill the available width, for instance using Modifier.widthIn(max = 400.dp), or set a certain size, like Modifier.width(200.dp). FlowRow( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center, verticalArrangement = Arrangement.Center, maxItemsInEachRow = 3 ) { Box(modifier = Modifier.widthIn(max = 400.dp)) Box(modifier = Modifier.width(200.dp)) Box(modifier = Modifier.size(200.dp)) // etc } We could also leverage the weight modifier to divide up the remaining area of a row or column, check out the documentation on item weights for more information. Use WindowSizeClasses to differentiate between devices WindowSizeClasses are useful for building up breakpoints in our UI for when elements should display differently. In JetLagged, we use the classes to know whether we should include cards in Columns or keep them flowing one after the other. For example, if WindowWidthSizeClass.COMPACT, we keep items in the same FlowRow, where as if the layout it larger than compact, they are placed in a FlowColumn, nested inside a FlowRow: FlowRow( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center, verticalArrangement = Arrangement.Center, maxItemsInEachRow = 3 ) { JetLaggedSleepGraphCard(uiState.value.sleepGraphData) if (windowSizeClass == WindowWidthSizeClass.COMPACT) { AverageTimeInBedCard() AverageTimeAsleepCard() } else { FlowColumn { AverageTimeInBedCard() AverageTimeAsleepCard() } } if (windowSizeClass == WindowWidthSizeClass.COMPACT) { WellnessCard(uiState.value.wellnessData) HeartRateCard(uiState.value.heartRateData) } else { FlowColumn { WellnessCard(uiState.value.wellnessData) HeartRateCard(uiState.value.heartRateData) } } } From the above logic, the UI will appear in the following ways on different device sizes: Different UI on different sized devices Use movableContentOf to maintain bits of UI state across screen resizes Movable content allows you to save the contents of a Composable to move it around your layout hierarchy without losing state. It should be used for content that is perceived to be the same - just in a different location on screen. Imagine this, you are moving house to a different city, and you pack a box with a clock inside of it. Opening the box in the new home, you’d see that the time would still be ticking from where it left off. It might not be the correct time of your new timezone, but it will definitely have ticked on from where you left it. The contents inside the box don’t reset their internal state when the box is moved around. What if you could use the same concept in Compose to move items on screen without losing their internal state? Take the following scenario into account: Define different Tile composables that display an infinitely animating value between 0 and 100 over 5000ms. @Composable fun Tile1() { val repeatingAnimation = rememberInfiniteTransition() val float = repeatingAnimation.animateFloat( initialValue = 0f, targetValue = 100f, animationSpec = infiniteRepeatable(repeatMode = RepeatMode.Reverse, animation = tween(5000)) ) Box(modifier = Modifier .size(100.dp) .background(purple, RoundedCornerShape(8.dp))){ Text(\"Tile 1 ${float.value.roundToInt()}\", modifier = Modifier.align(Alignment.Center)) } } We then display them on screen using a Column Layout - showing the infinite animations as they go: But what If we wanted to lay the tiles differently, based on if the phone is in a different orientation (or different screen size), and we don’t want the animation values to stop running? Something like the following: @Composable fun WithoutMovableContentDemo() { val mode = remember { mutableStateOf(Mode.Portrait) } if (mode.value == Mode.Landscape) { Row { Tile1() Tile2() } } else { Column { Tile1() Tile2() } } } This looks pretty standard, but running this on device - we can see that switching between the two layouts causes our animations to restart. This is the perfect case for movable content - it is the same Composables on screen, they are just in a different location. So how do we use it? We can just define our tiles in a movableContentOf block, using remember to ensure its saved across compositions: val tiles = remember { movableContentOf { Tile1() Tile2() } } Now instead of calling our composables again inside the Column and Row respectively, we call tiles() instead. @Composable fun MovableContentDemo() { val mode = remember { mutableStateOf(Mode.Portrait) } val tiles = remember { movableContentOf { Tile1() Tile2() } } Box(modifier = Modifier.fillMaxSize()) { if (mode.value == Mode.Landscape) { Row { tiles() } } else { Column { tiles() } } Button(onClick = { if (mode.value == Mode.Portrait) { mode.value = Mode.Landscape } else { mode.value = Mode.Portrait } }, modifier = Modifier.align(Alignment.BottomCenter)) { Text(\"Change layout\") } } } This will then remember the nodes generated by those Composables and preserve the internal state that these composables currently have. We can now see that our animation state is remembered across the different compositions. Our clock in the box will now keep state when it's moved around the world. Using this concept, we can keep the animating bubble state of our cards, by placing the cards in movableContentOf: Language val timeSleepSummaryCards = remember { movableContentOf { AverageTimeInBedCard() AverageTimeAsleepCard() } } LookaheadScope { FlowRow( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center, verticalArrangement = Arrangement.Center, maxItemsInEachRow = 3 ) { //.. if (windowSizeClass == WindowWidthSizeClass.Compact) { timeSleepSummaryCards() } else { FlowColumn { timeSleepSummaryCards() } } // } } This allows the cards state to be remembered and the cards won't be recomposed. This is evident when observing the bubbles in the background of the cards, on resizing the screen the bubble animation continues without restarting the animation. Use Modifier.animateBounds() to have fluid animations between different window sizes From the above example, we can see that state is maintained between changes in layout size (or layout itself), but the difference between the two layouts is a bit jarring. We’d like this to animate between the two states without issue. In the latest compose-bom-alpha (2024.09.03), there is a new experimental custom Modifier, Modifier.animateBounds(). The animateBounds modifier requires a LookaheadScope. LookaheadScope enables Compose to perform intermediate measurement passes of layout changes, notifying composables of the intermediate states between them. LookaheadScope is also used for the new shared element APIs, that you may have seen recently. To use Modifier.animateBounds(), we wrap the top-level FlowRow in a LookaheadScope, and then apply the animateBounds modifier to each card. We can also customize how the animation runs, by specifying the boundsTransform parameter to a custom spring spec: val boundsTransform = { _ : Rect, _: Rect -\u003e spring( dampingRatio = Spring.DampingRatioNoBouncy, stiffness = Spring.StiffnessMedium, visibilityThreshold = Rect.VisibilityThreshold ) } LookaheadScope { val animateBoundsModifier = Modifier.animateBounds( lookaheadScope = this@LookaheadScope, boundsTransform = boundsTransform) val timeSleepSummaryCards = remember { movableContentOf { AverageTimeInBedCard(animateBoundsModifier) AverageTimeAsleepCard(animateBoundsModifier) } } FlowRow( modifier = Modifier .fillMaxSize() .windowInsetsPadding(insets), horizontalArrangement = Arrangement.Center, verticalArrangement = Arrangement.Center, maxItemsInEachRow = 3 ) { JetLaggedSleepGraphCard(uiState.value.sleepGraphData, animateBoundsModifier.widthIn(max = 600.dp)) if (windowSizeClass == WindowWidthSizeClass.Compact) { timeSleepSummaryCards() } else { FlowColumn { timeSleepSummaryCards() } } FlowColumn { WellnessCard( wellnessData = uiState.value.wellnessData, modifier = animateBoundsModifier .widthIn(max = 400.dp) .heightIn(min = 200.dp) ) HeartRateCard( modifier = animateBoundsModifier .widthIn(max = 400.dp, min = 200.dp), uiState.value.heartRateData ) } } } Applying this to our layout, we can see the transition between the two states is more seamless without jarring interruptions. Applying this logic to our whole dashboard, when resizing our layout, you will see that we now have a fluid UI interaction throughout the whole screen. Summary As you can see from this article, using Compose has enabled us to build a responsive dashboard-like layout by leveraging flow layouts, WindowSizeClasses, movable content and LookaheadScope. These concepts can also be used for your own layouts that may have items moving around in them too. For more information on these different topics, be sure to check out the official documentation, for the detailed changes to JetLagged, take a look at this pull request.",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvmObDTm_UvKKZP8bDM_YVpknfPh2MBo1pZun6Vc_0CTOsoxvFAq0O_tIa33owHNckOXqKEGGf35C7PccmUFU9gA9VX7djih13zWISVNwdqAHY7waJ7tcWoZJUSuCwSnrLCmhQzNCr21e61IJ_8PLUzj6eKApPrxmK-cwMHrYp-iCbQ6XPyiLxIKvRZPU/w1200-h630-p-k-no-nu/Jetpack%20Adaptive%20Compose%20Metadata.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvmObDTm_UvKKZP8bDM_YVpknfPh2MBo1pZun6Vc_0CTOsoxvFAq0O_tIa33owHNckOXqKEGGf35C7PccmUFU9gA9VX7djih13zWISVNwdqAHY7waJ7tcWoZJUSuCwSnrLCmhQzNCr21e61IJ_8PLUzj6eKApPrxmK-cwMHrYp-iCbQ6XPyiLxIKvRZPU/s1600/Jetpack%20Adaptive%20Compose%20Metadata.png\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by  Rebecca Franks - Developer Relations Engineer\u003c/em\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiq-xjyTG_ks5AfowEaHg8NFwpTVt0EqH59N_7RExbYOHp8WESDEmFbRFPB7kc3_tP0B7XGARTbDvX6woNwZgRtwX2xH8xJI0uq4w7T3b2JFOjzB3qfU6EZC-MpYSZ537orOmLoI5VY69Fc-h9XMiJ3MRe7rk66yTMcEdDxSWlrOY71cQ04-kxG-kFalms/s1600/Jetpack%20Adaptive%20Compose%20%281%29.png\"\u003e\u003cimg data-original-height=\"800\" data-original-width=\"100%\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiq-xjyTG_ks5AfowEaHg8NFwpTVt0EqH59N_7RExbYOHp8WESDEmFbRFPB7kc3_tP0B7XGARTbDvX6woNwZgRtwX2xH8xJI0uq4w7T3b2JFOjzB3qfU6EZC-MpYSZ537orOmLoI5VY69Fc-h9XMiJ3MRe7rk66yTMcEdDxSWlrOY71cQ04-kxG-kFalms/s1600/Jetpack%20Adaptive%20Compose%20%281%29.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ci\u003eThis blog post is part of our series: Adaptive Spotlight Week where we provide resources—blog posts, videos, sample code, and more—all designed to help you adapt your apps to phones, foldables, tablets, ChromeOS and even cars. You can \u003ca href=\"https://android-developers.googleblog.com/2024/10/adaptive-spotlight-week.html\" target=\"_blank\"\u003eread more in the overview of the Adaptive Spotlight Week\u003c/a\u003e, which will be updated throughout the week.\u003c/i\u003e\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003eWe’ve heard the news, \u003ca href=\"https://developer.android.com/jetpack/compose/layouts/adaptive\" target=\"_blank\"\u003ecreating adaptive layouts\u003c/a\u003e in Jetpack Compose is easier than ever. As a declarative UI toolkit, Jetpack Compose is well suited for designing and implementing layouts that adjust themselves to render content differently across a variety of sizes. By using logic coupled with \u003ca href=\"https://developer.android.com/guide/topics/large-screens/support-different-screen-sizes#window_size_classes\" target=\"_blank\"\u003eWindow Size Classes\u003c/a\u003e, \u003ca href=\"https://developer.android.com/jetpack/compose/layouts/flow\" target=\"_blank\"\u003eFlow layouts\u003c/a\u003e, \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#movableContentOf%28kotlin.Function4%29\" target=\"_blank\"\u003emovableContentOf\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/LookaheadScope\" target=\"_blank\"\u003eLookaheadScope\u003c/a\u003e, we can ensure fluid responsive layouts in Jetpack Compose.\u003c/p\u003e\n\n\u003cp\u003eFollowing the release of the \u003ca href=\"https://github.com/android/compose-samples/tree/main/JetLagged\" target=\"_blank\"\u003eJetLagged\u003c/a\u003e sample at Google I/O 2023, we decided to add more examples to it. Specifically, we wanted to demonstrate how Compose can be used to create a beautiful dashboard-like layout. This article shows how we’ve achieved this.\u003c/p\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgeCcBP6eF2jTchTqeULZJXeCaCvA92M-cvj-8FQwEQxKD0DffQSDByWWdZ_ZfrG-2zhTakNjvLfye_DmwmwEEO7qK_-pZ-Wb4IZqRBFQoiU6f92hSUd_kqJHbIwRFhtgB3IsBalN-XN0PH1TQmQhATewShhu-URaUpKHoT5HJwdXVAacRY-KdxhSW5F0/s1600/overall_interaction_flow_jetlagged.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"Moving image demonstrating responsive design in Jetlagged where items animate positions automatically\" height=\"360\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgeCcBP6eF2jTchTqeULZJXeCaCvA92M-cvj-8FQwEQxKD0DffQSDByWWdZ_ZfrG-2zhTakNjvLfye_DmwmwEEO7qK_-pZ-Wb4IZqRBFQoiU6f92hSUd_kqJHbIwRFhtgB3IsBalN-XN0PH1TQmQhATewShhu-URaUpKHoT5HJwdXVAacRY-KdxhSW5F0/s1600/overall_interaction_flow_jetlagged.gif\" width=\"100%\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eResponsive design in Jetlagged where items animate positions automatically\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\u003cbr/\u003e\n\n\n\u003ch3\u003eUse FlowRow and FlowColumn to build layouts that respond to different screen sizes\u003c/h3\u003e\n\n\u003cp\u003eUsing \u003ca href=\"https://developer.android.com/jetpack/compose/layouts/flow\" target=\"_blank\"\u003eFlow layouts\u003c/a\u003e ( \u003cspan\u003eFlowRow\u003c/span\u003e and \u003cspan\u003eFlowColumn\u003c/span\u003e ) make it much easier to implement responsive, reflowing layouts that respond to screen sizes and automatically flow content to a new line when the available space in a row or column is full.\u003c/p\u003e\n\n\u003cp\u003eIn the JetLagged example, we use a \u003cspan\u003eFlowRow\u003c/span\u003e, with a \u003cspan\u003emaxItemsInEachRow\u003c/span\u003e set to 3. This ensures we maximize the space available for the dashboard, and place each individual card in a row or column where space is used wisely, and on mobile devices, we mostly have 1 card per row, only if the items are smaller are there two visible per row.\u003c/p\u003e \n\n\u003cp\u003eSome cards leverage Modifiers that don’t specify an exact size, therefore allowing the cards to grow to fill the available width, for instance using \u003cspan\u003eModifier.widthIn(max = 400.dp)\u003c/span\u003e, or set a certain size, like \u003cspan\u003eModifier.width(200.dp)\u003c/span\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003eFlowRow(\n    modifier = Modifier.fillMaxSize(),\n    horizontalArrangement = Arrangement.Center,\n    verticalArrangement = Arrangement.Center,\n    maxItemsInEachRow = \u003cspan\u003e3\u003c/span\u003e\n) {\n    Box(modifier = Modifier.widthIn(max = \u003cspan\u003e400.d\u003c/span\u003ep))\n    Box(modifier = Modifier.width(\u003cspan\u003e200.d\u003c/span\u003ep))\n    Box(modifier = Modifier.size(\u003cspan\u003e200.d\u003c/span\u003ep))\n    \u003cspan\u003e// etc \u003c/span\u003e\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe could also leverage the weight modifier to divide up the remaining area of a row or column, check out the documentation on \u003ca href=\"https://developer.android.com/jetpack/compose/layouts/flow#item-weights\" target=\"_blank\"\u003eitem weights\u003c/a\u003e for more information.\u003c/p\u003e\u003cbr/\u003e\n\n\u003ch3\u003eUse WindowSizeClasses to differentiate between devices\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://developer.android.com/guide/topics/large-screens/support-different-screen-sizes#window_size_classes\" target=\"_blank\"\u003eWindowSizeClasses\u003c/a\u003e are useful for building up breakpoints in our UI for when elements should display differently. In JetLagged, we use the classes to know whether we should include cards in Columns or keep them flowing one after the other.\u003c/p\u003e \n\n\u003cp\u003eFor example, if \u003cspan\u003eWindowWidthSizeClass.COMPACT\u003c/span\u003e, we keep items in the same \u003cspan\u003eFlowRow\u003c/span\u003e, where as if the layout it larger than compact, they are placed in a \u003cspan\u003eFlowColumn\u003c/span\u003e, nested inside a \u003cspan\u003eFlowRow\u003c/span\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e            FlowRow(\n                modifier = Modifier.fillMaxSize(),\n                horizontalArrangement = Arrangement.Center,\n                verticalArrangement = Arrangement.Center,\n                maxItemsInEachRow = \u003cspan\u003e3\u003c/span\u003e\n            ) {\n                JetLaggedSleepGraphCard(uiState.value.sleepGraphData)\n                \u003cspan\u003eif\u003c/span\u003e (windowSizeClass == WindowWidthSizeClass.COMPACT) {\n                    AverageTimeInBedCard()\n                    AverageTimeAsleepCard()\n                } \u003cspan\u003eelse\u003c/span\u003e {\n                    FlowColumn {\n                        AverageTimeInBedCard()\n                        AverageTimeAsleepCard()\n                    }\n                }\n                \u003cspan\u003eif\u003c/span\u003e (windowSizeClass == WindowWidthSizeClass.COMPACT) {\n                    WellnessCard(uiState.value.wellnessData)\n                    HeartRateCard(uiState.value.heartRateData)\n                } \u003cspan\u003eelse\u003c/span\u003e {\n                    FlowColumn {\n                        WellnessCard(uiState.value.wellnessData)\n                        HeartRateCard(uiState.value.heartRateData)\n                    }\n                }\n            }\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFrom the above logic, the UI will appear in the following ways on different device sizes:\u003c/p\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJDm1eVXzW0-0LgAnurf0aP2nw0JDs1n-QFQzU-MJVKACvRrRNCAi5WOwtcjk8kyyDH9QE4QmyVVTQxOOQug81Ax8sSdNl0jwqaDcU8h4-Ndvckc63tqj2d0L0O2azk4kTVQutYfkOj6HbTvgclw08XL1X_uvILNjZjjvfwfHpqnePe1sWt59SBLHfY3s/s1600/all_screens.png\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"Side by side comparisons of the differeces in UI on three different sized devices\" height=\"186\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJDm1eVXzW0-0LgAnurf0aP2nw0JDs1n-QFQzU-MJVKACvRrRNCAi5WOwtcjk8kyyDH9QE4QmyVVTQxOOQug81Ax8sSdNl0jwqaDcU8h4-Ndvckc63tqj2d0L0O2azk4kTVQutYfkOj6HbTvgclw08XL1X_uvILNjZjjvfwfHpqnePe1sWt59SBLHfY3s/s1600/all_screens.png\" width=\"100%\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eDifferent UI on different sized devices\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\u003cbr/\u003e\n\n\u003ch3\u003eUse movableContentOf to maintain bits of UI state across screen resizes\u003c/h3\u003e\n\n\u003cp\u003eMovable content allows you to save the contents of a Composable to move it around your layout hierarchy without losing state. It should be used for content that is perceived to be the same - just in a different location on screen.\u003c/p\u003e\n\n\u003cp\u003eImagine this, you are moving house to a different city, and you pack a box with a clock inside of it. Opening the box in the new home, you’d see that the time would still be ticking from where it left off. It might not be the correct time of your new timezone, but it will definitely have ticked on from where you left it. The contents inside the box don’t reset their internal state when the box is moved around.\u003c/p\u003e \n\n\u003cp\u003eWhat if you could use the same concept in Compose to move items on screen without losing their internal state?\u003c/p\u003e\n\n\u003cp\u003eTake the following scenario into account: Define different \u003cspan\u003eTile\u003c/span\u003e composables that display an infinitely animating value between 0 and 100 over 5000ms.\u003c/p\u003e\u003cbr/\u003e\n\n\u003cdiv\u003e\u003cpre\u003e@Composable\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eTile1\u003c/span\u003e() {\n    \u003cspan\u003eval\u003c/span\u003e repeatingAnimation = rememberInfiniteTransition()\n\n    \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003efloat\u003c/span\u003e = repeatingAnimation.animateFloat(\n        initialValue = \u003cspan\u003e0f\u003c/span\u003e,\n        targetValue = \u003cspan\u003e100f\u003c/span\u003e,\n        animationSpec = infiniteRepeatable(repeatMode = RepeatMode.Reverse,\n            animation = tween(\u003cspan\u003e5000\u003c/span\u003e))\n    )\n    Box(modifier = Modifier\n        .size(\u003cspan\u003e100.d\u003c/span\u003ep)\n        .background(purple, RoundedCornerShape(\u003cspan\u003e8.d\u003c/span\u003ep))){\n        Text(\u003cspan\u003e\u0026#34;Tile 1 ${float.value.roundToInt()}\u0026#34;\u003c/span\u003e,\n            modifier = Modifier.align(Alignment.Center))\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe then display them on screen using a Column Layout - showing the infinite animations as they go:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"A purple tile stacked in a column above a pink tile. Both tiles show a counter, counting up from 0 to 100 and back down to 0\" height=\"359\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhuE6wj7uJqjKHASh_Hcqr-GkFYJDNbSgJUaVvTvfJ_9_9eT-wpmhKDSmfyWK4Q57HGNvqBEgBxYiH0LlhCvfn90kcdsjZnp62IzU9U34aPoEK4nZuVb4SqvYgQxgdOTCVI2fZrz_jj_t5Bwc_XhMo7Tn6A89BeG7ho_Zw0D77ofINhoh7eIIlpGt1H9s0/w640-h359/image2.gif\" width=\"640\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBut what If we wanted to lay the tiles differently, based on if the phone is in a different orientation (or different screen size), and we don’t want the animation values to stop running? Something like the following:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e@Composable\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eWithoutMovableContentDemo\u003c/span\u003e() {\n    \u003cspan\u003eval\u003c/span\u003e mode = remember {\n        mutableStateOf(Mode.Portrait)\n    }\n    \u003cspan\u003eif\u003c/span\u003e (mode.value == Mode.Landscape) {\n        Row {\n           Tile1()\n           Tile2()\n        }\n    } \u003cspan\u003eelse\u003c/span\u003e {\n        Column {\n           Tile1()\n           Tile2()\n        }\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis looks pretty standard, but running this on device - we can see that switching between the two layouts causes our animations to restart.\u003c/p\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisOot3wdj0XzrKJUex2AtwlPUKEDPzbnoJoCTX6JH02mIoOFVSsYZ6HpK9M68YDmtEfvwVzp3gdW7pJcNDv2MSyJ9F_F26fMzGV2I17QiTHUcpI4vC7iGwEujnnP4KF5vtZLEHacaxgZkhQxRdMggDk0mktV5t4fr9moyJnfluiQG3bvnaWU6jCtu1kRo/w640-h359/image1.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"A purple tile stacked in a column above a pink tile. Both tiles show a counter, counting upward from 0. The column changes to a row and back to a column, and the counter restarts everytime the layout changes\" height=\"359\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisOot3wdj0XzrKJUex2AtwlPUKEDPzbnoJoCTX6JH02mIoOFVSsYZ6HpK9M68YDmtEfvwVzp3gdW7pJcNDv2MSyJ9F_F26fMzGV2I17QiTHUcpI4vC7iGwEujnnP4KF5vtZLEHacaxgZkhQxRdMggDk0mktV5t4fr9moyJnfluiQG3bvnaWU6jCtu1kRo/w640-h359/image1.gif\" width=\"640\"/\u003e\u003c/p\u003e\u003c/a\u003e\n\n\n\u003cp\u003eThis is the perfect case for movable content - it is the same Composables on screen, they are just in a different location. So how do we use it? We can just define our tiles in a \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#movableContentOf%28kotlin.Function0%29\" target=\"_blank\"\u003emovableContentOf\u003c/a\u003e\u003c/span\u003e block, using \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember%28kotlin.Any,kotlin.Any,kotlin.Any,kotlin.Function0%29\" target=\"_blank\"\u003eremember\u003c/a\u003e\u003c/span\u003e to ensure its saved across compositions:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e tiles = remember {\n        movableContentOf {\n            Tile1()\n            Tile2()\n        }\n }\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNow instead of calling our composables again inside the \u003cspan\u003eColumn\u003c/span\u003e and \u003cspan\u003eRow\u003c/span\u003e respectively, we call \u003cspan\u003etiles()\u003c/span\u003e instead.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e@Composable\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eMovableContentDemo\u003c/span\u003e() {\n    \u003cspan\u003eval\u003c/span\u003e mode = remember {\n        mutableStateOf(Mode.Portrait)\n    }\n    \u003cspan\u003eval\u003c/span\u003e tiles = remember {\n        movableContentOf {\n            Tile1()\n            Tile2()\n        }\n    }\n    Box(modifier = Modifier.fillMaxSize()) {\n        \u003cspan\u003eif\u003c/span\u003e (mode.value == Mode.Landscape) {\n            Row {\n                tiles()\n            }\n        } \u003cspan\u003eelse\u003c/span\u003e {\n            Column {\n                tiles()\n            }\n        }\n\n        Button(onClick = {\n            \u003cspan\u003eif\u003c/span\u003e (mode.value == Mode.Portrait) {\n                mode.value = Mode.Landscape\n            } \u003cspan\u003eelse\u003c/span\u003e {\n                mode.value = Mode.Portrait\n            }\n        }, modifier = Modifier.align(Alignment.BottomCenter)) {\n            Text(\u003cspan\u003e\u0026#34;Change layout\u0026#34;\u003c/span\u003e)\n        }\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis will then remember the nodes generated by those Composables and preserve the internal state that these composables currently have.\u003c/p\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhZpgt3pKBqtSV5_FnN_1gzaUeWg5_gaHooyPkNUnrOZyF07mw50rCufBU2ccXOktYEexBEARo5J6EncTfzL1d3e3O9ABFMBvJ87hDi6Su9lydkAOkjIDndhLJkeYiBkJXwbb7NucDgLktrtM73MalRL9JODkiejjdZLIuUp3qbEUCFmikmEnAptVvbufM/w640-h359/image6.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"A purple tile stacked in a column above a pink tile. Both tiles show a counter, counting upward from 0 to 100. The column changes to a row and back to a column, and the counter continues seamlessly when the layout changes\" height=\"359\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhZpgt3pKBqtSV5_FnN_1gzaUeWg5_gaHooyPkNUnrOZyF07mw50rCufBU2ccXOktYEexBEARo5J6EncTfzL1d3e3O9ABFMBvJ87hDi6Su9lydkAOkjIDndhLJkeYiBkJXwbb7NucDgLktrtM73MalRL9JODkiejjdZLIuUp3qbEUCFmikmEnAptVvbufM/w640-h359/image6.gif\" width=\"640\"/\u003e\u003c/p\u003e\u003c/a\u003e\n\n\u003cp\u003eWe can now see that our animation state is remembered across the different compositions. Our clock in the box will now keep state when it\u0026#39;s moved around the world. \u003c/p\u003e\n\n\u003cp\u003eUsing this concept, we can keep the animating bubble state of our cards, by placing the cards in \u003cspan\u003emovableContentOf\u003c/span\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cb\u003eLanguage\u003c/b\u003e\u003cbr/\u003e\n        \u003cspan\u003eval\u003c/span\u003e timeSleepSummaryCards = remember {\n            movableContentOf {\n                AverageTimeInBedCard()\n                AverageTimeAsleepCard()\n            }\n        }\n        LookaheadScope {\n            FlowRow(\n                modifier = Modifier.fillMaxSize(),\n                horizontalArrangement = Arrangement.Center,\n                verticalArrangement = Arrangement.Center,\n                maxItemsInEachRow = \u003cspan\u003e3\u003c/span\u003e\n            ) {\n                \u003cspan\u003e//..\u003c/span\u003e\n                \u003cspan\u003eif\u003c/span\u003e (windowSizeClass == WindowWidthSizeClass.Compact) {\n                    timeSleepSummaryCards()\n                } \u003cspan\u003eelse\u003c/span\u003e {\n                    FlowColumn {\n                        timeSleepSummaryCards()\n                    }\n                }\n                \u003cspan\u003e//\u003c/span\u003e\n            }\n        }\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis allows the cards state to be remembered and the cards won\u0026#39;t be recomposed. This is evident when observing the bubbles in the background of the cards, on resizing the screen the bubble animation continues without restarting the animation.\u003c/p\u003e\n\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj21BdF9kLNEN0OssHZNlm-UM41SeyBYXVyU2FZPjx-Pp6wYR9QeEciyg-K1MvST-RxqsUHOy2JI7ZzRCzlI0_C5QDqf6ZFg7gU2GcZ13rXtQbQ9yzk-ZEp23VZ_APonySSz0ggmiZh1SK24vfik3XlQyOxP_swnZZLGvsQmLqSgCe4FPv8o2K49pVGRds/w400-h400/image4.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"A purple tile showing Average time in bed stacked in a column above a green tile showing average time sleep. Both tiles show moving bubbles. The column changes to a row and back to a column, and the bubbles continue to move across the tiles as the layout changes\" height=\"400\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj21BdF9kLNEN0OssHZNlm-UM41SeyBYXVyU2FZPjx-Pp6wYR9QeEciyg-K1MvST-RxqsUHOy2JI7ZzRCzlI0_C5QDqf6ZFg7gU2GcZ13rXtQbQ9yzk-ZEp23VZ_APonySSz0ggmiZh1SK24vfik3XlQyOxP_swnZZLGvsQmLqSgCe4FPv8o2K49pVGRds/w400-h400/image4.gif\" width=\"400\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cbr/\u003e\n\n\u003ch3\u003eUse Modifier.animateBounds() to have fluid animations between different window sizes\u003c/h3\u003e\n\n\u003cp\u003eFrom the above example, we can see that state is maintained between changes in layout size (or layout itself), but the difference between the two layouts is a bit jarring. We’d like this to animate between the two states without issue.\u003c/p\u003e\n\n\u003cp\u003eIn the latest \u003ca href=\"https://developer.android.com/develop/ui/compose/bom#what_if_i_want_to_try_out_alpha_or_beta_releases_of_compose_libraries\" target=\"_blank\"\u003ecompose-bom-alpha\u003c/a\u003e (2024.09.03), there is a new experimental custom Modifier, \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#%28androidx.compose.ui.Modifier%29.animateBounds%28androidx.compose.ui.layout.LookaheadScope,androidx.compose.ui.Modifier,androidx.compose.animation.BoundsTransform,kotlin.Boolean%29\" target=\"_blank\"\u003eModifier.animateBounds()\u003c/a\u003e\u003c/span\u003e.  The \u003cspan\u003eanimateBounds\u003c/span\u003e modifier requires a \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/LookaheadScope?hl=en\" target=\"_blank\"\u003eLookaheadScope\u003c/a\u003e\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cspan\u003eLookaheadScope\u003c/span\u003e enables Compose to perform intermediate measurement passes of layout changes, notifying composables of the intermediate states between them. \u003cspan\u003eLookaheadScope\u003c/span\u003e is also used for the new \u003ca href=\"https://developer.android.com/develop/ui/compose/animation/shared-elements\" target=\"_blank\"\u003eshared element APIs\u003c/a\u003e, that you may have seen recently.\u003c/p\u003e \n\n\u003cp\u003eTo use \u003cspan\u003eModifier.animateBounds()\u003c/span\u003e, we wrap the top-level \u003cspan\u003eFlowRow\u003c/span\u003e in a \u003cspan\u003eLookaheadScope\u003c/span\u003e, and then apply the \u003cspan\u003eanimateBounds\u003c/span\u003e modifier to each card. We can also customize how the animation runs, by specifying the \u003cspan\u003eboundsTransform\u003c/span\u003e parameter to a custom spring spec:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e boundsTransform = { _ : Rect, _: Rect -\u0026gt;\n   spring(\n       dampingRatio = Spring.DampingRatioNoBouncy,\n       stiffness = Spring.StiffnessMedium,\n       visibilityThreshold = Rect.VisibilityThreshold\n   )\n}\n\n\nLookaheadScope {\n   \u003cspan\u003eval\u003c/span\u003e animateBoundsModifier = Modifier.animateBounds(\n       lookaheadScope = \u003cspan\u003ethis\u003c/span\u003e@LookaheadScope,\n       boundsTransform = boundsTransform)\n   \u003cspan\u003eval\u003c/span\u003e timeSleepSummaryCards = remember {\n       movableContentOf {\n           AverageTimeInBedCard(animateBoundsModifier)\n           AverageTimeAsleepCard(animateBoundsModifier)\n       }\n   }\n   FlowRow(\n       modifier = Modifier\n           .fillMaxSize()\n           .windowInsetsPadding(insets),\n       horizontalArrangement = Arrangement.Center,\n       verticalArrangement = Arrangement.Center,\n       maxItemsInEachRow = \u003cspan\u003e3\u003c/span\u003e\n   ) {\n       JetLaggedSleepGraphCard(uiState.value.sleepGraphData, animateBoundsModifier.widthIn(max = \u003cspan\u003e600.d\u003c/span\u003ep))\n       \u003cspan\u003eif\u003c/span\u003e (windowSizeClass == WindowWidthSizeClass.Compact) {\n           timeSleepSummaryCards()\n       } \u003cspan\u003eelse\u003c/span\u003e {\n           FlowColumn {\n               timeSleepSummaryCards()\n           }\n       }\n\n\n       FlowColumn {\n           WellnessCard(\n               wellnessData = uiState.value.wellnessData,\n               modifier = animateBoundsModifier\n                   .widthIn(max = \u003cspan\u003e400.d\u003c/span\u003ep)\n                   .heightIn(min = \u003cspan\u003e200.d\u003c/span\u003ep)\n           )\n           HeartRateCard(\n               modifier = animateBoundsModifier\n                   .widthIn(max = \u003cspan\u003e400.d\u003c/span\u003ep, min = \u003cspan\u003e200.d\u003c/span\u003ep),\n               uiState.value.heartRateData\n           )\n       }\n   }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eApplying this to our layout, we can see the transition between the two states is more seamless without jarring interruptions.\u003c/p\u003e\n\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEikUkY5b840moPDzQRUQM6aU-kAkJo-oYT3oJFwsz65JteQLblWPHx5uU9HMeZ0NioUpd-BmdKn4eoNVeoJztO7rMW7ZTvC3PmQj2ux68IDdU0KRhbgfAPdy2_yp3R6v9eje8LPhakj1Cz7rrl0LSHTX8pelOFuuv5JaTNgRFuGW5E7nPW2kw8FJBb0_kA/w400-h400/image7.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"A purple tile showing Average time in bed stacked in a column above a green tile showing average time sleep. Both tiles show moving bubbles. The column changes to a row and back to a column, and the bubbles continue to move across the tiles as the layout changes\" height=\"400\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEikUkY5b840moPDzQRUQM6aU-kAkJo-oYT3oJFwsz65JteQLblWPHx5uU9HMeZ0NioUpd-BmdKn4eoNVeoJztO7rMW7ZTvC3PmQj2ux68IDdU0KRhbgfAPdy2_yp3R6v9eje8LPhakj1Cz7rrl0LSHTX8pelOFuuv5JaTNgRFuGW5E7nPW2kw8FJBb0_kA/w400-h400/image7.gif\" width=\"400\"/\u003e\u003c/p\u003e\u003c/a\u003e\n\n\u003cp\u003eApplying this logic to our whole dashboard, when resizing our layout, you will see that we now have a fluid UI interaction throughout the whole screen.\u003c/p\u003e\n\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgeCcBP6eF2jTchTqeULZJXeCaCvA92M-cvj-8FQwEQxKD0DffQSDByWWdZ_ZfrG-2zhTakNjvLfye_DmwmwEEO7qK_-pZ-Wb4IZqRBFQoiU6f92hSUd_kqJHbIwRFhtgB3IsBalN-XN0PH1TQmQhATewShhu-URaUpKHoT5HJwdXVAacRY-KdxhSW5F0/s1600/overall_interaction_flow_jetlagged.gif\" target=\"_blank\"\u003e\u003cp\u003e\u003cimg alt=\"Moving image demonstrating responsive design in Jetlagged where items animate positions automatically\" height=\"360\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjgeCcBP6eF2jTchTqeULZJXeCaCvA92M-cvj-8FQwEQxKD0DffQSDByWWdZ_ZfrG-2zhTakNjvLfye_DmwmwEEO7qK_-pZ-Wb4IZqRBFQoiU6f92hSUd_kqJHbIwRFhtgB3IsBalN-XN0PH1TQmQhATewShhu-URaUpKHoT5HJwdXVAacRY-KdxhSW5F0/s1600/overall_interaction_flow_jetlagged.gif\" width=\"100%\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cbr/\u003e\n\n\u003ch3\u003eSummary\u003c/h3\u003e\n\n\u003cp\u003eAs you can see from this article, using Compose has enabled us to build a responsive dashboard-like layout by leveraging flow layouts, \u003cspan\u003eWindowSizeClasses\u003c/span\u003e, movable content and \u003cspan\u003eLookaheadScope\u003c/span\u003e. These concepts can also be used for your own layouts that may have items moving around in them too.\u003c/p\u003e \n\n\u003cp\u003eFor more information on these different topics, be sure to check out the \u003ca href=\"https://developer.android.com/jetpack/compose\" target=\"_blank\"\u003eofficial documentation\u003c/a\u003e, for the detailed changes to JetLagged, take a look at \u003ca href=\"https://github.com/android/compose-samples/pull/1473\" target=\"_blank\"\u003ethis pull request\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
