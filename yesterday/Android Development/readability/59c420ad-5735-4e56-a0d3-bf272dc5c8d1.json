{
  "id": "59c420ad-5735-4e56-a0d3-bf272dc5c8d1",
  "title": "SwipeTo explore different implementations in Jetpack Compose",
  "link": "https://proandroiddev.com/swipeto-explore-different-implementations-in-jetpack-compose-8c6cd59bbc3c?source=rss----c72404660798---4",
  "description": "",
  "author": "Stefano Natali",
  "published": "Mon, 11 Nov 2024 00:09:58 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "android",
    "kotlin",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Stefano Natali",
  "length": 11456,
  "excerpt": "Swipe gestures provide a natural way to interact with elements in an app, adding intuitive controls for actions like dismissing items or revealing options. Jetpack Compose makes it easy to implement…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "SwipeToDismiss and SwipeToReveal for an Interactive UISwipe gestures provide a natural way to interact with elements in an app, adding intuitive controls for actions like dismissing items or revealing options. Jetpack Compose makes it easy to implement in various ways. With recent updates of the Compose libraries, new APIs make swipe-based interactions simpler and more maintainable.In this article, we’ll explore how to implement the SwipeToDismiss and SwipeToReveal functionality and customize them for various use cases, empowering you to create dynamic, responsive UIs.Base Implementation with detectHorizontalDragGesturesThe first approach for implementing swipe-based interactions is to use detectHorizontalDragGestures, a flexible and foundational solution that allows for full customization. This method enables both SwipeToDismiss and SwipeToReveal functionalities by managing the horizontal drag manually. Below is an example of how to implement this in a composable:@Composablefun LibraryBook( onClickRead: () -\u003e Unit, onClickDelete: () -\u003e Unit) { var offsetX by remember { mutableFloatStateOf(0f) } Box( modifier .fillMaxSize() .pointerInput(Unit) { detectHorizontalDragGestures { _, dragAmount -\u003e offsetX = (offsetX + dragAmount).coerceIn(-300f, 0f) } } ) { // Actions revealed Row( modifier = Modifier .fillMaxSize() .padding(horizontal = 16.dp), horizontalArrangement = Arrangement.End, verticalAlignment = Alignment.CenterVertically ) { IconButton(onClick = onClickDelete) { Icon(Icons.Default.Delete, contentDescription = \"\") } } // Main content Box( modifier = Modifier .offset { IntOffset(offsetX.roundToInt(), 0) } ) { InternalLibraryBook() } }}In this implementation:We maintain an offsetX state to control the horizontal position of the item as it’s dragged.DetectHorizontalDragGestures handles horizontal dragging, updating offsetX within a specified range to prevent excessive movement.The main content is shifted based on offsetX, revealing the delete action as you swipe.This approach is straightforward, but it provides the flexibility to expand and customize as needed. If you want to dive deeper into this solution, Philipp Lackner’s video provides an excellent walkthrough. Philipp shares various Compose techniques in his videos, so consider following him for more useful tips and tutorials.Implementation with SwipeToDismissBoxWith recent updates to the Compose libraries, we now have the SwipeToDismissBox, which provides a more structured and controllable approach to swipe-based interactions. This component simplifies the process of implementing dismiss gestures and offers better control over the swipe state. Here’s how it enhances the previous implementation:@Composablefun LibraryBook2( modifier: Modifier = Modifier, onClickRead: () -\u003e Unit, onClickDelete: () -\u003e Unit) { val dismissState = rememberSwipeToDismissBoxState(confirmValueChange = { when (it) { SwipeToDismissBoxValue.EndToStart -\u003e { onClickDelete() true } SwipeToDismissBoxValue.StartToEnd -\u003e { onClickRead() true } else -\u003e false } }) SwipeToDismissBox( modifier = modifier, state = dismissState, backgroundContent = { Row( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically ) { // Read action on swipe from start to end AnimatedVisibility( visible = dismissState.targetValue == SwipeToDismissBoxValue.StartToEnd, enter = fadeIn() ) { Icon( imageVector = Icons.AutoMirrored.Outlined.MenuBook, contentDescription = \"Read\" ) } Spacer(modifier = Modifier.weight(1f)) // Delete action on swipe from end to start AnimatedVisibility( visible = dismissState.targetValue == SwipeToDismissBoxValue.EndToStart, enter = fadeIn() ) { Icon( imageVector = Icons.Default.Delete, contentDescription = \"Delete\" ) } } } ) { InternalLibraryBook() }}In this updated example:SwipeToDismissBox manages the swipe state internally, which simplifies the swipe handling compared to the detectHorizontalDragGestures approach.The backgroundContent is displayed conditionally based on the swipe direction, using in my case, AnimatedVisibility to smoothly show icons for delete and read actions.Resetting the Swipe PositionTo reset the swipe position after an action is taken, you can leverage LaunchedEffect to monitor dismissState.currentValue and trigger a reset when a swipe is completed:val dismissState = rememberSwipeToDismissBoxState()LaunchedEffect(dismissState.currentValue) { when (dismissState.currentValue) { SwipeToDismissBoxValue.EndToStart -\u003e { onClickDelete() dismissState.reset() } SwipeToDismissBoxValue.StartToEnd -\u003e { onClickRead() dismissState.reset() } else -\u003e { /* No action needed */ } }}Implementing SwipeToReveal with anchoredDraggableThe SwipeToDismissBox works well for swipe to dismiss interactions, but if we want to implement SwipeToReveal (where swiping reveals options rather than dismissing the item) we need a different approach. I found a powerful alternative with the anchoredDraggable API, as it allows us to define anchor points where specific actions can be triggered, making it ideal for reveal-based interactions.Here’s the example of implementing SwipeToReveal with anchoredDraggable:enum class SwipeToRevealValue { Read, Resting, Delete }@OptIn(ExperimentalFoundationApi::class)@Composablefun LibraryBook3( onClickRead: () -\u003e Unit, onClickDelete: () -\u003e Unit) { val density = LocalDensity.current val decayAnimationSpec = rememberSplineBasedDecay\u003cFloat\u003e() val dragState = remember { val actionOffset = with(density) { 100.dp.toPx() } AnchoredDraggableState( initialValue = SwipeToRevealValue.Resting, anchors = DraggableAnchors { SwipeToRevealValue.Read at -actionOffset SwipeToRevealValue.Resting at 0f SwipeToRevealValue.Delete at actionOffset }, positionalThreshold = { distance -\u003e distance * 0.5f }, velocityThreshold = { with(density) { 100.dp.toPx() } }, snapAnimationSpec = tween(), decayAnimationSpec = decayAnimationSpec, ) } val overScrollEffect = ScrollableDefaults.overscrollEffect() Box( modifier = Modifier.fillMaxSize() ) { // Main content that moves with the swipe Box( modifier = Modifier .anchoredDraggable( dragState, Orientation.Horizontal, overscrollEffect = overScrollEffect ) .overscroll(overScrollEffect) .offset { IntOffset( x = dragState.requireOffset().roundToInt(), y = 0 ) } ) { InternalLibraryBook() } // actions for \"Read\" and \"Delete\" Row( modifier = Modifier.matchParentSize(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically ) { // Read Action AnimatedVisibility( visible = dragState.currentValue == SwipeToRevealValue.Read, enter = slideInHorizontally(animationSpec = tween()) { it }, exit = slideOutHorizontally(animationSpec = tween()) { it } ) { IconButton(onClick = onClickRead) { Icon( imageVector = Icons.AutoMirrored.Outlined.MenuBook, contentDescription = \"Read\" ) } } Spacer(modifier = Modifier.weight(1f)) // Delete Action AnimatedVisibility( visible = dragState.currentValue == SwipeToRevealValue.Delete, enter = slideInHorizontally(animationSpec = tween()) { -it }, exit = slideOutHorizontally(animationSpec = tween()) { -it } ) { IconButton(onClick = onClickDelete) { Icon( imageVector = Icons.Default.Delete, contentDescription = \"Delete\" ) } } } }}In this setup:AnchoredDraggableState allows us to set specific anchor points for different actions. Here, swiping left reveals the delete option, while swiping right reveals the read option.AnimatedVisibility and slideInHorizontally are used to animate the icons as they are revealed or hidden, creating a smooth interaction.This approach work well also in the case of the swipe to dismiss interactions. In this case we need to add a LaunchedEffect to call our callbacks at the right moment:LaunchedEffect(dragState) { snapshotFlow { dragState.settledValue } .collectLatest { when (it) { SwipeToRevealValue.Read -\u003e onClickRead() SwipeToRevealValue.Delete -\u003e onClickDelete() else -\u003e {} } delay(30) dragState.animateTo(SwipeToRevealValue.Resting) }}The LaunchedEffect triggers the appropriate action based on the settled value, then resets the swipe position to maintain a clean UI state after each swipe.ConclusionIn this article, we’ve explored three powerful approaches to implementing swipe-based interactions in Jetpack Compose: detectHorizontalDragGestures, SwipeToDismissBox, and anchoredDraggable. Each method has its strengths, allowing for a range of customization and control over swipe behaviors.detectHorizontalDragGestures provides a low-level, customizable approach, ideal if you need control over gesture handling.SwipeToDismissBox simplifies the setup for dismissible items with built-in state management, making it a great choice for straightforward swipe-to-dismiss interactions.anchoredDraggable offers precise control over anchored states, making it well-suited for swipe functionalities.By choosing the right tool for the job, you can create smooth, intuitive swipe interactions that enhance your app’s UX. Compose continues to evolve, and with these options, you can build flexible and engaging interfaces that feel natural and responsive to users.If you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I publish new articles almost every week. Don’t hesitate to share your comments or reach out to me on LinkedIn if you prefer.Have a great day!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*3-hO6gU5ICeTlolbGhSQLQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"2217\"\u003eSwipeToDismiss and SwipeToReveal for an Interactive UI\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@stefanoq21?source=post_page---byline--8c6cd59bbc3c--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Stefano Natali\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*nJT9nmRwE28kmJAEiRyHMw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--8c6cd59bbc3c--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5e65\"\u003e\u003cstrong\u003eSwipe gestures\u003c/strong\u003e provide a natural way to interact with elements in an app, adding intuitive controls for actions like dismissing items or revealing options. \u003cstrong\u003eJetpack Compose\u003c/strong\u003e makes it easy to implement in various ways. With recent updates of the Compose libraries, new APIs make swipe-based interactions simpler and more maintainable.\u003c/p\u003e\u003cp id=\"5af0\"\u003eIn this article, we’ll explore how to implement the \u003cstrong\u003eSwipeToDismiss\u003c/strong\u003e and \u003cstrong\u003eSwipeToReveal\u003c/strong\u003e functionality and customize them for various use cases, empowering you to create dynamic, responsive UIs.\u003c/p\u003e\u003ch2 id=\"8a1d\"\u003eBase Implementation with \u003ccode\u003edetectHorizontalDragGestures\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"32d2\"\u003eThe first approach for implementing swipe-based interactions is to use \u003cstrong\u003edetectHorizontalDragGestures\u003c/strong\u003e, a flexible and foundational solution that allows for full customization. This method enables both \u003cstrong\u003eSwipeToDismiss \u003c/strong\u003eand \u003cstrong\u003eSwipeToReveal \u003c/strong\u003efunctionalities by managing the horizontal drag manually. Below is an example of how to implement this in a composable:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e3db\"\u003e@Composable\u003cbr/\u003efun LibraryBook(\u003cbr/\u003e    onClickRead: () -\u0026gt; Unit,\u003cbr/\u003e    onClickDelete: () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    var offsetX by remember { mutableFloatStateOf(0f) }\u003cp\u003e        Box(\u003cbr/\u003e        modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .pointerInput(Unit) {\u003cbr/\u003e                detectHorizontalDragGestures { _, dragAmount -\u0026gt;\u003cbr/\u003e                    offsetX = (offsetX + dragAmount).coerceIn(-300f, 0f)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e    ) {\u003cbr/\u003e        // Actions revealed\u003cbr/\u003e        Row(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxSize()\u003cbr/\u003e                .padding(horizontal = 16.dp),\u003cbr/\u003e            horizontalArrangement = Arrangement.End,\u003cbr/\u003e            verticalAlignment = Alignment.CenterVertically\u003cbr/\u003e        ) {\u003cbr/\u003e            IconButton(onClick = onClickDelete) {\u003cbr/\u003e                Icon(Icons.Default.Delete, contentDescription = \u0026#34;\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Main content\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .offset { IntOffset(offsetX.roundToInt(), 0) }\u003cbr/\u003e        ) {\u003cbr/\u003e            InternalLibraryBook()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"11b1\"\u003eIn this implementation:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d521\"\u003eWe maintain an \u003cstrong\u003eoffsetX \u003c/strong\u003estate to control the horizontal position of the item as it’s dragged.\u003c/li\u003e\u003cli id=\"560b\"\u003e\u003cstrong\u003eDetectHorizontalDragGestures \u003c/strong\u003ehandles horizontal dragging, updating \u003cstrong\u003eoffsetX \u003c/strong\u003ewithin a specified range to prevent excessive movement.\u003c/li\u003e\u003cli id=\"e3be\"\u003eThe main content is shifted based on \u003cstrong\u003eoffsetX\u003c/strong\u003e, revealing the delete action as you swipe.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"510c\"\u003eThis approach is straightforward, but it provides the flexibility to expand and customize as needed. If you want to dive deeper into this solution, \u003ca href=\"https://youtu.be/-L_d-0Emmwc?si=BJX2McZdzpGc-Nni\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePhilipp Lackner’s video\u003c/a\u003e provides an excellent walkthrough. Philipp shares various Compose techniques in his videos, so consider following him for more useful tips and tutorials.\u003c/p\u003e\u003ch2 id=\"e4c6\"\u003eImplementation with SwipeToDismissBox\u003c/h2\u003e\u003cp id=\"cbdd\"\u003eWith recent updates to the \u003cstrong\u003eCompose libraries\u003c/strong\u003e, we now have the \u003cstrong\u003eSwipeToDismissBox\u003c/strong\u003e, which provides a more structured and controllable approach to swipe-based interactions. This component simplifies the process of implementing dismiss gestures and offers better control over the swipe state. Here’s how it enhances the previous implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2504\"\u003e@Composable\u003cbr/\u003efun LibraryBook2(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    onClickRead: () -\u0026gt; Unit,\u003cbr/\u003e    onClickDelete: () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val dismissState = rememberSwipeToDismissBoxState(confirmValueChange = {\u003cbr/\u003e        when (it) {\u003cbr/\u003e            SwipeToDismissBoxValue.EndToStart -\u0026gt; {\u003cbr/\u003e                onClickDelete()\u003cbr/\u003e                true\u003cbr/\u003e            }\u003cbr/\u003e            SwipeToDismissBoxValue.StartToEnd -\u0026gt; {\u003cbr/\u003e                onClickRead()\u003cbr/\u003e                true\u003cbr/\u003e            }\u003cbr/\u003e            else -\u0026gt; false\u003cbr/\u003e        }\u003cbr/\u003e    })\u003cp\u003e    SwipeToDismissBox(\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        state = dismissState,\u003cbr/\u003e        backgroundContent = {\u003cbr/\u003e            Row(\u003cbr/\u003e                modifier = Modifier.fillMaxSize(),\u003cbr/\u003e                horizontalArrangement = Arrangement.SpaceBetween,\u003cbr/\u003e                verticalAlignment = Alignment.CenterVertically\u003cbr/\u003e            ) {\u003cbr/\u003e                // Read action on swipe from start to end\u003cbr/\u003e                AnimatedVisibility(\u003cbr/\u003e                    visible = dismissState.targetValue == SwipeToDismissBoxValue.StartToEnd,\u003cbr/\u003e                    enter = fadeIn()\u003cbr/\u003e                ) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        imageVector = Icons.AutoMirrored.Outlined.MenuBook,\u003cbr/\u003e                        contentDescription = \u0026#34;Read\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                Spacer(modifier = Modifier.weight(1f))\u003c/p\u003e\u003cp\u003e                // Delete action on swipe from end to start\u003cbr/\u003e                AnimatedVisibility(\u003cbr/\u003e                    visible = dismissState.targetValue == SwipeToDismissBoxValue.EndToStart,\u003cbr/\u003e                    enter = fadeIn()\u003cbr/\u003e                ) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        imageVector = Icons.Default.Delete,\u003cbr/\u003e                        contentDescription = \u0026#34;Delete\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    ) {\u003cbr/\u003e        InternalLibraryBook()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9a3a\"\u003eIn this updated example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"35b3\"\u003e\u003cstrong\u003eSwipeToDismissBox \u003c/strong\u003emanages the swipe state internally, which simplifies the swipe handling compared to the \u003cstrong\u003edetectHorizontalDragGestures \u003c/strong\u003eapproach.\u003c/li\u003e\u003cli id=\"dc66\"\u003eThe \u003cstrong\u003ebackgroundContent\u003c/strong\u003e is displayed conditionally based on the swipe direction, using in my case, \u003cstrong\u003eAnimatedVisibility\u003c/strong\u003e to smoothly show icons for delete and read actions.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ad84\"\u003eResetting the Swipe Position\u003c/h2\u003e\u003cp id=\"fa68\"\u003eTo reset the swipe position after an action is taken, you can leverage \u003cstrong\u003eLaunchedEffect \u003c/strong\u003eto monitor \u003cstrong\u003edismissState.currentValue\u003c/strong\u003e and trigger a reset when a swipe is completed:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f3a5\"\u003eval dismissState = rememberSwipeToDismissBoxState()\u003cp\u003eLaunchedEffect(dismissState.currentValue) {\u003cbr/\u003e    when (dismissState.currentValue) {\u003cbr/\u003e        SwipeToDismissBoxValue.EndToStart -\u0026gt; {\u003cbr/\u003e            onClickDelete()\u003cbr/\u003e            dismissState.reset()\u003cbr/\u003e        }\u003cbr/\u003e        SwipeToDismissBoxValue.StartToEnd -\u0026gt; {\u003cbr/\u003e            onClickRead()\u003cbr/\u003e            dismissState.reset()\u003cbr/\u003e        }\u003cbr/\u003e        else -\u0026gt; { /* No action needed */ }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5fce\"\u003eImplementing SwipeToReveal with anchoredDraggable\u003c/h2\u003e\u003cp id=\"e87d\"\u003eThe \u003cstrong\u003eSwipeToDismissBox \u003c/strong\u003eworks well for swipe to dismiss interactions, but if we want to implement \u003cstrong\u003eSwipeToReveal \u003c/strong\u003e(where swiping reveals options rather than dismissing the item) we need a different approach. I found a powerful alternative with the \u003cstrong\u003eanchoredDraggable \u003c/strong\u003eAPI, as it allows us to define anchor points where specific actions can be triggered, making it ideal for reveal-based interactions.\u003c/p\u003e\u003cp id=\"62ba\"\u003eHere’s the example of implementing \u003cstrong\u003eSwipeToReveal \u003c/strong\u003ewith \u003cstrong\u003eanchoredDraggable\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ae6b\"\u003eenum class SwipeToRevealValue { Read, Resting, Delete }\u003cp\u003e@OptIn(ExperimentalFoundationApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun LibraryBook3(\u003cbr/\u003e    onClickRead: () -\u0026gt; Unit,\u003cbr/\u003e    onClickDelete: () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val density = LocalDensity.current\u003cbr/\u003e    val decayAnimationSpec = rememberSplineBasedDecay\u0026lt;Float\u0026gt;()\u003cbr/\u003e    val dragState = remember {\u003cbr/\u003e        val actionOffset = with(density) { 100.dp.toPx() }\u003cbr/\u003e        AnchoredDraggableState(\u003cbr/\u003e            initialValue = SwipeToRevealValue.Resting,\u003cbr/\u003e            anchors = DraggableAnchors {\u003cbr/\u003e                SwipeToRevealValue.Read at -actionOffset\u003cbr/\u003e                SwipeToRevealValue.Resting at 0f\u003cbr/\u003e                SwipeToRevealValue.Delete at actionOffset\u003cbr/\u003e            },\u003cbr/\u003e            positionalThreshold = { distance -\u0026gt; distance * 0.5f },\u003cbr/\u003e            velocityThreshold = { with(density) { 100.dp.toPx() } },\u003cbr/\u003e            snapAnimationSpec = tween(),\u003cbr/\u003e            decayAnimationSpec = decayAnimationSpec,\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    val overScrollEffect = ScrollableDefaults.overscrollEffect()\u003c/p\u003e\u003cp\u003e    Box(\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        // Main content that moves with the swipe\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .anchoredDraggable(\u003cbr/\u003e                    dragState,\u003cbr/\u003e                    Orientation.Horizontal,\u003cbr/\u003e                    overscrollEffect = overScrollEffect\u003cbr/\u003e                )\u003cbr/\u003e                .overscroll(overScrollEffect)\u003cbr/\u003e                .offset {\u003cbr/\u003e                    IntOffset(\u003cbr/\u003e                        x = dragState.requireOffset().roundToInt(),\u003cbr/\u003e                        y = 0\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e        ) {\u003cbr/\u003e            InternalLibraryBook()\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // actions for \u0026#34;Read\u0026#34; and \u0026#34;Delete\u0026#34;\u003cbr/\u003e        Row(\u003cbr/\u003e            modifier = Modifier.matchParentSize(),\u003cbr/\u003e            horizontalArrangement = Arrangement.SpaceBetween,\u003cbr/\u003e            verticalAlignment = Alignment.CenterVertically\u003cbr/\u003e        ) {\u003cbr/\u003e            // Read Action\u003cbr/\u003e            AnimatedVisibility(\u003cbr/\u003e                visible = dragState.currentValue == SwipeToRevealValue.Read,\u003cbr/\u003e                enter = slideInHorizontally(animationSpec = tween()) { it },\u003cbr/\u003e                exit = slideOutHorizontally(animationSpec = tween()) { it }\u003cbr/\u003e            ) {\u003cbr/\u003e                IconButton(onClick = onClickRead) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        imageVector = Icons.AutoMirrored.Outlined.MenuBook,\u003cbr/\u003e                        contentDescription = \u0026#34;Read\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            Spacer(modifier = Modifier.weight(1f))\u003c/p\u003e\u003cp\u003e            // Delete Action\u003cbr/\u003e            AnimatedVisibility(\u003cbr/\u003e                visible = dragState.currentValue == SwipeToRevealValue.Delete,\u003cbr/\u003e                enter = slideInHorizontally(animationSpec = tween()) { -it },\u003cbr/\u003e                exit = slideOutHorizontally(animationSpec = tween()) { -it }\u003cbr/\u003e            ) {\u003cbr/\u003e                IconButton(onClick = onClickDelete) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        imageVector = Icons.Default.Delete,\u003cbr/\u003e                        contentDescription = \u0026#34;Delete\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a837\"\u003eIn this setup:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2806\"\u003e\u003cstrong\u003eAnchoredDraggableState \u003c/strong\u003eallows us to set specific anchor points for different actions. Here, swiping left reveals the delete option, while swiping right reveals the read option.\u003c/li\u003e\u003cli id=\"1f7f\"\u003e\u003cstrong\u003eAnimatedVisibility \u003c/strong\u003eand \u003cstrong\u003eslideInHorizontally \u003c/strong\u003eare used to animate the icons as they are revealed or hidden, creating a smooth interaction.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"692f\"\u003eThis approach work well also in the case of the swipe to dismiss interactions. In this case we need to add a \u003cstrong\u003eLaunchedEffect \u003c/strong\u003eto call our callbacks at the right moment:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6677\"\u003eLaunchedEffect(dragState) {\u003cbr/\u003e    snapshotFlow { dragState.settledValue }\u003cbr/\u003e        .collectLatest {\u003cbr/\u003e            when (it) {\u003cbr/\u003e                SwipeToRevealValue.Read -\u0026gt; onClickRead()\u003cbr/\u003e                SwipeToRevealValue.Delete -\u0026gt; onClickDelete()\u003cbr/\u003e                else -\u0026gt; {}\u003cbr/\u003e            }\u003cbr/\u003e            delay(30)\u003cbr/\u003e            dragState.animateTo(SwipeToRevealValue.Resting)\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"72c5\"\u003eThe \u003cstrong\u003eLaunchedEffect\u003c/strong\u003e triggers the appropriate action based on the settled value, then resets the swipe position to maintain a clean UI state after each swipe.\u003c/p\u003e\u003ch2 id=\"e8ab\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"2bd7\"\u003eIn this article, we’ve explored three powerful approaches to implementing swipe-based interactions in Jetpack Compose: \u003cstrong\u003edetectHorizontalDragGestures\u003c/strong\u003e, \u003cstrong\u003eSwipeToDismissBox\u003c/strong\u003e, and \u003cstrong\u003eanchoredDraggable\u003c/strong\u003e. \u003cbr/\u003eEach method has its strengths, allowing for a range of customization and control over swipe behaviors.\u003c/p\u003e\u003cul\u003e\u003cli id=\"111f\"\u003e\u003cstrong\u003edetectHorizontalDragGestures\u003c/strong\u003e provides a low-level, customizable approach, ideal if you need control over gesture handling.\u003c/li\u003e\u003cli id=\"d169\"\u003e\u003cstrong\u003eSwipeToDismissBox\u003c/strong\u003e simplifies the setup for dismissible items with built-in state management, making it a great choice for straightforward swipe-to-dismiss interactions.\u003c/li\u003e\u003cli id=\"0945\"\u003e\u003cstrong\u003eanchoredDraggable\u003c/strong\u003e offers precise control over anchored states, making it well-suited for swipe functionalities.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9c3f\"\u003eBy choosing the right tool for the job, you can create smooth, intuitive swipe interactions that enhance your app’s UX. \u003cstrong\u003eCompose \u003c/strong\u003econtinues to evolve, and with these options, you can build flexible and engaging interfaces that feel natural and responsive to users.\u003c/p\u003e\u003cp id=\"c27e\"\u003eIf you found this article interesting, feel free to \u003cstrong\u003efollow me\u003c/strong\u003e for more insightful content on Android development and Jetpack Compose. I publish new articles almost every week. Don’t hesitate to share your comments or reach out to me on \u003ca href=\"http://www.linkedin.com/in/stefano-natali-q21\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003eif you prefer.\u003c/p\u003e\u003cp id=\"2531\"\u003eHave a great day!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2024-11-10T18:48:23.553Z",
  "modifiedTime": null
}
