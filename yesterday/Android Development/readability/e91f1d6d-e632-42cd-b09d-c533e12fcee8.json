{
  "id": "e91f1d6d-e632-42cd-b09d-c533e12fcee8",
  "title": "Dotify | Rendering Retro Style Text in Compose with Bitmaps",
  "link": "https://proandroiddev.com/dotify-rendering-retro-style-text-in-compose-with-bitmaps-3035bffacebe?source=rss----c72404660798---4",
  "description": "",
  "author": "Nikhil Mandlik",
  "published": "Mon, 21 Jul 2025 17:11:22 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "android",
    "bitmap",
    "canvas",
    "kotlin"
  ],
  "byline": "Nikhil Mandlik",
  "length": 2198,
  "excerpt": "A few days ago, I came across this design on Pinterest, and it got me excited. There are many ways to build this, and the approach I took is a bit unusual, slightly complex, and not the most…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "A few days ago, I came across this design on Pinterest, and it got me excited. There are many ways to build this, and the approach I took is a bit unusual, slightly complex, and not the most performant. But for a first version? It looks good.OverviewWe start by creating a Bitmap and drawing text onto it. Why a bitmap, you ask? Because a bitmap is essentially a 2D array of pixels, where each pixel holds RGBA values and that’s exactly what we need for this design: pixelated text.Once we have the bitmap, we scale it down to match the number of dots we want to render using a fixed number of rows and columns. This gives us a smaller, low-res version of the original bitmap. More dots (i.e., higher pixel density) means a sharper, more accurate image.From this scaled-down bitmap, we extract a dotMatrix a 2D array where each value represents the alpha (transparency) of that pixel. We then loop through this matrix, and for each pixel:If it has visible content (alpha \u003e 0), we display a colored dot.If it’s fully transparent or black, we skip it or render it as empty.Creating a Bitmap with TextSince Jetpack Compose doesn’t support direct text rendering on bitmaps, we use the android.graphics.Canvas API to draw text manually. We create a mutable bitmap, attach it to a Canvas, and draw centered text using drawTextand we return this bitmapConverting Bitmap to Dot MatrixWe scale the bitmap to a fixed size (rows × cols) to control the number of dots rendered on the screen. Think of it like converting a high-resolution image into a low-res version. We then iterate through each cell in the scaled-down bitmap and record the alpha value at each pixel to construct a 2D matrix. This matrix helps us decide which dots should be visible (non-zero alpha) and which should be skipped (zero alpha).Displaying the Dot MatrixWe simply iterate through the matrix row by row, and for each cell. If the alpha value is greater than 0, we show a colored dot. Otherwise, we render it with the background color.That’s it! You can check out the GitHub repo below. I’ve also included another simple and intuitive approach to achieve the same effect, though it might need a few tweaks to match the exact output",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:800/1*aaNiq9NXmu9AD3Q0xp0Oqw.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@nikhil.here?source=post_page---byline--3035bffacebe---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Nikhil Mandlik\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*phVGVUHy5uG9cSGfQX12QQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"7105\"\u003eA few days ago, I came across \u003ca href=\"https://pin.it/282cRhllK\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis\u003c/a\u003e design on Pinterest, and it got me excited. There are many ways to build this, and the \u003cstrong\u003eapproach I took is a bit unusual, slightly complex, and not the most performant. \u003c/strong\u003eBut for a first version? It looks good.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c9cd\"\u003eOverview\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"76ce\"\u003eWe start by creating a \u003ccode\u003eBitmap\u003c/code\u003e and drawing text onto it. Why a bitmap, you ask? Because a bitmap is essentially a 2D array of pixels, where each pixel holds RGBA values and that’s exactly what we need for this design: \u003cstrong\u003epixelated text\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"256e\"\u003eOnce we have the bitmap, we \u003cstrong\u003escale it down\u003c/strong\u003e to match the number of dots we want to render using a fixed number of \u003cstrong\u003erows and columns\u003c/strong\u003e. This gives us a smaller, low-res version of the original bitmap. More dots (i.e., higher pixel density) means a sharper, more accurate image.\u003c/p\u003e\u003cp id=\"6384\"\u003eFrom this scaled-down bitmap, we extract a \u003cstrong\u003edotMatrix \u003c/strong\u003ea 2D array where each value represents the \u003cstrong\u003ealpha\u003c/strong\u003e (transparency) of that pixel. We then loop through this matrix, and for each pixel:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ba2c\"\u003eIf it has visible content (alpha \u0026gt; 0), we display a colored dot.\u003c/li\u003e\u003cli id=\"5598\"\u003eIf it’s fully transparent or black, we skip it or render it as empty.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0060\"\u003eCreating a Bitmap with Text\u003c/h2\u003e\u003cp id=\"a6e0\"\u003eSince Jetpack Compose doesn’t support direct text rendering on bitmaps, we use the \u003ccode\u003eandroid.graphics.Canvas\u003c/code\u003e API to draw text manually. We create a mutable bitmap, attach it to a \u003ccode\u003eCanvas\u003c/code\u003e, and draw centered text using \u003ccode\u003edrawText\u003c/code\u003eand we return this bitmap\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"bbd6\"\u003eConverting Bitmap to Dot Matrix\u003c/h2\u003e\u003cp id=\"a288\"\u003eWe scale the bitmap to a fixed size (\u003ccode\u003erows × cols\u003c/code\u003e) to control the number of dots rendered on the screen. Think of it like converting a high-resolution image into a low-res version. We then \u003cstrong\u003eiterate through each cell in the scaled-down bitmap\u003c/strong\u003e and \u003cstrong\u003erecord the alpha value\u003c/strong\u003e at each pixel to \u003cstrong\u003econstruct a 2D matrix\u003c/strong\u003e. This matrix helps us decide which dots should be visible (non-zero alpha) and which should be skipped (zero alpha).\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"607b\"\u003eDisplaying the Dot Matrix\u003c/h2\u003e\u003cp id=\"b239\"\u003eWe simply \u003cstrong\u003eiterate through the matrix row by row\u003c/strong\u003e, and for each cell. If the alpha value is greater than 0, we show a colored dot. Otherwise, we render it with the background color.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"edd7\"\u003eThat’s it! You can check out the GitHub repo below. I’ve also included another simple and intuitive approach to achieve the same effect, though it might need a few tweaks to match the exact output\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-07-15T18:50:22.815Z",
  "modifiedTime": null
}
