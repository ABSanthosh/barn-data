{
  "id": "2d58fa19-c0d4-46ff-9739-8b0acbac1722",
  "title": "Migrating to the Compose PullToRefreshBox",
  "link": "https://joebirch.co/android/migrating-to-the-compose-pulltorefreshbox/",
  "description": "Pull to Refresh is a common pattern we find across mobile apps – it allows our users to refresh the content of screen in a single swipe. Jetpack Compose has provided support for this for some time, through the pullRefresh modifier. In your code, this would look something like the following: While this was great... Continue reading →",
  "author": "hitherejoe",
  "published": "Fri, 31 Jan 2025 11:43:55 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Apps",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Material Design",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 6089,
  "excerpt": "Pull to Refresh is a common pattern we find across mobile apps - it allows our users to refresh the content of screen in a single swipe. Jetpack Compose has provided support for this for some time, through the pullRefresh modifier. In your code, this would look something like the following: val p",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "Pull to Refresh is a common pattern we find across mobile apps – it allows our users to refresh the content of screen in a single swipe. Jetpack Compose has provided support for this for some time, through the pullRefresh modifier. In your code, this would look something like the following: val pullRefreshState = rememberPullRefreshState(isRefreshing), { (handle refresh) }) Box( modifier.pullRefresh(pullRefreshState) ) { PullRefreshIndicator( modifier = Modifier.align(Alignment.TopCenter), refreshing = isRefreshing, state = pullRefreshState ) } While this was great to initially support pull to refresh in Compose UI, it provided several points of friction: Low discoverability – it is not immediately obvious that a pullRefresh modifier would be available to use, adding an extra step in for developers to search for its availability Boilerplate code – alongside adding a Box container with corresponding modifier, we have to add the use of the PullRefreshIndicator composable as a child of the Box. This results in developers having to add several pieces of code for something that was previously supported out of the box in the Android View System Difficult to customise – while the modifier provides us with access to this functionality, there is friction when it comes to customising the indicator Reduced readability – having to add a parent Box to any layout is fine, but it isn’t immediately clear why this has been added until you see the pullRefresh modifier We can see here that there are several points here which demonstrate how the API design for the original pull to refresh support was not as simple as it could have been. However, I am still grateful that I was able to add support for this to my apps – which is an OK trade off for me! Fast forward to now and we have access to a new experimental composable, the PullToRefreshBox. It’s important to note that this in an experimental state, but you’ll be able to access it in the latest version of the compose material 3 package. When using the PullToRefreshBox, you’ll want to do something like the following: PullToRefreshBox( modifier = modifier, isRefreshing = isRefreshing, onRefresh = onRefresh ) { } From this example, we can already see how some of the previous friction points are already cleared up: Improved discoverability – when looking for functionality in compose, I will initially attempt to type my desired functionality to see if there is a composable that exists (this is what I actually remember doing for pull-to-refresh originally!). With this new composable, developers will be able to discover support for this functionality when composing UI Improved readability – when scanning through code, this composable will make it much clearer what the purpose is of the composable, without having to rely on reading modifiers Less boilerplate code – with this composable, for out-of-the-box support, we no longer need to declare the indicator to be used or provide a reference to any pull refresh state. This results in much less code being added to our codebase As we can see from the example, we still need to provide a reference to an isRefreshingState that is used to depict if the refreshing indicator should be shown, along with an onRefresh callback for when the refresh operation is triggered. But with the above points, I am in full support of this composable and will be using this to simplify the pull-to-refresh implementations that I have in place (once this hits stable!). One of the other friction points we touched on above was existing modifier being difficult to customise – how does this new composable make this easier? The PullToRefreshBox composable support an indicator argument that allows us to provide an indicator for use as the refreshing indicator. When using this, we’ll need to provide the PullToRefreshState to the indicator, so we’ll need to declare this using the rememberPullToRefreshState function. This is so that we can use the same state reference to the parent PullToRefreshBox and the indicator to be used. As per the example above, if you are not customising the indicator, then you do not need to provide this PullToRefreshState. val state = rememberPullToRefreshState() PullToRefreshBox( modifier = modifier, state = state, isRefreshing = isRefreshing, onRefresh = onRefresh, indicator = { } ) { } When it comes to customising this indicator, we have a couple of options – which one you use will depend on how much customisation you are looking for! If we simply want to customise the colors used for the indicator, you can use the provided Indicator composable, providing values for both the containerColor and color arguments. We will also need to provide the value for the isRefreshing argument which we passed to the parent PullToRefreshComposable, along with the shared PullToRefreshState for the state. Providing this composable for the indicator argument will override the default indicator being used when the user performs the gesture. Indicator( modifier = Modifier.align(Alignment.TopCenter), isRefreshing = isRefreshing, containerColor = MaterialTheme.colorScheme.primaryContainer, color = MaterialTheme.colorScheme.onPrimaryContainer, state = state ) If you want to provide a completely custom indicator composable, then you can do so using the pullToRefreshIndicator modifier. This modifier can be applied to the composable that defines your indicator, for which you will need to provide the same state arguments as above to reflect the state of the indicator. pullToRefreshIndicator( state = state, isRefreshing = isRefreshing, containerColor = PullToRefreshDefaults.containerColor, threshold = PositionalThreshold ) From this post we can see how much the PullToRefreshBox simplifies pull-to-refresh within our Jetpack Compose UI. I recommend you checking this out and preparing to migrate when it feels in a stable enough state for your own projects!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003ePull to Refresh is a common pattern we find across mobile apps – it allows our users to refresh the content of screen in a single swipe. Jetpack Compose has provided support for this for some time, through the \u003cstrong\u003epullRefresh\u003c/strong\u003e modifier. In your code, this would look something like the following:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eval pullRefreshState = rememberPullRefreshState(isRefreshing), { (handle refresh) })\n\nBox(\n    modifier.pullRefresh(pullRefreshState)\n) {\n\n    PullRefreshIndicator(\n        modifier = Modifier.align(Alignment.TopCenter),\n        refreshing = isRefreshing,\n        state = pullRefreshState\n    )\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile this was great to initially support pull to refresh in Compose UI, it provided several points of friction:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLow discoverability\u003c/strong\u003e – it is not immediately obvious that a \u003cstrong\u003epullRefresh\u003c/strong\u003e modifier would be available to use, adding an extra step in for developers to search for its availability\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eBoilerplate code\u003c/strong\u003e – alongside adding a \u003cstrong\u003eBox\u003c/strong\u003e container with corresponding modifier, we have to add the use of the \u003cstrong\u003ePullRefreshIndicator\u003c/strong\u003e composable as a child of the \u003cstrong\u003eBox\u003c/strong\u003e. This results in developers having to add several pieces of code for something that was previously supported out of the box in the Android View System\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDifficult to customise\u003c/strong\u003e – while the modifier provides us with access to this functionality, there is friction when it comes to customising the indicator\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eReduced readability\u003c/strong\u003e – having to add a parent Box to any layout is fine, but it isn’t immediately clear why this has been added until you see the \u003cstrong\u003epullRefresh\u003c/strong\u003e modifier\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe can see here that there are several points here which demonstrate how the API design for the original pull to refresh support was not as simple as it could have been. However, I am still grateful that I was able to add support for this to my apps – which is an OK trade off for me!\u003c/p\u003e\n\n\n\n\u003cp\u003eFast forward to now and we have access to a new experimental composable, the \u003cstrong\u003ePullToRefreshBox\u003c/strong\u003e. It’s important to note that this in an experimental state, but you’ll be able to access it in the latest version of the compose material 3 package. When using the \u003cstrong\u003ePullToRefreshBox\u003c/strong\u003e, you’ll want to do something like the following:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003ePullToRefreshBox(\n    modifier = modifier,\n    isRefreshing = isRefreshing,\n    onRefresh = onRefresh\n) {\n\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFrom this example, we can already see how some of the previous friction points are already cleared up:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eImproved discoverability \u003c/strong\u003e– when looking for functionality in compose, I will initially attempt to type my desired functionality to see if there is a composable that exists (this is what I actually remember doing for pull-to-refresh originally!). With this new composable, developers will be able to discover support for this functionality when composing UI\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eImproved readability\u003c/strong\u003e – when scanning through code, this composable will make it much clearer what the purpose is of the composable, without having to rely on reading modifiers\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eLess boilerplate code\u003c/strong\u003e – with this composable, for out-of-the-box support, we no longer need to declare the indicator to be used or provide a reference to any pull refresh state. This results in much less code being added to our codebase\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAs we can see from the example, we still need to provide a reference to an \u003cstrong\u003eisRefreshingState\u003c/strong\u003e that is used to depict if the refreshing indicator should be shown, along with an \u003cstrong\u003eonRefresh\u003c/strong\u003e callback for when the refresh operation is triggered. But with the above points, I am in full support of this composable and will be using this to simplify the pull-to-refresh implementations that I have in place (once this hits stable!).\u003c/p\u003e\n\n\n\n\u003cp\u003eOne of the other friction points we touched on above was existing modifier being difficult to customise – how does this new composable make this easier? The \u003cstrong\u003ePullToRefreshBox\u003c/strong\u003e composable support an indicator argument that allows us to provide an indicator for use as the refreshing indicator. When using this, we’ll need to provide the \u003cstrong\u003ePullToRefreshState\u003c/strong\u003e to the indicator, so we’ll need to declare this using the \u003cstrong\u003erememberPullToRefreshState\u003c/strong\u003e function. This is so that we can use the same state reference to the parent \u003cstrong\u003ePullToRefreshBox\u003c/strong\u003e and the indicator to be used. As per the example above, if you are not customising the indicator, then you do not need to provide this \u003cstrong\u003ePullToRefreshState\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eval state = rememberPullToRefreshState()\n\nPullToRefreshBox(\n    modifier = modifier,\n    state = state,\n    isRefreshing = isRefreshing,\n    onRefresh = onRefresh,\n    indicator = {\n    \n    }\n) {\n\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen it comes to customising this indicator, we have a couple of options – which one you use will depend on how much customisation you are looking for! If we simply want to customise the colors used for the indicator, you can use the provided \u003cstrong\u003eIndicator\u003c/strong\u003e composable, providing values for both the \u003cstrong\u003econtainerColor\u003c/strong\u003e and \u003cstrong\u003ecolor\u003c/strong\u003e arguments. We will also need to provide the value for the \u003cstrong\u003eisRefreshing\u003c/strong\u003e argument which we passed to the parent \u003cstrong\u003ePullToRefreshComposable\u003c/strong\u003e, along with the shared \u003cstrong\u003ePullToRefreshState\u003c/strong\u003e for the \u003cstrong\u003estate\u003c/strong\u003e. Providing this composable for the \u003cstrong\u003eindicator\u003c/strong\u003e argument will override the default indicator being used when the user performs the gesture.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eIndicator(\n    modifier = Modifier.align(Alignment.TopCenter),\n    isRefreshing = isRefreshing,\n    containerColor = MaterialTheme.colorScheme.primaryContainer,\n    color = MaterialTheme.colorScheme.onPrimaryContainer,\n    state = state\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you want to provide a completely custom indicator composable, then you can do so using the \u003cstrong\u003epullToRefreshIndicator\u003c/strong\u003e modifier. This modifier can be applied to the composable that defines your indicator, for which you will need to provide the same state arguments as above to reflect the state of the indicator.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epullToRefreshIndicator(\n    state = state,\n    isRefreshing = isRefreshing,\n    containerColor = PullToRefreshDefaults.containerColor,\n    threshold = PositionalThreshold\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eFrom this post we can see how much the \u003cstrong\u003ePullToRefreshBox\u003c/strong\u003e simplifies pull-to-refresh within our Jetpack Compose UI. I recommend you checking this out and preparing to migrate when it feels in a stable enough state for your own projects!\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-01-31T11:43:55Z",
  "modifiedTime": "2025-01-31T11:43:55Z"
}
