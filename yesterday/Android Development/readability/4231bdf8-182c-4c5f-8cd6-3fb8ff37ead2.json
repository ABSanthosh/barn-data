{
  "id": "4231bdf8-182c-4c5f-8cd6-3fb8ff37ead2",
  "title": "Using SVGs on Canvas with Compose Multiplatform",
  "link": "https://proandroiddev.com/using-svgs-on-canvas-with-compose-multiplatform-f8dcf4a099de?source=rss----c72404660798---4",
  "description": "",
  "author": "Eevis Panula",
  "published": "Fri, 17 Jan 2025 20:18:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin-multiplatform",
    "android-development",
    "compose-multiplatform",
    "android",
    "jetpack-compose"
  ],
  "byline": "Eevis Panula",
  "length": 7976,
  "excerpt": "This blog post looks into one way you can draw SVGs to a Compose Canvas.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "One thing that has continued to amaze me with building my Compose Multiplatform app is how easily everything has worked with Canvas. When I started building Neule.art, I assumed that Canvas would cause some problems, but it has worked smoothly on both Android and iOS.I’ve been writing posts about creative coding on Canvas (see, for example, Not a Phase — Text with Compose and Canvas), and also about my First Impressions of Compose Multiplatform, and this post combines elements from both themes.There are different ways to parse an SVG to be used with Compose, and in this blog post, I’m looking into using path data. This approach requires some manual work, but it also allows better flexibility for controlling, e.g., colors of the individual elements within the SVG.What We’re BuildingEven though I’d love to show how I’ve built the shirt I’m using in Neule.art, simplifying the process into the form of a blog post is too difficult a task. I decided to create a smaller SVG, which we’re going to convert into Canvas. It looks like this:The hearts I’m using in the SVG are from Sarah Laroche’s Vector Heart Figma resource. And if you’ve ever seen the colors anywhere, you might recognize them as being from the non-binary flag.Getting the Paths from an SVGWe first need something from the original SVG to draw it on Canvas: the paths of individual components within the SVG.In an SVG, the path’s d-attribute contains the commands for defining the shape being drawn, and we're using that to parse the SVG to the path on Canvas. If you're unfamiliar with SVGs, I recommend checking MDN's documentation on SVGs, as it contains much in-depth information about SVGs.So, to prepare for drawing paths on Canvas, we’ll need an SVG image as code. Then, we need to copy the path’s d-attribute's content and finally store them somewhere inside our code. There are several options for opening the SVG's code - for example, open the file in an IDE or inspect it in the browser's developer tools.In our example, we store the path strings in a list with a variable called pathStrings. We also want to attach the color information to each path to make the drawing phase easier, so we store the path string together with the color it will be drawn with.The following example lists only two of the hearts’ paths, as the complete list would take up too much space. You can find the complete list of paths in the snippet linked at the end of the blog post.val pathStrings = listOf( Pair(\"M185.52 80.2313C172.773 67.8803 159.24 53.9097 154.36 36.3463C153.373 32.8076 152.633 29.1043 153.193 25.4737C154.813 14.8697 163.753 16.4547 168.74 23.722C175.593 33.7001 180.946 44.7021 184.58 56.2492C186.3 43.9382 188.04 31.5685 191.666 19.6794C192.786 16.0068 195.16 11.6456 198.98 12.0229C201.993 12.3195 203.8 15.5202 204.526 18.453C205.733 23.2988 205.426 28.3831 204.926 33.3509C202.806 52.8032 201.753 71.7397 198.673 91.1093C193.953 87.8965 189.62 84.204 185.52 80.2313\", Colors.white), Pair(\"M32.5198 119.231C19.7732 106.88 6.2398 92.9097 1.3598 75.3463C0.373129 71.8076 -0.366871 68.1043 0.193129 64.4737C1.81313 53.8697 10.7531 55.4547 15.7398 62.722C22.5931 72.7001 27.9465 83.7021 31.5798 95.2492C33.2998 82.9382 35.0398 70.5685 38.6664 58.6794C39.7864 55.0068 42.1598 50.6456 45.9798 51.0229C48.9931 51.3195 50.7998 54.5202 51.5265 57.453C52.7331 62.2988 52.4265 67.3831 51.9265 72.3509C49.8065 91.8032 48.7532 110.74 45.6732 130.109C40.9532 126.897 36.6198 123.204 32.5198 119.231\", Colors.black),)Now that we have the path string and the color, we can move on to parsing the path strings into Compose’s Path objects.Parsing PathsCompose has this great thing called PathParser, which is something we can use for, well, parsing paths. Inside a Canvas component's block, we map through the path strings, parse them, and then draw the path on canvas:Canvas(...) { paths.map { (pathString, color) -\u003e val parsedPath = PathParser() .parsePathString(pathString) .toPath() drawPath( path = parsedPath, color = color, ) }}PathParser's method parsePathString takes care of the parsing and returns a PathParser-object. Then, we call the toPath conversion method to get the Path out of PathParser.With these changes, we get the following image:As you might notice, the image doesn’t scale to the entire space available. The reason is that SVG code is hard-coded to fit a specific size. If you look at the path strings above, you can see that they contain numbers as coordinates — they’re inside the (in our case) 278 x 270 area defined in the original SVG as size.To fix this problem, we can add some scaling functions into the mix. Let’s talk about that next.ScalingWe’ll need to convert the parsed path to PathNodes to scale the paths. This way, we can scale every moveTo, curveTo, and other SVG drawing functions to the correct size.We’ll need a couple of helper functions to scale the paths on Canvas. One is a function for transforming float values from one size to another, and the other is a function that handles PathNode's scaling.This is how we define the float scaling:private fun Float.scaleToSize( oldSize: Float, newSize: Float,): Float { val ratio = newSize / oldSize return this * ratio}The function takes in the old size (so, for example, the full old width), and new size (the new full width). With those values, we calculate a ratio to convert the float value by multiplying the value with the calculated ratio.The PathNode's scaling requires a bit more code:private fun PathNode.scaleTo(size: Size): PathNode { val originalWidth = 278f val originalHeight = 207f return when (this) { is PathNode.CurveTo -\u003e this.copy( x1 = x1.scaleToSize(originalWidth, size.width), x2 = x2.scaleToSize(originalWidth, size.width), x3 = x3.scaleToSize(originalWidth, size.width), y1 = y1.scaleToSize(originalHeight, size.height), y2 = y2.scaleToSize(originalHeight, size.height), y3 = y3.scaleToSize(originalHeight, size.height), ) is PathNode.MoveTo -\u003e this.copy( x = x.scaleToSize(originalWidth, size.width), y = y.scaleToSize(originalHeight, size.height), ) else -\u003e this }}We’re scaling the values from the original size to the Canvas size for each type of PathNode. In the when-clause, we're handling only CurveTo and MoveTo, because those are the only commands our path strings contain. If there were others, they should be handled here too.Scaling of each parameter utilizes the scaleToSize we defined previously. The parameters we're passing to the function depend on if the parameter is on the x or y-axis - if it's on the x, we pass in width (as that's the x-axis), and if it is on the y-axis, then we pass in height.Now that we have the helper functions let’s change the mapping of path strings a bit:paths.map { (pathString, color) -\u003e val parsedPath = PathParser() .parsePathString(pathString) .toNodes() .map { it.scaleTo(size) } .toPath() drawPath( path = parsedPath, color = color, )}Here, we first parse the path, then convert the PathParser it returns with toNodes to a list of PathNodes. We then map through each PathNode, and scale it to size. Finally, we turn the scaled PathNode list into Path, which we can then draw.After these changes, the picture scales nicely:Wrapping upIn this blog post, we’ve looked into how to turn SVG into Paths that can be used in Compose's canvas. This approach works for both native Android development, and Compose Multiplatform projects.You can find the complete code from this Github gist.Links in the Blog PostNeule.artNot a Phase — Text with Compose and CanvasFirst Impressions of Compose MultiplatformSarah Laroche’s Vector Heart Figma resourceMDN’s documentation on SVGsGithub gist",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*2s0852fNryeblqpfFTw9Dg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@eevajonna?source=post_page---byline--f8dcf4a099de--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Eevis Panula\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*NhMD_9eOS1kF9_b3VomDEQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--f8dcf4a099de--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2472\"\u003eOne thing that has continued to amaze me with building my Compose Multiplatform app is how easily everything has worked with Canvas. When I started building \u003ca href=\"https://play.google.com/store/apps/details?id=com.eevajonna.neuleart\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNeule.art\u003c/a\u003e, I assumed that Canvas would cause some problems, but it has worked smoothly on both Android and iOS.\u003c/p\u003e\u003cp id=\"b54a\"\u003eI’ve been writing posts about creative coding on Canvas (see, for example, \u003ca href=\"https://medium.com/proandroiddev/not-a-phase-text-with-compose-and-canvas-97cacc35a5f7\" rel=\"noopener\"\u003eNot a Phase — Text with Compose and Canvas\u003c/a\u003e), and also about my \u003ca href=\"https://medium.com/@eevajonna/first-impressions-of-compose-multiplatform-983bddc67e61\" rel=\"noopener\"\u003eFirst Impressions of Compose Multiplatform\u003c/a\u003e, and this post combines elements from both themes.\u003c/p\u003e\u003cp id=\"5847\"\u003eThere are different ways to parse an SVG to be used with Compose, and in this blog post, I’m looking into using path data. This approach requires some manual work, but it also allows better flexibility for controlling, e.g., colors of the individual elements within the SVG.\u003c/p\u003e\u003ch2 id=\"99f6\"\u003eWhat We’re Building\u003c/h2\u003e\u003cp id=\"79cc\"\u003eEven though I’d love to show how I’ve built the shirt I’m using in Neule.art, simplifying the process into the form of a blog post is too difficult a task. I decided to create a smaller SVG, which we’re going to convert into Canvas. It looks like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0c23\"\u003eThe hearts I’m using in the SVG are from \u003ca href=\"https://www.figma.com/community/file/1099013061143326702\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSarah Laroche’s Vector Heart Figma resource\u003c/a\u003e. And if you’ve ever seen the colors anywhere, you might recognize them as being from the non-binary flag.\u003c/p\u003e\u003ch2 id=\"ecdf\"\u003eGetting the Paths from an SVG\u003c/h2\u003e\u003cp id=\"82d2\"\u003eWe first need something from the original SVG to draw it on Canvas: the paths of individual components within the SVG.\u003c/p\u003e\u003cp id=\"9e78\"\u003eIn an SVG, the path’s \u003ccode\u003ed\u003c/code\u003e-attribute contains the commands for defining the shape being drawn, and we\u0026#39;re using that to parse the SVG to the path on Canvas. If you\u0026#39;re unfamiliar with SVGs, I recommend checking \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMDN\u0026#39;s documentation on SVGs\u003c/a\u003e, as it contains much in-depth information about SVGs.\u003c/p\u003e\u003cp id=\"e0c8\"\u003eSo, to prepare for drawing paths on Canvas, we’ll need an SVG image as code. Then, we need to copy the path’s \u003ccode\u003ed\u003c/code\u003e-attribute\u0026#39;s content and finally store them somewhere inside our code. There are several options for opening the SVG\u0026#39;s code - for example, open the file in an IDE or inspect it in the browser\u0026#39;s developer tools.\u003c/p\u003e\u003cp id=\"19ee\"\u003eIn our example, we store the path strings in a list with a variable called \u003ccode\u003epathStrings\u003c/code\u003e. We also want to attach the color information to each path to make the drawing phase easier, so we store the path string together with the color it will be drawn with.\u003c/p\u003e\u003cp id=\"e1c0\"\u003eThe following example lists only two of the hearts’ paths, as the complete list would take up too much space. You can find the complete list of paths in the snippet linked at the end of the blog post.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2f6c\"\u003eval pathStrings = listOf(\u003cbr/\u003e    Pair(\u0026#34;M185.52 80.2313C172.773 67.8803 159.24 53.9097 154.36 36.3463C153.373 32.8076 152.633 29.1043 153.193 25.4737C154.813 14.8697 163.753 16.4547 168.74 23.722C175.593 33.7001 180.946 44.7021 184.58 56.2492C186.3 43.9382 188.04 31.5685 191.666 19.6794C192.786 16.0068 195.16 11.6456 198.98 12.0229C201.993 12.3195 203.8 15.5202 204.526 18.453C205.733 23.2988 205.426 28.3831 204.926 33.3509C202.806 52.8032 201.753 71.7397 198.673 91.1093C193.953 87.8965 189.62 84.204 185.52 80.2313\u0026#34;, Colors.white),\u003cbr/\u003e    Pair(\u0026#34;M32.5198 119.231C19.7732 106.88 6.2398 92.9097 1.3598 75.3463C0.373129 71.8076 -0.366871 68.1043 0.193129 64.4737C1.81313 53.8697 10.7531 55.4547 15.7398 62.722C22.5931 72.7001 27.9465 83.7021 31.5798 95.2492C33.2998 82.9382 35.0398 70.5685 38.6664 58.6794C39.7864 55.0068 42.1598 50.6456 45.9798 51.0229C48.9931 51.3195 50.7998 54.5202 51.5265 57.453C52.7331 62.2988 52.4265 67.3831 51.9265 72.3509C49.8065 91.8032 48.7532 110.74 45.6732 130.109C40.9532 126.897 36.6198 123.204 32.5198 119.231\u0026#34;, Colors.black),\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dedd\"\u003eNow that we have the path string and the color, we can move on to parsing the path strings into Compose’s \u003ccode\u003ePath\u003c/code\u003e objects.\u003c/p\u003e\u003ch2 id=\"476e\"\u003eParsing Paths\u003c/h2\u003e\u003cp id=\"997f\"\u003eCompose has this great thing called \u003ccode\u003ePathParser\u003c/code\u003e, which is something we can use for, well, parsing paths. Inside a \u003ccode\u003eCanvas\u003c/code\u003e component\u0026#39;s block, we map through the path strings, parse them, and then draw the path on canvas:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"26c9\"\u003eCanvas(...) {\u003cbr/\u003e    paths.map { (pathString, color) -\u0026gt;\u003cbr/\u003e        val parsedPath = PathParser()\u003cbr/\u003e          .parsePathString(pathString)\u003cbr/\u003e          .toPath()\u003cp\u003e                drawPath(\u003cbr/\u003e            path = parsedPath,\u003cbr/\u003e            color = color,\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3b3\"\u003e\u003ccode\u003ePathParser\u003c/code\u003e\u0026#39;s method \u003ccode\u003eparsePathString\u003c/code\u003e takes care of the parsing and returns a \u003ccode\u003ePathParser\u003c/code\u003e-object. Then, we call the \u003ccode\u003etoPath\u003c/code\u003e conversion method to get the \u003ccode\u003ePath\u003c/code\u003e out of \u003ccode\u003ePathParser\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"43a5\"\u003eWith these changes, we get the following image:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4c4d\"\u003eAs you might notice, the image doesn’t scale to the entire space available. The reason is that SVG code is hard-coded to fit a specific size. If you look at the path strings above, you can see that they contain numbers as coordinates — they’re inside the (in our case) 278 x 270 area defined in the original SVG as size.\u003c/p\u003e\u003cp id=\"4384\"\u003eTo fix this problem, we can add some scaling functions into the mix. Let’s talk about that next.\u003c/p\u003e\u003ch2 id=\"83ff\"\u003eScaling\u003c/h2\u003e\u003cp id=\"ac95\"\u003eWe’ll need to convert the parsed path to \u003ccode\u003ePathNode\u003c/code\u003es to scale the paths. This way, we can scale every \u003ccode\u003emoveTo\u003c/code\u003e, \u003ccode\u003ecurveTo\u003c/code\u003e, and other SVG drawing functions to the correct size.\u003c/p\u003e\u003cp id=\"5972\"\u003eWe’ll need a couple of helper functions to scale the paths on Canvas. One is a function for transforming float values from one size to another, and the other is a function that handles \u003ccode\u003ePathNode\u003c/code\u003e\u0026#39;s scaling.\u003c/p\u003e\u003cp id=\"8b24\"\u003eThis is how we define the float scaling:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"52a0\"\u003eprivate fun Float.scaleToSize(\u003cbr/\u003e    oldSize: Float,\u003cbr/\u003e    newSize: Float,\u003cbr/\u003e): Float {\u003cbr/\u003e    val ratio = newSize / oldSize\u003cbr/\u003e    return this * ratio\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6cbc\"\u003eThe function takes in the old size (so, for example, the full old width), and new size (the new full width). With those values, we calculate a ratio to convert the float value by multiplying the value with the calculated ratio.\u003c/p\u003e\u003cp id=\"21e4\"\u003eThe \u003ccode\u003ePathNode\u003c/code\u003e\u0026#39;s scaling requires a bit more code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e155\"\u003eprivate fun PathNode.scaleTo(size: Size): PathNode {\u003cbr/\u003e    val originalWidth = 278f\u003cbr/\u003e    val originalHeight = 207f\u003cp\u003e    return when (this) {\u003cbr/\u003e        is PathNode.CurveTo -\u0026gt;\u003cbr/\u003e            this.copy(\u003cbr/\u003e                x1 = x1.scaleToSize(originalWidth, size.width),\u003cbr/\u003e                x2 = x2.scaleToSize(originalWidth, size.width),\u003cbr/\u003e                x3 = x3.scaleToSize(originalWidth, size.width),\u003cbr/\u003e                y1 = y1.scaleToSize(originalHeight, size.height),\u003cbr/\u003e                y2 = y2.scaleToSize(originalHeight, size.height),\u003cbr/\u003e                y3 = y3.scaleToSize(originalHeight, size.height),\u003cbr/\u003e            )\u003cbr/\u003e        is PathNode.MoveTo -\u0026gt;\u003cbr/\u003e            this.copy(\u003cbr/\u003e                x = x.scaleToSize(originalWidth, size.width),\u003cbr/\u003e                y = y.scaleToSize(originalHeight, size.height),\u003cbr/\u003e            )\u003cbr/\u003e        else -\u0026gt; this\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"56c5\"\u003eWe’re scaling the values from the original size to the Canvas size for each type of \u003ccode\u003ePathNode\u003c/code\u003e. In the when-clause, we\u0026#39;re handling only \u003ccode\u003eCurveTo\u003c/code\u003e and \u003ccode\u003eMoveTo\u003c/code\u003e, because those are the only commands our path strings contain. If there were others, they should be handled here too.\u003c/p\u003e\u003cp id=\"6c40\"\u003eScaling of each parameter utilizes the \u003ccode\u003escaleToSize\u003c/code\u003e we defined previously. The parameters we\u0026#39;re passing to the function depend on if the parameter is on the x or y-axis - if it\u0026#39;s on the x, we pass in width (as that\u0026#39;s the x-axis), and if it is on the y-axis, then we pass in height.\u003c/p\u003e\u003cp id=\"c0d0\"\u003eNow that we have the helper functions let’s change the mapping of path strings a bit:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"577d\"\u003epaths.map { (pathString, color) -\u0026gt;\u003cbr/\u003e    val parsedPath =\u003cbr/\u003e        PathParser()\u003cbr/\u003e          .parsePathString(pathString)\u003cbr/\u003e          .toNodes()\u003cbr/\u003e          .map { it.scaleTo(size) }\u003cbr/\u003e          .toPath()\u003cp\u003e    drawPath(\u003cbr/\u003e        path = parsedPath,\u003cbr/\u003e        color = color,\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b06d\"\u003eHere, we first parse the path, then convert the \u003ccode\u003ePathParser\u003c/code\u003e it returns with \u003ccode\u003etoNodes\u003c/code\u003e to a list of \u003ccode\u003ePathNode\u003c/code\u003es. We then map through each \u003ccode\u003ePathNode\u003c/code\u003e, and scale it to size. Finally, we turn the scaled \u003ccode\u003ePathNode\u003c/code\u003e list into \u003ccode\u003ePath\u003c/code\u003e, which we can then draw.\u003c/p\u003e\u003cp id=\"a1be\"\u003eAfter these changes, the picture scales nicely:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b6a4\"\u003eWrapping up\u003c/h2\u003e\u003cp id=\"c1b9\"\u003eIn this blog post, we’ve looked into how to turn SVG into \u003ccode\u003ePath\u003c/code\u003es that can be used in Compose\u0026#39;s canvas. This approach works for both native Android development, and Compose Multiplatform projects.\u003c/p\u003e\u003cp id=\"4cc8\"\u003eYou can find the complete code from this \u003ca href=\"https://gist.github.com/eevajonnapanula/9a0d70dd6ecfcc4cad17a5543be97f88\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGithub gist\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"bb61\"\u003eLinks in the Blog Post\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a3ff\"\u003e\u003ca href=\"https://play.google.com/store/apps/details?id=com.eevajonna.neuleart\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNeule.art\u003c/a\u003e\u003c/li\u003e\u003cli id=\"1173\"\u003e\u003ca href=\"https://medium.com/proandroiddev/not-a-phase-text-with-compose-and-canvas-97cacc35a5f7\" rel=\"noopener\"\u003eNot a Phase — Text with Compose and Canvas\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6931\"\u003e\u003ca href=\"https://medium.com/@eevajonna/first-impressions-of-compose-multiplatform-983bddc67e61\" rel=\"noopener\"\u003eFirst Impressions of Compose Multiplatform\u003c/a\u003e\u003c/li\u003e\u003cli id=\"7b44\"\u003e\u003ca href=\"https://www.figma.com/community/file/1099013061143326702\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSarah Laroche’s Vector Heart Figma resource\u003c/a\u003e\u003c/li\u003e\u003cli id=\"3253\"\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMDN’s documentation on SVGs\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6cc1\"\u003e\u003ca href=\"https://gist.github.com/eevajonnapanula/9a0d70dd6ecfcc4cad17a5543be97f88\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGithub gist\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-01-15T14:12:04.4Z",
  "modifiedTime": null
}
