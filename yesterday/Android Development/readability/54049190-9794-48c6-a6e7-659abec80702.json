{
  "id": "54049190-9794-48c6-a6e7-659abec80702",
  "title": "Jetpack Compose Adoption — E2E",
  "link": "https://proandroiddev.com/jetpack-compose-adoption-e2e-90960f9c96b3?source=rss----c72404660798---4",
  "description": "",
  "author": "Siamak Mahmoudi",
  "published": "Sat, 28 Dec 2024 17:47:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "e2e-testing",
    "appium",
    "androiddev",
    "android-app-development",
    "android"
  ],
  "byline": "Siamak Mahmoudi",
  "length": 5396,
  "excerpt": "This document explores Jetpack Compose AndroidView component compatibility with common large-scale E2E testing platforms (Appium + Pytest). A key challenge when introducing Composables into a…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "BackgroundA key challenge when introducing Composables into a View-based codebase is ensuring compatibility with existing tools, particularly E2E testing platforms. A typical setup involves PyTest integrated with Appium WebDriver, which utilizes Selenium WebDriver.Appium provides AppiumBy to locate and interact with mobile UI elements:class AppiumBy(By): IOS_PREDICATE = '-ios predicate string' IOS_CLASS_CHAIN = '-ios class chain' ANDROID_UIAUTOMATOR = '-android uiautomator' ANDROID_VIEWTAG = '-android viewtag' ANDROID_DATA_MATCHER = '-android datamatcher' ANDROID_VIEW_MATCHER = '-android viewmatcher' ACCESSIBILITY_ID = 'accessibility id' IMAGE = '-image' CUSTOM = '-custom'AppiumBy enables element searches using attributes like Accessibility ID, ViewTag, and Class Chain. By setting the same Accessibility ID on both native Android and iOS apps, we would be able to write and execute one test for both platforms.In Jetpack Compose, contentDescription is crucial for making Composables locatable by Appium:@Composableprivate fun ShareButton(onClick: () -\u003e Unit) { IconButton(onClick = onClick) { Icon( imageVector = Icons.Filled.Share, contentDescription = \"shared_e2e_accessibility_id\" ) }}So far, we have made our View-Based component and Composables Locatable by Appium driver whilst keeping it backward compatible.The ProblemChallenges arise when dealing with hybrid View-Compose components, such as AndroidView or ComposeView. Setting contentDescription on the outer wrapper element does not automatically apply it to the inner element.This is a more common issue with large codebases where developers use shared components more often. E.g. They’ll have a Composable and setting a contentDescription on it seems to be the only step to pass E2E tests but if that’s an AndroidView internally, in fact this attribute will not be delivered to the very container.Sometimes we don’t have edit access to the wrapped item as we are consumers of it. So it’s recommended to expose the contentDescription APIs when you share a component.Working solutionHere is an example of the inner component implementation for the Button Composable and an example of an approach to resolve this issue:@Composablefun Button( text: String, modifier: Modifier = Modifier, ...) { AndroidView(modifier = modifier, factory = { context -\u003e Button(context = context).apply { setText(text) textColor?.let { setTextColor(textColor) } var accessibilityId: String? = null this.foldIn(null as String?) { _, element -\u003e if (element is SemanticsModifier) { element.semanticsConfiguration.getOrNull(\"contentDescription\")?.let { accessibilityId = it } } accessibilityId } contentDescription = accessibilityId } })}Here, modifier is an exposed parameter, so consumers can set semantics and send it.On the consumer side, here is how it can be used:@Composablefun LoginButtonsSet( modifier: Modifier = Modifier, ...) { Button( text = stringResource(...), modifier = Modifier .fillMaxWidth() .padding(horizontal = 24.dp) .semantics { contentDescription = 'btn_login_signup' }, ) ....Once it’s set, on the E2E side, you can use these methods to find the element:def get_sign_up_button_element(self): return find_element(AppiumBy.ACCESSIBILITY_ID, \"btn_login_signup\")get_sign_up_button_element().click()Next StepsTo simplify this process, consider creating extension functions:Modify.getContentDescription: to read contentDescription from any modifier object.Modifier.setContentDescription: to set it on the modifier.This approach enhances readability and reduces boilerplate code. Here is a simple implementation of it.utils/AccessibilityModifier.ktimport androidx.compose.ui.Modifierimport androidx.compose.ui.semantics.SemanticsModifierimport androidx.compose.ui.semantics.SemanticsPropertyKeyimport androidx.compose.ui.semantics.SemanticsPropertyReceiverimport androidx.compose.ui.semantics.getOrNullimport androidx.compose.ui.semantics.semantics/** * Key for the contentDescription semantics property. * If your composable works with E2E or UI tests, * you can use this property to set a unique identifier for the composable. *//** * Key for the contentDescription semantics property. */val ContentDescription = SemanticsPropertyKey\u003cString\u003e(\"ContentDescription\")/** * Receiver for the contentDescription semantics property. */var SemanticsPropertyReceiver.contentDescription by ContentDescription/** * Sets the contentDescription of a composable. * * @param contentDescription The contentDescription to set. */fun Modifier.contentDescription(contentDescription: String): Modifier { return semantics { this.contentDescription = contentDescription }}/** * Gets the contentDescription of a composable. * * @return The contentDescription, or null if not set. */fun Modifier.getContentDescription(): String? { return this.foldIn(null as String?) { _, element -\u003e if (element is SemanticsModifier) { element.semanticsConfiguration.getOrNull(ContentDescription)?.let { return@foldIn it } } }}",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*xQ7GVRF5wjsBwBu8",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"fa07\"\u003eBackground\u003c/h2\u003e\u003cp id=\"d07d\"\u003eA key challenge when introducing Composables into a View-based codebase is ensuring compatibility with existing tools, particularly E2E testing platforms. A typical setup involves PyTest integrated with Appium WebDriver, which utilizes Selenium WebDriver.\u003c/p\u003e\u003cp id=\"0217\"\u003eAppium provides \u003ccode\u003eAppiumBy\u003c/code\u003e to locate and interact with mobile UI elements:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4695\"\u003eclass AppiumBy(By):\u003cbr/\u003e    IOS_PREDICATE = \u0026#39;-ios predicate string\u0026#39;\u003cbr/\u003e    IOS_CLASS_CHAIN = \u0026#39;-ios class chain\u0026#39;\u003cbr/\u003e    ANDROID_UIAUTOMATOR = \u0026#39;-android uiautomator\u0026#39;\u003cbr/\u003e    ANDROID_VIEWTAG = \u0026#39;-android viewtag\u0026#39;\u003cbr/\u003e    ANDROID_DATA_MATCHER = \u0026#39;-android datamatcher\u0026#39;\u003cbr/\u003e    ANDROID_VIEW_MATCHER = \u0026#39;-android viewmatcher\u0026#39;\u003cbr/\u003e    ACCESSIBILITY_ID = \u0026#39;accessibility id\u0026#39;\u003cbr/\u003e    IMAGE = \u0026#39;-image\u0026#39;\u003cbr/\u003e    CUSTOM = \u0026#39;-custom\u0026#39;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"57d5\"\u003eAppiumBy enables element searches using attributes like Accessibility ID, ViewTag, and Class Chain. By setting the same \u003cstrong\u003eAccessibility ID\u003c/strong\u003e on both native Android and iOS apps, we would be able to write and execute \u003cstrong\u003eone test for both platforms\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"1be0\"\u003eIn Jetpack Compose, \u003ccode\u003econtentDescription\u003c/code\u003e is crucial for making Composables locatable by Appium\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7f31\"\u003e@Composable\u003cbr/\u003eprivate fun ShareButton(onClick: () -\u0026gt; Unit) {\u003cbr/\u003e    IconButton(onClick = onClick) {\u003cbr/\u003e        Icon(\u003cbr/\u003e            imageVector = Icons.Filled.Share,\u003cbr/\u003e            contentDescription = \u0026#34;shared_e2e_accessibility_id\u0026#34;\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"03c5\"\u003eSo far, we have made our View-Based component and Composables Locatable by Appium driver whilst keeping it backward compatible.\u003c/p\u003e\u003ch2 id=\"b7e7\"\u003eThe Problem\u003c/h2\u003e\u003cp id=\"9997\"\u003eChallenges arise when dealing with hybrid View-Compose components, such as \u003ccode\u003eAndroidView\u003c/code\u003e or \u003ccode\u003eComposeView\u003c/code\u003e. Setting \u003ccode\u003econtentDescription\u003c/code\u003e on the outer wrapper element does not automatically apply it to the inner element.\u003c/p\u003e\u003cp id=\"82c0\"\u003eThis is a more common issue with large codebases where developers use shared components more often. E.g. They’ll have a Composable and setting a contentDescription on it seems to be the only step to pass E2E tests but if that’s an \u003ca href=\"https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/views-in-compose\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroidView\u003c/a\u003e internally, in fact this attribute will \u003cstrong\u003enot\u003c/strong\u003e be delivered to the very container.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e126\"\u003eSometimes we don’t have edit access to the wrapped item as we are consumers of it. So it’s recommended to expose the \u003ccode\u003econtentDescription\u003c/code\u003e APIs when you share a component.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"108c\"\u003eWorking solution\u003c/h2\u003e\u003cp id=\"e624\"\u003eHere is an example of the inner component implementation for the \u003ccode\u003eButton\u003c/code\u003e Composable and an example of an approach to resolve this issue:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a27c\"\u003e@Composable\u003cbr/\u003efun Button(\u003cbr/\u003e    text: String,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    ...\u003cbr/\u003e) {\u003cbr/\u003e    AndroidView(modifier = modifier, factory = { context -\u0026gt;\u003cbr/\u003e        Button(context = context).apply {\u003cbr/\u003e            setText(text)\u003cbr/\u003e            textColor?.let { setTextColor(textColor) }\u003cbr/\u003e            var accessibilityId: String? = null\u003cbr/\u003e            this.foldIn(null as String?) { _, element -\u0026gt;\u003cbr/\u003e                if (element is SemanticsModifier) {\u003cbr/\u003e                    element.semanticsConfiguration.getOrNull(\u0026#34;contentDescription\u0026#34;)?.let {\u003cbr/\u003e                        accessibilityId = it\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e                accessibilityId\u003cbr/\u003e            }\u003cbr/\u003e            contentDescription = accessibilityId\u003cbr/\u003e        }\u003cbr/\u003e    })\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"98ad\"\u003eHere, \u003ccode\u003e\u003cstrong\u003emodifier\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eis an exposed parameter, so consumers can set semantics and send it.\u003c/p\u003e\u003cp id=\"0404\"\u003eOn the consumer side, here is how it can be used:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"33bd\"\u003e@Composable\u003cbr/\u003efun LoginButtonsSet(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    ...\u003cbr/\u003e) {\u003cbr/\u003e    Button(\u003cbr/\u003e        text = stringResource(...),\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .padding(horizontal = 24.dp)\u003cbr/\u003e            .semantics {\u003cbr/\u003e                contentDescription = \u0026#39;btn_login_signup\u0026#39;\u003cbr/\u003e            },\u003cbr/\u003e        )\u003cbr/\u003e        ....\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9787\"\u003eOnce it’s set, on the E2E side, you can use these methods to find the element:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6064\"\u003edef get_sign_up_button_element(self):\u003cbr/\u003e        return find_element(AppiumBy.ACCESSIBILITY_ID, \u0026#34;btn_login_signup\u0026#34;)\u003cp\u003eget_sign_up_button_element().click()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3198\"\u003eNext Steps\u003c/h2\u003e\u003cp id=\"f695\"\u003eTo simplify this process, consider creating extension functions:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3b3b\"\u003e\u003ccode\u003eModify.getContentDescription\u003c/code\u003e: to read contentDescription from any modifier object.\u003c/li\u003e\u003cli id=\"b0fc\"\u003e\u003ccode\u003eModifier.setContentDescription\u003c/code\u003e: to set it on the modifier.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9677\"\u003eThis approach enhances readability and reduces boilerplate code. Here is a simple implementation of it.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"03c8\"\u003eutils/AccessibilityModifier.kt\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"f623\"\u003e\u003cbr/\u003eimport androidx.compose.ui.Modifier\u003cbr/\u003eimport androidx.compose.ui.semantics.SemanticsModifier\u003cbr/\u003eimport androidx.compose.ui.semantics.SemanticsPropertyKey\u003cbr/\u003eimport androidx.compose.ui.semantics.SemanticsPropertyReceiver\u003cbr/\u003eimport androidx.compose.ui.semantics.getOrNull\u003cbr/\u003eimport androidx.compose.ui.semantics.semantics\u003cp\u003e/**\u003cbr/\u003e * Key for the contentDescription semantics property.\u003cbr/\u003e * If your composable works with E2E or UI tests,\u003cbr/\u003e * you can use this property to set a unique identifier for the composable.\u003cbr/\u003e */\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003e * Key for the contentDescription semantics property.\u003cbr/\u003e */\u003cbr/\u003eval ContentDescription = SemanticsPropertyKey\u0026lt;String\u0026gt;(\u0026#34;ContentDescription\u0026#34;)\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003e * Receiver for the contentDescription semantics property.\u003cbr/\u003e */\u003cbr/\u003evar SemanticsPropertyReceiver.contentDescription by ContentDescription\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003e * Sets the contentDescription of a composable.\u003cbr/\u003e *\u003cbr/\u003e * @param contentDescription The contentDescription to set.\u003cbr/\u003e */\u003cbr/\u003efun Modifier.contentDescription(contentDescription: String): Modifier {\u003cbr/\u003e    return semantics {\u003cbr/\u003e        this.contentDescription = contentDescription\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003e * Gets the contentDescription of a composable.\u003cbr/\u003e *\u003cbr/\u003e * @return The contentDescription, or null if not set.\u003cbr/\u003e */\u003cbr/\u003efun Modifier.getContentDescription(): String? {\u003cbr/\u003e    return this.foldIn(null as String?) { _, element -\u0026gt;\u003cbr/\u003e        if (element is SemanticsModifier) {\u003cbr/\u003e            element.semanticsConfiguration.getOrNull(ContentDescription)?.let {\u003cbr/\u003e                return@foldIn it\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-25T05:03:05.939Z",
  "modifiedTime": null
}
