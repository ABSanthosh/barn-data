{
  "id": "87c10b48-1564-4815-aaa3-738e864da551",
  "title": "How to use Koin scopes with Decompose components?",
  "link": "https://proandroiddev.com/how-to-use-koin-scopes-with-decompose-components-14d04ea18e1a?source=rss----c72404660798---4",
  "description": "",
  "author": "Sergei Mikhailovskii",
  "published": "Tue, 05 Nov 2024 00:07:15 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "koin",
    "android-app-development",
    "androiddev",
    "kotlin-multiplatform"
  ],
  "byline": "Sergei Mikhailovskii",
  "length": 3199,
  "excerpt": "In this article I’d like to share the approach of how I resolved the issue with the registration of the big amount of named dependencies by using scopes in Koin. Let me show the problem at the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image generated by ChatGPTIn this article I’d like to share the approach of how I resolved the issue with the registration of the big amount of named dependencies by using scopes in Koin. Let me show the problem at the beginning. We have two components that represent whole screens — list screen component and details screen component. Both these components have child slots to represent their own modal components.Image that describes the problemHere’s the code example of how it looked likeSo, as you can see, to fetch the needed modal component from the container, I had to use the named approach (since both modals used the same interface). Of course, I could create different interfaces and use them as markers but imho, it breaks the abstraction approach since it makes interface not flexible at all.And here’s the place where scopes come for the rescue!First of all, let the documentation explain, what the scope is.Scope is a fixed duration of time or method calls in which an object exists. Another way to look at this is to think of scope as the amount of time an object’s state persists. When the scope context ends, any objects bound under that scope cannot be injected again (they are dropped from the container).Koin provides the convenient way to work with scopes tied to Android lifecycle so it was not a big deal to transfer this logic to the Decompose component lifecycle.The first what I did is created the following interface:This interface is the marker that the component that implements it has it’s own scope. It provides the onScopeClose callback (is invoked when the scope is closed), implements the KoinScopeComponent (probably makes the whole magic with the injection of the right modal component) and ComponentContext (is needed to get the access to the lifecycle, so probably it’s enough to implement only the Lifecycle interface).And the second step I did is created these extensions:The first function is retrieves the already existing scope or creates the new otherwise, second is just a lazy delegate and the third is most interesting among them. It creates the scope and registers it inside the Koin, registers the callback that triggers the onScopeClose method (that I declared in interface) and attaches the scope to the lifecycle, so when it is in destroyed state, the scope is closed. So, now let me show how the code is transformed.As you can see, components started to implement the DecomposeScopeComponent interface, create the scope with the help of delegate. Now there’re no named injections and it is resolved in the DI module. ListModalComponent and DetailsModalComponent are tied to scopes of the screens, so there’s no conflict now.If we’ll look to the KoinComponent.get implementation under the hood, we’ll see why it became possibleSince the DecomposeScopeComponent implements the KoinScopeComponent, dependencies are taken not from the common graph by default but from the scope. But you still have the access to the dependencies that registered without any scope since the scope.get iterates recursively through the other linked scopes too.Of course, you can use the scopes not only to create other components but to inject any dependency you need.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1024/0*eru2Zt27h8fGOHgx",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@mikhailovskii.sergei?source=post_page---byline--14d04ea18e1a--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sergei Mikhailovskii\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*pQI7CRTSrlmr4iRF.jpg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--14d04ea18e1a--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage generated by ChatGPT\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ebe7\"\u003eIn this article I’d like to share the approach of how I resolved the issue with the registration of the big amount of named dependencies by using scopes in Koin. Let me show the problem at the beginning. We have two components that represent whole screens — list screen component and details screen component. Both these components have child slots to represent their own modal components.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage that describes the problem\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"38ae\"\u003eHere’s the code example of how it looked like\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ee51\"\u003eSo, as you can see, to fetch the needed modal component from the container, I had to use the named approach (since both modals used the same interface). Of course, I could create different interfaces and use them as markers but imho, it breaks the abstraction approach since it makes interface not flexible at all.\u003c/p\u003e\u003cp id=\"34e3\"\u003eAnd here’s the place where scopes come for the rescue!\u003c/p\u003e\u003cp id=\"8bc9\"\u003eFirst of all, let the \u003ca href=\"https://insert-koin.io/docs/reference/koin-core/scopes/#what-is-a-scope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e explain, what the scope is.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d74f\"\u003eScope is a fixed duration of time or method calls in which an object exists. Another way to look at this is to think of scope as the amount of time an object’s state persists. When the scope context ends, any objects bound under that scope cannot be injected again (they are dropped from the container).\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"46f0\"\u003eKoin provides the convenient way to work with scopes tied to Android lifecycle so it was not a big deal to transfer this logic to the Decompose component lifecycle.\u003c/p\u003e\u003cp id=\"3247\"\u003eThe first what I did is created the following interface:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"04f4\"\u003eThis interface is the marker that the component that implements it has it’s own scope. It provides the \u003cem\u003eonScopeClose \u003c/em\u003ecallback (is invoked when the scope is closed), implements the \u003cem\u003eKoinScopeComponent\u003c/em\u003e (probably makes the whole magic with the injection of the right modal component) and \u003cem\u003eComponentContext\u003c/em\u003e (is needed to get the access to the lifecycle, so probably it’s enough to implement only the \u003cem\u003eLifecycle\u003c/em\u003e interface).\u003c/p\u003e\u003cp id=\"ea24\"\u003eAnd the second step I did is created these extensions:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8280\"\u003eThe first function is retrieves the already existing scope or creates the new otherwise, second is just a lazy delegate and the third is most interesting among them. It creates the scope and registers it inside the Koin, registers the callback that triggers the \u003cem\u003eonScopeClose\u003c/em\u003e method (that I declared in interface) and attaches the scope to the lifecycle, so when it is in destroyed state, the scope is closed. So, now let me show how the code is transformed.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a222\"\u003eAs you can see, components started to implement the \u003cem\u003eDecomposeScopeComponent \u003c/em\u003einterface, create the scope with the help of delegate. Now there’re no named injections and it is resolved in the DI module. \u003cem\u003eListModalComponent\u003c/em\u003e and \u003cem\u003eDetailsModalComponent \u003c/em\u003eare tied to scopes of the screens, so there’s no conflict now.\u003c/p\u003e\u003cp id=\"b022\"\u003eIf we’ll look to the \u003cem\u003eKoinComponent.get \u003c/em\u003eimplementation under the hood, we’ll see why it became possible\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b654\"\u003eSince the \u003cem\u003eDecomposeScopeComponent\u003c/em\u003e implements the \u003cem\u003eKoinScopeComponent, \u003c/em\u003edependencies are taken not from the common graph by default but from the scope. But you still have the access to the dependencies that registered without any scope since the \u003cem\u003escope.get \u003c/em\u003eiterates recursively through the other linked scopes too.\u003c/p\u003e\u003cp id=\"dcb5\"\u003eOf course, you can use the scopes not only to create other components but to inject any dependency you need.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-11-04T21:47:34.384Z",
  "modifiedTime": null
}
