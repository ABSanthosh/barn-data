{
  "id": "886318ec-5114-4df5-ae25-dcfc30063171",
  "title": "At the Mountains of Madness with Jetpack Compose",
  "link": "https://proandroiddev.com/at-the-mountains-of-madness-with-jetpack-compose-09d3625597ad?source=rss----c72404660798---4",
  "description": "",
  "author": "Costa Fotiadis",
  "published": "Mon, 21 Apr 2025 20:58:50 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "software-development",
    "jetpack-compose",
    "android-app-development",
    "androiddev",
    "android"
  ],
  "byline": "Costa Fotiadis",
  "length": 2686,
  "excerpt": "For the uninitiated, the pull-to-refresh component allows users to drag downwards at the beginning of an app‚Äôs content to refresh some data. When I tried it out, to my surprise, the pull-to-refresh‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "As part of my daily attempt to pay the bills, I had to implement some pull-to-refresh action.For the uninitiated, the pull-to-refresh component allows users to drag downwards at the beginning of an app‚Äôs content to refresh some data.Kind of like this:EnhanceWhile the pattern is quite common, it‚Äôs not exactly something one does on the day-to-day.So, I went ahead and blatantly copied the official docs.The PullToRefreshViewModel holds the loading state and has a refresh function to test things out.This is innocent enough, right?Hol‚Äô upWhen I tried it out, to my surprise, the pull-to-refresh indicator was getting completely stuck. It would not leave the screen!One would expect it to spin a bit, then hide. Or just hide immediately.But getting stuck was not in the cards.Wait, why is the frame rate indicator turned on?This will hopefully be apparent by the end of this post.Successful guesses win a Kodee plush limited edition. (lie)Is this a bug?My first thought was that this is a bug on the PullToRefreshBox side of things. As always, it‚Äôs never my fault.Just to check, I put a breakpoint on the debugger and tried again.This breakpoint was never being hit when I was initiating the pull-to-refresh action. isRefreshing was never true! üòµHow is this even possible?Ok, so the StateFlow is clearly being updated to true first, then to false. What am I missing?Since this made no sense, I decided to put a 2000ms delay and gave it another go:The indicator now animates correctly, then disappears after 2000ms.But why does it work now?On a 60 Hz refresh rate phone, the screen refreshes 60 times per second.the refresh rate indicator can be turned on in developer options60 Hz, the UI can update at most every 16.67 ms144 Hz, the UI can update at most every 6.94 msIf updates are emitted faster than the frame duration, compose will skip intermediate updates and only process the latest value for the next frame.So, in this case:On a 60 Hz deviceloadData takes 1ms to complete, for examplecompose skips the intermediate update of true, and only processes the latest false valueThe crux of the issue is that PullToRefreshBox animates and hides the indicator properly only when toggling isRefreshing in a serial manner ‚Äî first to true then to false.UpdateWhile Material3 v1.4.0-alpha01 fixes this specific issue with PullToRefreshBox, (thanks for pointing it out Florent Guillemot üôè), the premise of this problem is the same when writing any composable.The compose layer is not guaranteed to receive all updates, if they happen way too fast.While this seems self-evident now after debugging through this, it was definitely not evident when I spent almost 2 hours going mad with this. ü§£",
  "image": "https://miro.medium.com/v2/resize:fit:430/1*IVqrh6UGSIV-hDLZhqEx-Q.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"5d05\"\u003eAs part of my daily attempt to pay the bills, I had to implement some pull-to-refresh action.\u003c/p\u003e\u003cp id=\"9766\"\u003eFor the uninitiated, the pull-to-refresh component allows users to drag downwards at the beginning of an app‚Äôs content to refresh some data.\u003c/p\u003e\u003cp id=\"f1e4\"\u003eKind of like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5e3a\"\u003eEnhance\u003c/h2\u003e\u003cp id=\"ebe7\"\u003eWhile the pattern is quite common, it‚Äôs not exactly something one does on the day-to-day.\u003c/p\u003e\u003cp id=\"4e31\"\u003eSo, I went ahead and blatantly copied the \u003ca href=\"https://developer.android.com/develop/ui/compose/components/pull-to-refresh\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial docs\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9d40\"\u003eThe \u003ccode\u003ePullToRefreshViewModel\u003c/code\u003e holds the loading state and has a refresh function to test things out.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7e48\"\u003eThis is innocent enough, right?\u003c/p\u003e\u003ch2 id=\"40a4\"\u003eHol‚Äô up\u003c/h2\u003e\u003cp id=\"10fd\"\u003eWhen I tried it out, to my surprise, the\u003cstrong\u003e \u003c/strong\u003epull-to-refresh indicator was getting \u003cstrong\u003ecompletely stuck\u003c/strong\u003e. It would not leave the screen!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f7df\"\u003eOne would expect it to spin a bit, then hide. Or just hide immediately.\u003c/p\u003e\u003cp id=\"8e46\"\u003eBut getting stuck was not in the cards.\u003c/p\u003e\u003ch2 id=\"bd25\"\u003eWait, why is the frame rate indicator turned on?\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"49b2\"\u003eThis will hopefully be apparent by the end of this post.\u003c/p\u003e\u003cp id=\"f226\"\u003eSuccessful guesses win a \u003ca href=\"https://blog.jetbrains.com/kotlin/2023/04/the-kotlin-mascot-returns/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKodee plush\u003c/a\u003e limited edition. (lie)\u003c/p\u003e\u003ch2 id=\"d461\"\u003eIs this a bug?\u003c/h2\u003e\u003cp id=\"09c4\"\u003eMy first thought was that this is a bug on the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/pulltorefresh/package-summary#PullToRefreshBox(kotlin.Boolean,kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.material3.pulltorefresh.PullToRefreshState,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePullToRefreshBox\u003c/a\u003e\u003c/code\u003e side of things. As always, it‚Äôs never my fault.\u003c/p\u003e\u003cp id=\"449e\"\u003eJust to check, I put a breakpoint on the debugger and tried again.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"100c\"\u003eThis breakpoint was never being hit when I was initiating the pull-to-refresh action. \u003ccode\u003eisRefreshing\u003c/code\u003e was never \u003ccode\u003etrue\u003c/code\u003e! üòµ\u003c/p\u003e\u003ch2 id=\"74cc\"\u003eHow is this even possible?\u003c/h2\u003e\u003cp id=\"ddd8\"\u003eOk, so the \u003ccode\u003eStateFlow\u003c/code\u003e is clearly being updated to \u003ccode\u003etrue\u003c/code\u003e first, then to \u003ccode\u003efalse\u003c/code\u003e. What am I missing?\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c6a7\"\u003eSince this made no sense, I decided to put a 2000\u003cem\u003ems \u003c/em\u003edelay and gave it another go:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0a91\"\u003eThe indicator now animates correctly, then disappears after 2000\u003cem\u003ems\u003c/em\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1116\"\u003eBut why does it work now?\u003c/h2\u003e\u003cp id=\"6e73\"\u003eOn a 60 Hz refresh rate phone, the screen refreshes 60 times per second.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003ethe refresh rate indicator can be turned on in developer options\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"6036\"\u003e60 Hz, the UI can update at most every 16.67 ms\u003c/p\u003e\u003cp id=\"84a2\"\u003e144 Hz, the UI can update at most every 6.94 ms\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"edf4\"\u003eIf updates are emitted faster than the frame duration, compose will skip \u003cstrong\u003eintermediate \u003c/strong\u003eupdates and only process the \u003cstrong\u003elatest \u003c/strong\u003evalue for the next frame.\u003c/p\u003e\u003cp id=\"46c3\"\u003eSo, in this case:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"87dd\"\u003eOn a 60 Hz device\u003c/li\u003e\u003cli id=\"a1ba\"\u003e\u003ccode\u003eloadData\u003c/code\u003e takes 1\u003cem\u003ems\u003c/em\u003e to complete, for example\u003c/li\u003e\u003cli id=\"c618\"\u003ecompose \u003cstrong\u003eskips \u003c/strong\u003ethe intermediate update of \u003ccode\u003etrue\u003c/code\u003e, and only processes the latest \u003ccode\u003efalse\u003c/code\u003e value\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f334\"\u003eThe crux of the issue is that \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/pulltorefresh/package-summary#PullToRefreshBox(kotlin.Boolean,kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.material3.pulltorefresh.PullToRefreshState,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePullToRefreshBox\u003c/a\u003e\u003c/code\u003e animates and hides the indicator properly \u003cstrong\u003eonly \u003c/strong\u003ewhen toggling \u003ccode\u003eisRefreshing\u003c/code\u003e in a serial manner ‚Äî first to \u003ccode\u003etrue\u003c/code\u003e then to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5bdf\"\u003eUpdate\u003c/h2\u003e\u003cp id=\"9659\"\u003eWhile \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/compose-material3#1.4.0-alpha01\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMaterial3 v1.4.0-alpha01\u003c/a\u003e fixes this specific issue with \u003ccode\u003ePullToRefreshBox\u003c/code\u003e, (thanks for pointing it out \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/d25c9444e1aa?source=post_page---user_mention--09d3625597ad---------------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eFlorent Guillemot\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e üôè), the premise of this problem is the same when writing any composable.\u003c/p\u003e\u003cp id=\"7cf6\"\u003eThe compose layer is \u003cstrong\u003enot \u003c/strong\u003eguaranteed to receive \u003cstrong\u003eall \u003c/strong\u003eupdates, if they happen \u003cem\u003eway\u003c/em\u003e too fast.\u003c/p\u003e\u003cp id=\"4d29\"\u003eWhile this seems self-evident now after debugging through this, it was definitely \u003cstrong\u003enot \u003c/strong\u003eevident when I spent almost 2 hours going mad with this. ü§£\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-04-21T20:58:50.568Z",
  "modifiedTime": null
}
