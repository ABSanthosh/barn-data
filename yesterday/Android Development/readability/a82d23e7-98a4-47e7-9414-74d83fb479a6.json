{
  "id": "a82d23e7-98a4-47e7-9414-74d83fb479a6",
  "title": "Kotlin Multiplatform and interoperability with Swift/Objective-C",
  "link": "https://proandroiddev.com/kotlin-multiplatform-and-interoperability-with-swift-objective-c-763406d15249?source=rss----c72404660798---4",
  "description": "",
  "author": "Viktor Mykhailiv",
  "published": "Tue, 10 Jun 2025 16:01:52 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "ios",
    "android",
    "kotlin-multiplatform",
    "androiddev"
  ],
  "byline": "Viktor Mykhailiv",
  "length": 4488,
  "excerpt": "How to use Kotlin declarations in Swift/Objective-C code",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin/Native provides indirect interoperability with Swift through Objective-C.This is what the documentation says.While developing my Kotlin Multiplatform library — HealthKMP — I thought after assembling and publishing it would be ready to use in Swift right away. I was wrong.Problem 1: kotlin.Resultkotlin.Result is an inline class which is not supported in Swift/Objective-C, and as a result we get Any? here.Inlined kotlin.Resultinterface HealthManager { fun isAvailable(): Result\u003cBoolean\u003e}As a possible solution we can create our own wrapper on top of kotlin.Result:sealed interface KmpResult\u003cout T\u003e { data class Success\u003cT\u003e(val value: T) : KmpResult\u003cT\u003e data class Failure(val error: Throwable) : KmpResult\u003cNothing\u003e}inline fun \u003cT\u003e kmpResult(block: () -\u003e T): KmpResult\u003cT\u003e { return try { KmpResult.Success(block()) } catch (e: Throwable) { KmpResult.Failure(e) }}interface HealthManager { fun isAvailable(): KmpResult\u003cBoolean\u003e}And in Swift we would get:KmpResult as return typelet result = health.isAvailable()switch(result) {case let success as KmpResultSuccess\u003cKotlinBoolean\u003e: let isAuthorized : KotlinBoolean? = success.value print(\"Success \\(isAuthorized ?? false)\")case let failure as KmpResultFailure: print(\"Failure \\(failure.error.description())\")default: print(\"Unknown result\")}But even if we specify that method returns not nullable result, we still get nullable value in success case.I prefer another solution. Let’s create a wrapper for iosMain / appleMain targets:interface HealthManager { fun isAvailable(): Result\u003cBoolean\u003e}class SwiftHealthManager( private val manager: HealthManager,) { @Throws(Throwable::class) fun isAvailable(): Boolean { return manager.isAvailable().getOrThrow() }}And in Swift we would have the correct return type:Inlined return typedo { let isAvailable : Bool = try health.isAvailable() print(\"Success \\(isAvailable)\")} catch { print(\"Failure \\(error)\")}Problem 2: kotlinx.datetimeI am using kotlinx.datetime.Instant to specify a date range. But when it comes to creating its instance in Swift, it doesn’t look like I expected it to be.I want to continue using Date in Swift instead of managing a new type Kotlinx_datetimeInstant.We can extend the existing wrapper in iMain / appleMain targets to accept NSDate:class SwiftHealthManager( private val manager: HealthManager,) { @Throws(Throwable::class) suspend fun readData( startTime: NSDate, endTime: NSDate, type: HealthDataType, ): List\u003cHealthRecord\u003e { return manager.readData( startTime = startTime.toKotlinInstant(), endTime = endTime.toKotlinInstant(), type = type, ).getOrThrow() }}And now we could create Date in Swift as usual:do { let records : [HealthRecord] = try await health.readData( startTime: Calendar.current.date(byAdding: .day, value: -7, to: Date())!, endTime: Date.now, type: HealthDataTypeWeight(), ) print(\"Success \\(records.count)\")} catch { print(\"Failure \\(error.localizedDescription)\")}Problem 3: ExtensionsKotlin extensions are exported in Swift, but in order to access them we need to know the file name, they don’t behave as usual Swift extensions.And this is where SKIE comes to help.SKIE is a tool for Kotlin Multiplatform development that enhances the Swift API published from Kotlin.Intallationlibs.versions.toml:[versions]skie = \"0.10.2\"[libraries][plugins]skie = { id = \"co.touchlab.skie\", version.ref = \"skie\" }2. project build.gradle.kts:plugins { alias(libs.plugins.skie) apply false}3. KMP module build.gradle.kts:plugins { // other plugins alias(libs.plugins.skie)}And that’s it, after assembling we will get Swift friendly code.Skie resultNow we can access Kotlin extensions in Swift:Swift extension itself:extension Date { public func toKotlinInstant() -\u003e Kotlinx_datetimeInstant}The original Kotlin extension:fun NSDate.toKotlinInstant(): Instant = toKotlinInstant()Skie is not only for extensions, see here for supported Kotlin features.Final thoughtsBuilding multiplatform library using Kotlin becomes easy nowadays, we can have shareed common Kotlin code and platform specific code for each target, publish our library to maven central Kotlin Multiplatform library or as Swift library to Swift Package Manager.Check out HealthKMP — Kotlin Multiplatform library for Apple HealthKit on iOS / watchOS and Google Fit / Health Connect on Android.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*6g7V0tLeE4k77peO4Tu0SA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cblockquote\u003e\u003cp id=\"6f45\"\u003eKotlin/Native provides indirect interoperability with Swift through Objective-C.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"2b23\"\u003eThis is what the \u003ca href=\"https://kotlinlang.org/docs/native-objc-interop.html#importing-swift-objective-c-libraries-to-kotlin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e says.\u003c/p\u003e\u003cp id=\"ffaa\"\u003eWhile developing my Kotlin Multiplatform library — \u003ca href=\"https://github.com/vitoksmile/HealthKMP\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHealthKMP\u003c/a\u003e — I thought after assembling and publishing it would be ready to use in Swift right away. I was wrong.\u003c/p\u003e\u003ch2 id=\"5290\"\u003eProblem 1: kotlin.Result\u003c/h2\u003e\u003cp id=\"68ec\"\u003e\u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-result/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin.Result\u003c/a\u003e\u003c/code\u003e is an inline class which is not supported in Swift/Objective-C, and as a result we get \u003ccode\u003eAny?\u003c/code\u003e here.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eInlined kotlin.Result\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"d4c8\"\u003einterface HealthManager {\u003cp\u003e    fun isAvailable(): Result\u0026lt;Boolean\u0026gt;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"414c\"\u003eAs a possible solution we can create our own wrapper on top of \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-result/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlin.Result\u003c/a\u003e\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d5ce\"\u003esealed interface KmpResult\u0026lt;out T\u0026gt; {\u003cp\u003e    data class Success\u0026lt;T\u0026gt;(val value: T) : KmpResult\u0026lt;T\u0026gt;\u003c/p\u003e\u003cp\u003e    data class Failure(val error: Throwable) : KmpResult\u0026lt;Nothing\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einline fun \u0026lt;T\u0026gt; kmpResult(block: () -\u0026gt; T): KmpResult\u0026lt;T\u0026gt; {\u003cbr/\u003e    return try {\u003cbr/\u003e        KmpResult.Success(block())\u003cbr/\u003e    } catch (e: Throwable) {\u003cbr/\u003e        KmpResult.Failure(e)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einterface HealthManager {\u003c/p\u003e\u003cp\u003e    fun isAvailable(): KmpResult\u0026lt;Boolean\u0026gt;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eb4b\"\u003eAnd in Swift we would get:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eKmpResult as return type\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"2994\"\u003elet result = health.isAvailable()\u003cp\u003eswitch(result) {\u003cbr/\u003ecase let success as KmpResultSuccess\u0026lt;KotlinBoolean\u0026gt;:\u003cbr/\u003e    let isAuthorized : KotlinBoolean? = success.value\u003cbr/\u003e    print(\u0026#34;Success \\(isAuthorized ?? false)\u0026#34;)\u003cbr/\u003ecase let failure as KmpResultFailure:\u003cbr/\u003e    print(\u0026#34;Failure \\(failure.error.description())\u0026#34;)\u003cbr/\u003edefault:\u003cbr/\u003e    print(\u0026#34;Unknown result\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5eff\"\u003eBut even if we specify that method returns not nullable result, we still get nullable value in success case.\u003c/p\u003e\u003cp id=\"b0b1\"\u003eI prefer another solution. Let’s create a wrapper for iosMain / appleMain targets:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b8a1\"\u003einterface HealthManager {\u003cp\u003e    fun isAvailable(): Result\u0026lt;Boolean\u0026gt;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eclass SwiftHealthManager(\u003cbr/\u003e    private val manager: HealthManager,\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e    @Throws(Throwable::class)\u003cbr/\u003e    fun isAvailable(): Boolean {\u003cbr/\u003e        return manager.isAvailable().getOrThrow()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1cb0\"\u003eAnd in Swift we would have the correct return type:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eInlined return type\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"55de\"\u003edo {\u003cbr/\u003e    let isAvailable : Bool = try health.isAvailable()\u003cbr/\u003e    print(\u0026#34;Success \\(isAvailable)\u0026#34;)\u003cbr/\u003e} catch {\u003cbr/\u003e  print(\u0026#34;Failure \\(error)\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1219\"\u003eProblem 2: kotlinx.datetime\u003c/h2\u003e\u003cp id=\"b345\"\u003eI am using \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx-datetime/kotlinx-datetime/kotlinx.datetime/-instant/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx.datetime.Instant\u003c/a\u003e\u003c/code\u003e to specify a date range. But when it comes to creating its instance in Swift, it doesn’t look like I expected it to be.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0a2e\"\u003eI want to continue using \u003ccode\u003eDate\u003c/code\u003e in Swift instead of managing a new type \u003ccode\u003eKotlinx_datetimeInstant\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"49ae\"\u003eWe can extend the existing wrapper in iMain / appleMain targets to accept NSDate:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a86\"\u003eclass SwiftHealthManager(\u003cbr/\u003e    private val manager: HealthManager,\u003cbr/\u003e) {\u003cp\u003e    @Throws(Throwable::class)\u003cbr/\u003e    suspend fun readData(\u003cbr/\u003e        startTime: NSDate,\u003cbr/\u003e        endTime: NSDate,\u003cbr/\u003e        type: HealthDataType,\u003cbr/\u003e    ): List\u0026lt;HealthRecord\u0026gt; {\u003cbr/\u003e        return manager.readData(\u003cbr/\u003e            startTime = startTime.toKotlinInstant(),\u003cbr/\u003e            endTime = endTime.toKotlinInstant(),\u003cbr/\u003e            type = type,\u003cbr/\u003e        ).getOrThrow()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e368\"\u003eAnd now we could create \u003ccode\u003eDate\u003c/code\u003e in Swift as usual:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d2cd\"\u003edo {\u003cbr/\u003e    let records : [HealthRecord] = try await health.readData(\u003cbr/\u003e        startTime: Calendar.current.date(byAdding: .day, value: -7, to: Date())!,\u003cbr/\u003e        endTime: Date.now,\u003cbr/\u003e        type: HealthDataTypeWeight(),\u003cbr/\u003e    )\u003cbr/\u003e    print(\u0026#34;Success \\(records.count)\u0026#34;)\u003cbr/\u003e} catch {\u003cbr/\u003e    print(\u0026#34;Failure \\(error.localizedDescription)\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"b583\"\u003eProblem 3: Extensions\u003c/h2\u003e\u003cp id=\"4b38\"\u003eKotlin extensions are exported in Swift, but in order to access them we need to know the file name, they don’t behave as usual Swift extensions.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d532\"\u003eAnd this is where SKIE comes to help.\u003c/p\u003e\u003cp id=\"e447\"\u003e\u003ca href=\"https://skie.touchlab.co/intro\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSKIE\u003c/a\u003e is a tool for Kotlin Multiplatform development that enhances the Swift API published from Kotlin.\u003c/p\u003e\u003ch2 id=\"db50\"\u003eIntallation\u003c/h2\u003e\u003col\u003e\u003cli id=\"da4d\"\u003e\u003ccode\u003elibs.versions.toml\u003c/code\u003e:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"dc69\"\u003e[versions]\u003cbr/\u003eskie = \u0026#34;0.10.2\u0026#34;\u003cp\u003e[libraries]\u003c/p\u003e\u003cp\u003e[plugins]\u003cbr/\u003eskie = { id = \u0026#34;co.touchlab.skie\u0026#34;, version.ref = \u0026#34;skie\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c693\"\u003e2. project \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cdc1\"\u003eplugins {\u003cbr/\u003e    alias(libs.plugins.skie) apply false\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8f0b\"\u003e3. KMP module \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"242d\"\u003eplugins {\u003cbr/\u003e    // other plugins\u003cbr/\u003e    alias(libs.plugins.skie)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2786\"\u003eAnd that’s it, after assembling we will get Swift friendly code.\u003c/p\u003e\u003ch2 id=\"85ad\"\u003eSkie result\u003c/h2\u003e\u003cp id=\"aecd\"\u003eNow we can access Kotlin extensions in Swift:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5d3c\"\u003eSwift extension itself:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9045\"\u003eextension Date {\u003cp\u003e    public func toKotlinInstant() -\u0026gt; Kotlinx_datetimeInstant\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8e74\"\u003eThe original Kotlin extension:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1fff\"\u003efun NSDate.toKotlinInstant(): Instant = toKotlinInstant()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ff6\"\u003eSkie is not only for extensions, see \u003ca href=\"https://skie.touchlab.co/features/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e for supported Kotlin features.\u003c/p\u003e\u003ch2 id=\"1184\"\u003eFinal thoughts\u003c/h2\u003e\u003cp id=\"fab0\"\u003eBuilding multiplatform library using Kotlin becomes easy nowadays, we can have shareed common Kotlin code and platform specific code for each target, publish our library to maven central Kotlin Multiplatform library or as Swift library to Swift Package Manager.\u003c/p\u003e\u003cp id=\"cbb3\"\u003eCheck out \u003ca href=\"https://github.com/vitoksmile/HealthKMP\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHealthKMP\u003c/a\u003e — Kotlin Multiplatform library for Apple HealthKit on iOS / watchOS and Google Fit / Health Connect on Android.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-06-10T16:01:51.947Z",
  "modifiedTime": null
}
