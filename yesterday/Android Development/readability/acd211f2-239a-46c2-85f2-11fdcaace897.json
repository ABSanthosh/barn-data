{
  "id": "acd211f2-239a-46c2-85f2-11fdcaace897",
  "title": "Problems with dispatchers",
  "link": "https://blog.kotlin-academy.com/problems-with-dispatchers-37791e581a4d?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Marcin Moskala",
  "published": "Tue, 17 Jun 2025 15:07:33 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "kotlin",
    "coroutines-in-kotlin",
    "kotlin-coroutines"
  ],
  "byline": "Marcin Moskala",
  "length": 1932,
  "excerpt": "I heard that you have some problems with dispatchers. I am here to help. In today’s issue, we will start a series about dispatchers, explaining what are they and how to use them in real-life…",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "Main topicCoroutines are lightweight abstractions (representing some task to be executed) that run on top of threads. What threads? That depends on what dispatcher they have configured. Dispatchers are objects responsible for starting or resuming coroutines on threads. Each dispatcher have one or many threads it can use. It also has a queue it is using if all its threads are already in use.We have four most important dispatchers that we use:Dispatchers.Default — Used by default or for CPU-intensive operationsDispatchers. IO — Used for blocking operationsDispatchers.Main — Used operations that must be executed on the platform-specific UI threadDispatchers.Unconfined — That never changes thread.Each of those dispatchers have different variants, each with distinct use-cases, and important characteristics that need to be understood to use them well. I will discuss them one-by-one in this and next issues.Today I would like to discuss Dispatchers.Default. It is designed be used for CPU-intensive operations. It is used by default by launch and async if no dispatcher is specified in scope. Dispatchers.Default by default uses as many threads as many CPU cores your machine has (but not less than 2).When should we actually use it? The default dispatcher is the best and the only dispatcher that we need if we use libraries with a proper suspending API, and we have no exceptional cases. If you are sure that you have no blocking calls or calls that must be started on a specific thread, you should confidently use Default everywhere else. It is a good default for the backend and for the Android logic (above the presentation layer).For functions that are highly CPU-intensive, we prefer to use a limited variant of this dispatcher to prevent other processes from experiencing thread starvation.What should you do if you have blocking calls? That will be explained in the next issue, where I will explain the IO dispatcher.",
  "image": "https://miro.medium.com/v2/resize:fit:1040/0*PurxxlajsOBAvm2P.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"0c3b\"\u003eMain topic\u003c/h2\u003e\u003cp id=\"fd7e\"\u003eCoroutines are lightweight abstractions (representing some task to be executed) that run on top of threads. What threads? That depends on what dispatcher they have configured. Dispatchers are objects responsible for starting or resuming coroutines on threads. Each dispatcher have one or many threads it can use. It also has a queue it is using if all its threads are already in use.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f6fb\"\u003eWe have four most important dispatchers that we use:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9063\"\u003eDispatchers.Default — Used by default or for CPU-intensive operations\u003c/li\u003e\u003cli id=\"ec36\"\u003eDispatchers. IO — Used for blocking operations\u003c/li\u003e\u003cli id=\"1ece\"\u003eDispatchers.Main — Used operations that must be executed on the platform-specific UI thread\u003c/li\u003e\u003cli id=\"bff1\"\u003eDispatchers.Unconfined — That never changes thread.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5d38\"\u003eEach of those dispatchers have different variants, each with distinct use-cases, and important characteristics that need to be understood to use them well. I will discuss them one-by-one in this and next issues.\u003c/p\u003e\u003cp id=\"bd77\"\u003eToday I would like to discuss Dispatchers.Default. It is designed be used for CPU-intensive operations. It is used by default by launch and async if no dispatcher is specified in scope. Dispatchers.Default by default uses as many threads as many CPU cores your machine has (but not less than 2).\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4434\"\u003eWhen should we actually use it? The default dispatcher is the best and the only dispatcher that we need if we use libraries with a proper suspending API, and we have no exceptional cases. If you are sure that you have no blocking calls or calls that must be started on a specific thread, you should confidently use Default everywhere else. It is a good default for the backend and for the Android logic (above the presentation layer).\u003c/p\u003e\u003cp id=\"16fb\"\u003eFor functions that are highly CPU-intensive, we prefer to use a limited variant of this dispatcher to prevent other processes from experiencing thread starvation.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1b43\"\u003eWhat should you do if you have blocking calls? That will be explained in the next issue, where I will explain the IO dispatcher.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-06-17T15:07:33.257Z",
  "modifiedTime": null
}
