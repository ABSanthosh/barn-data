{
  "id": "519632e1-66d3-4f90-ac54-50685bdb15c3",
  "title": "Android: Comparing FileProvider vs. MediaStore + Top Interview Questions",
  "link": "https://proandroiddev.com/android-comparing-fileprovider-vs-mediastore-top-interview-questions-b2d2cf570e8c?source=rss----c72404660798---4",
  "description": "",
  "author": "Leo N",
  "published": "Mon, 03 Feb 2025 03:27:11 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "questions",
    "mediastore",
    "fileprovider",
    "interview",
    "android"
  ],
  "byline": "Leo N",
  "length": 21599,
  "excerpt": "In the world of modern android development, Jetpack Compose has revolutionized UI building, making it more intuitive and efficient. But what if you need a simple function to download, save, and share‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In the world of modern android development, Jetpack Compose has revolutionized UI building, making it more intuitive and efficient. But what if you need a simple function to download, save, and share images within your app? Whether you are building a social media app, a gallery viewer, or just need to hand images dynamically, this guide will walk you through the comparison between FileProvider and MediaStore as well as suggest some of interview questions. Now let‚Äôs go üî•üì±Access app-specific filesüìÇ What is Android FileProvider?üîÑ FileProvider in a Multi-Module Android Project?üì∏ What is Android Media Store?üö®Common Error \u0026 Solutionüìå Questions \u0026 AnswersüéØ Conclusionüì± Access app-specific filesIn many cases, your app creates files that other apps don‚Äôt need to access, or shouldn‚Äôt access. The system provides the following locations for storing such app-specific files:Internal storage directories: These directories include both a dedicated location for storing persistent files, and another location for storing cache data. The system prevents other apps from accessing these locations, and on Android 10 (API level 29) and higher, these locations are encrypted. These characteristics make these locations a good place to store sensitive data that only your app itself can access.External storage directories: These directories include both a dedicated location for storing persistent files, and another location for storing cache data. Although it‚Äôs possible for another app to access these directories if that app has the proper permissions, the files stored in these directories are meant for use only by your app. If you specifically intend to create files that other apps should be able to access, your app should store these files in the shared storage part of external storage instead.When the user uninstalls your app, the files saved in app-specific storage are removed. Because of this behavior, you shouldn‚Äôt use this storage to save anything that the user expects to persist independently of your app. For example, if your app allows users to capture photos, the user would expect that they can access those photos even after they uninstall your app. So you should instead use shared storage to save those types of files to the appropriate media collection.Scoped Storage \u0026 Why It Matters in Android 10+ üöÄIn Android 10 (API 29) and above, Google introduced Scoped Storage to improve app security and user privacy. This change restricts how apps can access files on external storage. and MediaStore is the recommended way to interact with media files.Before Scoped Storage, apps could freely read/write to Environment.getExternalStorageDirectory(), but this posed security risks since apps could access files from other apps.Note: If your app requests a storage-related permission at runtime, the user-facing dialog indicates that your app is requesting broad access to external storage, even when scoped storage is enabled.‚úÖ What Scoped Storage ChangesLimited File AccessApps can no longer freely access all files in external storage (/sdcard/).Instead, apps can only access their own app-specific directories inside:üìÇ Android/data/com.example.app/üìÇ Android/media/com.example.app/FileProvider is Required for SharingDirect file:// URIs are blocked (causes FileUriExposedException).Apps must use FileProvider.getUriForFile() to share files.Temporary Permissions for File AccessIf an app wants to share a file (e.g., an image) with another app (WhatsApp, Gmail, etc.), it must use:intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)This grants temporary permission for the receiving app to read the file.Media Store APIs for Public FilesApps should use MediaStore APIs to read/write public files (e.g., Photos, Downloads).üìÇ What is Android FileProvider?FileProvider is a special subclass of ContentProvider in Android that allows you to securely share files between different applications without exposing the internal storage file paths. It provides a way to generate content:// URIs instead of file:// URIs, which prevents issues with the Scoped Storage and File URI Exposure Exception on modern Android versions.‚úÖ Securely share files between apps.‚úÖ Prevent FileUriExposedException on Android 7.0+.‚úÖ Works with camera intents, sharing files via email, social media, ‚Ä¶‚úÖ Supports multiple modules in a project.üìå Basic Implementation of FileProvider1Ô∏è‚É£ Specify the FileProvider in AndroidManifest.xmlDefining a FileProvider for your app requires an entry in your manifest. This entry specifies the authority to use in generating content URIs, as well as the name of an XML file that specifies the directories your app can share.\u003cprovider android:name=\"androidx.core.content.FileProvider\" android:authorities=\"${applicationId}.provider\" android:exported=\"false\" android:grantUriPermissions=\"true\"\u003e \u003cmeta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/filepaths\" /\u003e\u003c/provider\u003e2Ô∏è‚É£ Specify sharable directories filepaths.xml in res/xml/Once you have added the FileProvider to your app manifest, you need to specify the directories that contain the files you want to share. To specify the directories, start by creating the file filepaths.xml in the res/xml/ subdirectory of your project. In this file, specify the directories by adding an XML element for each directory. The following snippet shows you an example of the contents of res/xml/filepaths.xml. The snippet also demonstrates how to share a subdirectory of the files/ directory in your internal storage area:\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003c!-- Allow access to app-specific external storage --\u003e\u003cpaths\u003e \u003c!-- üìÇ /storage/emulated/0/Android/data/{package_name}/**/images/--\u003e \u003cexternal-files-path name=\"images\" path=\"images/\" /\u003e \u003cfiles-path name=\"myimages\" path=\"images/\" /\u003e\u003c/paths\u003eIn this example:external-files-path: Refers to the app's external storageexternal-cache-path: Refers to the app's external cache directory\u003cfiles-path\u003e tag shares directories within the files/ directory of your app's internal storage. The path attribute shares the images/ subdirectory of files/. The name attribute tells the FileProvider to add the path segment myimages to content URIs for files in the files/images/ subdirectory.Example of using context.cacheDirNote: The XML file is the only way you can specify the directories you want to share; you can‚Äôt programmatically add a directory.3Ô∏è‚É£ Define the BuildConfigBuildConfigbuildConfigField(\"String\", \"FILE_PROVIDER\", \"\\\"provider\\\"\")FileProviderimport androidx.core.content.FileProvider as AndroidFileProviderinterface FileProvider { @Throws(Exception::class) fun getUri(context: Context, file: File): Uri? { val authority = authority(context) return AndroidFileProvider.getUriForFile(context, authority, file) } companion object : FileProvider { val authority = { context: Context -\u003e \"${context.applicationContext.packageName}.${BuildConfig.FILE_PROVIDER}\" } }üÜö FileProvider in a Multi-Module Android Project?By default, FileProvider is tied to an authority (e.g., com.example.app.fileprovider), which is unique per module. In a multi-module project, each module cannot define its own FileProvider with the same authority. Instead, follow these steps:Approach 1: Declare FileProvider in the App ModuleAllow feature modules to access FileProviderPass the Context of the main application to the modules.Use FileProvider.getUriForFile(...) in the modules with the app‚Äôs authority (com.example.app.fileprovider).Approach 2: Create a Shared Module for FileProviderCreate a new module (e.g., foundation-io).Define the FileProvider in foundation-io and expose a method:All modules will use this method to get the URI.üìä Comparison of Approach 1 and Approach 2:Use Approach 1 (App Module) if:Your project is small or medium-sized.You don‚Äôt plan to reuse FileProvider in multiple apps.Simplicity is more important than modularity.Use Approach 2 (Shared Module) if:Your project is large, with multiple feature modules.You want to decouple FileProvider from the main app.You might reuse the shared module in other projects.Your team follows clean architecture and modularization best practices.If you‚Äôre working on a large-scale project with multiple modules (e.g., a super app, SDK-based architecture), Approach 2 (Shared Module) is the best choice because it promotes scalability, reusability, and maintainability. However, if you just need quick file sharing in a single app, Approach 1 (App Module) is simpler and works fine.üì∏ What is Android Media Store?The contract between the media provider and applications. Contains definitions for the supported URIs and columns. The media provider provides an indexed collection of common media types, such as Audio, Video, and Images, from any attached storage devices. Each collection is organized based on the primary MIME type of the underlying content; for example, image/* content is indexed under Images. The Files collection provides a broad view across all collections, and does not filter by MIME type.1Ô∏è‚É£ Query Media Files (Images)public void getAllImages(Context context) { Uri collection = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; String[] projection = { MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAY_NAME }; Cursor cursor = context.getContentResolver().query( collection, projection, null, null, MediaStore.Images.Media.DATE_ADDED + \" DESC\" ); if (cursor != null) { while (cursor.moveToNext()) { int id = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)); String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)); Uri imageUri = Uri.withAppendedPath(collection, String.valueOf(id)); Log.d(\"MediaStore\", \"Image: \" + name + \", URI: \" + imageUri); } cursor.close(); }}2Ô∏è‚É£ Insert a New Imagepublic Uri saveImageToGallery(Context context, Bitmap bitmap, String filename) { ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DISPLAY_NAME, filename); values.put(MediaStore.Images.Media.MIME_TYPE, \"image/png\"); values.put(MediaStore.Images.Media.RELATIVE_PATH, \"Pictures/MyApp\"); Uri imageUri = context.getContentResolver().insert( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); try { OutputStream outputStream = context.getContentResolver().openOutputStream(imageUri); bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream); outputStream.close(); return imageUri; } catch (Exception e) { e.printStackTrace(); return null; }}üìù Note:The RELATIVE_PATH specifies where the image is stored (Pictures/MyApp).No WRITE_EXTERNAL_STORAGE permission needed from Android 10+.3Ô∏è‚É£ Delete a Media Filepublic boolean deleteImage(Context context, Uri uri) { int deleted = context.getContentResolver().delete(uri, null, null); return deleted \u003e 0;}üîπ Permissions Needed:Android 10+: No storage permission required, as long as using MediaStore.Android 9 and below: Requires WRITE_EXTERNAL_STORAGE permission.4Ô∏è‚É£ Update Media File Metadatapublic void updateMediaDetails(Context context, Uri uri, String newTitle) { ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DISPLAY_NAME, newTitle); context.getContentResolver().update(uri, values, null, null);}The system automatically scans an external storage volume and adds media files to the following well-defined collections:Images, including photographs and screenshots, which are stored in the DCIM/ and Pictures/ directories. The system adds these files to the MediaStore.Images table.Videos, which are stored in the DCIM/, Movies/, and Pictures/ directories. The system adds these files to the MediaStore.Video table.Audio files, which are stored in the Alarms/, Audiobooks/, Music/, Notifications/, Podcasts/, and Ringtones/ directories. Additionally, the system recognizes audio playlists that are in the Music/ or Movies/ directories as well as voice recordings that are in the Recordings/ directory. The system adds these files to the MediaStore.Audio table. The Recordings/ directory isn't available on Android 11 (API level 30) and lower.Downloaded files, which are stored in the Download/ directory. On devices that run Android 10 (API level 29) and higher, these files are stored in the MediaStore.Downloads table. This table isn't available on Android 9 (API level 28) and lower.üö®Common Error \u0026 Solution1Ô∏è‚É£ SecurityException: Permission Deniedjava.lang.SecurityException: Permission Denial: writing Uri content://media/external/images/media from pid=12345, uid=10085 requires android.permission.WRITE_EXTERNAL_STORAGECause:Your app is targeting Android 10+ and trying to write to shared storage without using MediaStore.You did not request WRITE_EXTERNAL_STORAGE (Android 9 and below).Solution:‚úÖ Use MediaStore API for Android 10+ instead of direct file paths.‚úÖ No permission required for public media directories on Android 11+.ContentValues values = new ContentValues();values.put(MediaStore.Images.Media.DISPLAY_NAME, \"my_image.jpg\");values.put(MediaStore.Images.Media.MIME_TYPE, \"image/jpeg\");values.put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES);Uri uri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);2Ô∏è‚É£ File Not Found Exceptionjava.io.FileNotFoundException: open failed: ENOENT (No such file or directory)Cause:The file path is incorrect or does not exist.You are trying to access a file before it has been saved.Solution:‚úÖ Verify the file exists before accessing it.‚úÖ Ensure you have write permissions if using direct storage access.3Ô∏è‚É£ Image Not Appearing in GalleryCause: Media file is saved, but not indexed by MediaScanner.Solution: ‚úÖ Manually scan the file after saving.MediaScannerConnection.scanFile(context, new String[]{file.getAbsolutePath()}, new String[]{\"image/jpeg\"}, (path, uri) -\u003e Log.d(\"MediaScanner\", \"File Scanned: \" + path));4Ô∏è‚É£ FileUriExposedException (Android 7+)Direct file paths (file://) are not allowed for sharing files across apps in Android 7+.android.os.FileUriExposedException: file:///storage/emulated/0/my_file.pdf exposed beyond app through ClipData.Item.getUri()Solution: ‚úÖ Use FileProvider to generate a content URI instead.Uri uri = FileProvider.getUriForFile(context, context.getPackageName() + \".fileprovider\", new File(filePath));Intent intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(uri, \"application/pdf\");intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);startActivity(intent);5Ô∏è‚É£ android:authorities Not Matchingjava.lang.IllegalArgumentException: Couldn't find meta-data for provider with authority com.example.wrong.fileproviderCause: The authority name in AndroidManifest.xml does not match the one used in FileProvider.getUriForFile().Solution: ‚úÖ Ensure the android:authorities in AndroidManifest.xml matches exactly.6Ô∏è‚É£ Permission Denied When Opening a Shared Filejava.lang.SecurityException: Permission Denial: reading Uri content://com.example.myapp.fileprovider/my_files/test.pdfCause: The receiving app does not have permission to read the file.Solution: ‚úÖ Grant temporary read permissions when sharing a file.intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);7Ô∏è‚É£ Failed to find configured root that contains ‚Ä¶./storage/emulated/0/Pictures/..The error ‚ÄúFailed to find configured root that contains‚Ä¶‚Äù usually occurs when trying to share a file without proper FileProvider configuration. In Android 7.0 (API 24) and above, direct file:// URIs cannot be shared between apps due to security restrictions. Instead, you need to use a content:// URI via FileProvider.Inside the \u003capplication\u003e tag:\u003cprovider android:name=\"androidx.core.content.FileProvider\" android:authorities=\"${applicationId}.provider\" android:exported=\"false\" android:grantUriPermissions=\"true\"\u003e \u003cmeta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/file_paths\" /\u003e\u003c/provider\u003efile_paths.xml\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cpaths\u003e \u003c!-- Allow access to app-specific external storage --\u003e \u003cexternal-files-path name=\"pictures\" path=\"Pictures/\" /\u003e\u003c/paths\u003eCode// App-specific external storageval picturesDir = File(context.getExternalFilesDir(null), \"Pictures\")picturesDir.mkdirs() // Ensure the directory existsüìå Questions \u0026 Answers1Ô∏è‚É£ What is MediaStore in Android?MediaStore is an API that provides structured access to media files (images, videos, audio) stored on external storage. It allows querying, inserting, and updating media files without requiring direct file path access.2Ô∏è‚É£ How much space does your data require?Internal storage has limited space for app-specific data. Use other types of storage if you need to save a substantial amount of data.3Ô∏è‚É£ How reliable does data access need to be?If your app‚Äôs basic functionality requires certain data, such as when your app is starting up, place the data within internal storage directory or a database. App-specific files that are stored in external storage aren‚Äôt always accessible because some devices allow users to remove a physical device that corresponds to external storage.4Ô∏è‚É£ What are the advantages of using MediaStore over File API?‚úÖ No storage permission required (Android 10+).‚úÖ Works with scoped storage (File API does not).‚úÖ Structured access to media files.‚úÖ Auto indexing by the system.5Ô∏è‚É£ What is FileProvider in Android?FileProvider is a content provider (ContentProvider) that allows secure file sharing between apps using content:// URIs instead of file:// paths.7Ô∏è‚É£ Should the data be private to your app?When storing sensitive data ‚Äî data that shouldn‚Äôt be accessible from any other app ‚Äî use internal storage, preferences, or a database. Internal storage has the added benefit of the data being hidden from users.8Ô∏è‚É£ What is Scoped Storage in Android?Scoped Storage (introduced in Android 10) restricts direct access to shared storage and requires apps to use MediaStore or FileProvider.9Ô∏è‚É£ How do you access files in Scoped Storage?For media files: Use MediaStore APIFor app-specific files: Use getExternalFilesDir()For file sharing: Use FileProviderTo give users more control over their files and limit file clutter, Android 10 introduced a new storage paradigm for apps called scoped storage. Scoped storage changes the way apps store and access files on a device‚Äôs external storage. To help you migrate your app to support scoped storage, follow the best practices for common storage use cases that are outlined in this guide. The use cases are organized into two categories: handling media files and handling non-media files.üéØ ConclusionBy leveraging Jetpack Compose,FileProvider, and Kotlin, we can easily download, store, and share images in an Android app. This approach ensures smooth performance, proper file handling, and seamless sharing across different applications. Whether you are working on an image-heavy app or simply adding a sharing feature, mastering these techniques will enhance your development workflow üöÄüí°üîπ MediaStore (Scoped Storage API)Purpose:MediaStore is part of the Scoped Storage model introduced in Android 10 (API 29).It provides access to public media files (e.g., images, videos, and audio) stored in shared storage, without needing READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE permissions (from Android 11 onwards).Use Cases:Saving media files (images, videos, audio) in public directories (e.g., Pictures/, Movies/).Querying and managing media content using the ContentResolver API.Ensuring compliance with Scoped Storage, as direct file path access is restricted.Advantages:‚úÖ No need for storage permissions (from Android 11+).‚úÖ Works with Scoped Storage, avoiding direct file access.‚úÖ Provides a content URI, making it safer for media handling.‚úÖ Compatible with MediaScanner for indexing media files.Disadvantages:‚ùå Cannot store non-media files (e.g., PDFs, ZIPs).‚ùå Requires querying APIs (instead of direct file access)‚ùå Files are not private ‚Äî they‚Äôre accessible to all apps with read access to shared storage.üîπFileProvider (For Secure File Sharing)Purpose:FileProvider is a special ContentProvider that allows an app to share private files securely with other apps using a content URI, rather than exposing raw file paths.Use Cases:Sharing files (PDFs, images, videos, etc.) with other apps (e.g., email, social media, or messaging apps).Providing a secure way to expose app-private storage files (inside data/data/\u003cpackage\u003e/files).Granting temporary read/write access to specific files.Advantages:‚úÖ Secure file sharing (avoids exposing raw file paths).‚úÖ Supports any file type, not just media files.‚úÖ Provides temporary access permissions using FLAG_GRANT_READ_URI_PERMISSION.‚úÖ Works with intent-based sharing (e.g., Intent.ACTION_SEND).Disadvantages:‚ùå Requires defining a FileProvider in AndroidManifest.xml.‚ùå Needs XML configuration for file paths.‚ùå More complex setup compared to direct file sharing.https://developer.android.com/training/data-storage/app-specifichttps://developer.android.com/training/data-storage/sharedhttps://developer.android.com/training/secure-file-sharing/setup-sharinghttps://developer.android.com/training/secure-file-sharing/retrieve-infohttps://developer.android.com/training/data-storagehttps://developer.android.com/studio/debug/device-file-explorerhttps://developer.android.com/training/sharing/send",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*Sx4veSpq_Z1oYBsP5Q7nwQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://nphausg.medium.com/?source=post_page---byline--b2d2cf570e8c--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Leo N\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Tb0dILXcghQeKPocCvlv6g.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--b2d2cf570e8c--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1ecb\"\u003eIn the world of modern android development, \u003cstrong\u003eJetpack Compose \u003c/strong\u003ehas revolutionized UI building, making it more intuitive and efficient. But what if you need a simple function to download, save, and share images within your app? Whether you are building a social media app, a gallery viewer, or just need to hand images dynamically, \u003cstrong\u003ethis guide will walk you through the \u003c/strong\u003ecomparison between \u003ccode\u003eFileProvider\u003c/code\u003e and \u003ccode\u003eMediaStore\u003c/code\u003e as well as suggest some of interview questions. Now let‚Äôs go üî•\u003c/p\u003e\u003cul\u003e\u003cli id=\"68d3\"\u003eüì±Access app-specific files\u003c/li\u003e\u003cli id=\"3db3\"\u003eüìÇ What is Android \u003ccode\u003eFileProvider\u003c/code\u003e?\u003c/li\u003e\u003cli id=\"3114\"\u003eüîÑ \u003ccode\u003eFileProvider\u003c/code\u003e in a Multi-Module Android Project?\u003c/li\u003e\u003cli id=\"0cb8\"\u003eüì∏ What is Android \u003ccode\u003eMedia Store\u003c/code\u003e?\u003c/li\u003e\u003cli id=\"94ea\"\u003eüö®Common Error \u0026amp; Solution\u003c/li\u003e\u003cli id=\"5bfc\"\u003eüìå Questions \u0026amp; Answers\u003c/li\u003e\u003cli id=\"3726\"\u003eüéØ Conclusion\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b718\"\u003eüì± Access app-specific files\u003c/h2\u003e\u003cp id=\"294a\"\u003eIn many cases, your app creates files that other apps don‚Äôt need to access, or shouldn‚Äôt access. The system provides the following locations for storing such \u003cem\u003eapp-specific\u003c/em\u003e files:\u003c/p\u003e\u003cul\u003e\u003cli id=\"49ff\"\u003e\u003cstrong\u003eInternal storage directories:\u003c/strong\u003e These directories include both a dedicated location for storing persistent files, and another location for storing cache data. The system prevents other apps from accessing these locations, and on Android 10 (API level 29) and higher, these locations are encrypted. These characteristics make these locations a good place to store sensitive data that only your app itself can access.\u003c/li\u003e\u003cli id=\"4732\"\u003e\u003cstrong\u003eExternal storage directories:\u003c/strong\u003e These directories include both a dedicated location for storing persistent files, and another location for storing cache data. Although it‚Äôs possible for another app to access these directories if that app has the proper permissions, the files stored in these directories are meant for use only by your app. If you specifically intend to create files that other apps should be able to access, your app should store these files in the \u003ca href=\"https://developer.android.com/training/data-storage/shared\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eshared storage\u003c/a\u003e part of external storage instead.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"4fb7\"\u003eWhen the user uninstalls your app, the files saved in app-specific storage are removed. Because of this behavior, you shouldn‚Äôt use this storage to save anything that the user expects to persist independently of your app. For example, if your app allows users to capture photos, the user would expect that they can access those photos even after they uninstall your app. So you should instead use shared storage to save those types of files to the appropriate \u003ca href=\"https://developer.android.com/training/data-storage/shared/media\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emedia collection\u003c/a\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"0393\"\u003eScoped Storage \u0026amp; Why It Matters in Android 10+ üöÄ\u003c/h2\u003e\u003cp id=\"d27c\"\u003eIn \u003cstrong\u003eAndroid 10 (API 29)\u003c/strong\u003e and above, Google introduced \u003cstrong\u003eScoped Storage\u003c/strong\u003e to improve app security and user privacy. This change \u003cstrong\u003erestricts\u003c/strong\u003e how apps can access files on external storage. and \u003cstrong\u003eMediaStore\u003c/strong\u003e is the recommended way to interact with media files.\u003c/p\u003e\u003cp id=\"1c14\"\u003eBefore \u003cstrong\u003eScoped Storage\u003c/strong\u003e, apps could freely read/write to \u003ccode\u003eEnvironment.getExternalStorageDirectory()\u003c/code\u003e, but this \u003cstrong\u003eposed security risks\u003c/strong\u003e since apps could access files from other apps.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"dd88\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If your app requests a storage-related permission at runtime, the user-facing dialog indicates that your app is requesting broad access to external storage, even when scoped storage is enabled.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"3f45\"\u003e‚úÖ What Scoped Storage Changes\u003c/h2\u003e\u003cp id=\"937f\"\u003e\u003cstrong\u003eLimited File Access\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"432a\"\u003eApps can no longer \u003cstrong\u003efreely access\u003c/strong\u003e all files in external storage (\u003ccode\u003e/sdcard/\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"b222\"\u003eInstead, apps can only access \u003cstrong\u003etheir own app-specific directories\u003c/strong\u003e inside:\u003c/li\u003e\u003cli id=\"97a8\"\u003eüìÇ \u003ccode\u003eAndroid/data/com.example.app/\u003c/code\u003e\u003c/li\u003e\u003cli id=\"607b\"\u003eüìÇ \u003ccode\u003eAndroid/media/com.example.app/\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ede7\"\u003e\u003cstrong\u003eFileProvider is Required for Sharing\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"eb7a\"\u003eDirect \u003ccode\u003e\u003cstrong\u003efile://\u003c/strong\u003e\u003c/code\u003e URIs are \u003cstrong\u003eblocked\u003c/strong\u003e (causes \u003ccode\u003eFileUriExposedException\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"897d\"\u003eApps must \u003cstrong\u003euse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eFileProvider.getUriForFile()\u003c/strong\u003e\u003c/code\u003e to share files.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9026\"\u003e\u003cstrong\u003eTemporary Permissions for File Access\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"3a6e\"\u003eIf an app wants to share a file (e.g., an image) with another app (WhatsApp, Gmail, etc.), it must use:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"7d06\"\u003eintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"fb00\"\u003eThis grants temporary permission for the receiving app to read the file.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"444c\"\u003e\u003cstrong\u003eMedia Store APIs for Public Files\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"47ea\"\u003eApps should use \u003ccode\u003e\u003cstrong\u003eMediaStore\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e APIs\u003c/strong\u003e to read/write \u003cstrong\u003epublic\u003c/strong\u003e files (e.g., Photos, Downloads).\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"054c\"\u003eüìÇ What is Android \u003ccode\u003eFileProvider\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"dca6\"\u003e\u003ccode\u003eFileProvider\u003c/code\u003e is a special subclass of \u003ccode\u003eContentProvider\u003c/code\u003e in Android that allows you to securely share files between different applications without exposing the internal storage file paths. It provides a way to generate \u003ccode\u003econtent://\u003c/code\u003e URIs instead of \u003ccode\u003efile://\u003c/code\u003e URIs, which prevents issues with the \u003cstrong\u003eScoped Storage\u003c/strong\u003e and \u003cstrong\u003eFile URI Exposure Exception\u003c/strong\u003e on modern Android versions.\u003c/p\u003e\u003cul\u003e\u003cli id=\"1e9b\"\u003e‚úÖ Securely share files between apps.\u003c/li\u003e\u003cli id=\"6788\"\u003e‚úÖ Prevent \u003ccode\u003eFileUriExposedException\u003c/code\u003e on Android 7.0+.\u003c/li\u003e\u003cli id=\"2b4c\"\u003e‚úÖ Works with \u003cstrong\u003ecamera intents, sharing files via email, social media, ‚Ä¶\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"ebdf\"\u003e‚úÖ Supports multiple modules in a project.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ee9a\"\u003eüìå Basic Implementation of \u003ccode\u003eFileProvider\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3446\"\u003e1Ô∏è‚É£ Specify the \u003ccode\u003eFileProvider\u003c/code\u003e in \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e\u003c/p\u003e\u003cp id=\"0cb1\"\u003eDefining a \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/core/content/FileProvider\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFileProvider\u003c/a\u003e\u003c/code\u003e for your app requires an entry in your manifest. This entry specifies the authority to use in generating content URIs, as well as the name of an XML file that specifies the directories your app can share.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fb97\"\u003e\u0026lt;provider\u003cbr/\u003e    android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34;\u003cbr/\u003e    android:authorities=\u0026#34;${applicationId}.provider\u0026#34;\u003cbr/\u003e    android:exported=\u0026#34;false\u0026#34;\u003cbr/\u003e    android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt;\u003cbr/\u003e    \u0026lt;meta-data\u003cbr/\u003e        android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34;\u003cbr/\u003e        android:resource=\u0026#34;@xml/filepaths\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/provider\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e341\"\u003e2Ô∏è‚É£ Specify sharable directories \u003ccode\u003efilepaths.xml\u003c/code\u003e in \u003ccode\u003eres/xml/\u003c/code\u003e\u003c/p\u003e\u003cp id=\"d7f8\"\u003eOnce you have added the \u003ccode\u003eFileProvider\u003c/code\u003e to your app manifest, you need to specify the directories that contain the files you want to share. To specify the directories, start by creating the file \u003ccode\u003efilepaths.xml\u003c/code\u003e in the \u003ccode\u003eres/xml/\u003c/code\u003e subdirectory of your project. In this file, specify the directories by adding an XML element for each directory. The following snippet shows you an example of the contents of \u003ccode\u003eres/xml/filepaths.xml\u003c/code\u003e. The snippet also demonstrates how to share a subdirectory of the \u003ccode\u003efiles/\u003c/code\u003e directory in your internal storage area:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"73c2\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;!-- Allow access to app-specific external storage --\u0026gt;\u003cp\u003e\u0026lt;paths\u0026gt;\u003cbr/\u003e    \u0026lt;!-- üìÇ /storage/emulated/0/Android/data/{package_name}/**/images/--\u0026gt;\u003cbr/\u003e    \u0026lt;external-files-path\u003cbr/\u003e        name=\u0026#34;images\u0026#34;\u003cbr/\u003e        path=\u0026#34;images/\u0026#34; /\u0026gt;\u003cbr/\u003e    \u0026lt;files-path\u003cbr/\u003e        name=\u0026#34;myimages\u0026#34;\u003cbr/\u003e        path=\u0026#34;images/\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/paths\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ca14\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3ac8\"\u003e\u003ccode\u003eexternal-files-path\u003c/code\u003e: Refers to the app\u0026#39;s external storage\u003c/li\u003e\u003cli id=\"0956\"\u003e\u003ccode\u003eexternal-cache-path\u003c/code\u003e: Refers to the app\u0026#39;s external cache directory\u003c/li\u003e\u003cli id=\"b85a\"\u003e\u003ccode\u003e\u0026lt;files-path\u0026gt;\u003c/code\u003e tag shares directories within the \u003ccode\u003efiles/\u003c/code\u003e directory of your app\u0026#39;s internal storage. The \u003ccode\u003epath\u003c/code\u003e attribute shares the \u003ccode\u003eimages/\u003c/code\u003e subdirectory of \u003ccode\u003efiles/\u003c/code\u003e. The \u003ccode\u003ename\u003c/code\u003e attribute tells the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/core/content/FileProvider\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFileProvider\u003c/a\u003e\u003c/code\u003e to add the path segment \u003ccode\u003emyimages\u003c/code\u003e to content URIs for files in the \u003ccode\u003efiles/images/\u003c/code\u003e subdirectory.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eExample of using context.cacheDir\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"6a9a\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The XML file is the only way you can specify the directories you want to share; you can‚Äôt programmatically add a directory.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"524b\"\u003e3Ô∏è‚É£ Define the \u003ccode\u003eBuildConfig\u003c/code\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a2a6\"\u003eBuildConfig\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"c0e8\"\u003ebuildConfigField(\u0026#34;String\u0026#34;, \u0026#34;FILE_PROVIDER\u0026#34;, \u0026#34;\\\u0026#34;provider\\\u0026#34;\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"bcd4\"\u003eFileProvider\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"f831\"\u003e\u003cbr/\u003eimport androidx.core.content.FileProvider as AndroidFileProvider\u003cp\u003einterface FileProvider {\u003c/p\u003e\u003cp\u003e    @Throws(Exception::class)\u003cbr/\u003e    fun getUri(context: Context, file: File): Uri? {\u003cbr/\u003e        val authority = authority(context)\u003cbr/\u003e        return AndroidFileProvider.getUriForFile(context, authority, file)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    companion object : FileProvider {\u003cbr/\u003e        val authority = { context: Context -\u0026gt;\u003cbr/\u003e            \u0026#34;${context.applicationContext.packageName}.${BuildConfig.FILE_PROVIDER}\u0026#34;\u003cbr/\u003e       }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6e74\"\u003eüÜö \u003ccode\u003eFileProvider\u003c/code\u003e in a Multi-Module Android Project?\u003c/h2\u003e\u003cp id=\"6104\"\u003eBy default, \u003ccode\u003eFileProvider\u003c/code\u003e is tied to an \u003ccode\u003eauthority\u003c/code\u003e (e.g., \u003ccode\u003ecom.example.app.fileprovider\u003c/code\u003e), which is unique per module. In a \u003cstrong\u003emulti-module project\u003c/strong\u003e, each module \u003cstrong\u003ecannot define its own \u003c/strong\u003e\u003ccode\u003eFileProvider\u003c/code\u003e with the same \u003ccode\u003eauthority\u003c/code\u003e. Instead, follow these steps:\u003c/p\u003e\u003cp id=\"b7aa\"\u003e\u003cstrong\u003eApproach 1: \u003c/strong\u003eDeclare \u003ccode\u003eFileProvider\u003c/code\u003e in the App Module\u003c/p\u003e\u003cul\u003e\u003cli id=\"115d\"\u003eAllow feature modules to access \u003ccode\u003eFileProvider\u003c/code\u003e\u003c/li\u003e\u003cli id=\"949f\"\u003ePass the \u003ccode\u003eContext\u003c/code\u003e of the main application to the modules.\u003c/li\u003e\u003cli id=\"d66f\"\u003eUse \u003ccode\u003eFileProvider.getUriForFile(...)\u003c/code\u003e in the modules with the \u003cstrong\u003eapp‚Äôs authority\u003c/strong\u003e (\u003ccode\u003ecom.example.app.fileprovider\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a0c7\"\u003e\u003cstrong\u003eApproach 2:\u003c/strong\u003e Create a Shared Module for FileProvider\u003c/p\u003e\u003cul\u003e\u003cli id=\"0213\"\u003eCreate a new module (e.g., \u003ccode\u003efoundation-io\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"f0cd\"\u003eDefine the \u003ccode\u003eFileProvider\u003c/code\u003e in \u003ccode\u003efoundation-io\u003c/code\u003e and expose a method:\u003c/li\u003e\u003cli id=\"19e0\"\u003eAll modules will use this method to get the URI.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f1f6\"\u003eüìä Comparison of Approach 1 and Approach 2:\u003c/h2\u003e\u003cp id=\"f6d3\"\u003e\u003cstrong\u003eUse Approach 1 (App Module) if:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0f1f\"\u003eYour project is small or medium-sized.\u003c/li\u003e\u003cli id=\"f279\"\u003eYou don‚Äôt plan to reuse \u003ccode\u003eFileProvider\u003c/code\u003e in multiple apps.\u003c/li\u003e\u003cli id=\"c6ff\"\u003eSimplicity is more important than modularity.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e69c\"\u003e\u003cstrong\u003eUse Approach 2 (Shared Module) if:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1bfe\"\u003eYour project is large, with multiple feature modules.\u003c/li\u003e\u003cli id=\"b651\"\u003eYou want to \u003cstrong\u003edecouple\u003c/strong\u003e \u003ccode\u003eFileProvider\u003c/code\u003e from the main app.\u003c/li\u003e\u003cli id=\"7b23\"\u003eYou might reuse the shared module in other projects.\u003c/li\u003e\u003cli id=\"2029\"\u003eYour team follows \u003cstrong\u003eclean architecture and modularization\u003c/strong\u003e best practices.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"837c\"\u003eIf you‚Äôre working on a \u003cstrong\u003elarge-scale project\u003c/strong\u003e with multiple modules (e.g., a super app, SDK-based architecture), \u003cstrong\u003eApproach 2 (Shared Module) is the best choice\u003c/strong\u003e because it promotes \u003cstrong\u003escalability, reusability, and maintainability\u003c/strong\u003e. However, if you \u003cstrong\u003ejust need quick file sharing in a single app\u003c/strong\u003e, \u003cstrong\u003eApproach 1 (App Module) is simpler and works fine.\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"65c7\"\u003eüì∏ What is Android \u003ccode\u003eMedia Store\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"192f\"\u003eThe contract between the media provider and applications. Contains definitions for the supported URIs and columns. The media provider provides an indexed collection of common media types, such as \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Audio\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAudio\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Video\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eVideo\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Images\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eImages\u003c/a\u003e\u003c/code\u003e, from any attached storage devices. Each collection is organized based on the primary MIME type of the underlying content; for example, \u003ccode\u003eimage/*\u003c/code\u003e content is indexed under \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Images\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eImages\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Files\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFiles\u003c/a\u003e\u003c/code\u003e collection provides a broad view across all collections, and does not filter by MIME type.\u003c/p\u003e\u003ch2 id=\"c864\"\u003e1Ô∏è‚É£ Query Media Files (Images)\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"092c\"\u003epublic void getAllImages(Context context) {\u003cbr/\u003e    Uri collection = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\u003cp\u003e    String[] projection = {\u003cbr/\u003e            MediaStore.Images.Media._ID,\u003cbr/\u003e            MediaStore.Images.Media.DISPLAY_NAME\u003cbr/\u003e    };\u003c/p\u003e\u003cp\u003e    Cursor cursor = context.getContentResolver().query(\u003cbr/\u003e            collection,\u003cbr/\u003e            projection,\u003cbr/\u003e            null, null,\u003cbr/\u003e            MediaStore.Images.Media.DATE_ADDED + \u0026#34; DESC\u0026#34;\u003cbr/\u003e    );\u003c/p\u003e\u003cp\u003e    if (cursor != null) {\u003cbr/\u003e        while (cursor.moveToNext()) {\u003cbr/\u003e            int id = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID));\u003cbr/\u003e            String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME));\u003c/p\u003e\u003cp\u003e            Uri imageUri = Uri.withAppendedPath(collection, String.valueOf(id));\u003cbr/\u003e            Log.d(\u0026#34;MediaStore\u0026#34;, \u0026#34;Image: \u0026#34; + name + \u0026#34;, URI: \u0026#34; + imageUri);\u003cbr/\u003e        }\u003cbr/\u003e        cursor.close();\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"cdc0\"\u003e2Ô∏è‚É£ Insert a New Image\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"c014\"\u003epublic Uri saveImageToGallery(Context context, Bitmap bitmap, String filename) {\u003cbr/\u003e    ContentValues values = new ContentValues();\u003cbr/\u003e    values.put(MediaStore.Images.Media.DISPLAY_NAME, filename);\u003cbr/\u003e    values.put(MediaStore.Images.Media.MIME_TYPE, \u0026#34;image/png\u0026#34;);\u003cbr/\u003e    values.put(MediaStore.Images.Media.RELATIVE_PATH, \u0026#34;Pictures/MyApp\u0026#34;);\u003cp\u003e    Uri imageUri = context.getContentResolver().insert(\u003cbr/\u003e            MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\u003c/p\u003e\u003cp\u003e    try {\u003cbr/\u003e        OutputStream outputStream = context.getContentResolver().openOutputStream(imageUri);\u003cbr/\u003e        bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);\u003cbr/\u003e        outputStream.close();\u003cbr/\u003e        return imageUri;\u003cbr/\u003e    } catch (Exception e) {\u003cbr/\u003e        e.printStackTrace();\u003cbr/\u003e        return null;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9566\"\u003eüìù \u003cstrong\u003eNote:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8669\"\u003eThe \u003ccode\u003eRELATIVE_PATH\u003c/code\u003e specifies where the image is stored (\u003ccode\u003ePictures/MyApp\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"3abe\"\u003eNo \u003cstrong\u003eWRITE_EXTERNAL_STORAGE\u003c/strong\u003e permission needed from \u003cstrong\u003eAndroid 10+\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f6f4\"\u003e3Ô∏è‚É£ Delete a Media File\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"23ab\"\u003epublic boolean deleteImage(Context context, Uri uri) {\u003cbr/\u003e    int deleted = context.getContentResolver().delete(uri, null, null);\u003cbr/\u003e    return deleted \u0026gt; 0;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e7d6\"\u003e\u003cstrong\u003eüîπ Permissions Needed:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1a21\"\u003e\u003cstrong\u003eAndroid 10+\u003c/strong\u003e: No storage permission required, as long as using \u003ccode\u003eMediaStore\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"f89f\"\u003e\u003cstrong\u003eAndroid 9 and below\u003c/strong\u003e: Requires \u003ccode\u003eWRITE_EXTERNAL_STORAGE\u003c/code\u003e permission.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c7eb\"\u003e4Ô∏è‚É£ Update Media File Metadata\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"70a6\"\u003epublic void updateMediaDetails(Context context, Uri uri, String newTitle) {\u003cbr/\u003e    ContentValues values = new ContentValues();\u003cbr/\u003e    values.put(MediaStore.Images.Media.DISPLAY_NAME, newTitle);\u003cp\u003e    context.getContentResolver().update(uri, values, null, null);\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9ec1\"\u003eThe system automatically scans an external storage volume and adds media files to the following well-defined collections:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7901\"\u003e\u003cstrong\u003eImages,\u003c/strong\u003e including photographs and screenshots, which are stored in the \u003ccode\u003eDCIM/\u003c/code\u003e and \u003ccode\u003ePictures/\u003c/code\u003e directories. The system adds these files to the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Images\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMediaStore.Images\u003c/a\u003e\u003c/code\u003e table.\u003c/li\u003e\u003cli id=\"50f7\"\u003e\u003cstrong\u003eVideos,\u003c/strong\u003e which are stored in the \u003ccode\u003eDCIM/\u003c/code\u003e, \u003ccode\u003eMovies/\u003c/code\u003e, and \u003ccode\u003ePictures/\u003c/code\u003e directories. The system adds these files to the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Video\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMediaStore.Video\u003c/a\u003e\u003c/code\u003e table.\u003c/li\u003e\u003cli id=\"4dff\"\u003e\u003cstrong\u003eAudio files,\u003c/strong\u003e which are stored in the \u003ccode\u003eAlarms/\u003c/code\u003e, \u003ccode\u003eAudiobooks/\u003c/code\u003e, \u003ccode\u003eMusic/\u003c/code\u003e, \u003ccode\u003eNotifications/\u003c/code\u003e, \u003ccode\u003ePodcasts/\u003c/code\u003e, and \u003ccode\u003eRingtones/\u003c/code\u003e directories. Additionally, the system recognizes audio playlists that are in the \u003ccode\u003eMusic/\u003c/code\u003e or \u003ccode\u003eMovies/\u003c/code\u003e directories as well as voice recordings that are in the \u003ccode\u003eRecordings/\u003c/code\u003e directory. The system adds these files to the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Audio\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMediaStore.Audio\u003c/a\u003e\u003c/code\u003e table. \u003cem\u003eThe \u003c/em\u003e\u003ccode\u003e\u003cem\u003eRecordings/\u003c/em\u003e\u003c/code\u003e\u003cem\u003e directory isn\u0026#39;t available on Android 11 (API level 30) and lower.\u003c/em\u003e\u003c/li\u003e\u003cli id=\"4b8c\"\u003e\u003cstrong\u003eDownloaded files,\u003c/strong\u003e which are stored in the \u003ccode\u003eDownload/\u003c/code\u003e directory. On devices that run Android 10 (API level 29) and higher, these files are stored in the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/provider/MediaStore.Downloads\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMediaStore.Downloads\u003c/a\u003e\u003c/code\u003e table. \u003cem\u003eThis table isn\u0026#39;t available on Android 9 (API level 28) and lower.\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1ea6\"\u003eüö®Common Error \u0026amp; Solution\u003c/h2\u003e\u003ch2 id=\"e2a5\"\u003e1Ô∏è‚É£ SecurityException: Permission Denied\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"051c\"\u003ejava.lang.SecurityException: Permission Denial: writing Uri content://media/external/images/media from pid=12345, uid=10085 requires android.permission.WRITE_EXTERNAL_STORAGE\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"21d7\"\u003e\u003cstrong\u003eCause:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7670\"\u003eYour app is targeting \u003cstrong\u003eAndroid 10+\u003c/strong\u003e and trying to write to shared storage \u003cstrong\u003ewithout using MediaStore\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"8ca8\"\u003eYou did not request \u003cstrong\u003eWRITE_EXTERNAL_STORAGE\u003c/strong\u003e (Android 9 and below).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b224\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"af28\"\u003e‚úÖ Use \u003cstrong\u003eMediaStore\u003c/strong\u003e API for Android 10+ instead of direct file paths.\u003c/li\u003e\u003cli id=\"06ba\"\u003e‚úÖ \u003cstrong\u003eNo permission required\u003c/strong\u003e for public media directories on Android 11+.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"b7fc\"\u003eContentValues values = new ContentValues();\u003cbr/\u003evalues.put(MediaStore.Images.Media.DISPLAY_NAME, \u0026#34;my_image.jpg\u0026#34;);\u003cbr/\u003evalues.put(MediaStore.Images.Media.MIME_TYPE, \u0026#34;image/jpeg\u0026#34;);\u003cbr/\u003evalues.put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES);\u003cp\u003eUri uri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d9c9\"\u003e2Ô∏è‚É£ File Not Found Exception\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"54ae\"\u003ejava.io.FileNotFoundException: open failed: ENOENT (No such file or directory)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"db9d\"\u003e\u003cstrong\u003eCause:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"cc9c\"\u003eThe \u003cstrong\u003efile path is incorrect\u003c/strong\u003e or does not exist.\u003c/li\u003e\u003cli id=\"c35e\"\u003eYou are \u003cstrong\u003etrying to access a file before it has been saved\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5d6e\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"35dd\"\u003e‚úÖ \u003cstrong\u003eVerify the file exists\u003c/strong\u003e before accessing it.\u003c/li\u003e\u003cli id=\"1694\"\u003e‚úÖ Ensure you have \u003cstrong\u003ewrite permissions\u003c/strong\u003e if using direct storage access.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"d356\"\u003e3Ô∏è‚É£ Image Not Appearing in Gallery\u003c/h2\u003e\u003cp id=\"f41e\"\u003e\u003cstrong\u003eCause: \u003c/strong\u003eMedia file is saved, but \u003cstrong\u003enot indexed by MediaScanner\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"af5e\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e ‚úÖ \u003cstrong\u003eManually scan the file\u003c/strong\u003e after saving.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8ef3\"\u003eMediaScannerConnection.scanFile(context,\u003cbr/\u003e    new String[]{file.getAbsolutePath()},\u003cbr/\u003e    new String[]{\u0026#34;image/jpeg\u0026#34;},\u003cbr/\u003e    (path, uri) -\u0026gt; Log.d(\u0026#34;MediaScanner\u0026#34;, \u0026#34;File Scanned: \u0026#34; + path));\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1480\"\u003e4Ô∏è‚É£ FileUriExposedException (Android 7+)\u003c/h2\u003e\u003cp id=\"6435\"\u003e\u003cstrong\u003eDirect file paths (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003efile://\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e) are not allowed\u003c/strong\u003e for sharing files across apps in Android 7+.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8a4d\"\u003eandroid.os.FileUriExposedException: file:///storage/emulated/0/my_file.pdf exposed beyond app through ClipData.Item.getUri()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1bd1\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e ‚úÖ Use \u003cstrong\u003eFileProvider\u003c/strong\u003e to generate a \u003cstrong\u003econtent URI\u003c/strong\u003e instead.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aace\"\u003eUri uri = FileProvider.getUriForFile(context, context.getPackageName() + \u0026#34;.fileprovider\u0026#34;, new File(filePath));\u003cp\u003eIntent intent = new Intent(Intent.ACTION_VIEW);\u003cbr/\u003eintent.setDataAndType(uri, \u0026#34;application/pdf\u0026#34;);\u003cbr/\u003eintent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\u003cbr/\u003estartActivity(intent);\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8cf1\"\u003e5Ô∏è‚É£ android:authorities Not Matching\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9497\"\u003ejava.lang.IllegalArgumentException: Couldn\u0026#39;t find meta-data for provider with authority com.example.wrong.fileprovider\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a2a7\"\u003e\u003cstrong\u003eCause: \u003c/strong\u003eThe \u003cstrong\u003eauthority name in AndroidManifest.xml\u003c/strong\u003e does not match the one used in \u003ccode\u003eFileProvider.getUriForFile()\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ecea\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e ‚úÖ Ensure the \u003ccode\u003eandroid:authorities\u003c/code\u003e in \u003cstrong\u003eAndroidManifest.xml\u003c/strong\u003e matches exactly.\u003c/p\u003e\u003ch2 id=\"38ce\"\u003e6Ô∏è‚É£ Permission Denied When Opening a Shared File\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"87ba\"\u003ejava.lang.SecurityException: Permission Denial: reading Uri content://com.example.myapp.fileprovider/my_files/test.pdf\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b46b\"\u003e\u003cstrong\u003eCause: \u003c/strong\u003eThe receiving app \u003cstrong\u003edoes not have permission\u003c/strong\u003e to read the file.\u003c/p\u003e\u003cp id=\"c125\"\u003e\u003cstrong\u003eSolution:\u003c/strong\u003e ‚úÖ \u003cstrong\u003eGrant temporary read permissions\u003c/strong\u003e when sharing a file.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d7b1\"\u003eintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1df3\"\u003e7Ô∏è‚É£ Failed to find configured root that contains ‚Ä¶.\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003e/storage/emulated/0/Pictures/..\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"933d\"\u003eThe error \u003cstrong\u003e‚ÄúFailed to find configured root that contains‚Ä¶‚Äù\u003c/strong\u003e usually occurs when trying to share a file \u003cstrong\u003ewithout proper FileProvider configuration\u003c/strong\u003e. In \u003cstrong\u003eAndroid 7.0 (API 24) and above\u003c/strong\u003e, direct \u003cstrong\u003efile://\u003c/strong\u003e URIs cannot be shared between apps due to security restrictions. Instead, you need to use a \u003cstrong\u003econtent://\u003c/strong\u003e URI via \u003ccode\u003eFileProvider\u003c/code\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4556\"\u003eInside the \u003ccode\u003e\u0026lt;application\u0026gt;\u003c/code\u003e tag:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"0849\"\u003e\u0026lt;provider\u003cbr/\u003e    android:name=\u0026#34;androidx.core.content.FileProvider\u0026#34;\u003cbr/\u003e    android:authorities=\u0026#34;${applicationId}.provider\u0026#34;\u003cbr/\u003e    android:exported=\u0026#34;false\u0026#34;\u003cbr/\u003e    android:grantUriPermissions=\u0026#34;true\u0026#34;\u0026gt;\u003cbr/\u003e    \u0026lt;meta-data\u003cbr/\u003e        android:name=\u0026#34;android.support.FILE_PROVIDER_PATHS\u0026#34;\u003cbr/\u003e        android:resource=\u0026#34;@xml/file_paths\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/provider\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"4839\"\u003e\u003ccode\u003efile_paths.xml\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"e10e\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;paths\u0026gt;\u003cbr/\u003e    \u0026lt;!-- Allow access to app-specific external storage --\u0026gt;\u003cbr/\u003e    \u0026lt;external-files-path name=\u0026#34;pictures\u0026#34; path=\u0026#34;Pictures/\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;/paths\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"a84b\"\u003e\u003cstrong\u003eCode\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"127f\"\u003e// App-specific external storage\u003cbr/\u003eval picturesDir = File(context.getExternalFilesDir(null), \u0026#34;Pictures\u0026#34;)\u003cbr/\u003epicturesDir.mkdirs() // Ensure the directory exists\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"dc0a\"\u003eüìå Questions \u0026amp; Answers\u003c/h2\u003e\u003ch2 id=\"5870\"\u003e1Ô∏è‚É£ What is MediaStore in Android?\u003c/h2\u003e\u003cp id=\"901a\"\u003eMediaStore is an API that provides structured access to \u003cstrong\u003emedia files\u003c/strong\u003e (images, videos, audio) stored on \u003cstrong\u003eexternal storage\u003c/strong\u003e. It allows querying, inserting, and updating media files \u003cstrong\u003ewithout requiring direct file path access\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"eedf\"\u003e2Ô∏è‚É£ How much space does your data require?\u003c/h2\u003e\u003cp id=\"7d13\"\u003eInternal storage has limited space for app-specific data. Use other types of storage if you need to save a substantial amount of data.\u003c/p\u003e\u003ch2 id=\"e63b\"\u003e3Ô∏è‚É£ How reliable does data access need to be?\u003c/h2\u003e\u003cp id=\"d112\"\u003eIf your app‚Äôs basic functionality requires certain data, such as when your app is starting up, place the data within internal storage directory or a database. App-specific files that are stored in external storage aren‚Äôt always accessible because some devices allow users to remove a physical device that corresponds to external storage.\u003c/p\u003e\u003ch2 id=\"77b0\"\u003e4Ô∏è‚É£ What are the advantages of using MediaStore over File API?\u003c/h2\u003e\u003cp id=\"5893\"\u003e‚úÖ \u003cstrong\u003eNo storage permission required\u003c/strong\u003e (Android 10+).\u003cbr/\u003e‚úÖ \u003cstrong\u003eWorks with scoped storage\u003c/strong\u003e (File API does not).\u003cbr/\u003e‚úÖ \u003cstrong\u003eStructured access\u003c/strong\u003e to media files.\u003cbr/\u003e‚úÖ \u003cstrong\u003eAuto indexing\u003c/strong\u003e by the system.\u003c/p\u003e\u003ch2 id=\"1a82\"\u003e5Ô∏è‚É£ What is FileProvider in Android?\u003c/h2\u003e\u003cp id=\"b5ea\"\u003eFileProvider is a \u003cstrong\u003econtent provider\u003c/strong\u003e (\u003ccode\u003eContentProvider\u003c/code\u003e) that allows \u003cstrong\u003esecure file sharing\u003c/strong\u003e between apps using \u003ccode\u003econtent://\u003c/code\u003e URIs instead of \u003ccode\u003efile://\u003c/code\u003e paths.\u003c/p\u003e\u003ch2 id=\"ff20\"\u003e7Ô∏è‚É£ Should the data be private to your app?\u003c/h2\u003e\u003cp id=\"9c24\"\u003eWhen storing sensitive data ‚Äî data that shouldn‚Äôt be accessible from any other app ‚Äî use internal storage, preferences, or a database. Internal storage has the added benefit of the data being hidden from users.\u003c/p\u003e\u003ch2 id=\"4a1f\"\u003e8Ô∏è‚É£ What is Scoped Storage in Android?\u003c/h2\u003e\u003cp id=\"9b12\"\u003eScoped Storage (introduced in Android 10) \u003cstrong\u003erestricts\u003c/strong\u003e direct access to shared storage and requires apps to use \u003cstrong\u003eMediaStore\u003c/strong\u003e or \u003cstrong\u003eFileProvider\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"45cd\"\u003e9Ô∏è‚É£ How do you access files in Scoped Storage?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"2482\"\u003e\u003cstrong\u003eFor media files:\u003c/strong\u003e Use \u003cstrong\u003eMediaStore API\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"1fd2\"\u003e\u003cstrong\u003eFor app-specific files:\u003c/strong\u003e Use \u003cstrong\u003egetExternalFilesDir()\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"e77a\"\u003e\u003cstrong\u003eFor file sharing:\u003c/strong\u003e Use \u003cstrong\u003eFileProvider\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8586\"\u003eTo give users more control over their files and limit file clutter, Android 10 introduced a new storage paradigm for apps called \u003ca href=\"https://developer.android.com/training/data-storage#scoped-storage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003escoped storage\u003c/a\u003e. Scoped storage changes the way apps store and access files on a device‚Äôs external storage. To help you migrate your app to support scoped storage, follow the best practices for common storage use cases that are outlined in this guide. The use cases are organized into two categories: \u003ca href=\"https://developer.android.com/training/data-storage/use-cases#handle-media-files\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehandling media files\u003c/a\u003e and \u003ca href=\"https://developer.android.com/training/data-storage/use-cases#handle-non-media-files\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehandling non-media files\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"3bee\"\u003eüéØ Conclusion\u003c/h2\u003e\u003cp id=\"e84c\"\u003eBy leveraging \u003cstrong\u003eJetpack Compose\u003c/strong\u003e,\u003ccode\u003eFileProvider\u003c/code\u003e, and Kotlin, we can easily \u003cstrong\u003edownload, store, and share images\u003c/strong\u003e in an Android app. This approach ensures smooth performance, proper file handling, and seamless sharing across different applications. Whether you are working on an image-heavy app or simply adding a sharing feature, mastering these techniques will enhance your development workflow üöÄüí°\u003c/p\u003e\u003ch2 id=\"f86e\"\u003eüîπ MediaStore (Scoped Storage API)\u003c/h2\u003e\u003cp id=\"c3ce\"\u003e\u003cstrong\u003ePurpose\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9b5c\"\u003e\u003cstrong\u003eMediaStore\u003c/strong\u003e is part of the \u003cstrong\u003eScoped Storage\u003c/strong\u003e model introduced in \u003cstrong\u003eAndroid 10 (API 29)\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"dd14\"\u003eIt provides access to \u003cstrong\u003epublic media files\u003c/strong\u003e (e.g., images, videos, and audio) stored in shared storage, without needing \u003ccode\u003eREAD_EXTERNAL_STORAGE\u003c/code\u003e or \u003ccode\u003eWRITE_EXTERNAL_STORAGE\u003c/code\u003e permissions (from Android 11 onwards).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ad0c\"\u003e\u003cstrong\u003eUse Cases\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f890\"\u003eSaving media files (images, videos, audio) in \u003cstrong\u003epublic directories\u003c/strong\u003e (e.g., \u003ccode\u003ePictures/\u003c/code\u003e, \u003ccode\u003eMovies/\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"04fc\"\u003eQuerying and managing media content using the \u003cstrong\u003eContentResolver\u003c/strong\u003e API.\u003c/li\u003e\u003cli id=\"3836\"\u003eEnsuring compliance with \u003cstrong\u003eScoped Storage\u003c/strong\u003e, as direct file path access is restricted.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"107f\"\u003e\u003cstrong\u003eAdvantages\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b1e7\"\u003e‚úÖ No need for storage permissions (from Android 11+).\u003c/li\u003e\u003cli id=\"efb7\"\u003e‚úÖ Works with \u003cstrong\u003eScoped Storage\u003c/strong\u003e, avoiding direct file access.\u003c/li\u003e\u003cli id=\"bd6f\"\u003e‚úÖ Provides a \u003cstrong\u003econtent URI\u003c/strong\u003e, making it safer for media handling.\u003c/li\u003e\u003cli id=\"5931\"\u003e‚úÖ Compatible with \u003cstrong\u003eMediaScanner\u003c/strong\u003e for indexing media files.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6709\"\u003e\u003cstrong\u003eDisadvantages\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b151\"\u003e‚ùå Cannot store \u003cstrong\u003enon-media files\u003c/strong\u003e (e.g., PDFs, ZIPs).\u003c/li\u003e\u003cli id=\"5f4d\"\u003e‚ùå Requires \u003cstrong\u003equerying APIs\u003c/strong\u003e (instead of direct file access)\u003c/li\u003e\u003cli id=\"bda6\"\u003e‚ùå Files are \u003cstrong\u003enot private\u003c/strong\u003e ‚Äî they‚Äôre accessible to all apps with read access to shared storage.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1155\"\u003eüîπFileProvider (For Secure File Sharing)\u003c/h2\u003e\u003cp id=\"1b1c\"\u003e\u003cstrong\u003ePurpose\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7611\"\u003e\u003cstrong\u003eFileProvider\u003c/strong\u003e is a special \u003cstrong\u003eContentProvider\u003c/strong\u003e that allows an app to \u003cstrong\u003eshare private files\u003c/strong\u003e securely with other apps using a \u003cstrong\u003econtent URI\u003c/strong\u003e, rather than exposing raw file paths.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8645\"\u003e\u003cstrong\u003eUse Cases\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e31a\"\u003eSharing \u003cstrong\u003efiles (PDFs, images, videos, etc.)\u003c/strong\u003e with other apps (e.g., email, social media, or messaging apps).\u003c/li\u003e\u003cli id=\"afb2\"\u003eProviding a secure way to expose \u003cstrong\u003eapp-private storage files\u003c/strong\u003e (inside \u003ccode\u003edata/data/\u0026lt;package\u0026gt;/files\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"ccfc\"\u003eGranting \u003cstrong\u003etemporary read/write access\u003c/strong\u003e to specific files.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1e58\"\u003e\u003cstrong\u003eAdvantages\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"02fe\"\u003e‚úÖ \u003cstrong\u003eSecure file sharing\u003c/strong\u003e (avoids exposing raw file paths).\u003c/li\u003e\u003cli id=\"5162\"\u003e‚úÖ Supports \u003cstrong\u003eany file type\u003c/strong\u003e, not just media files.\u003c/li\u003e\u003cli id=\"cf86\"\u003e‚úÖ Provides \u003cstrong\u003etemporary access permissions\u003c/strong\u003e using \u003ccode\u003eFLAG_GRANT_READ_URI_PERMISSION\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"9eee\"\u003e‚úÖ Works with \u003cstrong\u003eintent-based sharing\u003c/strong\u003e (e.g., \u003ccode\u003eIntent.ACTION_SEND\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"438c\"\u003e\u003cstrong\u003eDisadvantages\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e6cf\"\u003e‚ùå Requires defining a \u003cstrong\u003eFileProvider in AndroidManifest.xml\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"0ca0\"\u003e‚ùå Needs \u003cstrong\u003eXML configuration\u003c/strong\u003e for file paths.\u003c/li\u003e\u003cli id=\"58ce\"\u003e‚ùå \u003cstrong\u003eMore complex setup\u003c/strong\u003e compared to direct file sharing.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli id=\"b97b\"\u003e\u003ca href=\"https://developer.android.com/training/data-storage/app-specific\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/data-storage/app-specific\u003c/a\u003e\u003c/li\u003e\u003cli id=\"f192\"\u003e\u003ca href=\"https://developer.android.com/training/data-storage/shared\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/data-storage/shared\u003c/a\u003e\u003c/li\u003e\u003cli id=\"296a\"\u003e\u003ca href=\"https://developer.android.com/training/secure-file-sharing/setup-sharing\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/secure-file-sharing/setup-sharing\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5520\"\u003e\u003ca href=\"https://developer.android.com/training/secure-file-sharing/retrieve-info\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/secure-file-sharing/retrieve-info\u003c/a\u003e\u003c/li\u003e\u003cli id=\"70af\"\u003e\u003ca href=\"https://developer.android.com/training/data-storage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/data-storage\u003c/a\u003e\u003c/li\u003e\u003cli id=\"e5e9\"\u003e\u003ca href=\"https://developer.android.com/studio/debug/device-file-explorer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/studio/debug/device-file-explorer\u003c/a\u003e\u003c/li\u003e\u003cli id=\"29da\"\u003e\u003ca href=\"https://developer.android.com/training/sharing/send\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/training/sharing/send\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2025-02-03T03:27:11.843Z",
  "modifiedTime": null
}
