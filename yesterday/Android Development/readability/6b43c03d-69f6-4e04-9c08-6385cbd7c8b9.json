{
  "id": "6b43c03d-69f6-4e04-9c08-6385cbd7c8b9",
  "title": "The Final Article on Loading Data in Kotlin Apps",
  "link": "https://proandroiddev.com/how-to-load-data-kotlin-898f9add9c6f?source=rss----c72404660798---4",
  "description": "",
  "author": "Nek.12",
  "published": "Sun, 04 May 2025 06:10:09 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "mvvm",
    "software-development",
    "software-architecture",
    "android"
  ],
  "byline": "Nek.12",
  "length": 25099,
  "excerpt": "Full Guide: How to Load Data and Collect Flows in ViewModel on Android, Kotlin Multiplatform with Compose and Coroutines in MVVM or MVI.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Why this article?I’ve built 15+ apps and read thousands of articles on Kotlin Dev, and I’ve seen so many, so many ways to load data for display on the UI that are wrong that I’m worried about all of the people who are unknowingly using those.The worst thing is — they keep coming! Every month I see another article / video / code sample with a flawed implementation of either events or data loading strategies that cause hidden bugs that will likely only surface in production.Do you want to know if you’re using one of them? Fix the issues? Then this article is for you, because this is the definitive guide you need for loading data correctly in Kotlin apps.Our example:For illustration purposes, let us say that we have an app which loads a homepage with:User profile info, backed by a local cache file + network endpoint.Some news articles for the user to read, from the network, without file caching.The requirements are:We must only show up-to-date articles while the user is browsing the page.The user may be able to open additional pages on top of our homepage, and edit their profile info or article preferences. When they return, we must update the data.Now let’s say we’re trying to satisfy the requirements, and have already built our repository.interface HomeRepository { suspend fun getArticles(): List\u003cArticle\u003e // load articles from network, only possible while signed in val user: Flow\u003cUser\u003e // locally cached user, auto updated on refreshUser() suspend fun refreshUser(): User // update user data from the BE}sealed interface HomeState { data object Loading: HomeState data object DisplayingFeed(val user: User, val feed: List\u003cArticle\u003e): HomeState}If you’re confused on why we structured our state this way, this is covered in my article on state management (not important right now). Some notes:We have omitted the UI model mapping and pagination on purpose for the sake of simplicityKeep in mind that I also omitted error handling and user authentication handling to simplify the codeAnd now it is the time to load that data, as an example, in our Compose application on an Android target.Part 1: What NOT to doThe best way to figure out what to do in our case is to begin by eliminating what not to do, and seeing what is left.1. Do not load eagerly!Let’s say that naively, we wrote the following code:class HomeViewModel( private val repo: HomeRepository,): ViewModel() { private val _state = MutableStateFlow\u003cHomeState\u003e(HomeState.Loading) val state = _state.asStateFlow() init { viewModelScope.launch { val user = repo.refreshUser() val articles = repo.getArticles() _state.value = DisplayingFeed(user, articles) } }}This code has several resource leaks, races and UX flaws:1. Stale Data: The data is fetched only once when the ViewModel is created.If the app goes into the background and returns hours (or even days/weeks!) later, the user sees outdated information. Modern phones can keep apps suspended for a long time.If the user navigates away (e.g., to a profile editing screen), the HomeViewModel often stays alive in the backstack. When they return after making changes, they'll still see the old profile data, thinking the update failed. This is a quick way to get your app uninstalled.We are not observing the repo.user flow, so any background updates (by our code) to the cached user data are ignored.2. Inefficient Loading: Data (user and articles) is loaded sequentially (refreshUser completes before getArticles starts). This makes the initial loading time longer than necessary. While you could use async {} to parallelize, this often adds complexity, race conditions during data mapping, and more boilerplate.3. Manual State Management Issues: Using a raw MutableStateFlow and manually updating .value is error-prone.It’s easy to introduce subtle bugs related to atomicity and thread safety, especially as logic grows.It bypasses the robust state management mechanisms provided by coroutines. As discussed in my other articles, rolling your own state management often leads to problems. We should strive for a single, reliable source of truth for UI state. There must be a better way, right?4. Eager Loading: The data loading starts immediately when the ViewModel is initialized, regardless of whether the UI actually needs the data yet or if anyone is observing the state flow. This can happen with conditional UI logic (e.g., waiting for login) or complex component structures. It's a waste of resources (CPU, network, battery).2. Do not roll your own onDataRefresh() callback!Let’s say we tried to address problem #1 (stale data) and ignored 2 and 3 (because they will only get ticketed by QA in production later).A common (but flawed) approach is to hook into the system lifecycle and call a “refresh” function:class HomeViewModel( /* ... */ ) : ViewModel() { // ... init { refreshData() } fun onResume() = refreshData() fun onPullToRefresh() = refreshData() private fun refreshData() = viewModelScope.launch { val user = repo.refreshUser() val articles = repo.getArticles() _state.value = DisplayingFeed(user, articles) }}This “fix” is just a hack that introduces more problems:1. The amount of coroutines now grows uncontrollably.Every time the screen comes back into focus (onResume), a new refreshData is launched. If the network is slow and the user navigates back and forth quickly (or interacts with dialogs), you can end up launching many concurrent refresh jobs. These then might:Overwrite each other’s results in unpredictable ways.Overload the system and network resources.Fail due to resource contention.Manually managing these jobs (e.g., cancelling previous ones) requires complex, error-prone boilerplate involving Job instances. There must be a simpler way, right?2. We still did not solve the original problem. This manual refresh only triggers on lifecycle events or specific user actions. What if the underlying data (like the cached repo.user) changes due to some other background process unrelated to this screen's lifecycle? For example, a startup synchronization job might update the user profile after refreshData has already run. The screen will still show stale data until the next manual refresh3. Threading problems exacerbated. As we add more operations (like filtering the feed based on user input), managing concurrency and preventing conflicts with the ongoing refreshData calls becomes even harder without a proper state management strategy.4. We likely rolled an incomplete subscription lifecycle implementation. Simply using onResume is often too frequent for some data and not frequent enough for others. onStart/onStop might be better sometimes, but choosing the right lifecycle event and implementing the triggering logic correctly every time adds significant boilerplate, especially if you're (correctly) avoiding generic BaseViewModel classes.5. We leak the update coroutine. When the user navigates away from the screen, the refreshData coroutine launched by viewModelScope keeps running in the background until it completes. If the data loading is resource-intensive and the user quickly moves elsewhere, you're wasting resources loading data that's no longer needed immediately. Ideally, this work should be cancelled. This might seem minor for a home screen, but if this pattern is adopted for the entire codebase, the problem will resurface in more significant ways later.3. Do not observe data sources in the background!Let’s say QA has reported #1 and #2 from the previous chapter to us. We decided to not add any hacks, and instead correctly subscribe to the user: Flow in our ViewModel.This is good, because now we're able to reactively observe data in our view model. Whenever anything changes the data, we will know about the update. But we made a critical mistake - we collect the flow in the init block.class HomeViewModel( private val repo: HomeRepository,): ViewModel() { // ... init { repo.user.onEach { user -\u003e _state.value = DisplayingFeed(user, repo.getArticles()) }.launchIn(viewModelScope) }}I’ve used launchIn here to make the code look deceptively simple (and similar to what I’ve seen my colleagues write). The core problem isn't launchIn itself, but collecting a flow for the entire lifetime of the viewModelScope without considering the UI lifecycle. Any mechanism that makes a cold flow - hot (like collect, launchIn, stateIn with SharingStarted.Eagerly or Lazily) can lead to this.The reason the mistake is “critical” is because when we start doing this for all of our screens, we will have leaks that waste resources proportionally to the backstack size, not even mentioning wasting the resources while the app is in background.Let’s say the user can open the feed page multiple times. The backstack will grow without any limits, and each new ViewModel in the backstack will continue to load and update data. If you have 100 pages in the history, the moment one property of the user object changes, 100 pages will reload their information. This will surface in bad user reviews (poor performance, device heats up, poor battery life) and obscure, untraceable ANRs and OOM crashes, in production. This is almost impossible to discover with manual QA, integration testing, unit testing or during development unless you look for this specific issue.If you start fixing this on a case by case basis instead, you will need to add caching with the ability to retry, manual lifecycle hooks for every ViewModel, error handling and throttling code, and it will get out of hand quickly. So,Do NOT collect flows using the viewModelScope unless you explicitly need the data stream to remain active even when the UI is not visible.The shoulder case above is rare (maybe \u003c5% of cases) and often indicates an underlying architectural issue or a need for a dedicated background worker.4. Do not trigger loading from the UISuppose you just got frustrated this isn’t working and decided to trigger loading of all information from the UI (in our example — from the composition):class HomeViewModel(/* ... */) : ViewModel() { // ... suspend fun observeData() = coroutineScope { val feed = repo.getArticles() repo.user.collect { user -\u003e _state.update { it.copy(user = user, feed = feed) } } }}@Composablefun HomeScreen(vm: HomeViewModel) { LaunchedEffect(Unit) { vm.observeData() } // ... }So in our example we refresh the data until observeData() is cancelled, i.e. while the page is visible.This approach, including variations like sending “ScreenVisible” events/intents from the UI to the ViewModel to trigger viewModelScope.launch { ... }, is just another form of manual lifecycle and job management.The problems with it are:We’re back to manually trying to align data loading with the UI lifecycle, which LaunchedEffect or onResume only partially address.We leak the responsibilities of the ViewModel (loading data) onto the UI layer.We now always have to keep track of whether only one consumer is running the observeData() .There is additional burden on the UI to decide when the refreshing is needed. What if the UI doesn’t need the state until, for example user has dismissed an update dialog? Or signed in? All that logic is now on the UI.How do you handle retries if repo.getArticles() fails? Putting retry logic inside observeData is possible, but triggering it or managing its state from the UI becomes awkward.Part 2: The Right Way to Load and Observe DataSo we have defined what we must not do:Don’t observe data streams indefinitely in the backstack/viewModelScope without lifecycle awareness.Don’t rely on manual UI triggers or lifecycle callbacks (onResume, LaunchedEffect) to start core data loading logic in the ViewModel.Don’t use raw mutable state (MutableStateFlow) as your primary state holder without a robust, atomic update mechanism.Don’t roll your own complex job management for cancellation and restarting.Don’t fetch all data sources again if only one changes (unless necessary).Don’t use loading logic that isn’t easily cancellable or retryable.And now here’s what we should actually do:Combine multiple data sources reactively using flow operators (like combine) and expose the result as a StateFlow using stateIn, configuring it to respect the presence of UI subscribers via SharingStarted.WhileSubscribed.An example:class HomeViewModel( private val repo: HomeRepository,): ViewModel() { private val articles = flow { emit(repo.getArticles()) }, // 1 val state = combine( // 2 repo.user.distinctUntilChanged(), articles, ) { user, feed -\u003e DisplayingFeed(user, feed) }.stateIn( // 3 scope = viewModelScope, initialValue = HomeState.Loading started = SharingStarted.WhileSubscribed( // 4 stopTimeoutMillis = 1.seconds, // 5 replayExpirationMillis = 9.seconds, // 6 ), )}1. We wrap the repo.getArticles() suspend function call in a flow { } builder. This creates a cold flow – it doesn't do anything until collected. We can also apply any mapping operators to individual flows instead of during state assembly, significantly reducing wasted work.2. The combine operator:Collects all provided flows (repo.user, articles) concurrently.As soon as all flows have emitted at least one value, invokes the transformation lambda ({ user, articles -\u003e ... }) with the latest value from each flow.Whenever any of the input flows emits a new value later, combine re-runs the lambda with the new value and the most recent (cached) values from the other flows, producing an updated HomeState.3. We call the stateIn operator to convert our cold flow to a hot flow, mainly, because we want to have a value which can be used on the UI to render it, and to cache and reuse the result of the operator. We will produce the parent flow in the view model scope, but...4. We will only collect the parent flow WhileSubscribed. When first subscriber appears, the stateIn will trigger collection of the combine result flow, which in turn will trigger all of our data sources. Furthermore, we configure the WhileSubscribed such that...5. We stop and cancel the collection of the flow after 1 second (or other reasonable small delay). The 1 second is just an arbitrary value that is roughly equivalent to how long a configuration change can take on Android worst-case. We need to do that because on Android specifically, the UI will briefly unsubscribe while the configuration changes sometimes, and we don’t want to waste resources because of that.6. Additionally, we configure a replayExpirationMillis, which is how long a value that was computed last time will be valid for our UI, if it needs to resubscribe. If that time expires, the state will go to the initialValue again. This isn't the same as stopTimeout, as an expiring stopTimeout will cause the combine to re-trigger all of the flows regardless of the replay, but a valid replay will also provide the last emitted value to subscribers while that re-trigger is happening (instead of the initialValue). That number excludes stopTimeout, so I subtracted 1 second from my desired ten. Sometimes, you may want this to be long or infinite depending on the desired UX.Here’s why this code has none of the problems discussed above:Lazy \u0026 On-Demand: Data loading (articles) only starts when the UI observes the state. repo.user is only observed while the UI is subscribed. No work is done if the UI isn't interested.Always Up-to-Date: combine ensures that changes in any underlying data source (repo.user) automatically trigger a state update.Parallel Loading: combine collects its input flows concurrently. repo.user observation starts, and articlesFlow execution starts in parallel. The first DisplayingFeed state is emitted as soon as both have produced a value.Atomic \u0026 Safe Updates: The coroutine machinery handles the concurrency, atomicity, and thread safety within combine and stateIn. We don't need manual synchronization in the transformation lambda.Single Upstream Collector: stateIn ensures the upstream combine flow is collected only once, regardless of how many UI collectors observe the final state. No risk of uncontrolled coroutine proliferation.Lifecycle-Aware \u0026 Cancellable: SharingStarted.WhileSubscribed automatically cancels the upstream collection (including the articles network call) when the UI is no longer observing (after the timeout), preventing leaked work and saving resources.Decoupled: The ViewModel focuses purely on defining the state based on data sources. The UI simply collects the state using lifecycle-aware collectors (like collectAsStateWithLifecycle() in Compose) without needing to know how the state is produced or trigger anything.Retryable: You can easily add retry logic to the individual flows before they enter the combine operator (e.g., using the retry operator on articles) without complicating the overall structure.But what if I have transient data that I want to update manually?Then do NOT do this:class HomeViewModel @Inject constructor() : ViewModel() { private val screenState = MutableStateFlow(value = ScreenState()) val uiState = screenState .onStart { fetchArticleList() } // ❌ .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(stopTimeoutMillis = 5000L), initialValue = screenState.value, // ❌ ) suspend fun fetchArticleList() { delay(timeMillis = 2000L) screenState.update { state -\u003e state.copy( text = \"Fetch Data ${state.counter}\", counter = state.counter + 1 ) } } } This erroneous code is copied directly from another article on loading initial data.Problems with the code:Double dispatching. We convert a hot flow to a cold flow using onStart and then back to a hot flow. At a minimum, it's a wasted computation, but this code also doesn't behave correctly, as the WhileSubscribed option has no effect on a flow that is backed by a hot flow already. The onStart operator is invoked eagerly because the flow is hot.onStart isn't the correct operator to use. I already explained how custom callbacks make our code fragile and non-thread-safe.The code above rolls its own mutable state, and uses double conversion with a trigger to load the initial data, but most importantly, it uses a pattern of “amending” the transient state with the source data. We should do the opposite by amending the data source state with the transient state, like this:data class UserInput( val searchQuery: String? = null,)sealed interface HomeState { // ... data class DisplayingArticles( val input: UserInput, // ... )}class HomeViewModel(/* .. */) : ViewModel() { // ... private val input = MutableStateFlow(UserInput()) val state = combine( repo.user, articles, input, // \u003c- ! using our input ) { user, feed, input -\u003e DisplayingFeed(input, user, feed) }.stateIn( / * ... */ ) fun onSearchQueryChanged(value: String) = input.update { it.copy(searchQuery = value) }}This way:Transient state (_input) is managed separately and updated atomically using update.The main state is still derived reactively by combine and gets all the benefits of stateIn.But what if I’m using MVI?Well, this is a complicated one. With MVI, we have to use a single, mutable state as the source of truth. It’s one of the “flaws” of MVI that proponents of MVVM often appeal to. Mutable state of MVI has its advantages, but here we have to pay the price. But don’t worry, it’s possible to solve this.We just need to implement logic similar to how WhileSubscribed works under the hood: it tracks the number of subscribers, and when the number of them drops to 0, it dispatches a special command to the flow to cancel the collection of the upstream.I thought about this for a while and devised the following extension functions that should behave similarly:suspend inline fun MutableSharedFlow\u003c*\u003e.whileSubscribed( stopDelay: Duration = 1.seconds, minSubscribers: Int = 1, crossinline action: suspend () -\u003e Unit ) = subscriptionCount // 1 .map { it \u003e= minSubscribers } // 2 .dropWhile { !it } // 3 .debounce { if (it) Duration.ZERO else stopDelay } // 4 .distinctUntilChanged() // 5 .collectLatest { if (it) action() } // 6inline fun MutableSharedFlow\u003c*\u003e.whileSubscribed( scope: CoroutineScope, stopDelay: Duration = 1.seconds, minSubscribers: Int = 1, crossinline action: suspend () -\u003e Unit ) = scope.launch(start = CoroutineStart.UNDISPATCHED) { whileSubscribed(stopDelay, minSubscribers, action) }Let’s explain it line by line:Each MutableSharedFlow (which StateFlow is) has a separate flow subscriptionCount, we use it...To map to whether we have any subscribers that satisfy criteria,..Then wait until that condition becomes true for the first time…Then if the condition became true, we immediately proceed, otherwise wait stopDelay to see if the subscribers appear again shortly...Then filter out duplicates (that would otherwise repeatedly cancel our flow) of subscription events…And then on each change of the subscription count condition, we run action if it became true.Then all you have to do to use this function is:class HomeViewModel( /* ... */ ) : ViewModel() { // ... init { _state.whileSubscribed(viewModelScope) { combine( repo.user, articles, ) { user, feed -\u003e updateState { produceState(user, feed) } // use a state transaction here to handle transient states }.collect() // important - you are expected to suspend in the block } }}Keep in mind:I personally didn’t test or use this function in productionIt handles only subscriptions to the state. If you have a separate channel for side effects, they won’t be picked up and you need to amend this implementationIt doesn’t have the state-resetting behavior of WhileSubscribed (generally not desired with MVI). If you need it, a simple addition to the collect code can give you that.You still have to correctly subscribe to the state with lifecycle awareness using something like collectAsStateWithLifecycle in Compose.It’s dangerous to use this function without Serialized State Transactions when parallel updates are involved (unless you carefully make the transactions atomic manually).You are expected to suspend in the action block (instead of using viewModelScope) in order to play along with our cancellation policy.Conclusion: Don’t Reinvent the WheelIf you are using plain simple MVVM(+), lucky you! Just don’t reinvent the wheel — use the proven and idiomatic way of loading data and producing state, and you will be good for the most part!And if at some point you decided that you want safer state management or some of the features of MVI, and all that setup sounds complicated, you’re right. There’s just too much stuff to keep in mind.When people feel like they need something more robust than MVVM, they often roll their own “in-house MVI implementation”, but when it comes to correctly loading and observing data, handling side effects or managing state, 95% of those “implementations” are flawed in one way or another.It only sounds simple on the surface:“I just need a flow for side effects and a state flow for states and then to send intents, right?”Not so much, as you see. In my opinion, that’s why architecture frameworks exist. The benefit of them is that all of the complicated stuff like this is solved, documented, thoroughly tested, benchmarked and verified in production before you commit to any usage of the new code.You can reinvent a wheel and not depend on any framework — sure, great, “one less library the author may abandon any moment”. But how is your wheel (that your team now has to maintain and fix) better than the community-driven, tested, optimized, documented, polished solution that solved the problems that you never even knew existed, for years?I made FlowMVI precisely because of that — I was tired of seeing me and my team make the same mistakes over, and over, and over. I spent 2 years polishing the framework so that the entirety of this article is reduced to this code:val store = store(HomeState.Loading) { val articles by retry { repo.getArticles() } whileSubscribed { combine(repo.user, articles) { user, feed -\u003e updateState { DisplayingFeed(user, feed, typed\u003cDisplayingFeed\u003e()) } }.collect() }}@Composable fun HomeScreen( /* ... */ ) { val state by store.subscribe() }The code above follows system, composition, navigation and subscription plifecycle, uses SSTs to update the state in parallel, uses transient state to preserve data, allows to retry computations, resets the state properly on shutdown, and even persists the state to disk as needed.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*4w8kudxp4VpvHLuqTI0VaQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"ebca\"\u003eWhy this article?\u003c/h2\u003e\u003cp id=\"a642\"\u003eI’ve built 15+ apps and read \u003cstrong\u003ethousands\u003c/strong\u003e of articles on Kotlin Dev, and I’ve seen so many, so many ways to \u003cstrong\u003eload data\u003c/strong\u003e for display on the UI that are \u003cstrong\u003ewrong\u003c/strong\u003e that I’m worried about all of the people who are unknowingly using those.\u003c/p\u003e\u003cp id=\"e1b5\"\u003eThe worst thing is — they keep coming! Every month I see another article / video / code sample with a flawed implementation of either events or data loading strategies that \u003cstrong\u003ecause hidden bugs that will likely only surface in production\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"9995\"\u003eDo you want to know if you’re using one of them? Fix the issues? Then this article is for you, because this is the \u003cstrong\u003edefinitive\u003c/strong\u003e guide you need for loading data correctly in Kotlin apps.\u003c/p\u003e\u003ch2 id=\"b42a\"\u003eOur example:\u003c/h2\u003e\u003cp id=\"73e2\"\u003eFor illustration purposes, let us say that we have an app which loads a homepage with:\u003c/p\u003e\u003col\u003e\u003cli id=\"cc9c\"\u003eUser profile info, backed by a local cache file + network endpoint.\u003c/li\u003e\u003cli id=\"2b25\"\u003eSome news articles for the user to read, from the network, without file caching.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"03d6\"\u003eThe requirements are:\u003c/p\u003e\u003col\u003e\u003cli id=\"8510\"\u003eWe must only show up-to-date articles while the user is browsing the page.\u003c/li\u003e\u003cli id=\"1185\"\u003eThe user may be able to open additional pages on top of our homepage, and edit their profile info or article preferences. When they return, we must update the data.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"403d\"\u003eNow let’s say we’re trying to satisfy the requirements, and have already built our repository.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"18d2\"\u003einterface HomeRepository {\u003cbr/\u003e    suspend fun getArticles(): List\u0026lt;Article\u0026gt; // load articles from network, only possible while signed in\u003cbr/\u003e    val user: Flow\u0026lt;User\u0026gt; // locally cached user, auto updated on refreshUser()\u003cbr/\u003e    suspend fun refreshUser(): User // update user data from the BE\u003cbr/\u003e}\u003cp\u003esealed interface HomeState {\u003cbr/\u003e    data object Loading: HomeState\u003cbr/\u003e    data object DisplayingFeed(val user: User, val feed: List\u0026lt;Article\u0026gt;): HomeState\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f8cf\"\u003eIf you’re confused on why we structured our state this way, this is covered in my article on state management (not important right now). Some notes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6431\"\u003eWe have omitted the UI model mapping and pagination on purpose for the sake of simplicity\u003c/li\u003e\u003cli id=\"d97c\"\u003eKeep in mind that I also omitted error handling and user authentication handling to simplify the code\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8cc5\"\u003eAnd now it is the time to load that data, as an example, in our Compose application on an Android target.\u003c/p\u003e\u003ch2 id=\"5033\"\u003ePart 1: What NOT to do\u003c/h2\u003e\u003cp id=\"bf37\"\u003eThe best way to figure out what to do in our case is to begin by eliminating what \u003cstrong\u003enot\u003c/strong\u003e to do, and seeing what is left.\u003c/p\u003e\u003ch2 id=\"4c6d\"\u003e1. Do not load eagerly!\u003c/h2\u003e\u003cp id=\"3512\"\u003eLet’s say that naively, we wrote the following code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"913c\"\u003eclass HomeViewModel(\u003cbr/\u003e    private val repo: HomeRepository,\u003cbr/\u003e): ViewModel() {\u003cp\u003e        private val _state = MutableStateFlow\u0026lt;HomeState\u0026gt;(HomeState.Loading)\u003cbr/\u003e    val state = _state.asStateFlow()\u003cbr/\u003e    init {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            val user = repo.refreshUser()\u003cbr/\u003e            val articles = repo.getArticles()\u003cbr/\u003e            _state.value = DisplayingFeed(user, articles)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1454\"\u003e\u003cstrong\u003eThis code has several resource leaks, races and UX flaws:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"690b\"\u003e\u003cstrong\u003e1. Stale Data:\u003c/strong\u003e \u003cbr/\u003eThe data is fetched \u003cem\u003eonly once\u003c/em\u003e when the ViewModel is created.\u003c/p\u003e\u003cul\u003e\u003cli id=\"c230\"\u003eIf the app goes into the background and returns hours (or even days/weeks!) later, the user sees outdated information. Modern phones can keep apps suspended for a long time.\u003c/li\u003e\u003cli id=\"fbf9\"\u003eIf the user navigates away (e.g., to a profile editing screen), the \u003ccode\u003eHomeViewModel\u003c/code\u003e often stays alive in the backstack. When they return after making changes, they\u0026#39;ll still see the old profile data, thinking the update failed. This is a quick way to get your app uninstalled.\u003c/li\u003e\u003cli id=\"1ae4\"\u003eWe are not observing the \u003ccode\u003erepo.user\u003c/code\u003e flow, so any background updates (by our code) to the cached user data are ignored.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5698\"\u003e\u003cstrong\u003e2. Inefficient Loading:\u003c/strong\u003e \u003cbr/\u003eData (user and articles) is loaded sequentially (\u003ccode\u003erefreshUser\u003c/code\u003e completes before \u003ccode\u003egetArticles\u003c/code\u003e starts). This makes the initial loading time longer than necessary. While you \u003cem\u003ecould\u003c/em\u003e use \u003ccode\u003easync {}\u003c/code\u003e to parallelize, this often adds complexity, race conditions during data mapping, and more boilerplate.\u003c/p\u003e\u003cp id=\"0f19\"\u003e\u003cstrong\u003e3. Manual State Management Issues:\u003c/strong\u003e \u003cbr/\u003eUsing a raw \u003ccode\u003eMutableStateFlow\u003c/code\u003e and manually updating \u003ccode\u003e.value\u003c/code\u003e is error-prone.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4c8b\"\u003eIt’s easy to introduce subtle bugs related to atomicity and thread safety, especially as logic grows.\u003c/li\u003e\u003cli id=\"9cb9\"\u003eIt bypasses the robust state management mechanisms provided by coroutines. As discussed in \u003ca href=\"https://medium.com/proandroiddev/how-to-safely-update-state-in-your-kotlin-apps-bf51ccebe2ef\" rel=\"noopener\"\u003emy other articles\u003c/a\u003e, rolling your own state management often leads to problems. We should strive for a single, reliable source of truth for UI state. There must be a better way, right?\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"47ff\"\u003e\u003cstrong\u003e4. Eager Loading:\u003c/strong\u003e \u003cbr/\u003eThe data loading starts immediately when the ViewModel is initialized, regardless of whether the UI actually needs the data yet or if anyone is observing the \u003ccode\u003estate\u003c/code\u003e flow. This can happen with conditional UI logic (e.g., waiting for login) or complex component structures. It\u0026#39;s a waste of resources (CPU, network, battery).\u003c/p\u003e\u003ch2 id=\"b426\"\u003e2. Do not roll your own onDataRefresh() callback!\u003c/h2\u003e\u003cp id=\"dbad\"\u003eLet’s say we tried to address problem #1 (stale data) and ignored 2 and 3 (because they will only get ticketed by QA in production later).\u003c/p\u003e\u003cp id=\"52c9\"\u003eA common (but flawed) approach is to hook into the system lifecycle and call a “refresh” function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98e2\"\u003eclass HomeViewModel( /* ... */ ) : ViewModel() {\u003cbr/\u003e    // ...\u003cp\u003e    init {\u003cbr/\u003e        refreshData()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun onResume() = refreshData()\u003cbr/\u003e    fun onPullToRefresh() = refreshData()\u003c/p\u003e\u003cp\u003e    private fun refreshData() = viewModelScope.launch {\u003cbr/\u003e        val user = repo.refreshUser()\u003cbr/\u003e        val articles = repo.getArticles()\u003cbr/\u003e        _state.value = DisplayingFeed(user, articles)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2820\"\u003e\u003cstrong\u003eThis\u003c/strong\u003e “fix” is \u003cstrong\u003ejust a hack that introduces\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003emore\u003c/em\u003e\u003c/strong\u003e \u003cstrong\u003eproblems\u003c/strong\u003e:\u003c/p\u003e\u003cp id=\"1930\"\u003e\u003cstrong\u003e1. The amount of coroutines now grows uncontrollably\u003c/strong\u003e.\u003cbr/\u003eEvery time the screen comes back into focus (\u003ccode\u003eonResume\u003c/code\u003e), a new \u003ccode\u003erefreshData\u003c/code\u003e is launched. If the network is slow and the user navigates back and forth quickly (or interacts with dialogs), you can end up launching \u003cem\u003emany\u003c/em\u003e concurrent refresh jobs. These then might:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f3b1\"\u003eOverwrite each other’s results in unpredictable ways.\u003c/li\u003e\u003cli id=\"558e\"\u003eOverload the system and network resources.\u003c/li\u003e\u003cli id=\"8eed\"\u003eFail due to resource contention.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ab1f\"\u003eManually managing these jobs (e.g., cancelling previous ones) requires complex, error-prone boilerplate involving \u003ccode\u003eJob\u003c/code\u003e instances. There must be a simpler way, right?\u003c/p\u003e\u003cp id=\"1671\"\u003e\u003cstrong\u003e2. We still did not solve the original problem\u003c/strong\u003e. \u003cbr/\u003eThis manual refresh only triggers on lifecycle events or specific user actions. What if the underlying data (like the cached \u003ccode\u003erepo.user\u003c/code\u003e) changes due to some \u003cem\u003eother\u003c/em\u003e background process unrelated to this screen\u0026#39;s lifecycle? For example, a startup synchronization job might update the user profile \u003cem\u003eafter\u003c/em\u003e \u003ccode\u003erefreshData\u003c/code\u003e has already run. The screen will \u003cem\u003estill\u003c/em\u003e show stale data until the next manual refresh\u003c/p\u003e\u003cp id=\"5c81\"\u003e\u003cstrong\u003e3. Threading problems exacerbated\u003c/strong\u003e. \u003cbr/\u003eAs we add more operations (like filtering the feed based on user input), managing concurrency and preventing conflicts with the ongoing \u003ccode\u003erefreshData\u003c/code\u003e calls becomes even harder without a proper state management strategy.\u003c/p\u003e\u003cp id=\"2ea0\"\u003e\u003cstrong\u003e4. We likely rolled an incomplete subscription lifecycle implementation\u003c/strong\u003e. Simply using \u003ccode\u003eonResume\u003c/code\u003e is often too frequent for some data and not frequent enough for others. \u003ccode\u003eonStart\u003c/code\u003e/\u003ccode\u003eonStop\u003c/code\u003e might be better sometimes, but choosing the right lifecycle event and implementing the triggering logic correctly \u003cem\u003eevery time\u003c/em\u003e adds significant boilerplate, especially if you\u0026#39;re (correctly) avoiding generic \u003ccode\u003eBaseViewModel\u003c/code\u003e classes.\u003c/p\u003e\u003cp id=\"b544\"\u003e\u003cstrong\u003e5. We leak the update coroutine\u003c/strong\u003e. \u003cbr/\u003eWhen the user navigates \u003cem\u003eaway\u003c/em\u003e from the screen, the \u003ccode\u003erefreshData\u003c/code\u003e coroutine launched by \u003ccode\u003eviewModelScope\u003c/code\u003e keeps running in the background until it completes. If the data loading is resource-intensive and the user quickly moves elsewhere, you\u0026#39;re wasting resources loading data that\u0026#39;s no longer needed immediately. Ideally, this work should be cancelled. This might seem minor for a home screen, but if this pattern is adopted for the entire codebase, the problem will resurface in more significant ways later.\u003c/p\u003e\u003ch2 id=\"7803\"\u003e3. Do not observe data sources in the background!\u003c/h2\u003e\u003cp id=\"804e\"\u003eLet’s say QA has reported #1 and #2 from the previous chapter to us. We decided to not add any hacks, and instead correctly subscribe to the \u003ccode\u003euser: Flow\u003c/code\u003e in our ViewModel.\u003c/p\u003e\u003cp id=\"9c29\"\u003eThis is good, because now we\u0026#39;re able to \u003cstrong\u003ereactively observe data\u003c/strong\u003e in our view model. Whenever \u003cstrong\u003eanything\u003c/strong\u003e changes the data, we will know about the update. But we made a critical mistake - \u003cstrong\u003ewe collect the flow in the init block\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a453\"\u003eclass HomeViewModel(\u003cbr/\u003e   private val repo: HomeRepository,\u003cbr/\u003e): ViewModel() {\u003cbr/\u003e    // ... \u003cbr/\u003e    init {\u003cbr/\u003e        repo.user.onEach { user -\u0026gt;\u003cbr/\u003e            _state.value = DisplayingFeed(user, repo.getArticles())\u003cbr/\u003e        }.launchIn(viewModelScope)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e8cc\"\u003eI’ve used \u003ccode\u003elaunchIn\u003c/code\u003e here to make the code look deceptively simple (and similar to what I’ve seen my colleagues write). The core problem isn\u0026#39;t \u003ccode\u003elaunchIn\u003c/code\u003e itself, but collecting a flow for the entire lifetime of the \u003ccode\u003eviewModelScope\u003c/code\u003e without considering the UI lifecycle. Any mechanism that makes a cold flow - \u003cem\u003ehot\u003c/em\u003e (like \u003ccode\u003ecollect\u003c/code\u003e, \u003ccode\u003elaunchIn\u003c/code\u003e, \u003ccode\u003estateIn\u003c/code\u003e with \u003ccode\u003eSharingStarted.Eagerly\u003c/code\u003e or \u003ccode\u003eLazily\u003c/code\u003e) can lead to this.\u003c/p\u003e\u003cp id=\"f899\"\u003eThe reason the mistake is “critical” is because when we start doing this for all of our screens, we will have leaks that waste resources proportionally to the backstack size, not even mentioning wasting the resources while the app is in background.\u003c/p\u003e\u003cp id=\"61fe\"\u003eLet’s say the user can open the feed page multiple times. The backstack will grow without any limits, and \u003cstrong\u003eeach new ViewModel in the backstack will continue to load and update data\u003c/strong\u003e. If you have 100 pages in the history, the moment one property of the user object changes, 100 pages will reload their information. This will surface in bad user reviews (poor performance, device heats up, poor battery life) and obscure, untraceable ANRs and OOM crashes, \u003cstrong\u003ein production\u003c/strong\u003e. This is almost impossible to discover with manual QA, integration testing, unit testing or during development unless you look for this specific issue.\u003c/p\u003e\u003cp id=\"8680\"\u003eIf you start fixing this on a case by case basis instead, you will need to add caching with the ability to retry, manual lifecycle hooks for every ViewModel, error handling and throttling code, and it will get out of hand quickly. So,\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"193d\"\u003e\u003cstrong\u003e\u003cem\u003eDo NOT collect flows using the \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e\u003cem\u003eviewModelScope\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e \u003c/em\u003e\u003c/strong\u003e\u003cem\u003eunless you explicitly \u003c/em\u003eneed\u003cem\u003e the data stream to remain active even when the UI is not visible\u003c/em\u003e\u003cstrong\u003e\u003cem\u003e.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"7981\"\u003eThe shoulder case above is rare (maybe \u0026lt;5% of cases) and often indicates an underlying architectural issue or a need for a dedicated background worker.\u003c/p\u003e\u003ch2 id=\"38cb\"\u003e4. Do not trigger loading from the UI\u003c/h2\u003e\u003cp id=\"3c74\"\u003eSuppose you just got frustrated this isn’t working and decided to trigger loading of all information from the UI (in our example — from the composition):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"07da\"\u003eclass HomeViewModel(/* ... */) : ViewModel() {\u003cbr/\u003e    // ... \u003cbr/\u003e    suspend fun observeData() = coroutineScope {\u003cbr/\u003e        val feed = repo.getArticles()\u003cbr/\u003e        repo.user.collect { user -\u0026gt;\u003cbr/\u003e            _state.update {\u003cbr/\u003e                it.copy(user = user, feed = feed)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun HomeScreen(vm: HomeViewModel) {\u003c/p\u003e\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        vm.observeData()\u003cbr/\u003e    }\u003cbr/\u003e    // ... \u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f393\"\u003eSo in our example we refresh the data until observeData() is cancelled, i.e. while the page is visible.\u003c/p\u003e\u003cp id=\"3a5a\"\u003eThis approach, including variations like sending “ScreenVisible” events/intents from the UI to the ViewModel to trigger \u003ccode\u003eviewModelScope.launch { ... }\u003c/code\u003e, is just another form of manual lifecycle and job management.\u003c/p\u003e\u003cp id=\"e173\"\u003eThe problems with it are:\u003c/p\u003e\u003col\u003e\u003cli id=\"f268\"\u003eWe’re back to manually trying to align data loading with the UI lifecycle, which \u003ccode\u003eLaunchedEffect\u003c/code\u003e or \u003ccode\u003eonResume\u003c/code\u003e only partially address.\u003c/li\u003e\u003cli id=\"5b40\"\u003eWe leak the responsibilities of the ViewModel (loading data) onto the UI layer.\u003c/li\u003e\u003cli id=\"0e99\"\u003eWe now always have to keep track of whether \u003cstrong\u003eonly one consumer\u003c/strong\u003e is running the \u003ccode\u003eobserveData()\u003c/code\u003e .\u003c/li\u003e\u003cli id=\"486a\"\u003eThere is additional burden on the UI to decide when the refreshing is needed. What if the UI doesn’t need the state until, for example user has dismissed an update dialog? Or signed in? All that logic is now on the UI.\u003c/li\u003e\u003cli id=\"9f24\"\u003eHow do you handle retries if \u003ccode\u003erepo.getArticles()\u003c/code\u003e fails? Putting retry logic inside \u003ccode\u003eobserveData\u003c/code\u003e is possible, but triggering it or managing its state from the UI becomes awkward.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"3761\"\u003ePart 2: The Right Way to Load and Observe Data\u003c/h2\u003e\u003cp id=\"2d67\"\u003eSo we have defined what we must not do:\u003c/p\u003e\u003cul\u003e\u003cli id=\"71ef\"\u003e\u003cstrong\u003eDon’t observe data streams indefinitely\u003c/strong\u003e in the backstack/\u003ccode\u003eviewModelScope\u003c/code\u003e without lifecycle awareness.\u003c/li\u003e\u003cli id=\"b7c4\"\u003e\u003cstrong\u003eDon’t rely on manual UI triggers\u003c/strong\u003e or lifecycle callbacks (\u003ccode\u003eonResume\u003c/code\u003e, \u003ccode\u003eLaunchedEffect\u003c/code\u003e) to start core data loading logic in the ViewModel.\u003c/li\u003e\u003cli id=\"4dcd\"\u003e\u003cstrong\u003eDon’t use raw mutable state\u003c/strong\u003e (\u003ccode\u003eMutableStateFlow\u003c/code\u003e) as your primary state holder without a robust, atomic update mechanism.\u003c/li\u003e\u003cli id=\"4112\"\u003e\u003cstrong\u003eDon’t roll your own complex job management\u003c/strong\u003e for cancellation and restarting.\u003c/li\u003e\u003cli id=\"af37\"\u003e\u003cstrong\u003eDon’t fetch all data sources again if only one changes\u003c/strong\u003e (unless necessary).\u003c/li\u003e\u003cli id=\"2d89\"\u003e\u003cstrong\u003eDon’t use loading logic that isn’t easily cancellable\u003c/strong\u003e or retryable.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"41a0\"\u003eAnd now here’s what we should actually do:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"9f73\"\u003e\u003cstrong\u003e\u003cem\u003eCombine multiple data sources reactively using flow operators (like \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cem\u003ecombine\u003c/em\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e) and expose the result as a \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cem\u003eStateFlow\u003c/em\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e using \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cem\u003estateIn\u003c/em\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e, configuring it to respect the presence of UI subscribers via \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cem\u003eSharingStarted.WhileSubscribed\u003c/em\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"f1f4\"\u003eAn example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"79f5\"\u003eclass HomeViewModel(\u003cbr/\u003e    private val repo: HomeRepository,\u003cbr/\u003e): ViewModel() {\u003cp\u003e        private val articles = flow { emit(repo.getArticles()) }, // 1\u003c/p\u003e\u003cp\u003e        val state = combine( // 2\u003cbr/\u003e         repo.user.distinctUntilChanged(), \u003cbr/\u003e         articles,\u003cbr/\u003e    ) { user, feed -\u0026gt; \u003cbr/\u003e        DisplayingFeed(user, feed)\u003cbr/\u003e    }.stateIn( // 3 \u003cbr/\u003e        scope = viewModelScope, \u003cbr/\u003e        initialValue = HomeState.Loading \u003cbr/\u003e        started = SharingStarted.WhileSubscribed( // 4\u003cbr/\u003e           stopTimeoutMillis = 1.seconds, // 5\u003cbr/\u003e           replayExpirationMillis = 9.seconds, // 6\u003cbr/\u003e         ), \u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8ab2\"\u003e\u003cstrong\u003e1. \u003c/strong\u003eWe wrap the \u003ccode\u003erepo.getArticles()\u003c/code\u003e suspend function call in a \u003ccode\u003eflow { }\u003c/code\u003e builder. This creates a \u003cem\u003ecold\u003c/em\u003e flow – it doesn\u0026#39;t do anything until collected. We can also apply any mapping operators to \u003cstrong\u003eindividual\u003c/strong\u003e flows instead of during state assembly, significantly reducing wasted work.\u003c/p\u003e\u003cp id=\"524c\"\u003e\u003cstrong\u003e2. \u003c/strong\u003eThe \u003ccode\u003ecombine\u003c/code\u003e operator:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bd90\"\u003eCollects all provided flows (\u003ccode\u003erepo.user\u003c/code\u003e, \u003ccode\u003earticles\u003c/code\u003e) concurrently.\u003c/li\u003e\u003cli id=\"911f\"\u003eAs soon as \u003cem\u003eall\u003c/em\u003e flows have emitted at least one value, invokes the transformation lambda (\u003ccode\u003e{ user, articles -\u0026gt; ... }\u003c/code\u003e) with the \u003cem\u003elatest\u003c/em\u003e value from each flow.\u003c/li\u003e\u003cli id=\"14c2\"\u003eWhenever \u003cem\u003eany\u003c/em\u003e of the input flows emits a \u003cem\u003enew\u003c/em\u003e value later, \u003ccode\u003ecombine\u003c/code\u003e re-runs the lambda with the new value and the most recent (cached) values from the other flows, producing an updated \u003ccode\u003eHomeState\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"aa67\"\u003e\u003cstrong\u003e3. \u003c/strong\u003eWe call the \u003ccode\u003estateIn\u003c/code\u003e operator to convert our \u003cstrong\u003ecold\u003c/strong\u003e flow to a \u003cstrong\u003ehot flow\u003c/strong\u003e, mainly, because we want to have a \u003ccode\u003evalue\u003c/code\u003e which can be used on the UI to render it, and to cache and reuse the result of the operator. We will \u003cem\u003eproduce\u003c/em\u003e the parent flow in the view model scope, but...\u003c/p\u003e\u003cp id=\"ddb5\"\u003e\u003cstrong\u003e4. \u003c/strong\u003eWe will only \u003cem\u003ecollect\u003c/em\u003e the parent flow \u003ccode\u003eWhileSubscribed\u003c/code\u003e. When first subscriber appears, the \u003ccode\u003estateIn\u003c/code\u003e will trigger collection of the \u003ccode\u003ecombine\u003c/code\u003e result flow, which in turn will trigger all of our data sources. Furthermore, we configure the \u003ccode\u003eWhileSubscribed\u003c/code\u003e such that...\u003c/p\u003e\u003cp id=\"786d\"\u003e\u003cstrong\u003e5. \u003c/strong\u003eWe stop \u003cstrong\u003eand cancel\u003c/strong\u003e the collection of the flow after 1 second (or other reasonable small delay). The 1 second is just an arbitrary value that is roughly equivalent to how long a configuration change can take on Android worst-case. We need to do that because on Android specifically, the UI will briefly unsubscribe while the configuration changes sometimes, and we don’t want to waste resources because of that.\u003c/p\u003e\u003cp id=\"c707\"\u003e\u003cstrong\u003e6. \u003c/strong\u003eAdditionally, we configure a \u003ccode\u003ereplayExpirationMillis\u003c/code\u003e, which is how long a value that was computed last time will be valid for our UI, if it needs to resubscribe. If that time expires, the state will go to the \u003ccode\u003einitialValue\u003c/code\u003e again. This isn\u0026#39;t the same as \u003ccode\u003estopTimeout\u003c/code\u003e, as an expiring \u003ccode\u003estopTimeout\u003c/code\u003e will cause the \u003ccode\u003ecombine\u003c/code\u003e to \u003cstrong\u003ere-trigger\u003c/strong\u003e all of the flows regardless of the replay, but a valid replay will also provide the last emitted value to subscribers while that re-trigger is happening (instead of the \u003ccode\u003einitialValue\u003c/code\u003e). That number excludes \u003ccode\u003estopTimeout\u003c/code\u003e, so I subtracted 1 second from my desired ten. Sometimes, you may want this to be long or infinite depending on the desired UX.\u003c/p\u003e\u003cp id=\"9df4\"\u003eHere’s why this code has none of the problems discussed above:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8252\"\u003e\u003cstrong\u003eLazy \u0026amp; On-Demand:\u003c/strong\u003e Data loading (\u003ccode\u003earticles\u003c/code\u003e) only starts when the UI observes the \u003ccode\u003estate\u003c/code\u003e. \u003ccode\u003erepo.user\u003c/code\u003e is only observed while the UI is subscribed. No work is done if the UI isn\u0026#39;t interested.\u003c/li\u003e\u003cli id=\"a8d9\"\u003e\u003cstrong\u003eAlways Up-to-Date:\u003c/strong\u003e \u003ccode\u003ecombine\u003c/code\u003e ensures that changes in \u003cem\u003eany\u003c/em\u003e underlying data source (\u003ccode\u003erepo.user\u003c/code\u003e) automatically trigger a state update.\u003c/li\u003e\u003cli id=\"631c\"\u003e\u003cstrong\u003eParallel Loading:\u003c/strong\u003e \u003ccode\u003ecombine\u003c/code\u003e collects its input flows concurrently. \u003ccode\u003erepo.user\u003c/code\u003e observation starts, and \u003ccode\u003earticlesFlow\u003c/code\u003e execution starts in parallel. The first \u003ccode\u003eDisplayingFeed\u003c/code\u003e state is emitted as soon as both have produced a value.\u003c/li\u003e\u003cli id=\"00c3\"\u003e\u003cstrong\u003eAtomic \u0026amp; Safe Updates:\u003c/strong\u003e The coroutine machinery handles the concurrency, atomicity, and thread safety within \u003ccode\u003ecombine\u003c/code\u003e and \u003ccode\u003estateIn\u003c/code\u003e. We don\u0026#39;t need manual synchronization in the transformation lambda.\u003c/li\u003e\u003cli id=\"8826\"\u003e\u003cstrong\u003eSingle Upstream Collector:\u003c/strong\u003e \u003ccode\u003estateIn\u003c/code\u003e ensures the upstream \u003ccode\u003ecombine\u003c/code\u003e flow is collected only \u003cem\u003eonce\u003c/em\u003e, regardless of how many UI collectors observe the final \u003ccode\u003estate\u003c/code\u003e. No risk of uncontrolled coroutine proliferation.\u003c/li\u003e\u003cli id=\"ca8c\"\u003e\u003cstrong\u003eLifecycle-Aware \u0026amp; Cancellable:\u003c/strong\u003e \u003ccode\u003eSharingStarted.WhileSubscribed\u003c/code\u003e automatically cancels the upstream collection (including the \u003ccode\u003earticles\u003c/code\u003e network call) when the UI is no longer observing (after the timeout), preventing leaked work and saving resources.\u003c/li\u003e\u003cli id=\"d1c4\"\u003e\u003cstrong\u003eDecoupled:\u003c/strong\u003e The ViewModel focuses purely on defining the state based on data sources. The UI simply collects the \u003ccode\u003estate\u003c/code\u003e using lifecycle-aware collectors (like \u003ccode\u003ecollectAsStateWithLifecycle()\u003c/code\u003e in Compose) without needing to know \u003cem\u003ehow\u003c/em\u003e the state is produced or trigger anything.\u003c/li\u003e\u003cli id=\"2087\"\u003e\u003cstrong\u003eRetryable:\u003c/strong\u003e You can easily add retry logic to the individual flows \u003cem\u003ebefore\u003c/em\u003e they enter the \u003ccode\u003ecombine\u003c/code\u003e operator (e.g., using the \u003ccode\u003eretry\u003c/code\u003e operator on \u003ccode\u003earticles\u003c/code\u003e) without complicating the overall structure.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1e78\"\u003eBut what if I have transient data that I want to update manually?\u003c/h2\u003e\u003cp id=\"fe1c\"\u003eThen do \u003cstrong\u003eNOT\u003c/strong\u003e do this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1224\"\u003eclass HomeViewModel @Inject constructor() : ViewModel() {\u003cp\u003e        private val screenState = MutableStateFlow(value = ScreenState())  \u003cbr/\u003e    val uiState = screenState  \u003cbr/\u003e        .onStart {   fetchArticleList()   }  // ❌\u003cbr/\u003e        .stateIn(  \u003cbr/\u003e            scope = viewModelScope,  \u003cbr/\u003e            started = SharingStarted.WhileSubscribed(stopTimeoutMillis = 5000L),  \u003cbr/\u003e            initialValue = screenState.value,  // ❌\u003cbr/\u003e        )  \u003c/p\u003e\u003cp\u003e    suspend fun fetchArticleList() {  \u003cbr/\u003e        delay(timeMillis = 2000L)  \u003cbr/\u003e        screenState.update { state -\u0026gt; \u003cbr/\u003e            state.copy(  \u003cbr/\u003e                text = \u0026#34;Fetch Data ${state.counter}\u0026#34;,  \u003cbr/\u003e                counter = state.counter + 1  \u003cbr/\u003e            )  \u003cbr/\u003e        }  \u003cbr/\u003e    }  \u003cbr/\u003e}  \u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"f408\"\u003e\u003cem\u003eThis erroneous code is copied directly from another \u003c/em\u003e\u003ca href=\"https://medium.com/proandroiddev/load-initial-data-when-screen-appears-358f77126a08\" rel=\"noopener\"\u003e\u003cem\u003earticle\u003c/em\u003e\u003c/a\u003e\u003cem\u003e on loading initial data.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"9cc8\"\u003eProblems with the code:\u003c/p\u003e\u003col\u003e\u003cli id=\"f4b5\"\u003e\u003cstrong\u003eDouble dispatching\u003c/strong\u003e. We convert a hot flow to a cold flow using \u003ccode\u003eonStart\u003c/code\u003e and then back to a hot flow. At a minimum, it\u0026#39;s a wasted computation, but this code also doesn\u0026#39;t behave correctly, as the \u003ccode\u003eWhileSubscribed\u003c/code\u003e option has no effect on a flow that is backed by a hot flow already. The \u003ccode\u003eonStart\u003c/code\u003e operator is invoked eagerly because the flow is hot.\u003c/li\u003e\u003cli id=\"e37d\"\u003e\u003ccode\u003eonStart\u003c/code\u003e \u003cstrong\u003eisn\u0026#39;t the correct operator to use\u003c/strong\u003e. I already explained how custom callbacks make our code fragile and non-thread-safe.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"dbd7\"\u003eThe code above rolls its own mutable state, and uses double conversion with a trigger to load the initial data, but most importantly, it uses a pattern of “amending” the transient state with the source data. We should do the opposite by \u003cstrong\u003eamending the data source state with the transient state\u003c/strong\u003e, like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9bdd\"\u003edata class UserInput(\u003cbr/\u003e    val searchQuery: String? = null,\u003cbr/\u003e)\u003cp\u003esealed interface HomeState {\u003cbr/\u003e   // ...\u003cbr/\u003e   data class DisplayingArticles(\u003cbr/\u003e       val input: UserInput,\u003cbr/\u003e       // ... \u003cbr/\u003e   )\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass HomeViewModel(/* .. */) : ViewModel() {\u003cbr/\u003e    // ...\u003c/p\u003e\u003cp\u003e    private val input = MutableStateFlow(UserInput())\u003c/p\u003e\u003cp\u003e    val state = combine(\u003cbr/\u003e         repo.user, \u003cbr/\u003e         articles,\u003cbr/\u003e         input, // \u0026lt;- ! using our input\u003cbr/\u003e    ) { user, feed, input -\u0026gt; \u003cbr/\u003e        DisplayingFeed(input, user, feed)\u003cbr/\u003e    }.stateIn( / * ... */ )\u003c/p\u003e\u003cp\u003e    fun onSearchQueryChanged(value: String) = input.update {\u003cbr/\u003e        it.copy(searchQuery = value)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"27cf\"\u003eThis way:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bbac\"\u003eTransient state (\u003ccode\u003e_input\u003c/code\u003e) is managed separately and updated atomically using \u003ccode\u003eupdate\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"2334\"\u003eThe main \u003ccode\u003estate\u003c/code\u003e is still derived reactively by \u003ccode\u003ecombine\u003c/code\u003e and gets all the benefits of \u003ccode\u003estateIn\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5a1a\"\u003eBut what if I’m using MVI?\u003c/h2\u003e\u003cp id=\"c80a\"\u003eWell, this is a complicated one. With MVI, we \u003cstrong\u003ehave to\u003c/strong\u003e use a single, mutable state as the source of truth. It’s one of the “flaws” of MVI that proponents of MVVM often appeal to. Mutable state of MVI has its advantages, but here we have to pay the price. But don’t worry, it’s possible to solve this.\u003c/p\u003e\u003cp id=\"5fd1\"\u003eWe just need to implement logic similar to how \u003ccode\u003eWhileSubscribed\u003c/code\u003e works under the hood: it tracks the number of subscribers, and when the number of them drops to 0, it dispatches a special command to the flow to cancel the collection of the upstream.\u003c/p\u003e\u003cp id=\"837a\"\u003eI thought about this for a while and devised the following extension functions that should behave similarly:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2402\"\u003esuspend inline fun MutableSharedFlow\u0026lt;*\u0026gt;.whileSubscribed(  \u003cbr/\u003e    stopDelay: Duration = 1.seconds,  \u003cbr/\u003e    minSubscribers: Int = 1,\u003cbr/\u003e    crossinline action: suspend () -\u0026gt; Unit  \u003cbr/\u003e) = subscriptionCount  // 1\u003cbr/\u003e    .map { it \u0026gt;= minSubscribers } // 2  \u003cbr/\u003e    .dropWhile { !it }  // 3\u003cbr/\u003e    .debounce { if (it) Duration.ZERO else stopDelay } // 4  \u003cbr/\u003e    .distinctUntilChanged() // 5\u003cbr/\u003e    .collectLatest { if (it) action() }  // 6\u003cp\u003einline fun MutableSharedFlow\u0026lt;*\u0026gt;.whileSubscribed(  \u003cbr/\u003e    scope: CoroutineScope,  \u003cbr/\u003e    stopDelay: Duration = 1.seconds,  \u003cbr/\u003e    minSubscribers: Int = 1,\u003cbr/\u003e    crossinline action: suspend () -\u0026gt; Unit  \u003cbr/\u003e) = scope.launch(start = CoroutineStart.UNDISPATCHED) {  \u003cbr/\u003e    whileSubscribed(stopDelay, minSubscribers, action)  \u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"40ff\"\u003eLet’s explain it line by line:\u003c/p\u003e\u003col\u003e\u003cli id=\"8013\"\u003eEach \u003ccode\u003eMutableSharedFlow\u003c/code\u003e (which StateFlow \u003cstrong\u003eis\u003c/strong\u003e) has a separate flow \u003ccode\u003esubscriptionCount\u003c/code\u003e, we use it...\u003c/li\u003e\u003cli id=\"8947\"\u003eTo map to whether we have any subscribers that satisfy criteria,..\u003c/li\u003e\u003cli id=\"198f\"\u003eThen wait until that condition becomes true \u003cstrong\u003efor the first time\u003c/strong\u003e…\u003c/li\u003e\u003cli id=\"e062\"\u003eThen if the condition became true, we immediately proceed, otherwise wait \u003ccode\u003estopDelay\u003c/code\u003e to see if the subscribers appear again shortly...\u003c/li\u003e\u003cli id=\"4292\"\u003eThen filter out duplicates (that would otherwise repeatedly cancel our flow) of subscription events…\u003c/li\u003e\u003cli id=\"0972\"\u003eAnd then on each change of the subscription count condition, we run \u003ccode\u003eaction\u003c/code\u003e if it became \u003ccode\u003etrue\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"198a\"\u003eThen all you have to do to use this function is:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98f0\"\u003eclass HomeViewModel( /* ... */ ) : ViewModel() {\u003cbr/\u003e    // ...\u003cp\u003e    init {\u003cbr/\u003e        _state.whileSubscribed(viewModelScope) {\u003cbr/\u003e            combine(\u003cbr/\u003e                 repo.user,\u003cbr/\u003e                 articles,\u003cbr/\u003e            ) { user, feed -\u0026gt; \u003cbr/\u003e                updateState { produceState(user, feed) } // use a state transaction here to handle transient states\u003cbr/\u003e            }.collect() // important - you are expected to suspend in the block\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bdf5\"\u003eKeep in mind:\u003c/p\u003e\u003col\u003e\u003cli id=\"312c\"\u003eI personally didn’t test or use this function in production\u003c/li\u003e\u003cli id=\"dc8a\"\u003eIt handles only subscriptions to the \u003cem\u003estate\u003c/em\u003e. If you have a separate channel for side effects, they won’t be picked up and you need to amend this implementation\u003c/li\u003e\u003cli id=\"ab93\"\u003eIt doesn’t have the state-resetting behavior of \u003ccode\u003eWhileSubscribed\u003c/code\u003e (generally not desired with MVI). If you need it, a simple addition to the \u003ccode\u003ecollect\u003c/code\u003e code can give you that.\u003c/li\u003e\u003cli id=\"7ce3\"\u003eYou still have to correctly subscribe to the state with lifecycle awareness using something like \u003ccode\u003ecollectAsStateWithLifecycle\u003c/code\u003e in Compose.\u003c/li\u003e\u003cli id=\"96dc\"\u003eIt’s dangerous to use this function without \u003ca href=\"https://medium.com/proandroiddev/how-to-safely-update-state-in-your-kotlin-apps-bf51ccebe2ef\" rel=\"noopener\"\u003eSerialized State Transactions \u003c/a\u003ewhen parallel updates are involved (unless you carefully make the transactions atomic manually).\u003c/li\u003e\u003cli id=\"5f39\"\u003eYou are expected to \u003cstrong\u003esuspend\u003c/strong\u003e in the \u003ccode\u003eaction\u003c/code\u003e block (instead of using \u003ccode\u003eviewModelScope\u003c/code\u003e) in order to play along with our cancellation policy.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"e3b9\"\u003eConclusion: Don’t Reinvent the Wheel\u003c/h2\u003e\u003cp id=\"5d4b\"\u003eIf you are using plain simple MVVM(+), lucky you! Just don’t reinvent the wheel — use the proven and idiomatic way of loading data and producing state, and you will be good for the most part!\u003c/p\u003e\u003cp id=\"ebef\"\u003eAnd if at some point you decided that you want safer state management or some of the features of MVI, and all that setup sounds complicated, you’re right. There’s just too much stuff to keep in mind.\u003c/p\u003e\u003cp id=\"c531\"\u003eWhen people feel like they need something more robust than MVVM, they often roll their own “in-house MVI implementation”, but when it comes to correctly loading and observing data, handling \u003ca href=\"https://medium.com/proandroiddev/viewmodel-events-as-state-are-an-antipattern-35ff4fbc6fb6\" rel=\"noopener\"\u003eside effects\u003c/a\u003e or \u003ca href=\"https://medium.com/proandroiddev/how-to-safely-update-state-in-your-kotlin-apps-bf51ccebe2ef\" rel=\"noopener\"\u003emanaging state\u003c/a\u003e, 95% of those “implementations” are \u003cstrong\u003eflawed\u003c/strong\u003e in one way or another.\u003c/p\u003e\u003cp id=\"0b8d\"\u003eIt only sounds simple on the surface:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"ac30\"\u003e\u003cem\u003e“I just need a flow for side effects and a state flow for states and then to send intents, right?”\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"88df\"\u003eNot so much, as you see. In my opinion, that’s why architecture frameworks exist. The benefit of them is that all of the complicated stuff like this is solved, documented, thoroughly tested, benchmarked and verified in production \u003cstrong\u003ebefore\u003c/strong\u003e you commit to any usage of the new code.\u003c/p\u003e\u003cp id=\"2e24\"\u003eYou can reinvent a wheel and not depend on any framework — sure, great, “one less library the author may abandon any moment”. But how is \u003cem\u003eyour\u003c/em\u003e wheel (that your team now has to maintain and fix) better than the community-driven, tested, optimized, documented, polished solution that solved the problems that you never even knew existed, for years?\u003c/p\u003e\u003cp id=\"eeb6\"\u003eI made \u003ca href=\"https://opensource.respawn.pro/FlowMVI/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFlowMVI\u003c/a\u003e precisely because of that — I was tired of seeing me and my team make the same mistakes over, and over, and over. I spent 2 years polishing the framework so that the entirety of this article is reduced to this code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a62a\"\u003eval store = store(HomeState.Loading) {\u003cp\u003e        val articles by retry { repo.getArticles() }\u003c/p\u003e\u003cp\u003e        whileSubscribed { \u003cbr/\u003e        combine(repo.user, articles) { user, feed -\u0026gt;\u003cbr/\u003e            updateState { DisplayingFeed(user, feed, typed\u0026lt;DisplayingFeed\u0026gt;())  }\u003cbr/\u003e        }.collect()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable  \u003cbr/\u003efun HomeScreen( /* ... */ ) {  \u003c/p\u003e\u003cp\u003e    val state by store.subscribe()   \u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6eef\"\u003eThe code above follows system, composition, navigation and subscription plifecycle, uses SSTs to update the state in parallel, uses transient state to preserve data, allows to retry computations, resets the state properly on shutdown, and even persists the state to disk as needed.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "26 min read",
  "publishedTime": "2025-05-04T06:10:08.993Z",
  "modifiedTime": null
}
