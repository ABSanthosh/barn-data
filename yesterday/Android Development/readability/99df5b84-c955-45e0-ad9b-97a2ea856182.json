{
  "id": "99df5b84-c955-45e0-ad9b-97a2ea856182",
  "title": "Building a sub-sampling image viewer for Compose UI",
  "link": "https://saket.me/compose-sub-sampling-image-viewer/",
  "description": "How do you display a 100mb image on Android without running into OutOfMemoryError? You can’t. But you can cheat. For years Android developers have used Dave Morrissey’s excellent library, subsampling-scale-image-view for displaying large bitmaps with deep zoom. It optimizes memory usage by loading lower resolution bitmaps whenever possible and avoiding loading parts of the original […] The post Building a sub-sampling image viewer for Compose UI appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Wed, 09 Aug 2023 21:07:52 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android"
  ],
  "byline": "Saket Narayan",
  "length": 5329,
  "excerpt": "How do you display a 100mb image on Android without running into OutOfMemoryError? You can’t. But you can cheat.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "How do you display a 100mb image on Android without running into OutOfMemoryError? You can’t. But you can cheat. For years Android developers have used Dave Morrissey’s excellent library, subsampling-scale-image-view for displaying large bitmaps with deep zoom. It optimizes memory usage by loading lower resolution bitmaps whenever possible and avoiding loading parts of the original image that are not visible. It felt magical. When Compose UI came out, it made it difficult to continue using subsampling-scale-image-view due to its initial lack of interoperability with Views, especially around nested scrolling. It made me wish that the library’s image viewer code was decoupled from its gesture detector. That’d have made it possible for me to plug-in a compose-compatible gesture detector and even allowed the same gestures to be used for GIFs and other non-sampled bitmaps. This seed of an idea blossomed into what telephoto is today. Building a sub-sampling image viewer from scratch was a lot of fun and I’d like to share my adventure with future Sakets who might dare to embark on the same path for Android or other platforms. There are two concepts for displaying a large image with minimal memory usage: 1. Sub-sampling Phones are small, images can be big. To fit an 4K image within a Pixel 7’s 1080p display, scaling it to 0.5x zoom is necessary. However, a more efficient approach is to load the image at half its resolution and display it at 1x zoom, achieving the same visual quality. Left: 2160p resolution at 0.5x zoom. Right: 1080p resolution at 1x zoom. Photo by Romain Guy. If you ask your math professor, they’ll agree that 2160 x 0.5 == 1080 x 1. Our eyes wouldn’t be able to tell any differences between the two images and we’ll have saved a whopping 75% of memory space — from ~23.7MB to ~5.9MB. // Assuming that the image has a color depth of // 8 bits per channel in the sRGB color space. 2160 x 3840 x 3 = ~23.7 MB 1080 x 1920 x 3 = ~5.9 MB For decoding an image at a lower resolution, telephoto uses Android’s BitmapRegionDecoder. It uses a technique called “sub-sampling”, which involves sampling and retaining only a subset of the original data with fewer data points. In other words, a 4K image can be converted into 1080p by skipping every alternate pixel. val decoder = BitmapRegionDecoder.newInstance(…) val bitmap = decoder.decodeRegion( bounds = tile.bounds, options = BitmapFactory.Options().apply { inSampleSize = sampleSizeFor(tile.zoom) } ) 2. Tiling Images can’t remain zoomed-out forever. Telephoto is a zoomable image library after all (among other things). As an image is zoomed in, it is progressively replaced with higher resolution copies at various zoom buckets. This reduces the amount of memory saved through sub-sampling, but opens up another clever way to save memory — tiling. Tiling refers to a technique where the image is divided into smaller tiles so that they can be lazy loaded. Tiles whose coordinates lie within the visible region are selectively loaded and cached. When the image is panned, tiles that are no longer visible are safely discarded from memory. val tileSize = imageSize * (sampleSizeFor(zoom) / sampleSizeAtMinZoom) val xTileCount = imageSize.width / tileSize.width val yTileCount = imageSize.height / tileSize.height val tileGrid = (0 until xTileCount).flatMap { x -\u003e (0 until yTileCount).map { y -\u003e BitmapRegionTile( zoom = zoom, bounds = IntRect( offset = IntOffset( x = x * tileSize.width, y = y * tileSize.width ), size = tileSize, ) ) } } val tileBounds = tile.bounds.scaledAndOffsetBy(zoom, offset) val isTileVisible = tileBounds.overlaps(canvasBounds) These two strategies ensure that the memory usage of images remains approximately the same regardless of how large they are. A 1080p image and an 8k image will have similar memory usage on a Pixel 7! One small detail that was omitted from the video above is that the loading of bitmap tiles is not instant and can take time depending on the image size. To hide this, telephoto draws the base, low-resolution tile as a filler. Take a penny, leave a penny One interesting math problem I ran into was that the visible tiles need to be stitched together after they’ve been divided. Because zoom levels are fractional and canvas expects integers, it’s easy to run into precision errors. My first naive attempt was to convert fractions into integers by using Math.ceil. As you may have guessed, this caused the tiles to contain gaps at certain levels: A correct solution was to discard fractional values from all tiles (commit). This may sound the opposite of what was needed, but it works out well since discarding a fractional value causes the next tile to be shifted back by a pixel and so on, eventually eliminating any fractional error from the whole image. The last tiles along the X and Y axes may become 1px shorter than the original image, but who cares it’s not noticeable enough to be a problem. If you’ve made it to the end of this article, I’d recommend checking out telephoto. It performs everything mentioned along with gestures for panning and zooming images with just one word: - AsyncImage( + ZoomableAsyncImage( model = \"https://example.com/image.jpg\", contentDescription = ... )",
  "image": "https://saket.me/wp-content/uploads/2023/08/subsamplingimage_cover.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eHow do you display a 100mb image on Android without running into \u003ccode\u003eOutOfMemoryError\u003c/code\u003e? You can’t. But you can cheat.\u003c/p\u003e\n\u003cp\u003eFor years Android developers have used Dave Morrissey’s excellent library, \u003ca href=\"https://github.com/davemorrissey/subsampling-scale-image-view\"\u003esubsampling-scale-image-view\u003c/a\u003e for displaying large bitmaps with deep zoom. It optimizes memory usage by loading lower resolution bitmaps whenever possible and avoiding loading parts of the original image that are not visible. It felt magical.\u003c/p\u003e\n\u003cp\u003eWhen Compose UI came out, it made it difficult to continue using \u003ccode\u003esubsampling-scale-image-view\u003c/code\u003e due to its initial lack of interoperability with Views, especially around nested scrolling. It made me wish that the library’s image viewer code was decoupled from its gesture detector. That’d have made it possible for me to plug-in a compose-compatible gesture detector and even allowed the same gestures to be used for GIFs and other non-sampled bitmaps.\u003c/p\u003e\n\u003cp\u003eThis seed of an idea blossomed into what \u003ca href=\"https://saket.github.io/telephoto/\"\u003etelephoto\u003c/a\u003e is today. Building a sub-sampling image viewer from scratch was a lot of fun and I’d like to share my adventure with future Sakets who might dare to embark on the same path for Android or other platforms.\u003c/p\u003e\n\u003cp\u003eThere are two concepts for displaying a large image with minimal memory usage:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Sub-sampling\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePhones are small, images can be big. To fit an 4K image within a Pixel 7’s 1080p display, scaling it to 0.5x zoom is necessary. However, a more efficient approach is to load the image at half its resolution and display it at 1x zoom, achieving the same \u003cem\u003evisual\u003c/em\u003e quality.\u003c/p\u003e\n\u003cfigure id=\"attachment_1711\" aria-describedby=\"caption-attachment-1711\"\u003e\u003cimg decoding=\"async\" data-attachment-id=\"1711\" data-permalink=\"https://saket.me/compose-sub-sampling-image-viewer/sampled_vs_non_samped/\" data-orig-file=\"https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped.jpg\" data-orig-size=\"1002,600\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"sampled_vs_non_samped\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped-300x180.jpg\" data-large-file=\"https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped.jpg\" src=\"https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped.jpg\" alt=\"\" width=\"1002\" height=\"600\" srcset=\"https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped.jpg 1002w, https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped-300x180.jpg 300w, https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped-768x460.jpg 768w, https://saket.me/wp-content/uploads/2023/08/sampled_vs_non_samped-600x359.jpg 600w\" sizes=\"(max-width: 1002px) 100vw, 1002px\"/\u003e\u003cfigcaption id=\"caption-attachment-1711\"\u003eLeft: 2160p resolution at 0.5x zoom. Right: 1080p resolution at 1x zoom. Photo by \u003ca href=\"https://androiddev.social/@romainguy\" rel=\"nofollow\"\u003eRomain Guy\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eIf you ask your math professor, they’ll agree that \u003ccode\u003e2160 x 0.5 == 1080 x 1\u003c/code\u003e. Our eyes wouldn’t be able to tell any differences between the two images and we’ll have saved a whopping 75% of memory space — from ~23.7MB to ~5.9MB.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Assuming that the image has a color depth of\n// 8 bits per channel in the sRGB color space.\n2160 x 3840 x 3 = ~23.7 MB\n1080 x 1920 x 3 = ~5.9 MB\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor decoding an image at a lower resolution, telephoto uses Android’s \u003ca href=\"https://developer.android.com/reference/android/graphics/BitmapRegionDecoder#decodeRegion(android.graphics.Rect,%20android.graphics.BitmapFactory.Options)\"\u003eBitmapRegionDecoder\u003c/a\u003e. It uses a technique called “sub-sampling”, which involves sampling and retaining only a subset of the original data with fewer data points. In other words, a 4K image can be converted into 1080p by skipping every alternate pixel.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval decoder = BitmapRegionDecoder.newInstance(…)\nval bitmap = decoder.decodeRegion(\n  bounds = tile.bounds,\n  options = BitmapFactory.Options().apply {\n    inSampleSize = sampleSizeFor(tile.zoom)\n  }\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Tiling\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eImages can’t remain zoomed-out forever. Telephoto is a zoomable image library after all (among other things). As an image is zoomed in, it is progressively replaced with higher resolution copies at various zoom buckets. This reduces the amount of memory saved through sub-sampling, but opens up another clever way to save memory — tiling.\u003c/p\u003e\n\u003cp\u003eTiling refers to a technique where the image is divided into smaller tiles so that they can be lazy loaded. Tiles whose coordinates lie within the visible region are selectively loaded and cached. When the image is panned, tiles that are no longer visible are safely discarded from memory.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eval tileSize = imageSize * (sampleSizeFor(zoom) / sampleSizeAtMinZoom)\nval xTileCount = imageSize.width / tileSize.width\nval yTileCount = imageSize.height / tileSize.height\n\nval tileGrid = (0 until xTileCount).flatMap { x -\u0026gt;\n  (0 until yTileCount).map { y -\u0026gt;\n    BitmapRegionTile(\n      zoom = zoom,\n      bounds = IntRect(\n        offset = IntOffset(\n          x = x * tileSize.width, \n          y = y * tileSize.width\n        ),\n        size = tileSize, \n      )\n    )\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eval tileBounds = tile.bounds.scaledAndOffsetBy(zoom, offset)\nval isTileVisible = tileBounds.overlaps(canvasBounds)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese two strategies ensure that the memory usage of images remains approximately the same regardless of how large they are. A 1080p image and an 8k image will have similar memory usage on a Pixel 7!\u003c/p\u003e\n\u003cp\u003eOne small detail that was omitted from the video above is that the loading of bitmap tiles is not instant and can take time depending on the image size. To hide this, telephoto draws the base, low-resolution tile as a filler.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTake a penny, leave a penny\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOne interesting math problem I ran into was that the visible tiles need to be stitched together after they’ve been divided. Because zoom levels are fractional and canvas expects integers, it’s easy to run into precision errors. My first naive attempt was to convert fractions into integers by using \u003ccode\u003eMath.ceil\u003c/code\u003e. As you may have guessed, this caused the tiles to contain gaps at certain levels:\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" data-attachment-id=\"1680\" data-permalink=\"https://saket.me/compose-sub-sampling-image-viewer/precision_error/\" data-orig-file=\"https://saket.me/wp-content/uploads/2023/08/precision_error.png\" data-orig-size=\"1000,600\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"precision_error\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2023/08/precision_error-300x180.png\" data-large-file=\"https://saket.me/wp-content/uploads/2023/08/precision_error.png\" src=\"https://saket.me/wp-content/uploads/2023/08/precision_error.png\" alt=\"\" width=\"1000\" height=\"600\" srcset=\"https://saket.me/wp-content/uploads/2023/08/precision_error.png 1000w, https://saket.me/wp-content/uploads/2023/08/precision_error-300x180.png 300w, https://saket.me/wp-content/uploads/2023/08/precision_error-768x461.png 768w, https://saket.me/wp-content/uploads/2023/08/precision_error-600x360.png 600w\" sizes=\"(max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eA correct solution was to discard fractional values from all tiles (\u003ca href=\"https://github.com/saket/telephoto/commit/b76f287#diff-90dc3746bebdcbb7864d429fa3a9e2a750cbf42c357a244999de68bf31864be9\"\u003ecommit\u003c/a\u003e). This may sound the opposite of what was needed, but it works out well since discarding a fractional value causes the next tile to be shifted back by a pixel and so on, eventually eliminating any fractional error from the whole image. The last tiles along the X and Y axes may become 1px shorter than the original image, but \u003cdel\u003ewho cares\u003c/del\u003e it’s not noticeable enough to be a problem.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eIf you’ve made it to the end of this article, I’d recommend checking out \u003ca href=\"https://saket.github.io/telephoto/\"\u003etelephoto\u003c/a\u003e. It performs everything mentioned along with gestures for panning and zooming images with just one word:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e- AsyncImage(\n+ ZoomableAsyncImage(\n    model = \u0026#34;https://example.com/image.jpg\u0026#34;,\n    contentDescription = ...\n  )\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2023-08-09T21:07:52Z",
  "modifiedTime": "2024-01-27T05:09:15Z"
}
