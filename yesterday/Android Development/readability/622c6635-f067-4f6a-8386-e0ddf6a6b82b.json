{
  "id": "622c6635-f067-4f6a-8386-e0ddf6a6b82b",
  "title": "Gradle toolchains are rarely a good idea",
  "link": "https://jakewharton.com/gradle-toolchains-are-rarely-a-good-idea/",
  "description": "",
  "author": "",
  "published": "2024-03-21T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 7728,
  "excerpt": "21 March 2024",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Gradle toolchains are rarely a good idea 21 March 2024 The last post featured some Kotlin code inadvertently targeting a new Java API when the build JDK was bumped to 21. This can be solved with the -Xjdk-release Kotlin compiler flag, or by using Gradle toolchains to build with an old JDK. If you read the Gradle docs… Using Java toolchains is a preferred way to target a language version …or the Android docs… We recommend that you always specify the Java toolchain …you wouldn’t be blamed for thinking Java toolchains are the way to go! However, Java toolchains are rarely a good idea. Let’s look at why. Bad docs Last week I released a new version of Retrofit which uses a Java toolchain to target Java 8. Its use of toolchains was contributed a while ago, and I simply forgot to remove it. As a consequence, its Javadoc was built using JDK 8 and is thus not searchable. Searchable Javadoc came in JEP 225 with JDK 9. The next release of Retrofit will be made without a toolchain and with the latest JDK. Its docs will have all the Javadoc advancements from the last 10 years including search and better modern HTML/CSS. Resource ignorance Old JVMs were somewhat notorious for being ignorant to resource limitations imposed by the system. The rise of containers, especially on CI systems, means your process resource limits are different from those of the host OS. JDK 10 kicked things into high gear with cgroups support and JDK 15 extended that to cgroups2. Both of those changes were backported to the 8 and 11 branches, but since Gradle toolchains will use an already-installed JDK if available you have to have kept your JDK 8 and/or JDK 11 up-to-date. Have you? Not to stray too far off-topic, but if you installed it with SDKMAN! or similar JDK management tools there’s a good chance it’s wildly out of date. I keep all my JDKs up-to-date by installing them through a Homebrew tap which itself updates automatically using the Azul Zulu API. As long as I do a brew upgrade every so often, each major JDK release that I have installed will be updated. Without a Java toolchain, a modern JDK (even an outdated patch release of one) will honor resource limits and perform much better in containerized environments. Compiler bugs All software has bugs, and sometimes the JVM, the Java compiler, or both have bugs. When you are using a 10-year-old version of the JVM and Java compiler, you run a much greater risk of compiler bugs, especially around features introduced near to that release. There were many compilation problems around lambdas which were introduced in Java 8. If you are using the Java compiler from JDK 8 to target Java 8 JVMs you can still run into those bugs. Even if you are keeping your JDK 8 up-to-date many fixes are not backported. You can find ones on the issue tracker without much effort. Now is the Java compiler in JDK 22 completely bug-free? No. But is using the Java compiler from JDK 22 on sources targeting Java 8 using only Java 8 language features much safer than using one from JDK 8? Absolutely. Worse performance Oracle and other large JVM shops devote lots of person-hours to making the JVM faster. We have newer garbage collectors that use less memory and consume less CPU. Work that happened on startup gets deferred to first-use to try and spread the cost out over the lifetime of the process. Algorithms and in-memory representations are specialized for common cases. A language compiler is basically a worst-case scenario for the JVM. Endless string manipulation, object creation, and so so many maps. These areas receive many improvements over the years. My favorite of which is that strings which are ASCII-based suddenly occupy half as much memory in Java 9 than in Java 8. You know what’s often entirely ASCII? Java and Kotlin source code! Not needed for cross-compilation Using the Java compiler from JDK 8 I can set -source and -target to “1.7” to compile a class that works on a Java 7 JVM. This does not prevent me from using Java 8 APIs, however. You have to add -bootclasspath with a pointer to a JDK 7 runtime (rt.jar) so that the compiler knows what APIs are available in Java 7. You could alternatively use a tool like Animal Sniffer to validate that no APIs newer than Java 7 were used. In this world, just compiling with JDK 7 to target Java 7 might actually just be easier. In JDK 9, however, this all changed. The compiler now contains a record of all public APIs from every Java version going back to Java 8. It also allows specifying a single compiler flag, --release, which sets the source code language version, the target bytecode version, and the available runtime APIs to the specified release. There is simply no value in compiling with an older JDK to target an older JVM anymore. Wasted disk space All those JDKs needlessly take up space in your home directory. Each JDK is a few hundred MiB. By default, Gradle will try to match an existing JDK when a toolchain is requested. Project owners can specify additional attributes such as the JDK vendor which might cause existing JDKs to not match. This means even though one project forced you to install Eclipse Temurin JDK 8, another might force Azul Zulu JDK 8. So not only do you now have a bunch of old JDKs, you have two or three copies of each. My JDK cache in ~/.gradle is nearly 2 GiB. Not the Gradle JVM Toolchains are only used for tasks that create a new JVM. That means compilation (of Java or Kotlin) and running unit tests. They do not control the JVM that is used for running the actual Gradle build or any of the plugins therein. If you have minimum requirements there, or in other JVM-based tools which are invoked by the Gradle build, the toolchain does not help you. If your build already has a minimum JDK requirement then why force installation of old JDKs given the newer one is already available on disk, can cross-compile perfectly, has fewer compiler bugs, builds faster, and respects system CPU and memory limits more effectively? Not all bad I want to stress that toolchains are unequivocally not a good idea for compilation. They still have utility elsewhere, however. Retrofit has runtime behavior that changes based on the JVM version on which it’s running. (This is because until Java 16 it took various different hacks to support invoking default methods through a Proxy.) That code needs to be tested on different JVM versions. As a result, we compile with the latest Java, but test through the lowest-supported Java using toolchains on the Test task. No need to worry about the user having weird old JDKs for Java 14 because it’s now installed on-demand when the full test suite is run. Some tools that dip into JDK internals regularly break on newer versions of the compiler because they rely on unstable APIs. I’m thinking about things like Google Java Format or Error-Prone. No need to hold the rest of your project from enjoying the latest JDK, if those tools are run via a JavaExec task you can use a toolchain to keep them on an older JDK until a newer version is available. What do I do? Use the --release flag if you’re compiling Java! Gradle exposes a property for it now. Use the -Xjdk-release flag if you’re compiling Kotlin. Future versions of the Kotlin Gradle plugin will expose a nice DSL property for it. If you’re targeting Android (with Java, Kotlin, or both) you need only specify the sourceCompatibility (for Java) and jvmTarget (for Kotlin). You don’t need the targetCompatibility as it will default to match the sourceCompatibility. No matter what the Gradle or Android docs tell you, don’t use a toolchain! Save toolchains for JVM unit tests or incompatible tools. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eGradle toolchains are rarely a good idea\u003c/h2\u003e\n      \u003cp\u003e21 March 2024\u003c/p\u003e\n\n      \u003cp\u003eThe \u003ca href=\"https://jakewharton.com/kotlins-jdk-release-compatibility-flag/\"\u003elast post\u003c/a\u003e featured some Kotlin code inadvertently targeting a new Java API when the build JDK was bumped to 21. This can be solved with the \u003ccode\u003e-Xjdk-release\u003c/code\u003e Kotlin compiler flag, or by using Gradle toolchains to build with an old JDK.\u003c/p\u003e\n\n\u003cp\u003eIf you read the \u003ca href=\"https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_cross_compilation\"\u003eGradle docs\u003c/a\u003e…\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eUsing Java toolchains is a preferred way to target a language version\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e…or the \u003ca href=\"https://developer.android.com/build/jdks#toolchain\"\u003eAndroid docs\u003c/a\u003e…\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eWe recommend that you always specify the Java toolchain\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e…you wouldn’t be blamed for thinking Java toolchains are the way to go!\u003c/p\u003e\n\n\u003cp\u003eHowever, Java toolchains are rarely a good idea. Let’s look at why.\u003c/p\u003e\n\n\u003ch3 id=\"bad-docs\"\u003eBad docs\u003c/h3\u003e\n\n\u003cp\u003eLast week I released a new version of \u003ca href=\"https://github.com/square/retrofit\"\u003eRetrofit\u003c/a\u003e which uses a Java toolchain to target Java 8. Its use of toolchains was contributed a while ago, and I simply forgot to remove it. As a consequence, \u003ca href=\"https://square.github.io/retrofit/2.x/retrofit/\"\u003eits Javadoc\u003c/a\u003e was built using JDK 8 and is thus not searchable. Searchable Javadoc came in \u003ca href=\"https://openjdk.org/jeps/225\"\u003eJEP 225\u003c/a\u003e with JDK 9.\u003c/p\u003e\n\n\u003cp\u003eThe next release of Retrofit will be made without a toolchain and with the latest JDK. Its docs will have all the Javadoc advancements from the last 10 years including search and better modern HTML/CSS.\u003c/p\u003e\n\n\u003ch3 id=\"resource-ignorance\"\u003eResource ignorance\u003c/h3\u003e\n\n\u003cp\u003eOld JVMs were somewhat notorious for being ignorant to resource limitations imposed by the system. The rise of containers, especially on CI systems, means your process resource limits are different from those of the host OS. JDK 10 kicked things into high gear with \u003ca href=\"https://bugs.openjdk.org/browse/JDK-8146115\"\u003ecgroups support\u003c/a\u003e and JDK 15 \u003ca href=\"https://bugs.openjdk.org/browse/JDK-8230305\"\u003eextended that to cgroups2\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eBoth of those changes were backported to the 8 and 11 branches, but since Gradle toolchains will use an already-installed JDK if available you have to have kept your JDK 8 and/or JDK 11 up-to-date. Have you?\u003c/p\u003e\n\n\u003cp\u003eNot to stray too far off-topic, but if you installed it with SDKMAN! or similar JDK management tools there’s a good chance it’s wildly out of date. I keep all my JDKs up-to-date by installing them through \u003ca href=\"https://github.com/mdogan/homebrew-zulu\"\u003ea Homebrew tap\u003c/a\u003e which itself updates automatically using the Azul Zulu API. As long as I do a \u003ccode\u003ebrew upgrade\u003c/code\u003e every so often, each major JDK release that I have installed will be updated.\u003c/p\u003e\n\n\u003cp\u003eWithout a Java toolchain, a modern JDK (even an outdated patch release of one) will honor resource limits and perform much better in containerized environments.\u003c/p\u003e\n\n\u003ch3 id=\"compiler-bugs\"\u003eCompiler bugs\u003c/h3\u003e\n\n\u003cp\u003eAll software has bugs, and sometimes the JVM, the Java compiler, or both have bugs. When you are using a 10-year-old version of the JVM and Java compiler, you run a much greater risk of compiler bugs, especially around features introduced near to that release.\u003c/p\u003e\n\n\u003cp\u003eThere were many compilation problems around lambdas which were introduced in Java 8. If you are using the Java compiler from JDK 8 to target Java 8 JVMs you can still run into those bugs. Even if you are keeping your JDK 8 up-to-date many fixes are not backported. You \u003ca href=\"https://bugs.openjdk.org/browse/JDK-8182401\"\u003ecan find ones\u003c/a\u003e on the issue tracker without much effort.\u003c/p\u003e\n\n\u003cp\u003eNow is the Java compiler in JDK 22 completely bug-free? No. But is using the Java compiler from JDK 22 on sources targeting Java 8 using only Java 8 language features much safer than using one from JDK 8? Absolutely.\u003c/p\u003e\n\n\u003ch3 id=\"worse-performance\"\u003eWorse performance\u003c/h3\u003e\n\n\u003cp\u003eOracle and other large JVM shops devote lots of person-hours to making the JVM faster. We have newer garbage collectors that use less memory and consume less CPU. Work that happened on startup gets deferred to first-use to try and spread the cost out over the lifetime of the process. Algorithms and in-memory representations are specialized for common cases.\u003c/p\u003e\n\n\u003cp\u003eA language compiler is basically a worst-case scenario for the JVM. Endless string manipulation, object creation, and so so many maps. These areas receive many improvements over the years. My favorite of which is that strings which are ASCII-based suddenly occupy half as much memory in Java 9 than in Java 8. You know what’s often entirely ASCII? Java and Kotlin source code!\u003c/p\u003e\n\n\u003ch3 id=\"not-needed-for-cross-compilation\"\u003eNot needed for cross-compilation\u003c/h3\u003e\n\n\u003cp\u003eUsing the Java compiler from JDK 8 I can set \u003ccode\u003e-source\u003c/code\u003e and \u003ccode\u003e-target\u003c/code\u003e to “1.7” to compile a class that works on a Java 7 JVM. This does not prevent me from using Java 8 APIs, however. You have to add \u003ccode\u003e-bootclasspath\u003c/code\u003e with a pointer to a JDK 7 runtime (\u003ccode\u003ert.jar\u003c/code\u003e) so that the compiler knows what APIs are available in Java 7. You could alternatively use a tool like \u003ca href=\"https://www.mojohaus.org/animal-sniffer/\"\u003eAnimal Sniffer\u003c/a\u003e to validate that no APIs newer than Java 7 were used. In this world, just compiling with JDK 7 to target Java 7 might actually just be easier.\u003c/p\u003e\n\n\u003cp\u003eIn JDK 9, however, this all changed. The compiler now contains a record of all public APIs from every Java version going back to Java 8. It also allows specifying a single compiler flag, \u003ccode\u003e--release\u003c/code\u003e, which sets the source code language version, the target bytecode version, and the available runtime APIs to the specified release. There is simply no value in compiling with an older JDK to target an older JVM anymore.\u003c/p\u003e\n\n\u003ch3 id=\"wasted-disk-space\"\u003eWasted disk space\u003c/h3\u003e\n\n\u003cp\u003eAll those JDKs needlessly take up space in your home directory. Each JDK is a few hundred MiB. By default, Gradle will try to match an existing JDK when a toolchain is requested. Project owners can specify additional attributes such as the JDK vendor which might cause existing JDKs to not match. This means even though one project forced you to install Eclipse Temurin JDK 8, another might force Azul Zulu JDK 8. So not only do you now have a bunch of old JDKs, you have two or three copies of each. My JDK cache in \u003ccode\u003e~/.gradle\u003c/code\u003e is nearly 2 GiB.\u003c/p\u003e\n\n\u003ch3 id=\"not-the-gradle-jvm\"\u003eNot the Gradle JVM\u003c/h3\u003e\n\n\u003cp\u003eToolchains are only used for tasks that create a new JVM. That means compilation (of Java or Kotlin) and running unit tests. They do not control the JVM that is used for running the actual Gradle build or any of the plugins therein. If you have minimum requirements there, or in other JVM-based tools which are invoked by the Gradle build, the toolchain does not help you.\u003c/p\u003e\n\n\u003cp\u003eIf your build already has a minimum JDK requirement then why force installation of old JDKs given the newer one is already available on disk, can cross-compile perfectly, has fewer compiler bugs, builds faster, and respects system CPU and memory limits more effectively?\u003c/p\u003e\n\n\u003ch3 id=\"not-all-bad\"\u003eNot all bad\u003c/h3\u003e\n\n\u003cp\u003eI want to stress that toolchains are unequivocally not a good idea \u003cem\u003efor compilation\u003c/em\u003e. They still have utility elsewhere, however.\u003c/p\u003e\n\n\u003cp\u003eRetrofit has runtime behavior that changes based on the JVM version on which it’s running. (This is because until Java 16 it took various different hacks to support invoking default methods through a \u003ca href=\"https://docs.oracle.com/en%2Fjava%2Fjavase%2F22%2Fdocs%2Fapi%2F%2F/java.base/java/lang/reflect/Proxy.html\"\u003e\u003ccode\u003eProxy\u003c/code\u003e\u003c/a\u003e.) That code needs to be tested on different JVM versions. As a result, we \u003ca href=\"https://jakewharton.com/build-on-latest-java-test-through-lowest-java/\"\u003ecompile with the latest Java, but test through the lowest-supported Java\u003c/a\u003e using toolchains on the \u003ccode\u003eTest\u003c/code\u003e task. No need to worry about the user having weird old JDKs for Java 14 because it’s now installed on-demand when the full test suite is run.\u003c/p\u003e\n\n\u003cp\u003eSome tools that dip into JDK internals regularly break on newer versions of the compiler because they rely on unstable APIs. I’m thinking about things like \u003ca href=\"https://github.com/google/google-java-format\"\u003eGoogle Java Format\u003c/a\u003e or \u003ca href=\"https://errorprone.info/\"\u003eError-Prone\u003c/a\u003e. No need to hold the rest of your project from enjoying the latest JDK, if those tools are run via a \u003ccode\u003eJavaExec\u003c/code\u003e task you can use a toolchain to keep them on an older JDK until a newer version is available.\u003c/p\u003e\n\n\u003ch3 id=\"what-do-i-do\"\u003eWhat do I do?\u003c/h3\u003e\n\n\u003cp\u003eUse the \u003ccode\u003e--release\u003c/code\u003e flag if you’re compiling Java! Gradle \u003ca href=\"https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:release\"\u003eexposes a property\u003c/a\u003e for it now.\u003c/p\u003e\n\n\u003cp\u003eUse the \u003ccode\u003e-Xjdk-release\u003c/code\u003e flag if you’re compiling Kotlin. Future versions of the Kotlin Gradle plugin will expose a nice DSL property for it.\u003c/p\u003e\n\n\u003cp\u003eIf you’re \u003ca href=\"https://developer.android.com/build/jdks#target-compat\"\u003etargeting Android\u003c/a\u003e (with Java, Kotlin, or both) you need only specify the \u003ccode\u003esourceCompatibility\u003c/code\u003e (for Java) and \u003ccode\u003ejvmTarget\u003c/code\u003e (for Kotlin). You don’t need the \u003ccode\u003etargetCompatibility\u003c/code\u003e as it will default to match the \u003ccode\u003esourceCompatibility\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNo matter what the Gradle or Android docs tell you, don’t use a toolchain! Save toolchains for JVM unit tests or incompatible tools.\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-03-21T00:00:00Z",
  "modifiedTime": null
}
