{
  "id": "e47f8763-6ed3-4183-8b87-1185d19d7451",
  "title": "Vulkan 1.4: Faster App Loads, Less Stutter and Less Memory Usage — Host Image Copy Is a Game…",
  "link": "https://medium.com/androiddevelopers/vulkan-1-4-faster-app-loads-less-stutter-and-less-memory-usage-host-image-copy-is-a-game-53c57e531f5d?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Shahbaz Youssefi",
  "published": "Thu, 05 Dec 2024 17:04:33 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "vulkan",
    "graphics-programming",
    "games",
    "performance",
    "android"
  ],
  "byline": "Shahbaz Youssefi",
  "length": 7411,
  "excerpt": "Vulkan 1.4 was released recently, and with it comes a significant feature for Android: Host Image Copy, based on VK_EXT_host_image_copy. We have previously written about this extension in this…",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Host Image Copy is a game changer for AndroidOverviewVulkan 1.4 was released recently, and with it comes a significant feature for Android: Host Image Copy, based on VK_EXT_host_image_copy.We have previously written about this extension in this Khronos blog post, explaining the technical details of using this extension. This extension is particularly useful for Android games as we’ll see in this post.In short, Host Image Copy is a Vulkan feature that allows the application to transfer image data using the CPU instead of the GPU. This feature is particularly useful on UMA devices (such as typical Android devices), but may place restrictions on images. In particular, most drivers disable framebuffer compression for host-copyable images that are otherwise renderable. Read on to learn where this feature really shines.To put things in context, Host Image Copy is one way to asynchronously transfer image data. The other is using a dedicated transfer queue (with VK_QUEUE_TRANSFER_BIT, and without VK_QUEUE_GRAPHICS_BIT). In Vulkan 1.4, at least one is required. You can expect that the vast majority of Android devices shipping with Vulkan 1.4 will implement Host Image Copy, and implement it optimally for compressed formats. That is, Vulkan requires optimalDeviceAccess to be true for these formats.As it happens, texture data constitutes the largest amount of image data in typical games, and they use compressed formats!Host Image Copy vs GPU TransferFirst, let’s see how Host Image Copy differs from doing data copies on the GPU, such as with vkCmdCopyBufferToImage2.Without Host Image Copy, the path from texture data loaded from disk to an image goes through a Vulkan buffer:A Vulkan buffer is allocated, taking up about as much memory as the Vulkan image does.The texture data is copied (in the style of memcpy) to the buffer after mapping it by the CPU.vkCmdCopyBufferToImage2 is recorded in the command buffer that is later submitted.The texture data is copied to the image by the GPU.The buffer memory is freed a few frames later once the application knows the GPU copy is finished.In the above, the texture data is copied twice, and for a few frames the amount of memory allocated for the texture data is twice the size of the image. There are two further things to note here:The copy on the CPU is as fast as it can get, because it is effectively memcpy.The copy on the GPU efficiently reorders the data to match the physical layout of the image (a.k.a. layout swizzling), but it happens on the graphics queue (assuming no dedicated transfer queues), interfering with rendering in the same frame.With Host Image Copy instead, the copy is done simply by calling vkCopyMemoryToImage. In this case, the CPU does the copy and layout swizzling. This copy is slower than each of the copies above, because the CPU is not as efficient in reordering the data, but:The copy, even if slower, is only done onceThe copy does not interfere with ongoing GPU workThere is no extra memory allocated for texture dataFYI, the reason this extension has less utility on NUMA devices, such as devices with dedicated GPUs (and dedicated memory) is that the CPU may not have access to the entire GPU memory or access may be too slow, which may limit the amount of memory that could be used for host-copyable textures, or the copy may be prohibitively expensive. The identicalMemoryTypeRequirements property indicates whether Host Image Copy limits access to GPU memory or not.In the following, two scenarios are presented where Host Image Copy can significantly improve a game with the above properties in mind.Stutter-Free Streaming With Half the MemoryRemoving stutter during texture data streaming while simultaneously halving memory usage sounds too good to be true, but that’s exactly the sort of thing Host Image Copy enables.To set the scene: imagine an open-world game, you are nearing a new area and lots of new textures need to be loaded from persistent storage. You are cruising at 60 FPS; it would be a shame if that drops to 20 FPS or the game crashes with Out of Memory.Avoiding such stutters with Host Image Copy is very simple.The application can use a CPU thread to stream in texture data directly into new images using Host Image Copy. The GPU would continue to render frames of consistent complexity as before, maintaining FPS, and the memory increase is as minimal as it can get. Don’t forget to memory map the texture data file instead of reading into a CPU buffer first for even more efficiency!Faster Load Times With Half the MemoryCan we apply the same strategy for when the game is being loaded in the first place? Sure, use multiple CPU threads to copy texture data directly into images. Given that the CPU copy is slower due to layout swizzling, load times may not really be any faster, but at least the memory usage is halved!But Host Image Copy has a secret way of making this much faster — as fast as memcpy! Basically the CPU copy would be just as efficient as the CPU copy in the GPU Transfer scenario, the GPU copy is gone, the GPU buffer is gone, it’s all goodness and no downsides. The key is VK_HOST_IMAGE_COPY_MEMCPY.This flag is trivial, it simply tells the CPU not to do layout swizzling. So the texture data being copied to the image is assumed to be pre-swizzled, and the copy is simply memcpy. But since the layout swizzling of images on various devices is not public information, how is this useful?The answer is in image-to-memory copies with the same flag, that is readback of swizzled image data without undoing the layout swizzling. Many high-fidelity AAA Android games download massive packages of texture data on the first run of the game. Take the following algorithm:Download texture dataUse a temporary Vulkan image and call vkCopyMemoryToImage -\u003e the CPU does layout swizzlingRead back the image contents with vkCopyImageToMemory with the VK_HOST_IMAGE_COPY_MEMCPY flag -\u003e the returned data is pre-swizzled for this particular device/driverStore only the pre-swizzled data to persistent storage, not the original texture data, to minimize storage footprintThe next time the game runs, it can simply use vkCopyMemoryToImage with VK_HOST_IMAGE_COPY_MEMCPY to copy the pre-swizzled data into the images as fast as a simple read of the file contents would be. This also happens to optimize the streaming scenario above!Only gotcha is that driver updates might change the layout swizzling of images. The game needs to check that optimalTilingLayoutUUID is unchanged since the pre-swizzled texture data was cached, and redo the above if it ever changes. Fortunately, changes to the layout swizzle are rare. In practice, the game is unlikely to ever need to redownload or reprocess its texture data.ConclusionThe Host Image Copy feature as conditionally required by Vulkan 1.4, and unconditionally required by Android 16 for new devices, is a game changer for games on Android. In this post we looked at a few easy but significant wins using this functionality, but there are others, notably asynchronous image memory defragmentation. Surely, your ingenuity will lead to other optimizations that are made possible by this feature.Be sure to check out this post on the Khronos blog for more technical details around the usage of this functionality. As this functionality starts to become prevalent on Android phones, Vulkan games will be at an advantage. Don’t miss out!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Uz21_KlpWNb_Zc7qXlM7fw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"a9c8\"\u003eHost Image Copy is a game changer for Android\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@syoussefi?source=post_page---byline--53c57e531f5d--------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Shahbaz Youssefi\" src=\"https://miro.medium.com/v2/da:true/resize:fill:88:88/0*1thOJ-DDFdofqivL\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page---byline--53c57e531f5d--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2 id=\"160a\"\u003eOverview\u003c/h2\u003e\u003cp id=\"a637\"\u003eVulkan 1.4 was released \u003ca href=\"https://www.khronos.org/news/press/khronos-streamlines-development-and-deployment-of-gpu-accelerated-applications-with-vulkan-1.4\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erecently\u003c/a\u003e, and with it comes a significant feature for Android: Host Image Copy, based on \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_host_image_copy.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eVK_EXT_host_image_copy\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"a82c\"\u003eWe have previously written about this extension in \u003ca href=\"https://www.khronos.org/blog/copying-images-on-the-host-in-vulkan\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis Khronos blog post\u003c/a\u003e, explaining the technical details of using this extension. This extension is particularly useful for Android games as we’ll see in this post.\u003c/p\u003e\u003cp id=\"d866\"\u003eIn short, Host Image Copy is a Vulkan feature that allows the application to transfer image data using the \u003cem\u003eCPU\u003c/em\u003e instead of the \u003cem\u003eGPU\u003c/em\u003e. This feature is particularly useful on \u003ca href=\"https://en.wikipedia.org/wiki/Uniform_memory_access\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUMA\u003c/a\u003e devices (such as typical Android devices), but may place \u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyDevicePerformanceQuery.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erestrictions\u003c/a\u003e on images. In particular, most drivers disable framebuffer compression for host-copyable images that are otherwise renderable. \u003cstrong\u003eRead on to learn where this feature really shines\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"e8b1\"\u003eTo put things in context, Host Image Copy is one way to asynchronously transfer image data. The other is using a dedicated transfer queue (with \u003ccode\u003eVK_QUEUE_TRANSFER_BIT\u003c/code\u003e, and without \u003ccode\u003eVK_QUEUE_GRAPHICS_BIT\u003c/code\u003e). In Vulkan 1.4, at least one is \u003cem\u003erequired\u003c/em\u003e. \u003cstrong\u003eYou can expect that the vast majority of Android devices shipping with Vulkan 1.4 will implement Host Image Copy, and implement it optimally for \u003cem\u003ecompressed\u003c/em\u003e formats\u003c/strong\u003e. That is, Vulkan requires \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/VkHostImageCopyDevicePerformanceQuery.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoptimalDeviceAccess\u003c/a\u003e\u003c/code\u003e to be true for these formats.\u003c/p\u003e\u003cp id=\"d3d8\"\u003eAs it happens, texture data constitutes the largest amount of image data in typical games, and they use compressed formats!\u003c/p\u003e\u003ch2 id=\"9b21\"\u003eHost Image Copy vs GPU Transfer\u003c/h2\u003e\u003cp id=\"5761\"\u003eFirst, let’s see how Host Image Copy differs from doing data copies on the GPU, such as with \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003evkCmdCopyBufferToImage2\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"673c\"\u003eWithout Host Image Copy, the path from texture data loaded from disk to an image goes through a Vulkan buffer:\u003c/p\u003e\u003cul\u003e\u003cli id=\"327a\"\u003eA Vulkan buffer is allocated, taking up about as much memory as the Vulkan image does.\u003c/li\u003e\u003cli id=\"df55\"\u003eThe texture data is copied (in the style of \u003ccode\u003ememcpy\u003c/code\u003e) to the buffer after mapping it \u003cem\u003eby the CPU\u003c/em\u003e.\u003c/li\u003e\u003cli id=\"2251\"\u003e\u003ccode\u003evkCmdCopyBufferToImage2\u003c/code\u003e is recorded in the command buffer that is later submitted.\u003c/li\u003e\u003cli id=\"d42e\"\u003eThe texture data is copied to the image \u003cem\u003eby the GPU\u003c/em\u003e.\u003c/li\u003e\u003cli id=\"4807\"\u003eThe buffer memory is freed a few frames later once the application knows the GPU copy is finished.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ecb4\"\u003eIn the above, the texture data is copied \u003cem\u003etwice\u003c/em\u003e, and for a few frames the amount of memory allocated for the texture data is \u003cem\u003etwice\u003c/em\u003e the size of the image. There are two further things to note here:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9373\"\u003eThe copy on the CPU is as fast as it can get, because it is effectively \u003ccode\u003ememcpy\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"4c57\"\u003eThe copy on the GPU efficiently reorders the data to match the physical layout of the image (a.k.a. \u003cem\u003elayout swizzling\u003c/em\u003e), but it happens on the graphics queue (assuming no dedicated transfer queues), interfering with rendering in the same frame.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"47ee\"\u003eWith Host Image Copy instead, the copy is done simply by calling \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003evkCopyMemoryToImage\u003c/a\u003e\u003c/code\u003e. In this case, the CPU does the copy \u003cem\u003eand layout swizzling\u003c/em\u003e. This copy is slower than each of the copies above, because the CPU is not as efficient in reordering the data, but:\u003c/p\u003e\u003cul\u003e\u003cli id=\"68a1\"\u003eThe copy, even if slower, is only done once\u003c/li\u003e\u003cli id=\"6f04\"\u003eThe copy does not interfere with ongoing GPU work\u003c/li\u003e\u003cli id=\"b718\"\u003eThere is no extra memory allocated for texture data\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"87a5\"\u003eFYI, the reason this extension has less utility on NUMA devices, such as devices with dedicated GPUs (and dedicated memory) is that the CPU may not have access to the entire GPU memory or access may be too slow, which may limit the amount of memory that could be used for host-copyable textures, or the copy may be prohibitively expensive. The \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyProperties.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eidenticalMemoryTypeRequirements\u003c/a\u003e\u003c/code\u003e property indicates whether Host Image Copy limits access to GPU memory or not.\u003c/p\u003e\u003cp id=\"2d69\"\u003e\u003cstrong\u003eIn the following, two scenarios are presented where Host Image Copy can significantly improve a game with the above properties in mind.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"af26\"\u003eStutter-Free Streaming With Half the Memory\u003c/h2\u003e\u003cp id=\"3e34\"\u003eRemoving stutter during texture data streaming while simultaneously halving memory usage sounds too good to be true, but that’s exactly the sort of thing Host Image Copy enables.\u003c/p\u003e\u003cp id=\"a944\"\u003eTo set the scene: imagine an open-world game, you are nearing a new area and lots of new textures need to be loaded from persistent storage. You are cruising at 60 FPS; it would be a shame if that drops to 20 FPS or the game crashes with Out of Memory.\u003c/p\u003e\u003cp id=\"bc74\"\u003e\u003cstrong\u003eAvoiding such stutters with Host Image Copy is \u003cem\u003every simple\u003c/em\u003e\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"acff\"\u003eThe application can use \u003cem\u003ea CPU thread\u003c/em\u003e to stream in texture data directly into new images using Host Image Copy. The GPU would continue to render frames of consistent complexity as before, maintaining FPS, and the memory increase is as minimal as it can get. Don’t forget to memory map the texture data file instead of reading into a CPU buffer first for even more efficiency!\u003c/p\u003e\u003ch2 id=\"0dd7\"\u003eFaster Load Times With Half the Memory\u003c/h2\u003e\u003cp id=\"fdfd\"\u003eCan we apply the same strategy for when the game is being loaded in the first place? Sure, use multiple CPU threads to copy texture data directly into images. Given that the CPU copy is slower due to layout swizzling, load times may not really be any faster, but at least the memory usage is halved!\u003c/p\u003e\u003cp id=\"cf7a\"\u003eBut Host Image Copy has a secret way of making this much faster — \u003cstrong\u003eas fast as \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ememcpy\u003c/strong\u003e\u003c/code\u003e! Basically the CPU copy would be just as efficient as the CPU copy in the GPU Transfer scenario, the GPU copy is gone, the GPU buffer is gone, it’s all goodness and no downsides. The key is \u003ccode\u003eVK_HOST_IMAGE_COPY_MEMCPY\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ad03\"\u003eThis flag is trivial, it simply tells the CPU \u003cem\u003enot\u003c/em\u003e to do layout swizzling. So the texture data being copied to the image is assumed to be pre-swizzled, and the copy is simply \u003ccode\u003ememcpy\u003c/code\u003e. But since the layout swizzling of images on various devices is not public information, how is this useful?\u003c/p\u003e\u003cp id=\"8255\"\u003eThe answer is in image-to-memory copies with the same flag, that is readback of swizzled image data without undoing the layout swizzling. Many high-fidelity AAA Android games download massive packages of texture data on the first run of the game. Take the following algorithm:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0697\"\u003eDownload texture data\u003c/li\u003e\u003cli id=\"37c8\"\u003eUse a temporary Vulkan image and call \u003ccode\u003evkCopyMemoryToImage\u003c/code\u003e -\u0026gt; the CPU does layout swizzling\u003c/li\u003e\u003cli id=\"f02d\"\u003eRead back the image contents with \u003ccode\u003evkCopyImageToMemory\u003c/code\u003e with the \u003ccode\u003eVK_HOST_IMAGE_COPY_MEMCPY\u003c/code\u003e flag -\u0026gt; \u003cstrong\u003ethe returned data is pre-swizzled for this particular device/driver\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"1e88\"\u003eStore \u003cstrong\u003eonly\u003c/strong\u003e the pre-swizzled data to persistent storage, not the original texture data, to minimize storage footprint\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e41e\"\u003eThe next time the game runs, it can simply use \u003ccode\u003evkCopyMemoryToImage\u003c/code\u003e with \u003ccode\u003eVK_HOST_IMAGE_COPY_MEMCPY\u003c/code\u003e to \u003cstrong\u003ecopy the pre-swizzled data into the images as fast as a simple read of the file contents would be\u003c/strong\u003e. This also happens to optimize the streaming scenario above!\u003c/p\u003e\u003cp id=\"20b6\"\u003eOnly gotcha is that driver updates might change the layout swizzling of images. The game needs to check that \u003ccode\u003e\u003ca href=\"https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceHostImageCopyProperties.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoptimalTilingLayoutUUID\u003c/a\u003e\u003c/code\u003e is unchanged since the pre-swizzled texture data was cached, and redo the above if it ever changes. Fortunately, changes to the layout swizzle are rare. In practice, the game is unlikely to ever need to redownload or reprocess its texture data.\u003c/p\u003e\u003ch2 id=\"5ce6\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"3110\"\u003eThe Host Image Copy feature as conditionally required by Vulkan 1.4, and \u003ca href=\"https://github.com/KhronosGroup/Vulkan-Profiles/blob/main/profiles/VP_ANDROID_16_minimums.json\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eunconditionally required by Android 16 for new devices\u003c/a\u003e, is a game changer for games on Android. In this post we looked at a few easy but significant wins using this functionality, but there are others, notably asynchronous image memory defragmentation. Surely, your ingenuity will lead to other optimizations that are made possible by this feature.\u003c/p\u003e\u003cp id=\"7b5f\"\u003eBe sure to check out \u003ca href=\"https://www.khronos.org/blog/copying-images-on-the-host-in-vulkan\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis post on the Khronos blog\u003c/a\u003e for more technical details around the usage of this functionality. As this functionality starts to become prevalent on Android phones, Vulkan games will be at an advantage. \u003cstrong\u003eDon’t miss out\u003c/strong\u003e!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-12-05T17:04:33.409Z",
  "modifiedTime": null
}
