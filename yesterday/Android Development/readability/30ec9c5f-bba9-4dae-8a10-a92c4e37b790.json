{
  "id": "30ec9c5f-bba9-4dae-8a10-a92c4e37b790",
  "title": "The beauty of Kotlin Type System",
  "link": "https://proandroiddev.com/the-beauty-of-kotlin-type-system-25d0a187b130?source=rss----c72404660798---4",
  "description": "",
  "author": "Jintin",
  "published": "Wed, 30 Oct 2024 15:24:57 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android",
    "android-app-development",
    "java",
    "kotlin"
  ],
  "byline": "Jintin",
  "length": 5742,
  "excerpt": "As Kotlin is a statically typed language fully compatible with Java, it has similar type system as Java does. Further more, Kotlin’s design choice introduces several enhancements, making it a more…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "As Kotlin is a statically typed language fully compatible with Java, it has similar type system as Java does. Further more, Kotlin’s design choice introduces several enhancements, making it a more consistent, elegant, practical, and platform-agnostic language. Let’s explore some of these features to gain a better understanding of what makes Kotlin so appealing.AnySimilar to Java’s Object class which is every object’s root type, but there’re subtle difference between them. As the Java’s naming suggested, it’s only work for object types but not primitive types like int, char etc. Sure it involved to some low level memory management about where the variable should store, and we can gain more performance if using primative only. But Kotlin does a even better job here, it automatically transform to Java’s primitive type where possible and remove the need to declare primitive specifically from high level programing language perspective. The decision make it more consistant and also decouple it from the Java implementation to embrace Kotlin-multi-platform later.Java Object compare to Koelin Anypublic open class Any { public open operator fun equals(other: Any?): Boolean public open fun hashCode(): Int public open fun toString(): String}When it come’s to Java specific implementation where Kotlin can’t get rid of, it sometimes leverage on Kotlin extension functions and put these extensions to seperate package, you can check how Java's getClass() function is implemented in Kotlin and also check how simple/elegant it is as the Any definition in Kotlin above.OptionalAs NullPointerEexception(NPE) might be Java’s billion dollar mistake which I think every Java developer will encounter, Kotlin definitely don’t want to follow the same path.The answer for this is also quite common nowadays — Nullability. Every type in Kotlin will have a nulltable version, and by declare the nullability specifically, we can have strong confidant where we have to or don’t have to do the null check and get rid of NPE forever thanks to Kotlin compiler.There’s one subtle factor we used everyday but maybe not aware of. NonNull types and Nullable types are belong to different groups and only Nullable type can jump to NonNull type by proving its nullability no matter is via a null check or force-unwrap. So every NonNull/Nullable type stay in their own group consistantly hence promice the safety.Though it’s safe to deal with null in Kotlin’s own world, you might want to know how about using Kotlin with Java togher. Check https://kotlinlang.org/docs/java-to-kotlin-nullability-guide.html for more information.NothingHere comes the most interesting part of Kotlin type system from my own perspective — Nothing. Let’s first check the source code:public class Nothing private constructor()Even it just an one liner, it tells a lot.First, it’s not open so no one can extend itSecond, the constructor is private and it don’t expose anything to instatiate itself.Lastly, there’s no any function it provided.Seems a not useful type, right? Even if you’re unfamilia rabout Nothing, you can still write a bug free code without problem. However, if you delve into the documentation or comments for Nothing, you’ll soon discover it functions as a bottom type for every other type, the opposite of Any.Nothing typeWhy would we need a bottom type for anything? Wouldn’t it wired if it’s the child of a String and also an Int? Yes, the intersection of everything is something that couldn’t actually existed and that’s exactly the definition of Nothing.Let’s try the clasic example to elaborate more as the document said, a function has the return type of Nothing, it means that it never returns (always throws an exception).interface Animal { fun eat(): String fun walk(): String}class Dog : Animal { override fun eat() = \"dog eat\" override fun walk() = \"dog walk\"}Let’s define an Animal type with two classic function and both return String to display the action. What if we want to create a Fish which extend from Animal?class Fish : Animal { override fun eat() = \"fish eat\" override fun walk() = throw RuntimeException(\"fish can't walk\")}Because a fish can’t walk we would like to throw exception instead, and if you call walk like below, you’ll see some interesting warning.fun main() { val fish = Fish() fish.walk() println(\"where am I\") // IDE warn this will be unreachable code}And if you assign the type of fish to Animal, the warning will disappear. If you check the return type of fish’s walk function, you’ll found it automatically change to Nothing from String. Because Nothing can’t existed, so a function with Nothing as return type can’t return successfully, thus IDE can known the println is unreachable. And because throw can happen anywhere, every type will have a child type as Nothing. Hence IDE can do a better job and the language itself can have a better design which is more consistantly.Nothing is not limited to thow exceptions, a function with an infinite loop is also a valid case. The TODO() will also return Nothing as it shouldn’t successfully executed. And if you search the usage of Nothing accross Kotlin itself, you might found it also used to represent any emtpy Collection as Nothing can be the common child of everything. Although you can’t actually use it, but it serve as a good placeholder as you can swap later. Take listOf for example:var list: List\u003cString\u003e = listOf()// Kotlin's Collections.ktpublic inline fun \u003cT\u003e listOf(): List\u003cT\u003e = emptyList()public fun \u003cT\u003e emptyList(): List\u003cT\u003e = EmptyListinternal object EmptyList : List\u003cNothing\u003eBonusCan you try to spot what is the extact type the myObj inferred below? (Ans: can paste in IDE and try to reassign it)var myObj = null",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*DHhrCLSouyohPEzMBq1pxw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"1ab9\"\u003eAs Kotlin is a statically typed language fully compatible with Java, it has similar type system as Java does. Further more, Kotlin’s design choice introduces several enhancements, making it a more consistent, elegant, practical, and platform-agnostic language. Let’s explore some of these features to gain a better understanding of what makes Kotlin so appealing.\u003c/p\u003e\u003ch2 id=\"7818\"\u003eAny\u003c/h2\u003e\u003cp id=\"56b2\"\u003eSimilar to Java’s \u003ccode\u003eObject\u003c/code\u003e class which is every object’s root type, but there’re subtle difference between them. As the Java’s naming suggested, it’s only work for object types but not primitive types like \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e etc. Sure it involved to some low level memory management about where the variable should store, and we can gain more performance if using primative only. But Kotlin does a even better job here, it automatically transform to Java’s primitive type where possible and remove the need to declare primitive specifically from high level programing language perspective. The decision make it more consistant and also decouple it from the Java implementation to embrace Kotlin-multi-platform later.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eJava Object compare to Koelin Any\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"fc6b\"\u003epublic open class Any {\u003cp\u003e       public open operator fun equals(other: Any?): Boolean\u003c/p\u003e\u003cp\u003e    public open fun hashCode(): Int\u003c/p\u003e\u003cp\u003e    public open fun toString(): String\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"731d\"\u003eWhen it come’s to Java specific implementation where Kotlin can’t get rid of, it sometimes leverage on Kotlin extension functions and put these extensions to seperate package, you can check how Java\u0026#39;s \u003ccode\u003egetClass()\u003c/code\u003e function is implemented in Kotlin and also check how simple/elegant it is as the \u003ccode\u003eAny\u003c/code\u003e definition in Kotlin above.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"0f5e\"\u003eOptional\u003c/h2\u003e\u003cp id=\"8cc0\"\u003eAs NullPointerEexception(NPE) might be Java’s \u003ca href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebillion dollar mistake\u003c/a\u003e which I think every Java developer will encounter, Kotlin definitely don’t want to follow the same path.\u003c/p\u003e\u003cp id=\"8e13\"\u003eThe answer for this is also quite common nowadays — Nullability. Every type in Kotlin will have a nulltable version, and by declare the nullability specifically, we can have strong confidant where we have to or don’t have to do the null check and get rid of NPE forever thanks to Kotlin compiler.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7087\"\u003eThere’s one subtle factor we used everyday but maybe not aware of. NonNull types and Nullable types are belong to different groups and only Nullable type can jump to NonNull type by proving its nullability no matter is via a null check or force-unwrap. So every NonNull/Nullable type stay in their own group consistantly hence promice the safety.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"819e\"\u003eThough it’s safe to deal with null in Kotlin’s own world, you might want to know how about using Kotlin with Java togher. Check \u003ca href=\"https://kotlinlang.org/docs/java-to-kotlin-nullability-guide.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://kotlinlang.org/docs/java-to-kotlin-nullability-guide.html\u003c/a\u003e for more information.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"22c0\"\u003eNothing\u003c/h2\u003e\u003cp id=\"5c8a\"\u003eHere comes the most interesting part of Kotlin type system from my own perspective — Nothing. Let’s first check the source code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"90d3\"\u003epublic class Nothing private constructor()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"61a2\"\u003eEven it just an one liner, it tells a lot.\u003c/p\u003e\u003cul\u003e\u003cli id=\"1ad9\"\u003eFirst, it’s not open so no one can extend it\u003c/li\u003e\u003cli id=\"6d55\"\u003eSecond, the constructor is private and it don’t expose anything to instatiate itself.\u003c/li\u003e\u003cli id=\"db19\"\u003eLastly, there’s no any function it provided.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c8c6\"\u003eSeems a not useful type, right? Even if you’re unfamilia rabout Nothing, you can still write a bug free code without problem. However, if you delve into the documentation or comments for Nothing, you’ll soon discover it functions as a bottom type for every other type, the opposite of Any.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNothing type\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"dadb\"\u003eWhy would we need a bottom type for anything? Wouldn’t it wired if it’s the child of a String and also an Int? Yes, the intersection of everything is something that couldn’t actually existed and that’s exactly the definition of \u003ccode\u003eNothing\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ab1a\"\u003eLet’s try the clasic example to elaborate more as the document said, a function has the return type of \u003ccode\u003eNothing\u003c/code\u003e, it means that it never returns (always throws an exception).\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"97d0\"\u003einterface Animal {\u003cbr/\u003e    fun eat(): String\u003cp\u003e    fun walk(): String\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass Dog : Animal {\u003cbr/\u003e    override fun eat() = \u0026#34;dog eat\u0026#34;\u003c/p\u003e\u003cp\u003e    override fun walk() = \u0026#34;dog walk\u0026#34;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a23a\"\u003eLet’s define an \u003ccode\u003eAnimal\u003c/code\u003e type with two classic function and both return \u003ccode\u003eString\u003c/code\u003e to display the action. What if we want to create a \u003ccode\u003eFish\u003c/code\u003e which extend from \u003ccode\u003eAnimal\u003c/code\u003e?\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e7b0\"\u003eclass Fish : Animal {\u003cbr/\u003e    override fun eat() = \u0026#34;fish eat\u0026#34;\u003cp\u003e    override fun walk() = throw RuntimeException(\u0026#34;fish can\u0026#39;t walk\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"de25\"\u003eBecause a fish can’t walk we would like to throw exception instead, and if you call \u003ccode\u003ewalk\u003c/code\u003e like below, you’ll see some interesting warning.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c36f\"\u003efun main() {\u003cbr/\u003e    val fish = Fish()\u003cbr/\u003e    fish.walk()\u003cbr/\u003e    println(\u0026#34;where am I\u0026#34;) // IDE warn this will be unreachable code\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7460\"\u003eAnd if you assign the type of fish to \u003ccode\u003eAnimal\u003c/code\u003e, the warning will disappear. If you check the return type of fish’s \u003ccode\u003ewalk\u003c/code\u003e function, you’ll found it automatically change to \u003ccode\u003eNothing\u003c/code\u003e from \u003ccode\u003eString\u003c/code\u003e. Because \u003ccode\u003eNothing\u003c/code\u003e can’t existed, so a function with \u003ccode\u003eNothing\u003c/code\u003e as return type can’t return successfully, thus IDE can known the \u003ccode\u003eprintln\u003c/code\u003e is unreachable. And because throw can happen anywhere, every type will have a child type as \u003ccode\u003eNothing\u003c/code\u003e. Hence IDE can do a better job and the language itself can have a better design which is more consistantly.\u003c/p\u003e\u003cp id=\"8172\"\u003e\u003ccode\u003eNothing\u003c/code\u003e is not limited to thow exceptions, a function with an infinite loop is also a valid case. The \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-t-o-d-o.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTODO()\u003c/a\u003e\u003c/code\u003e will also return \u003ccode\u003eNothing\u003c/code\u003e as it shouldn’t successfully executed. And if you search the usage of \u003ccode\u003eNothing\u003c/code\u003e accross Kotlin itself, you might found it also used to represent any emtpy Collection as \u003ccode\u003eNothing\u003c/code\u003e can be the common child of everything. Although you can’t actually use it, but it serve as a good placeholder as you can swap later. Take \u003ccode\u003elistOf\u003c/code\u003e for example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bf67\"\u003evar list: List\u0026lt;String\u0026gt; = listOf()\u003cp\u003e// Kotlin\u0026#39;s Collections.kt\u003cbr/\u003epublic inline fun \u0026lt;T\u0026gt; listOf(): List\u0026lt;T\u0026gt; = emptyList()\u003c/p\u003e\u003cp\u003epublic fun \u0026lt;T\u0026gt; emptyList(): List\u0026lt;T\u0026gt; = EmptyList\u003c/p\u003e\u003cp\u003einternal object EmptyList : List\u0026lt;Nothing\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a547\"\u003eBonus\u003c/h2\u003e\u003cp id=\"2918\"\u003eCan you try to spot what is the extact type the \u003ccode\u003emyObj\u003c/code\u003e inferred below? (Ans: can paste in IDE and try to reassign it)\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7ac4\"\u003evar myObj = null\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-10-24T23:14:25.566Z",
  "modifiedTime": null
}
