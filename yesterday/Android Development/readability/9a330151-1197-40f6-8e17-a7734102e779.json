{
  "id": "9a330151-1197-40f6-8e17-a7734102e779",
  "title": "Facing a Multithreading Tech Interview",
  "link": "https://proandroiddev.com/facing-a-multithreading-tech-interview-08927e4d2855?source=rss----c72404660798---4",
  "description": "",
  "author": "Andrii Veremiienko",
  "published": "Mon, 14 Oct 2024 05:18:54 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "multithreading",
    "coroutine",
    "tech-interview"
  ],
  "byline": "Andrii Veremiienko",
  "length": 4756,
  "excerpt": "I’ve recently gone through several interesting tech interviews and one of the new challenges for me was a multithreading interview. It was a one-hour live-coding session where I had to solve typical…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Lessons from a Live Coding SessionMotivationI’ve recently gone through several interesting tech interviews and one of the new challenges for me was a multithreading interview. It was a one-hour live-coding session where I had to solve typical Android multithreading issues. Even though I have experience with threads and coroutines, it was still a challenge. The main reason for this was my lack of practical experience in solving such tasks.This article will be helpful for mid-level and junior developers who haven’t had extensive experience with multithreading or whose tasks have mainly involved simple GET/POST requests in a coroutine launch block (nothing wrong with that!). In this article, I present a more complex example to help you improve your skills and better prepare for similar interviews.En avant!Initial ImplementationThe entire interview consisted of a series of tasks centered around multithreading and code optimization in a single example. One of the requirements was that all code should be written in a single class and function, so let’s focus on the key concepts. The code can always be refactored later.Here is the initial code.As you can see, this implementation attempts to download an image on the main thread, which is problematic. Afterward, the image is set to the imageView. Not good. The first task was to identify and resolve these issues.Base ImplementationInitially, I downloaded the image on a background thread and then set the bitmap on the main thread (since the UI can only be updated from the main thread). My first thought was, “Ha, that was much easier than I imagined!” But, of course, it was just the beginning…What if we want to change the previous image?The next task was to stop an ongoing download process and start a new one. This can easily be done by canceling the current job.It’s important to note, that even though we trigger cancellation, it only takes effect within a suspended block. In our case, this happens when we switch contexts using the withContext function, as I mentioned during the interview.Let’s Add Some CacheAnother task was to implement a cache. I chose ConcurrentHashMap because it allows for fast access to entries, and we have unique keys in the form of URLs. Additionally, using ConcurrentHashMap ensures thread safety, which is important in a multithreaded environment. Now, when we attempt to download the same image, it will be retrieved from the cache without needing to re-download it.One important aspect of the code below is that we double-check and save the bitmap only if the image wasn’t downloaded previously.It was my original solution, I kept it unchanged. But after a brief discussion with ChatGPT, I realized that there still could be a race condition if multiple threads reach the same point simultaneously. As a better solution, I was recommended to use the following method, which enhances atomicity and reduces the number of lines:val bitmap = hashMap.computeIfAbsent(url) { loadBitmap(url)}However, there is still one issue that my interviewer politely brought to my attention: what if two or more requests try to download the same image simultaneously? The answer is that if hashMap is empty, all threads will initiate their own downloading processes, leading to multiple requests for the same image.Let’s add some cache but now with asyncThis was the most challenging part for me, but I eventually found a solution. We can use coroutines with the async builder to handle future results. By saving the Deferred value in our cache, we can return it whenever we need the same image.Now, there’s no need to wait for the image to download each time. We simply retrieve the existing Deferred object and wait until the image becomes available. This approach not only reduces redundant network calls but also improves the overall efficiency of our application.Retry PoliciesThe next task was to add retry policies. Initially, my mind was overwhelmed by the previous challenge, and I started overthinking the solution. Then my interviewer pointed out, “You are thinking too much,” and at that moment, the simplest approach to adding the retry functionality became clear to me.Restricting the Number of ThreadsThe final question was about how to restrict the number of threads used for these operations. Fortunately, this one was quite straightforward.private val scope = CoroutineScope(newFixedThreadPoolContext(3, \"Pool\"))ConclusionAs you can see, it wasn’t a particularly difficult interview, and I was pleased that I found solutions and implemented them for each of the tasks on my own.I hope this article has been useful and that some readers have gained new insights. Good luck with your interviews!P.S. Any suggestions for improvement are always welcome!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*wnibk_XT8sI6BUCk",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"1230\"\u003eLessons from a Live Coding Session\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@andriyveremiyenko?source=post_page-----08927e4d2855--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Andrii Veremiienko\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*_zSSttSTG1UslDuGUKvNvg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----08927e4d2855--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2 id=\"aad9\"\u003eMotivation\u003c/h2\u003e\u003cp id=\"f35b\"\u003eI’ve recently gone through several interesting tech interviews and one of the new challenges for me was a multithreading interview. It was a one-hour live-coding session where I had to solve typical Android multithreading issues. Even though I have experience with threads and coroutines, it was still a challenge. The main reason for this was my lack of practical experience in solving such tasks.\u003c/p\u003e\u003cp id=\"bb9b\"\u003eThis article will be helpful for mid-level and junior developers who haven’t had extensive experience with multithreading or whose tasks have mainly involved simple GET/POST requests in a coroutine launch block (nothing wrong with that!). In this article, I present a more complex example to help you improve your skills and better prepare for similar interviews.\u003c/p\u003e\u003cp id=\"e6f4\"\u003eEn avant!\u003c/p\u003e\u003ch2 id=\"b108\"\u003eInitial Implementation\u003c/h2\u003e\u003cp id=\"c24b\"\u003eThe entire interview consisted of a series of tasks centered around multithreading and code optimization in a single example. One of the requirements was that all code should be written in a single class and function, so let’s focus on the key concepts. The code can always be refactored later.\u003c/p\u003e\u003cp id=\"308e\"\u003eHere is the initial code.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6a1c\"\u003eAs you can see, this implementation attempts to download an image on the main thread, which is problematic. Afterward, the image is set to the \u003ccode\u003eimageView\u003c/code\u003e. Not good. The first task was to identify and resolve these issues.\u003c/p\u003e\u003ch2 id=\"6990\"\u003eBase Implementation\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0bf1\"\u003eInitially, I downloaded the image on a background thread and then set the bitmap on the main thread (since the UI can only be updated from the main thread). My first thought was, \u003cem\u003e“Ha, that was much easier than I imagined!”\u003c/em\u003e But, of course, it was just the beginning…\u003c/p\u003e\u003ch2 id=\"1344\"\u003eWhat if we want to change the previous image?\u003c/h2\u003e\u003cp id=\"a015\"\u003eThe next task was to stop an ongoing download process and start a new one. This can easily be done by canceling the current job.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e466\"\u003eIt’s important to note, that even though we trigger cancellation, it only takes effect within a suspended block. In our case, this happens when we switch contexts using the \u003ccode\u003ewithContext\u003c/code\u003e function, as I mentioned during the interview.\u003c/p\u003e\u003ch2 id=\"b8fe\"\u003eLet’s Add Some Cache\u003c/h2\u003e\u003cp id=\"25c5\"\u003eAnother task was to implement a cache. I chose \u003ccode\u003eConcurrentHashMap\u003c/code\u003e because it allows for fast access to entries, and we have unique keys in the form of URLs. Additionally, using \u003ccode\u003eConcurrentHashMap\u003c/code\u003e ensures thread safety, which is important in a multithreaded environment. Now, when we attempt to download the same image, it will be retrieved from the cache without needing to re-download it.\u003c/p\u003e\u003cp id=\"ada1\"\u003eOne important aspect of the code below is that we double-check and save the bitmap only if the image wasn’t downloaded previously.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"172d\"\u003eIt was my original solution, I kept it unchanged. But after a brief discussion with ChatGPT, I realized that there still could be a race condition if multiple threads reach the same point simultaneously. As a better solution, I was recommended to use the following method, which enhances atomicity and reduces the number of lines:\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"145c\"\u003eval bitmap = hashMap.computeIfAbsent(url) {\u003cbr/\u003e    loadBitmap(url)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"696b\"\u003eHowever, there is still one issue that my interviewer politely brought to my attention: what if two or more requests try to download the same image simultaneously? The answer is that if \u003ccode\u003ehashMap\u003c/code\u003e is empty, all threads will initiate their own downloading processes, leading to multiple requests for the same image.\u003c/p\u003e\u003ch2 id=\"d088\"\u003eLet’s add some cache but now with async\u003c/h2\u003e\u003cp id=\"a7e3\"\u003eThis was the most challenging part for me, but I eventually found a solution. We can use coroutines with the \u003ccode\u003easync\u003c/code\u003e builder to handle future results. By saving the \u003ccode\u003eDeferred\u003c/code\u003e value in our cache, we can return it whenever we need the same image.\u003c/p\u003e\u003cp id=\"5d5a\"\u003eNow, there’s no need to wait for the image to download each time. We simply retrieve the existing \u003ccode\u003eDeferred\u003c/code\u003e object and wait until the image becomes available. This approach not only reduces redundant network calls but also improves the overall efficiency of our application.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"acf4\"\u003eRetry Policies\u003c/h2\u003e\u003cp id=\"1e84\"\u003eThe next task was to add retry policies. Initially, my mind was overwhelmed by the previous challenge, and I started overthinking the solution. Then my interviewer pointed out, \u003cem\u003e“You are thinking too much,”\u003c/em\u003e and at that moment, the simplest approach to adding the retry functionality became clear to me.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"22cd\"\u003eRestricting the Number of Threads\u003c/h2\u003e\u003cp id=\"7ef7\"\u003eThe final question was about how to restrict the number of threads used for these operations. Fortunately, this one was quite straightforward.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1f70\"\u003eprivate val scope = CoroutineScope(newFixedThreadPoolContext(3, \u0026#34;Pool\u0026#34;))\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"b589\"\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"e6a2\"\u003eAs you can see, it wasn’t a particularly difficult interview, and I was pleased that I found solutions and implemented them for each of the tasks on my own.\u003c/p\u003e\u003cp id=\"089f\"\u003eI hope this article has been useful and that some readers have gained new insights. Good luck with your interviews!\u003c/p\u003e\u003cp id=\"7d77\"\u003eP.S. Any suggestions for improvement are always welcome!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-10-14T05:18:54.781Z",
  "modifiedTime": null
}
