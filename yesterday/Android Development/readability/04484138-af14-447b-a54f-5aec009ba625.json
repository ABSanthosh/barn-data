{
  "id": "04484138-af14-447b-a54f-5aec009ba625",
  "title": "Don't use Type-safe Project Accessors with Kotlin Gradle DSL",
  "link": "https://www.zacsweers.dev/dont-use-type-safe-project-accessors-with-kotlin-gradle-dsl/",
  "description": "Another Gradle footgun",
  "author": "Zac Sweers",
  "published": "Wed, 02 Jul 2025 02:00:33 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Kotlin",
    "Gradle"
  ],
  "byline": "Zac Sweers",
  "length": 3285,
  "excerpt": "Another Gradle footgun",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "Gradle 7.0 introduced the type-safe project accessors feature for IDE support of referencing projects in dependencies. This allowed you to replace this:dependencies { implementation(project(\":lib1\")) }with thisdependencies { implementation(projects.lib1) }This is great! Improved IDE support is always a good thing for developer experience and it's super convenient to have autocomplete like this.The ProblemThere's a hidden but serious cost here.To make this work, Gradle generates these accessors in Java, and it's based on the included projects in your settings. i.e.// settings.gradle include(\":lib1\")This generates a file like thispackage org.gradle.accessors.dm; // imports... @NonNullApi public class RootProjectAccessor extends TypeSafeProjectDependencyFactory { @Inject public RootProjectAccessor(DefaultProjectDependencyFactory factory, ProjectFinder finder) { super(factory, finder); } /** * Creates a project dependency on the project at path \":lib1\" */ public Lib1ProjectDependency getLib1() { return new Lib1ProjectDependency(getFactory(), create(\":lib1\")); } }When Kotlin incremental compilation kicks in, it looks at the ABI of its depedencies. In this case, the accessors dependencies produce a certain ABI of all its public getters, and this is an input to all of your project's build files. The API surface area of these getters is more or less equal to the set of included projects.Now, what happens if you change the set of included projects? The ABI changes, and those kotlin DSL build files all have to recompile now. That sucks! Especially in a larger codebase.What's worse is that it's quite easy for your project's buildscript classpath to become an input to your project's compilation tasks (sadly I've yet to track down how or why this happens, but I do observe it in practice), and as a result your compilation tasks will also then be invalidated.So, just removing an unused project from settings can cause a cascade of cache failures: buildscript file recompilation -\u003e configuration cache miss -\u003e possible compilation task cache miss.This becomes especially rough if you use tools like Spotlight (which you should!) or Focus, as they are designed to minimize the set of included projects for a given build.I'd actually go as far as saying that type-safe project accessors shouldn't be compatible with Kotlin Gradle DSL until there's a better IC solution or alternative IDE support, and highly recommend disabling them if you use them today. I put together a little script to do this if you want to borrow it here, though note it assumes a Spotlight all-projects.txt file (you can modify this as needed to read from elsewhere, such as settings.gradle.kts).Other notesThis also affects version catalogs, but these are less invasive with tools like the ones I mentioned above and most changes to them are value changes (non-ABI changing) rather than changed dependencies.This doesn't seem to affect Groovy buildscripts, but I don't understand enough about how those are compiled/Groovy IC works to say why. That said, Groovy is very much on its way out and this post is in no way advice to use Groovy.This behavior is the same in Gradle \u003c9.0.0's custom IC implementation and kotlinc's native IC implementation.",
  "image": "https://www.zacsweers.dev/content/images/2025/07/Screenshot-2025-07-01-at-9.38.58---PM.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle role=\"article\" aria-label=\"Article Content\"\u003e\n    \u003cp\u003eGradle 7.0 \u003ca href=\"https://docs.gradle.org/7.0/release-notes.html?ref=zacsweers.dev#type-safe-project-accessors\"\u003eintroduced\u003c/a\u003e the type-safe project accessors feature for IDE support of referencing projects in dependencies. This allowed you to replace this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edependencies {\n  implementation(project(\u0026#34;:lib1\u0026#34;))\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewith this\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edependencies {\n  implementation(projects.lib1)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is great! Improved IDE support is always a good thing for developer experience and it\u0026#39;s super convenient to have autocomplete like this.\u003c/p\u003e\u003ch2 id=\"the-problem\"\u003eThe Problem\u003c/h2\u003e\u003cp\u003eThere\u0026#39;s a hidden but serious cost here.\u003c/p\u003e\u003cp\u003eTo make this work, Gradle generates these accessors in Java, and it\u0026#39;s based on the included projects in your settings. i.e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// settings.gradle\ninclude(\u0026#34;:lib1\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis generates a file like this\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epackage org.gradle.accessors.dm;\n\n// imports...\n\n@NonNullApi\npublic class RootProjectAccessor extends TypeSafeProjectDependencyFactory {\n\n\n    @Inject\n    public RootProjectAccessor(DefaultProjectDependencyFactory factory, ProjectFinder finder) {\n        super(factory, finder);\n    }\n\n    /**\n     * Creates a project dependency on the project at path \u0026#34;:lib1\u0026#34;\n     */\n    public Lib1ProjectDependency getLib1() { return new Lib1ProjectDependency(getFactory(), create(\u0026#34;:lib1\u0026#34;)); }\n\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen Kotlin incremental compilation kicks in, it looks at the ABI of its depedencies. In this case, the accessors dependencies produce a certain ABI of all its public getters, and this is an input to all of your project\u0026#39;s build files. The API surface area of these getters is more or less equal to the set of included projects.\u003c/p\u003e\u003cp\u003eNow, what happens if you change the set of included projects? The ABI changes, and those kotlin DSL build files all have to recompile now. That sucks! Especially in a larger codebase.\u003c/p\u003e\u003cp\u003eWhat\u0026#39;s worse is that it\u0026#39;s quite easy for your project\u0026#39;s buildscript classpath to become an input to your project\u0026#39;s compilation tasks (sadly I\u0026#39;ve yet to track down how or why this happens, but I do observe it in practice), and as a result your compilation tasks will also then be invalidated.\u003c/p\u003e\u003cp\u003eSo, just removing an unused project from settings can cause a cascade of cache failures: buildscript file recompilation -\u0026gt; configuration cache miss -\u0026gt; possible compilation task cache miss.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis becomes especially rough if you use tools like \u003ca href=\"https://github.com/joshfriend/spotlight?ref=zacsweers.dev\"\u003eSpotlight\u003c/a\u003e (which you should!) or \u003ca href=\"https://github.com/dropbox/focus?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eFocus\u003c/a\u003e, as they are designed to minimize the set of included projects for a given build.\u003c/p\u003e\u003cp\u003eI\u0026#39;d actually go as far as saying that type-safe project accessors shouldn\u0026#39;t be compatible with Kotlin Gradle DSL until there\u0026#39;s a better IC solution or alternative IDE support, and \u003cstrong\u003ehighly\u003c/strong\u003e recommend disabling them if you use them today. I put together a little script to do this if you want to borrow it \u003ca href=\"https://github.com/ZacSweers/CatchUp/blob/main/projectAccessors.main.kts?ref=zacsweers.dev\"\u003ehere\u003c/a\u003e, though note it assumes a Spotlight \u003ccode\u003eall-projects.txt\u003c/code\u003e file (you can modify this as needed to read from elsewhere, such as \u003ccode\u003esettings.gradle.kts\u003c/code\u003e).\u003c/p\u003e\u003ch3 id=\"other-notes\"\u003eOther notes\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThis also affects \u003ca href=\"https://docs.gradle.org/current/userguide/version_catalogs.html?ref=zacsweers.dev\"\u003eversion catalogs\u003c/a\u003e, but these are less invasive with tools like the ones I mentioned above and most changes to them are value changes (non-ABI changing) rather than changed dependencies.\u003c/li\u003e\u003cli\u003eThis doesn\u0026#39;t seem to affect Groovy buildscripts, but I don\u0026#39;t understand enough about how those are compiled/Groovy IC works to say why. That said, Groovy is very much on its way out and this post is in no way advice to use Groovy.\u003c/li\u003e\u003cli\u003eThis behavior is the same in Gradle \u0026lt;9.0.0\u0026#39;s custom IC implementation and kotlinc\u0026#39;s native IC implementation.\u003c/li\u003e\u003c/ul\u003e\n\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-07-02T02:00:33Z",
  "modifiedTime": "2025-07-02T02:00:33Z"
}
