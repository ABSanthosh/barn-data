{
  "id": "8e4f1ab0-6a8c-481a-a139-f02c460055f4",
  "title": "Effortless Multimodule Configuration for Kotlin Multiplatform Projects with Gradle Convention‚Ä¶",
  "link": "https://proandroiddev.com/effortless-multimodule-configuration-for-kotlin-multiplatform-projects-with-gradle-convention-8e6593dff1d9?source=rss----c72404660798---4",
  "description": "",
  "author": "Vaibhav Jaiswal",
  "published": "Wed, 23 Apr 2025 15:19:25 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "gradle",
    "android",
    "kotlin-multiplatform",
    "android-app-development"
  ],
  "byline": "Vaibhav Jaiswal",
  "length": 16521,
  "excerpt": "Have you tried Kotlin Multiplatform yet, if not what are you waiting for? Kotlin Multiplatform is great and very powerful but configuring it can be a pain. Kotlin Multimodule projects have complex‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin Multiplatform is great, but Gradle modules can be a hassle. Manage multiple modules and clean up code with Gradle Convention Plugins effortlessly!Have you tried Kotlin Multiplatform yet? If not, what are you waiting for? KMP is great and very powerful but configuring it can be a pain. KMP projects have complex and large Gradle module configurations, which can be hard to maintain especially if you have a multi-module project. This leads to a lot of code duplication and multiple such huge Gradle files to deal with.Let‚Äôs see how we can remove this duplication and centralize the configuration with ease using the power of Gradle Convention Plugins.Hold on for the bonus section at the end of this article, I will also be covering up a custom Gradle convention plugin for easily configuring Compose Multiplatform ModulesI will be referring to Kotlin Multiplatform by its abbreviation KMP and Compose Multiplatform with its abbreviation CMP throughout this blog.Gradle Composite Builds üèóYou might have heard about writing custom Gradle plugins using buildSrc. buildSrc is a directory at the Gradle project root, which can contain our build logic. This allows us to use the Kotlin DSL to write our custom build code with very little configuration and share this logic across the whole project. This became a very popular approach but not that good.Then came the new Gradle Composite builds which fixed a lot of issues with buildSrc. Excited to learn more? Josef Raska‚Äôs got you covered in his blog where he dives deep into the buildSrc vs Composite builds showdown.This read‚Äôs all about Gradle Composite Builds, but fear not ‚Äî much of it applies to buildSrc too. Let‚Äôs unravel the mysteries together! üí°Creating the Conventions Module üìÅTo get started with Gradle Convention plugin, we would first need to create a directory named build-logic in our root project directory. Now inside this we need to add two files gradle.propertiesorg.gradle.parallel=trueorg.gradle.caching=trueorg.gradle.configureondemand=trueand settings.gradle.ktsdependencyResolutionManagement { repositories { google() mavenCentral() } versionCatalogs { create(\"libs\") { from(files(\"../gradle/libs.versions.toml\")) } }}rootProject.name = \"build-logic\"include(\":convention\")Now we need to create a sub-module named convention or any other name. This is how would module must look likeNow heading into the build.gradle.kts of convention module, we need to set up Kotlin DSL and add a few dependenciesplugins { `kotlin-dsl`}group = \"com.example.app.buildlogic\" //your module namedependencies { compileOnly(libs.android.gradlePlugin) //if targetting Android compileOnly(libs.kotlin.gradlePlugin) compileOnly(libs.compose.gradlePlugin) //if you are using Compose Multiplatform}/**libs.versions.tomlandroid-gradlePlugin = { module = \"com.android.tools.build:gradle\", version.ref = \"agp\" }kotlin-gradlePlugin = { module = \"org.jetbrains.kotlin:kotlin-gradle-plugin\", version.ref = \"kotlin\" }compose-gradlePlugin = { module = \"org.jetbrains.compose:org.jetbrains.compose.gradle.plugin\", version.ref = \"compose\" }**/Now, all we need to do is create the package structure for our conventions module if not already created by the IDESomething like src/main/kotlin/com/example/app/convention For exampleThis is where our helper functions will be placed and our plugin will go into the Kotlin directory.Now that our setup is done, let's get started with the plugin.Creating independent feature configurations ‚öôÔ∏èOur approach is to configure each part of the project independently as an extension function and then combine all, to create the final Plugin.All these files will be put under the com.example.app.convention packageWe will have three feature configs, for Android, Cocoapods and KMP.Accessing the Gradle Version CatalogueWe create an extension function on the Project class to access our Gradle Version Catalogue libs.versions.toml in a file Libs.ktval Project.libs get(): VersionCatalog = extensions.getByType\u003cVersionCatalogsExtension\u003e().named(\"libs\")val Project.androidLibs get(): VersionCatalog = extensions.getByType\u003cVersionCatalogsExtension\u003e().named(\"androidLibs\")Here, I have another version catalogue for Android dependencies only, you can omit this.Configuring AndroidLet's start with writing a configuration for our Android Target. Create a Kotlin file and paste this code.internal fun Project.configureKotlinAndroid( extension: LibraryExtension) = extension.apply { //get module name from module path val moduleName = path.split(\":\").drop(2).joinToString(\".\") namespace = if(moduleName.isNotEmpty()) \"com.example.app.$moduleName\" else \"com.example.app\" compileSdk = androidLibs.findVersion(\"compileSdk\").get().requiredVersion.toInt() defaultConfig { minSdk = androidLibs.findVersion(\"minSdk\").get().requiredVersion.toInt() } compileOptions { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } packaging { resources { excludes += \"/META-INF/{AL2.0,LGPL2.1}\" } }}That's a lot of code to paste. Don‚Äôt worry, I will be explaining each part.Breaking down the codeHere we create an extension function on the Gradle Project interface to configure our Project.We get the current moduleName from the module path of the module where the plugin is applied, we use this to set the android namespace for the module.We use drop(2) to drop the empty string and ‚Äúshared‚Äù from the module path, as our shared module will be named ‚Äúcom.example.app‚Äù and for all submodules, the module path will be appended after the shared module‚Äôs name. Eg ‚Äî shared for :shared, shared=core for :shared:core, shared-data-network for :shared:data:networkWe then set the compileSdk , minSdk and other Android ConfigurationsHere you can fully configure your modules for Android same as you do for an Android Project.Configuring Cocoapods for iOS üçéWe are using Cocoapods for iOS dependency management, if you are using Swift Package Manager or not targetting iOS, you can skip this part.internal fun Project.configureKotlinCocoapods( extension: CocoapodsExtension) = extension.apply { val moduleName = this@configureKotlinCocoapods.path.split(\":\").drop(1).joinToString(\"-\") summary = \"Some description for the Shared Module\" homepage = \"Link to the Shared Module homepage\" version = \"1.0\" //your cocoapods version ios.deploymentTarget = \"14.1\" //your iOS deployment target name = moduleName framework { isStatic = true //static or dynamic according to your project baseName = moduleName }}Here we do a common set-up of Cocoapods for all our modules, you can add more configurations here.We get the module name from the module path and use it to name our cocoapods module, this is the name that will be used for the podspec file created.The logic for module name is the same as what we did for Android, the only change here is drop(1) as here we want the shared module to be named ‚Äúshared‚Äù and all child module names appending to it.Configuring Kotlin MultiplatformNow we configure our KMP Project. In this configuration, we will configure the followingKotlinThe Targets we want to build for (iOS, Android, Linux, Windows etc)All Common dependencies which are needed in all modulesCocoapods Dependency Management for iOSinternal fun Project.configureKotlinMultiplatform( extension: KotlinMultiplatformExtension) = extension.apply { jvmToolchain(17) // targets androidTarget() iosArm64() iosX64() iosSimulatorArm64() applyDefaultHierarchyTemplate() //common dependencies sourceSets.apply { commonMain { dependencies { implementation(libs.findLibrary(\"koin.core\").get()) implementation(libs.findLibrary(\"coroutines.core\").get()) implementation(libs.findLibrary(\"kotlinx-dateTime\").get()) implementation(libs.findLibrary(\"napier\").get()) implementation(libs.findLibrary(\"kotlinx-serialization\").get()) } } androidMain { dependencies { implementation(libs.findLibrary(\"koin.android\").get() ) } } commonTest.dependencies { implementation(kotlin(\"test\")) } } //applying the Cocoapods Configuration we made (this as ExtensionAware).extensions.configure\u003cCocoapodsExtension\u003e(::configureKotlinCocoapods)}Breaking down this huge piece of code we haveSetting up the Java Version (17 is recommended for KMP)Setting up our targets, Android and iOS in this caseApplying the default Kotlin Hierarchy which created the source sets for usApplying all the common dependencies that we need in all of our KMP Modules, we use the Gradle version catalogue to store the dependency configs.We apply the Cocoapods configuration to the Cocoapods Extenstion included in the KMP Plugin.Combining Feature Configurations to Build the Kotlin Multiplatform Plugin üèõNow we applying all three of our feature configurations to build up the KMP Plugin.Apart from applying our created configurations, we also add all the common Gradle Plugins that we need in all of our modules.class KotlinMultiplatformPlugin: Plugin\u003cProject\u003e { override fun apply(target: Project):Unit = with(target){ with(pluginManager){ apply(libs.findPlugin(\"kotlinMultiplatform\").get().get().pluginId) apply(libs.findPlugin(\"kotlinCocoapods\").get().get().pluginId) apply(libs.findPlugin(\"androidLibrary\").get().get().pluginId) apply(libs.findPlugin(\"kotlin.serialization\").get().get().pluginId) } extensions.configure\u003cKotlinMultiplatformExtension\u003e(::configureKotlinMultiplatform) extensions.configure\u003cLibraryExtension\u003e(::configureKotlinAndroid) }}We create a class inheriting the Gradle Plugin interface to create our custom Gradle Convention Plugin.Now all we need to do is to register the Plugin for use.Registering our Custom PluginNow to register our plugin for use, we head out to the build.gradle.kts of our conventions module and add this.gradlePlugin { plugins { register(\"kotlinMultiplatform\"){ id = \"com.example.app.kotlinMultiplatform\" implementationClass = \"KotlinMultiplatformPlugin\" } }}We can use our plugin with apply(\"com.example.app.kotlinMultiplatform\")This is how our convention module should look likeUsing our Custom Gradle PluginUsing the custom plugin we made is very very simple, we can now remove all repeated code and replace it with just apply(\"com.example.app.kotlinMultiplatform\")Example of how our modules will look likeplugins { id(\"com.example.app.kotlinMultiplatform\") //handling all config}kotlin { // if yoy have any pod dependencies, you just to define and not configure cocoapods cocoapods { pod(\"Amplitude\", \"8.17.1\") pod(\"FirebaseMessaging\") pod(\"Reachability\") } // module specific dependencies sourceSets { commonMain.dependencies { api(libs.touchlabs.crashlytics) implementation(libs.ktor.client.core) } androidMain.dependencies { implementation(androidLibs.amplitude) implementation(androidLibs.firebase.messaging.shared) } }}We can easily customize our plugin to add extra configuration or to override the ones in our Plugin.Bonus: Custom Gradle Plugin for Compose Multiplatform üéâIf you‚Äôre still reading, there‚Äôs some bonus content awaiting you. Given the surge in popularity of Jetpack Compose and its multiplatform counterpart, Compose Multiplatform, many apps are adopting it. Let‚Äôs delve into crafting a Custom Gradle Convention Plugin to configure our CMP Modules.class ComposeMultiplatformPlugin : Plugin\u003cProject\u003e { override fun apply(target: Project) = with(target) { with(pluginManager){ apply(libs.findPlugin(\"composeMultiplatform\").get().get().pluginId) } val composeDeps = extensions.getByType\u003cComposeExtension\u003e().dependencies extensions.configure\u003cKotlinMultiplatformExtension\u003e { sourceSets.apply { commonMain { dependencies { implementation(composeDeps.runtime) implementation(composeDeps.foundation) implementation(composeDeps.material3) implementation(composeDeps.materialIconsExtended) implementation(composeDeps.material) } } } } }}/**libs.versions.tomlcomposeMultiplatform = { id = \"org.jetbrains.compose\", version.ref = \"compose\" }**/Similar to the KMP Plugin, we make a class inheriting the Gradle Plugin interface and implementing the apply function.Breaking down the code, what we do here isWe apply the JetBrains compose plugin to enable CMP for this module.We then get the Compose Extension which gets added to our project when adding the CMP Plugin.We use the dependencies from Compose Extension and apply all the common Compose dependencies we want to have in our modules.Registering the PluginNow to register our plugin for use, we head out to the build.gradle.kts of our conventions module and add this.gradlePlugin { plugins { register(\"composeMultiplatform\"){ id = \"com.example.app.composeMultiplatform\" implementationClass = \"ComposeMultiplatformPlugin\" } }}ConclusionCreating our custom Gradle Convention Plugins for configuring KMP modules is a great way to simplify our module‚Äôs Gradle configuration and maintain a single source of configuration.This cleans up our gradle config code a lot and makes it easy to maintain and free from errors when modifying configurationLet's see what the Gradle Config is like before and after using both our Custom KMP and CMP Gradle Convention Plugins.This is a very basic project targeting only iOS and Android, with very minimal configuration, in larger projects with more complex configurations and many more targets, the difference is a lot more.Original Gradle file before using our Custom Pluginsimport org.jetbrains.kotlin.gradle.tasks.KotlinCompileplugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidLibrary) alias(libs.plugins.composeMultiplatform) kotlin(\"native.cocoapods\")}@OptIn(org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi::class)kotlin { jvmToolchain(11) android() ios() iosSimulatorArm64() cocoapods { summary = \"Some description for the Shared Module\" homepage = \"Link to the Shared Module homepage\" version = \"1.0\" ios.deploymentTarget = \"14.1\" framework { baseName = \"filePicker\" isStatic = true } } sourceSets { val commonMain by getting { dependencies { implementation(compose.runtime) implementation(compose.foundation) implementation(compose.material) } } val androidMain by getting { dependencies { implementation(androidLibs.activity.compose) } } }}android { namespace = \"com.example.app.filepicker\" compileSdk = androidLibs.versions.compileSdk.get().toInt() defaultConfig { minSdk = androidLibs.versions.minSdk.get().toInt() } compileOptions { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } kotlin { jvmToolchain(17) }}Refactored Gradle file after using our Custom Gradle Pluginsplugins { //our custom plugins id(\"com.example.app.kotlinMultiplatform\") id(\"com.example.app.composeMultiplatform\")}kotlin { sourceSets { androidMain.dependencies { implementation(androidLibs.activity.compose) } }}The difference is huge, and even more huge in more complex projects.Farewell üëãAs we wrap up here, I hope you‚Äôve picked up some cool tricks to level up your Kotlin Multiplatform game. With Gradle Convention Plugins by your side, there‚Äôs no limit to what you can achieve. Keep tinkering, keep coding, and may your projects always spark joy. Catch you on the flip side for more coding adventures!Hope you liked this article. To read more of my articles head on to my Medium Profile or my Hashnode blogs or my website to find all If you want to connect with me, head on to my website to find my socials.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*SdO3PswmwFcSaH66KmpFlQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"e2bc\"\u003eKotlin Multiplatform is great, but Gradle modules can be a hassle. Manage multiple modules and clean up code with Gradle Convention Plugins effortlessly!\u003c/h2\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://vaibhav3011.medium.com/?source=post_page---byline--8e6593dff1d9---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Vaibhav Jaiswal\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*3IeQSB0vTEfCag3Ev0jf5A.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9b5a\"\u003eHave you tried Kotlin Multiplatform yet? If not, what are you waiting for? \u003cbr/\u003eKMP is great and very powerful but configuring it can be a pain. \u003cbr/\u003eKMP projects have complex and large Gradle module configurations, which can be hard to maintain especially if you have a multi-module project. This leads to a lot of code duplication and multiple such huge Gradle files to deal with.\u003cbr/\u003eLet‚Äôs see how we can remove this duplication and centralize the configuration with ease using the power of Gradle Convention Plugins.\u003cbr/\u003eHold on for the bonus section at the end of this article, I will also be covering up a custom Gradle convention plugin for easily configuring Compose Multiplatform Modules\u003cbr/\u003eI will be referring to Kotlin Multiplatform by its abbreviation KMP and Compose Multiplatform with its abbreviation CMP throughout this blog.\u003c/p\u003e\u003ch2 id=\"2d31\"\u003eGradle Composite Builds üèó\u003c/h2\u003e\u003cp id=\"a161\"\u003eYou might have heard about writing custom Gradle plugins using \u003ccode\u003ebuildSrc\u003c/code\u003e\u003cstrong\u003e. \u003c/strong\u003e\u003ccode\u003ebuildSrc\u003c/code\u003e is a directory at the Gradle project root, which can contain\u003ca href=\"https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e our build logic\u003c/a\u003e. This allows us to use the\u003ca href=\"https://docs.gradle.org/current/userguide/kotlin_dsl.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e Kotlin DSL\u003c/a\u003e to write our custom build code with very little configuration and share this logic across the whole project. This became a very popular approach but not that good.\u003c/p\u003e\u003cp id=\"e499\"\u003eThen came the new\u003cstrong\u003e \u003c/strong\u003e\u003ca href=\"https://docs.gradle.org/current/userguide/composite_builds.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGradle Composite builds\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003ewhich fixed a lot of issues with \u003ccode\u003ebuildSrc\u003c/code\u003e. Excited to learn more? Josef Raska‚Äôs got you covered in his \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/stop-using-gradle-buildsrc-use-composite-builds-instead-3c38ac7a2ab3\"\u003eblog\u003c/a\u003e where he dives deep into the buildSrc vs Composite builds showdown.\u003c/p\u003e\u003cp id=\"58bc\"\u003eThis read‚Äôs all about Gradle Composite Builds, but fear not ‚Äî much of it applies to \u003ccode\u003ebuildSrc\u003c/code\u003e too. Let‚Äôs unravel the mysteries together! üí°\u003c/p\u003e\u003ch2 id=\"f2ce\"\u003eCreating the Conventions Module üìÅ\u003c/h2\u003e\u003cp id=\"fe30\"\u003eTo get started with Gradle Convention plugin, we would first need to create a directory named \u003ccode\u003ebuild-logic\u003c/code\u003e in our root project directory. \u003cbr/\u003eNow inside this we need to add two files \u003ccode\u003egradle.properties\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"efc5\"\u003eorg.gradle.parallel=true\u003cbr/\u003eorg.gradle.caching=true\u003cbr/\u003eorg.gradle.configureondemand=true\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f877\"\u003eand \u003ccode\u003esettings.gradle.kts\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d305\"\u003edependencyResolutionManagement {\u003cbr/\u003e    repositories {\u003cbr/\u003e        google()\u003cbr/\u003e        mavenCentral()\u003cbr/\u003e    }\u003cbr/\u003e    versionCatalogs {\u003cbr/\u003e        create(\u0026#34;libs\u0026#34;) {\u003cbr/\u003e            from(files(\u0026#34;../gradle/libs.versions.toml\u0026#34;))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003erootProject.name = \u0026#34;build-logic\u0026#34;\u003cbr/\u003einclude(\u0026#34;:convention\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"467b\"\u003eNow we need to create a sub-module named \u003ccode\u003econvention\u003c/code\u003e or any other name. \u003cbr/\u003eThis is how would module must look like\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7306\"\u003eNow heading into the \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e of convention module, we need to set up Kotlin DSL and add a few dependencies\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1b55\"\u003eplugins {\u003cbr/\u003e    `kotlin-dsl`\u003cbr/\u003e}\u003cp\u003egroup = \u0026#34;com.example.app.buildlogic\u0026#34; //your module name\u003c/p\u003e\u003cp\u003edependencies {\u003cbr/\u003e    compileOnly(libs.android.gradlePlugin) //if targetting Android\u003cbr/\u003e    compileOnly(libs.kotlin.gradlePlugin)\u003cbr/\u003e    compileOnly(libs.compose.gradlePlugin) //if you are using Compose Multiplatform\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003elibs.versions.toml\u003cbr/\u003eandroid-gradlePlugin = { module = \u0026#34;com.android.tools.build:gradle\u0026#34;, version.ref = \u0026#34;agp\u0026#34; }\u003cbr/\u003ekotlin-gradlePlugin = { module = \u0026#34;org.jetbrains.kotlin:kotlin-gradle-plugin\u0026#34;, version.ref = \u0026#34;kotlin\u0026#34; }\u003cbr/\u003ecompose-gradlePlugin = { module = \u0026#34;org.jetbrains.compose:org.jetbrains.compose.gradle.plugin\u0026#34;, version.ref = \u0026#34;compose\u0026#34; }\u003cbr/\u003e**/\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5242\"\u003eNow, all we need to do is create the package structure for our conventions module if not already created by the IDE\u003cbr/\u003eSomething like \u003ccode\u003esrc/main/kotlin/com/example/app/convention\u003c/code\u003e \u003cbr/\u003eFor example\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ffbb\"\u003eThis is where our helper functions will be placed and our plugin will go into the Kotlin directory.\u003c/p\u003e\u003cp id=\"be36\"\u003eNow that our setup is done, let\u0026#39;s get started with the plugin.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"11ba\"\u003eCreating independent feature configurations ‚öôÔ∏è\u003c/h2\u003e\u003cp id=\"1f99\"\u003eOur approach is to configure each part of the project independently as an extension function and then combine all, to create the final Plugin.\u003cbr/\u003eAll these files will be put under the \u003ccode\u003ecom.example.app.convention\u003c/code\u003e package\u003cbr/\u003eWe will have three feature configs, for Android, Cocoapods and KMP.\u003c/p\u003e\u003ch2 id=\"8e51\"\u003eAccessing the Gradle Version Catalogue\u003c/h2\u003e\u003cp id=\"1bce\"\u003eWe create an extension function on the \u003ccode\u003eProject\u003c/code\u003e class to access our Gradle Version Catalogue \u003ccode\u003elibs.versions.toml\u003c/code\u003e in a file \u003ccode\u003eLibs.kt\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a67\"\u003eval Project.libs\u003cbr/\u003e    get(): VersionCatalog = extensions.getByType\u0026lt;VersionCatalogsExtension\u0026gt;().named(\u0026#34;libs\u0026#34;)\u003cp\u003eval Project.androidLibs\u003cbr/\u003e    get(): VersionCatalog = extensions.getByType\u0026lt;VersionCatalogsExtension\u0026gt;().named(\u0026#34;androidLibs\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9825\"\u003eHere, I have another version catalogue for Android dependencies only, you can omit this.\u003c/p\u003e\u003ch2 id=\"5b38\"\u003eConfiguring Android\u003c/h2\u003e\u003cp id=\"2490\"\u003eLet\u0026#39;s start with writing a configuration for our Android Target. Create a Kotlin file and paste this code.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0bb9\"\u003einternal fun Project.configureKotlinAndroid(\u003cbr/\u003e    extension: LibraryExtension\u003cbr/\u003e) = extension.apply {\u003cp\u003e        //get module name from module path\u003cbr/\u003e    val moduleName = path.split(\u0026#34;:\u0026#34;).drop(2).joinToString(\u0026#34;.\u0026#34;)\u003cbr/\u003e    namespace = if(moduleName.isNotEmpty()) \u0026#34;com.example.app.$moduleName\u0026#34; else \u0026#34;com.example.app\u0026#34;\u003c/p\u003e\u003cp\u003e    compileSdk = androidLibs.findVersion(\u0026#34;compileSdk\u0026#34;).get().requiredVersion.toInt()\u003cbr/\u003e    defaultConfig {\u003cbr/\u003e        minSdk = androidLibs.findVersion(\u0026#34;minSdk\u0026#34;).get().requiredVersion.toInt()\u003cbr/\u003e    }\u003cbr/\u003e    compileOptions {\u003cbr/\u003e        sourceCompatibility = JavaVersion.VERSION_17\u003cbr/\u003e        targetCompatibility = JavaVersion.VERSION_17\u003cbr/\u003e    }\u003cbr/\u003e    packaging {\u003cbr/\u003e        resources {\u003cbr/\u003e            excludes += \u0026#34;/META-INF/{AL2.0,LGPL2.1}\u0026#34;\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"77e0\"\u003eThat\u0026#39;s a lot of code to paste. Don‚Äôt worry, I will be explaining each part.\u003cbr/\u003eBreaking down the code\u003cbr/\u003eHere we create an extension function on the Gradle Project interface to configure our Project.\u003c/p\u003e\u003cul\u003e\u003cli id=\"34bf\"\u003eWe get the current moduleName from the module path of the module where the plugin is applied, we use this to set the android namespace for the module.\u003cbr/\u003eWe use \u003ccode\u003edrop(2)\u003c/code\u003e to drop the empty string and ‚Äúshared‚Äù from the module path, as our shared module will be named ‚Äúcom.example.app‚Äù and for all submodules, the module path will be appended after the shared module‚Äôs name. Eg ‚Äî \u003ccode\u003eshared\u003c/code\u003e for \u003ccode\u003e:shared\u003c/code\u003e, \u003ccode\u003eshared=core\u003c/code\u003e for \u003ccode\u003e:shared:core\u003c/code\u003e, \u003ccode\u003eshared-data-network\u003c/code\u003e for \u003ccode\u003e:shared:data:network\u003c/code\u003e\u003c/li\u003e\u003cli id=\"f214\"\u003eWe then set the \u003ccode\u003ecompileSdk\u003c/code\u003e , \u003ccode\u003eminSdk\u003c/code\u003e and other Android Configurations\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ab8f\"\u003eHere you can fully configure your modules for Android same as you do for an Android Project.\u003c/p\u003e\u003ch2 id=\"7522\"\u003eConfiguring Cocoapods for iOS üçé\u003c/h2\u003e\u003cp id=\"2991\"\u003eWe are using Cocoapods for iOS dependency management, if you are using Swift Package Manager or not targetting iOS, you can skip this part.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c0e7\"\u003einternal fun Project.configureKotlinCocoapods(\u003cbr/\u003e    extension: CocoapodsExtension\u003cbr/\u003e) = extension.apply {\u003cbr/\u003e    val moduleName = this@configureKotlinCocoapods.path.split(\u0026#34;:\u0026#34;).drop(1).joinToString(\u0026#34;-\u0026#34;)\u003cbr/\u003e    summary = \u0026#34;Some description for the Shared Module\u0026#34;\u003cbr/\u003e    homepage = \u0026#34;Link to the Shared Module homepage\u0026#34;\u003cbr/\u003e    version = \u0026#34;1.0\u0026#34; //your cocoapods version\u003cbr/\u003e    ios.deploymentTarget = \u0026#34;14.1\u0026#34; //your iOS deployment target\u003cbr/\u003e    name = moduleName\u003cbr/\u003e    framework {\u003cbr/\u003e        isStatic = true //static or dynamic according to your project\u003cbr/\u003e        baseName = moduleName\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e123\"\u003eHere we do a common set-up of Cocoapods for all our modules, you can add more configurations here.\u003cbr/\u003eWe get the module name from the module path and use it to name our cocoapods module, this is the name that will be used for the \u003ccode\u003epodspec\u003c/code\u003e file created.\u003cbr/\u003eThe logic for module name is the same as what we did for Android, the only change here is \u003ccode\u003edrop(1)\u003c/code\u003e as here we want the shared module to be named ‚Äúshared‚Äù and all child module names appending to it.\u003c/p\u003e\u003ch2 id=\"9d8d\"\u003eConfiguring Kotlin Multiplatform\u003c/h2\u003e\u003cp id=\"7b3e\"\u003eNow we configure our KMP Project. In this configuration, we will configure the following\u003c/p\u003e\u003cul\u003e\u003cli id=\"7b3b\"\u003eKotlin\u003c/li\u003e\u003cli id=\"6af7\"\u003eThe Targets we want to build for (iOS, Android, Linux, Windows etc)\u003c/li\u003e\u003cli id=\"29eb\"\u003eAll Common dependencies which are needed in all modules\u003c/li\u003e\u003cli id=\"e8c5\"\u003eCocoapods Dependency Management for iOS\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"3c2a\"\u003einternal fun Project.configureKotlinMultiplatform(\u003cbr/\u003e    extension: KotlinMultiplatformExtension\u003cbr/\u003e) = extension.apply {\u003cbr/\u003e    jvmToolchain(17)\u003cp\u003e        // targets\u003cbr/\u003e    androidTarget()\u003cbr/\u003e    iosArm64()\u003cbr/\u003e    iosX64()\u003cbr/\u003e    iosSimulatorArm64()\u003c/p\u003e\u003cp\u003e    applyDefaultHierarchyTemplate()\u003c/p\u003e\u003cp\u003e    //common dependencies\u003cbr/\u003e    sourceSets.apply {\u003cbr/\u003e        commonMain {\u003cbr/\u003e            dependencies {\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;koin.core\u0026#34;).get())\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;coroutines.core\u0026#34;).get())\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;kotlinx-dateTime\u0026#34;).get())\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;napier\u0026#34;).get())\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;kotlinx-serialization\u0026#34;).get())\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        androidMain {\u003cbr/\u003e            dependencies {\u003cbr/\u003e                implementation(libs.findLibrary(\u0026#34;koin.android\u0026#34;).get() )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        commonTest.dependencies {\u003cbr/\u003e            implementation(kotlin(\u0026#34;test\u0026#34;))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    //applying the Cocoapods Configuration we made\u003cbr/\u003e    (this as ExtensionAware).extensions.configure\u0026lt;CocoapodsExtension\u0026gt;(::configureKotlinCocoapods)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4a93\"\u003eBreaking down this huge piece of code we have\u003c/p\u003e\u003cul\u003e\u003cli id=\"958a\"\u003eSetting up the Java Version (17 is recommended for KMP)\u003c/li\u003e\u003cli id=\"99dd\"\u003eSetting up our targets, Android and iOS in this case\u003c/li\u003e\u003cli id=\"dd61\"\u003eApplying the default Kotlin Hierarchy which created the source sets for us\u003c/li\u003e\u003cli id=\"8b75\"\u003eApplying all the common dependencies that we need in all of our KMP Modules, we use the Gradle version catalogue to store the dependency configs.\u003c/li\u003e\u003cli id=\"1ddf\"\u003eWe apply the Cocoapods configuration to the \u003ccode\u003eCocoapods Extenstion\u003c/code\u003e included in the KMP Plugin.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9d32\"\u003eCombining Feature Configurations to Build the Kotlin Multiplatform Plugin üèõ\u003c/h2\u003e\u003cp id=\"a427\"\u003eNow we applying all three of our feature configurations to build up the KMP Plugin.\u003cbr/\u003eApart from applying our created configurations, we also add all the common Gradle Plugins that we need in all of our modules.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5d51\"\u003eclass KotlinMultiplatformPlugin: Plugin\u0026lt;Project\u0026gt; {\u003cp\u003e    override fun apply(target: Project):Unit = with(target){\u003cbr/\u003e        with(pluginManager){\u003cbr/\u003e            apply(libs.findPlugin(\u0026#34;kotlinMultiplatform\u0026#34;).get().get().pluginId)\u003cbr/\u003e            apply(libs.findPlugin(\u0026#34;kotlinCocoapods\u0026#34;).get().get().pluginId)\u003cbr/\u003e            apply(libs.findPlugin(\u0026#34;androidLibrary\u0026#34;).get().get().pluginId)\u003cbr/\u003e            apply(libs.findPlugin(\u0026#34;kotlin.serialization\u0026#34;).get().get().pluginId)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        extensions.configure\u0026lt;KotlinMultiplatformExtension\u0026gt;(::configureKotlinMultiplatform)\u003cbr/\u003e        extensions.configure\u0026lt;LibraryExtension\u0026gt;(::configureKotlinAndroid)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"626a\"\u003eWe create a class inheriting the Gradle Plugin interface to create our custom Gradle Convention Plugin.\u003cbr/\u003eNow all we need to do is to register the Plugin for use.\u003c/p\u003e\u003ch2 id=\"fc47\"\u003eRegistering our Custom Plugin\u003c/h2\u003e\u003cp id=\"b832\"\u003eNow to register our plugin for use, we head out to the \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e of our conventions module and add this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f43c\"\u003egradlePlugin {\u003cbr/\u003e    plugins {\u003cbr/\u003e        register(\u0026#34;kotlinMultiplatform\u0026#34;){\u003cbr/\u003e            id = \u0026#34;com.example.app.kotlinMultiplatform\u0026#34;\u003cbr/\u003e            implementationClass = \u0026#34;KotlinMultiplatformPlugin\u0026#34;\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"399a\"\u003eWe can use our plugin with \u003ccode\u003eapply(\u0026#34;com.example.app.kotlinMultiplatform\u0026#34;)\u003c/code\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"829c\"\u003eThis is how our convention module should look like\u003c/p\u003e\u003ch2 id=\"9072\"\u003eUsing our Custom Gradle Plugin\u003c/h2\u003e\u003cp id=\"377d\"\u003eUsing the custom plugin we made is very very simple, we can now remove all repeated code and replace it with just \u003ccode\u003eapply(\u0026#34;com.example.app.kotlinMultiplatform\u0026#34;)\u003c/code\u003e\u003c/p\u003e\u003cp id=\"e456\"\u003eExample of how our modules will look like\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c0db\"\u003eplugins {\u003cbr/\u003e    id(\u0026#34;com.example.app.kotlinMultiplatform\u0026#34;) //handling all config\u003cbr/\u003e}\u003cp\u003ekotlin {\u003c/p\u003e\u003cp\u003e    // if yoy have any pod dependencies, you just to define and not configure cocoapods\u003cbr/\u003e    cocoapods {\u003cbr/\u003e        pod(\u0026#34;Amplitude\u0026#34;, \u0026#34;8.17.1\u0026#34;)\u003cbr/\u003e        pod(\u0026#34;FirebaseMessaging\u0026#34;)\u003cbr/\u003e        pod(\u0026#34;Reachability\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // module specific dependencies\u003cbr/\u003e    sourceSets {\u003cbr/\u003e        commonMain.dependencies {\u003cbr/\u003e            api(libs.touchlabs.crashlytics)\u003cbr/\u003e            implementation(libs.ktor.client.core)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        androidMain.dependencies {\u003cbr/\u003e            implementation(androidLibs.amplitude)\u003cbr/\u003e            implementation(androidLibs.firebase.messaging.shared)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0ece\"\u003eWe can easily customize our plugin to add extra configuration or to override the ones in our Plugin.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bf92\"\u003eBonus: Custom Gradle Plugin for Compose Multiplatform üéâ\u003c/h2\u003e\u003cp id=\"065a\"\u003eIf you‚Äôre still reading, there‚Äôs some bonus content awaiting you. Given the surge in popularity of Jetpack Compose and its multiplatform counterpart, Compose Multiplatform, many apps are adopting it. Let‚Äôs delve into crafting a Custom Gradle Convention Plugin to configure our CMP Modules.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9105\"\u003eclass ComposeMultiplatformPlugin : Plugin\u0026lt;Project\u0026gt; {\u003cbr/\u003e    override fun apply(target: Project) = with(target) {\u003cbr/\u003e        with(pluginManager){\u003cbr/\u003e            apply(libs.findPlugin(\u0026#34;composeMultiplatform\u0026#34;).get().get().pluginId)\u003cbr/\u003e        }\u003cp\u003e        val composeDeps = extensions.getByType\u0026lt;ComposeExtension\u0026gt;().dependencies\u003c/p\u003e\u003cp\u003e        extensions.configure\u0026lt;KotlinMultiplatformExtension\u0026gt; {\u003cbr/\u003e            sourceSets.apply {\u003cbr/\u003e                commonMain {\u003cbr/\u003e                    dependencies {\u003cbr/\u003e                        implementation(composeDeps.runtime)\u003cbr/\u003e                        implementation(composeDeps.foundation)\u003cbr/\u003e                        implementation(composeDeps.material3)\u003cbr/\u003e                        implementation(composeDeps.materialIconsExtended)\u003cbr/\u003e                        implementation(composeDeps.material)\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e/**\u003cbr/\u003elibs.versions.toml\u003cbr/\u003ecomposeMultiplatform = { id = \u0026#34;org.jetbrains.compose\u0026#34;, version.ref = \u0026#34;compose\u0026#34; }\u003cbr/\u003e**/\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bfe4\"\u003eSimilar to the KMP Plugin, we make a class inheriting the Gradle \u003ccode\u003ePlugin\u003c/code\u003e interface and implementing the \u003ccode\u003eapply\u003c/code\u003e function.\u003cbr/\u003eBreaking down the code, what we do here is\u003c/p\u003e\u003cul\u003e\u003cli id=\"15a7\"\u003eWe apply the JetBrains compose plugin to enable CMP for this module.\u003c/li\u003e\u003cli id=\"7d20\"\u003eWe then get the Compose Extension which gets added to our project when adding the CMP Plugin.\u003c/li\u003e\u003cli id=\"d56a\"\u003eWe use the dependencies from Compose Extension and apply all the common Compose dependencies we want to have in our modules.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c0b1\"\u003eRegistering the Plugin\u003c/h2\u003e\u003cp id=\"588d\"\u003eNow to register our plugin for use, we head out to the \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e of our conventions module and add this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c9a7\"\u003egradlePlugin {\u003cbr/\u003e    plugins {\u003cbr/\u003e        register(\u0026#34;composeMultiplatform\u0026#34;){\u003cbr/\u003e            id = \u0026#34;com.example.app.composeMultiplatform\u0026#34;\u003cbr/\u003e            implementationClass = \u0026#34;ComposeMultiplatformPlugin\u0026#34;\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8935\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"b3e7\"\u003eCreating our custom Gradle Convention Plugins for configuring KMP modules is a great way to simplify our module‚Äôs Gradle configuration and maintain a single source of configuration.\u003cbr/\u003eThis cleans up our gradle config code a lot and makes it easy to maintain and free from errors when modifying configuration\u003c/p\u003e\u003cp id=\"576b\"\u003eLet\u0026#39;s see what the Gradle Config is like before and after using both our Custom KMP and CMP Gradle Convention Plugins.\u003c/p\u003e\u003cp id=\"acbf\"\u003e\u003cem\u003eThis is a very basic project targeting only iOS and Android, with very minimal configuration, in larger projects with more complex configurations and many more targets, the difference is a lot more.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"933a\"\u003eOriginal Gradle file before using our Custom Plugins\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a8e8\"\u003eimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\u003cp\u003eplugins {\u003cbr/\u003e    alias(libs.plugins.kotlinMultiplatform)\u003cbr/\u003e    alias(libs.plugins.androidLibrary)\u003cbr/\u003e    alias(libs.plugins.composeMultiplatform)\u003cbr/\u003e    kotlin(\u0026#34;native.cocoapods\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@OptIn(org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi::class)\u003cbr/\u003ekotlin {\u003cbr/\u003e    jvmToolchain(11)\u003cbr/\u003e    android()\u003cbr/\u003e    ios()\u003cbr/\u003e    iosSimulatorArm64()\u003c/p\u003e\u003cp\u003e    cocoapods {\u003cbr/\u003e        summary = \u0026#34;Some description for the Shared Module\u0026#34;\u003cbr/\u003e        homepage = \u0026#34;Link to the Shared Module homepage\u0026#34;\u003cbr/\u003e        version = \u0026#34;1.0\u0026#34;\u003cbr/\u003e        ios.deploymentTarget = \u0026#34;14.1\u0026#34;\u003cbr/\u003e        framework {\u003cbr/\u003e            baseName = \u0026#34;filePicker\u0026#34;\u003cbr/\u003e            isStatic = true\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        sourceSets {\u003cbr/\u003e        val commonMain by getting {\u003cbr/\u003e            dependencies {\u003cbr/\u003e                implementation(compose.runtime)\u003cbr/\u003e                implementation(compose.foundation)\u003cbr/\u003e                implementation(compose.material)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        val androidMain by getting {\u003cbr/\u003e            dependencies {\u003cbr/\u003e                implementation(androidLibs.activity.compose)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eandroid {\u003cbr/\u003e    namespace = \u0026#34;com.example.app.filepicker\u0026#34;\u003cbr/\u003e    compileSdk = androidLibs.versions.compileSdk.get().toInt()\u003cbr/\u003e    defaultConfig {\u003cbr/\u003e        minSdk =  androidLibs.versions.minSdk.get().toInt()\u003cbr/\u003e    }\u003cbr/\u003e    compileOptions {\u003cbr/\u003e        sourceCompatibility = JavaVersion.VERSION_17\u003cbr/\u003e        targetCompatibility = JavaVersion.VERSION_17\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    kotlin {\u003cbr/\u003e        jvmToolchain(17)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4a13\"\u003eRefactored Gradle file after using our Custom Gradle Plugins\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"732c\"\u003eplugins {\u003cbr/\u003e    //our custom plugins\u003cbr/\u003e    id(\u0026#34;com.example.app.kotlinMultiplatform\u0026#34;)\u003cbr/\u003e    id(\u0026#34;com.example.app.composeMultiplatform\u0026#34;)\u003cbr/\u003e}\u003cp\u003ekotlin {\u003c/p\u003e\u003cp\u003e    sourceSets {\u003cbr/\u003e        androidMain.dependencies {\u003cbr/\u003e            implementation(androidLibs.activity.compose)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6dc1\"\u003eThe difference is huge, and even more huge in more complex projects.\u003c/p\u003e\u003ch2 id=\"4a43\"\u003eFarewell üëã\u003c/h2\u003e\u003cp id=\"bf2f\"\u003eAs we wrap up here, I hope you‚Äôve picked up some cool tricks to level up your Kotlin Multiplatform game. With Gradle Convention Plugins by your side, there‚Äôs no limit to what you can achieve. Keep tinkering, keep coding, and may your projects always spark joy. Catch you on the flip side for more coding adventures!\u003cbr/\u003eHope you liked this article. To read more of my articles head on to my Medium Profile or my Hashnode \u003ca href=\"https://vaibhav2002.hashnode.dev/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eblogs\u003c/a\u003e or my \u003ca href=\"https://www.vaibhavjaiswal.tech/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewebsite\u003c/a\u003e to find all \u003cbr/\u003eIf you want to connect with me, head on to my website to find my socials.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2024-02-25T17:46:24.017Z",
  "modifiedTime": null
}
