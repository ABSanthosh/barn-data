{
  "id": "ebf8ea5a-6f81-4553-9b76-98278b177ad5",
  "title": "Parameterized Android Tests with Burst 2.0",
  "link": "https://handstandsam.com/2024/10/31/parameterized-android-tests-with-burst-2-0/",
  "description": "Parameterized tests allow you to write a test once, but allow it to be called with multiple parameters. This means it is creating more methods than youâ€™ve written, but without you having to write and maintain each one individually. Here is a trivial example of writing a single test with TestParameterInjector, but having it run [â€¦]",
  "author": "Sam Edwards",
  "published": "Thu, 31 Oct 2024 15:52:32 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Updates"
  ],
  "byline": "Sam Edwards Published October 31, 2024",
  "length": 5317,
  "excerpt": "Parameterized tests allow you to write a test once, but allow it to be called with multiple parameters. This means it is creating more methods than youâ€™ve written, but without you having to write and maintain each one individually.",
  "siteName": "",
  "favicon": "",
  "text": "Parameterized tests allow you to write a test once, but allow it to be called with multiple parameters. This means it is creating more methods than youâ€™ve written, but without you having to write and maintain each one individually. Here is a trivial example of writing a single test with TestParameterInjector, but having it run twice with true and false. @RunWith(TestParameterInjector::class) class MyTest { @Test fun test(@TestParameter isOwner: Boolean) { // Your test logic here } } This example results in the following tests being run: MyTest#test[isOwner=true] MyTest#test[isOwner=false] TestParameterInjector has been the defacto way to do this on the JVM and is still a good solution for those projects. The original Burst 1.x project was archived and pointed users to use TestParameterInjector. Burst 2.0 bursts onto the Scene! Fast forward to October 2024 and Kotlin Multiplatform in full swing. There is no solution for parameterized tests for Kotlin Multiplatform, so in order to solve the problem, Burst 2.0 was created as a Kotlin Compiler Plugin. It Works on Android! ðŸŽ‰ While Kotlin Multiplatform support is fantastic, my biggest need at work is to use it for Parameterized Android Instrumentation tests, so I tried it out on my open source project ShoppingApp and here are my experiences. It ran successfully via the ./gradlew :app:connectedDebugAndroidTest --info command. Despite IDE support issues (red highlighting), the underlying library compiles and executes on the command line ðŸ˜„ . Executing the Android Tests with the IDE also causes failures for some reason even though it works. The Problem of Massively Sharding Android Tests TestParameterInjector has been a solution for Android Parameterized Tests but falls short when wanting to statically compute all tests methods for sharding purposes. Cloud based device farms like Firebase Test Lab can run your tests on _ number of devices at once and combine the results. This is facilitated in many projects through Flank (Fladle â€“ Flank Support in Gradle). The problem is that TestParameterInjector computes the test method names at runtime, and therefore these device farms can only get an entire class to run (which might end up having 100 permutations with parameterized tests). Parameterized tests are powerful, reduce boilerplate and ensure exhaustive coverage. To unlock this capability and support massively sharding tests, I personally spent 2 weeks developing a solution that DOES work with TestParameterInjector to compute all test names via static analysis of the APK via this multi-step process described here: https://github.com/google/TestParameterInjector/issues/27#issuecomment-2419775787 This has been super helpful in allowing my team to run parameterized tests in a massively sharded device farm, but it is a complex solution (but runs in 3 seconds), and while there are tons of integration tests for the library to ensure it works, because itâ€™s an involved set of steps, it still feels like it could fall over at some point. I could open source this solution, but it has itâ€™s limitations, and if we do have Burst 2.0 at our disposal now. Iâ€™m going to endorse their project and avoid having to maintain a project with a pretty equal feature set. The big hurdle with TestParameterInjector and computing a deterministic list of tests statically (using limited features like enums, strings, etc) is hard because itâ€™s determining the tests to run via the JUnit Runner itself at runtime, instead of when code is being compiled. This means the full list of methods are not in the final Test APK, but need to be loaded into JUnit and computed in a JVM runtime. Burst 2.0 uses the same limitations as my solution (enums, booleans and list of strings), but does it at the Kotlin Compiler phase Because of this different method, computing all android tests to be run can be done via static analysis of the APK by tools like https://github.com/linkedin/dex-test-parser which computes a full list of methods from an APK. This also means that it will work in Firebase Test Lab and other sharding by method runners. Related Issue of TestParameterInjector -\u003e https://github.com/google/TestParameterInjector/issues/27 to allow that functionality. Kotlin Compiler Plugin This what the resulting classes look like for a compiled class after getting processed by Burst. Required Dependencies Transitively brings in Kotlin 2.0.21 to your build classpath. Conclusion Burst 2.0 seems like the right solution for Android Developers to run parameterized tests and have it possible for sharded test runners to deterministically compute all test method names using static analysis. If you are someone out there that really wants the implementation I have for TestParameterInjector, then reach out to me a threads.net/@handstandsam and Iâ€™ll see if I can share it in open source (but wonâ€™t maintain the library). For now, to use Burst 2.0, you need Kotlin 2.0, but thatâ€™s already the case in the majority of projects since it was released as stable 6 months ago. You might have some IDE support issues for a bit, but Iâ€™m excited about Burst 2.0, and Iâ€™d encourage you to try it out on your Android projects!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-2071\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eParameterized tests allow you to write a test once, but allow it to be called with multiple parameters. This means it is creating more methods than youâ€™ve written, but without you having to write and maintain each one individually.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is a trivial example of writing a single test with \u003ccode\u003eTestParameterInjector\u003c/code\u003e, but having it run twice with \u003ccode\u003etrue\u003c/code\u003e and \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@RunWith(TestParameterInjector::class)\nclass MyTest {\n\n    @Test\n    fun test(@TestParameter isOwner: Boolean) {\n        // Your test logic here\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis example results in the following tests being run: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eMyTest#test[isOwner=true]\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eMyTest#test[isOwner=false]\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/google/TestParameterInjector\"\u003eTestParameterInjector\u003c/a\u003e has been the defacto way to do this on the JVM and is still a good solution for those projects. The original \u003ca href=\"https://github.com/square/burst\"\u003eBurst 1.x project was archived\u003c/a\u003e and pointed users to use \u003ccode\u003eTestParameterInjector\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\u003ch2\u003e\u003ca href=\"https://github.com/cashapp/burst\"\u003eBurst 2.0\u003c/a\u003e bursts onto the Scene!\u003c/h2\u003e\n\n\n\n\u003cp\u003eFast forward to October 2024 and Kotlin Multiplatform in full swing.  There is no solution for parameterized tests for Kotlin Multiplatform, so in order to solve the problem, Burst 2.0 was created as a Kotlin Compiler Plugin.\u003c/p\u003e\n\n\n\n\n\n\u003ch2\u003eIt Works on Android! ðŸŽ‰\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile Kotlin Multiplatform support is fantastic, my biggest need at work is to use it for Parameterized Android Instrumentation tests, so I \u003ca href=\"https://github.com/handstandsam/ShoppingApp/pull/78\"\u003etried it out on my open source project ShoppingApp\u003c/a\u003e and here are my experiences.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt ran successfully via the \u003ccode\u003e./gradlew :app:connectedDebugAndroidTest --info\u003c/code\u003e command.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://github.com/user-attachments/assets/5358e30d-d8cd-435b-aa19-25d944ca1037\" alt=\"Screenshot 2024-10-31 at 9 42 33â€¯AM\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eDespite IDE support issues (red highlighting), the underlying library compiles and executes on the command line ðŸ˜„ .\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://github.com/user-attachments/assets/dc311d69-9d30-4311-a9da-8d7724cf45ad\" alt=\"Screenshot 2024-10-31 at 9 36 37â€¯AM\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eExecuting the Android Tests with the IDE also causes failures for some reason even though it works.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://github.com/user-attachments/assets/d0606247-6f5a-4007-8f25-1c7471bcd3e6\" alt=\"Screenshot 2024-10-31 at 9 37 07â€¯AM\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eThe Problem of Massively Sharding Android Tests\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eTestParameterInjector\u003c/code\u003e has been a solution for Android Parameterized Tests but falls short when wanting to statically compute all tests methods for sharding purposes.\u003c/p\u003e\n\n\n\n\u003cp\u003eCloud based device farms like \u003ca href=\"https://firebase.google.com/docs/test-lab\"\u003eFirebase Test Lab\u003c/a\u003e can run your tests on _ number of devices at once and combine the results. This is facilitated in many projects through \u003ca href=\"https://flank.github.io/flank/\"\u003eFlank\u003c/a\u003e (\u003ca href=\"https://runningcode.github.io/fladle/\"\u003eFladle\u003c/a\u003e â€“ Flank Support in Gradle).  The problem is that \u003ccode\u003eTestParameterInjector\u003c/code\u003e computes the test method names at runtime, and therefore these device farms can only get an entire class to run (which might end up having 100 permutations with parameterized tests).\u003c/p\u003e\n\n\n\n\u003cp\u003eParameterized tests are powerful, reduce boilerplate and ensure exhaustive coverage.  To unlock this capability and support massively sharding tests, I personally spent 2 weeks developing a solution that DOES work with \u003ccode\u003eTestParameterInjector\u003c/code\u003e to compute all test names via static analysis of the APK via this multi-step process described here:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ca href=\"https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM.png\"\u003e\u003cimg decoding=\"async\" width=\"1024\" height=\"723\" src=\"https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-1024x723.png\" alt=\"\" srcset=\"https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-1024x723.png 1024w, https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-300x212.png 300w, https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-768x542.png 768w, https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-1536x1085.png 1536w, https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM-700x494.png 700w, https://handstandsam.com/wp-content/uploads/2024/10/Screenshot-2024-10-31-at-11.33.04â€¯AM.png 1866w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e\u003ca href=\"https://github.com/google/TestParameterInjector/issues/27#issuecomment-2419775787\"\u003ehttps://github.com/google/TestParameterInjector/issues/27#issuecomment-2419775787\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis has been super helpful in allowing my team to run parameterized tests in a massively sharded device farm, but it is a complex solution (but runs in 3 seconds), and while there are tons of integration tests for the library to ensure it works, because itâ€™s an involved set of steps, it still feels like it could fall over at some point.\u003c/p\u003e\n\n\n\n\u003cp\u003eI could open source this solution, but it has itâ€™s limitations, and if we do have Burst 2.0 at our disposal now.  Iâ€™m going to endorse their project and avoid having to maintain a project with a pretty equal feature set.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe big hurdle with \u003ccode\u003eTestParameterInjector\u003c/code\u003e and computing a deterministic list of tests statically (using limited features like enums, strings, etc) is hard because itâ€™s determining the tests to run via the JUnit Runner itself at runtime, instead of when code is being compiled. This means the full list of methods are not in the final Test APK, but need to be loaded into JUnit and computed in a JVM runtime.\u003c/p\u003e\n\n\n\n\u003cp\u003eBurst 2.0 uses the same limitations as my solution (enums, booleans and list of strings), but does it at the Kotlin Compiler phase Because of this different method, computing all android tests to be run can be done via static analysis of the APK by tools like https://github.com/linkedin/dex-test-parser which computes a full list of methods from an APK. This also means that it will work in Firebase Test Lab and other sharding by method runners. Related Issue of TestParameterInjector -\u0026gt; https://github.com/google/TestParameterInjector/issues/27 to allow that functionality.\u003c/p\u003e\n\n\n\n\u003ch2\u003eKotlin Compiler Plugin\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis what the resulting classes look like for a compiled class after getting processed by \u003ccode\u003eBurst\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://github.com/user-attachments/assets/45acf0e7-eea2-4d11-9e5c-914277731e9b\" alt=\"Screenshot 2024-10-31 at 9 39 48â€¯AM\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://github.com/user-attachments/assets/cd190929-7611-4539-99f4-4091d3c2c7e6\" alt=\"Screenshot 2024-10-31 at 9 39 26â€¯AM\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eRequired Dependencies\u003c/h2\u003e\n\n\n\n\u003cp\u003eTransitively brings in \u003ccode\u003eKotlin 2.0.21\u003c/code\u003e to your build classpath.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eBurst 2.0 seems like the right solution for Android Developers to run parameterized tests and have it possible for sharded test runners to deterministically compute all test method names using static analysis.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you are someone out there that really wants the implementation I have for \u003ccode\u003eTestParameterInjector\u003c/code\u003e, then reach out to me a \u003ca href=\"https://www.threads.net/@handstandsam\"\u003ethreads.net/@handstandsam\u003c/a\u003e and Iâ€™ll see if I can share it in open source (but wonâ€™t maintain the library).\u003c/p\u003e\n\n\n\n\u003cp\u003eFor now, to use Burst 2.0, you need Kotlin 2.0, but thatâ€™s already the case in the majority of projects since it was released as stable 6 months ago.  You might have some IDE support issues for a bit, but Iâ€™m excited about Burst 2.0, and Iâ€™d encourage you to try it out on your Android projects!\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
