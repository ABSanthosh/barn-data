{
  "id": "e47cc53c-1628-4f37-8db9-14335dbb1efa",
  "title": "It’s All About (Accessibility) Focus And Compose",
  "link": "https://proandroiddev.com/its-all-about-accessibility-focus-and-compose-de1ec352649a?source=rss----c72404660798---4",
  "description": "",
  "author": "Eevis Panula",
  "published": "Mon, 07 Jul 2025 15:33:28 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "accessibility",
    "android-app-development",
    "jetpack-compose",
    "focus",
    "android"
  ],
  "byline": "Eevis Panula",
  "length": 10014,
  "excerpt": "I’ve seen multiple questions in various Slack communities, Stack Overflow, and other places related to focus on Android and how it doesn’t behave as expected. The question typically concerns the use…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "It’s All About (Accessibility) Focus And ComposeI’ve seen multiple questions in various Slack communities, Stack Overflow, and other places related to focus on Android and how it doesn’t behave as expected. The question typically concerns the use of focusRequester and then inquires why Talkback or other assistive technologies fail to set focus correctly.The simple answer is that these APIs are different, and focus behaves differently with accessibility focus and keyboard focus.In this blog post, I’ll discuss the differences and what you can do in different cases. Let’s first look at what I mean when I talk about accessibility focus and keyboard focus.Accessibility FocusIn this blog post, accessibility focus refers to the focus related to screen readers, such as TalkBack. It could include focus for switch access as well, but I’m leaving it out of the scope of this blog post.When using a screen reader, accessibility focus can be set to any element relevant to the user, such as interactive elements, text, images with text alternatives (content descriptions), and other meaningful elements. The focus indicator can look different on different phones, but here’s an example from my phone:It’s set by the system, so the app developer can’t edit it, and there shouldn’t be any need to do that either.Keyboard FocusKeyboard focus, on the other hand, is the focus that interactive elements receive when a user uses a keyboard, D-pad, or other keyboard-emulating device for navigation.Only interactive elements should be focusable; never, for example, headings or other text. The default focus indicator is the ripple, so it’s not that visible:Later, I will write a blog post about customising and making the focus indicator pass the accessibility legal requirements with color contrast and other requirements.Making a Component FocusableSo you’re creating a custom component, and wondering if it’s the kind that should be focusable. The short and simple answer is that every component that the user can interact with via touch input should most likely be focusable. The actual interaction should be handled with accessibility actions and key events, depending on the component.To put it even more clearly: every button, checkbox, editable text, swipeable element, and graph that has touch input for either/both scrolling or/and data point exploration, should usually be focusable.However, note that when using Material components, such as buttons and other interactive elements, they are already focusable, so you don’t need to add it manually. Adding, for example, a focusable modifier makes the element appear twice in the focus order.There are several ways to make a custom interactive element focusable for both screen readers and keyboard navigation.Using clickable, toggleable, or selectable modifiers. If you're creating a component that the user should be able to either click, toggle, or select, use the respective modifiers. They make the component focusable as well.Using focusable-modifier. Sometimes a component needs to be focusable, but it's not clickable, toggleable, or selectable. It might, for example, require custom keyboard shortcuts, such as a chart with touch input that reveals more data with touch gestures. In these cases, using the focusable modifier is the right choice for making the component focusable.Moving Focus Programmatically to a ComponentThe next thing we need to discuss is moving the focus programmatically based on the user’s actions. For keyboard and keyboard-emulating navigation methods, this is relatively straightforward. For screen readers, it requires a little bit more. Let’s first discuss the keyboard focus and then the accessibility focus.Keyboard FocusIf you want to move keyboard focus from an element when a new screen appears, or on, let’s say, a button click, FocusRequester is your friend.Here’s what using it looks like in code:@Composablefun Component() { val focusRequester = remember { FocusRequester() } Button( onClick = { focusRequester.requestFocus() } ) { Text(\"Move focus\") } CustomComponentWereFocusing( modifier = Modifier .focusRequester(focusRequester) .toggleable(...) )}In this example, when the user clicks the Button, focus moves to the CustomComponentWereFocusing. We first define the focusRequester by remembering FocusRequester(), then set it to the focusRequester modifier for the CustomComponentWereFocusing. Finally, we call FocusRequester's requestFocus() method on button click.One important thing to remember here, as with other modifiers, is that the order of modifiers matters. So, when setting the focusRequester modifier, it must be placed before the modifier that adds focusability to the component. Otherwise, it doesn’t work at all.Accessibility FocusMoving the accessibility focus for screen readers needs a little bit more work. The focusRequester doesn't work here, so we need to resort to workarounds to accomplish it. I'll share some ideas; the final implementation, naturally, depends on the actual use case.The first suggestion is that, in some cases, changing the traversal order may be the solution. The following section discusses this topic, so keep reading for tips on how to do that.Then there’s a solution for changing the focused property on the semantics modifier. I found this solution from Kotlinlang Slack's Compose channel.The example from the keyboard navigation section with the ability to focus with a screen reader would look like this:@Composablefun Component() { val isFocused by remember { mutableStateOf(false) } LaunchedEffect(isFocused) { if (isFocused) isFocused = false } Button( onClick = { isFocused = true } ) { Text(\"Move focus\") } CustomComponentWereFocusing( modifier = Modifier .semantics { focused = isFocused } .toggleable(...) )}So, here we first define a boolean variable isFocused, which we remember. Then, we set the focused property of the semantics modifier to isFocused for CustomComponentWereFocusing. On the button click, we set the isFocused to true to move the focus to CustomComponentWereFocusing.And finally, we have a LaunchedEffect listening for changes to isFocused, and if it's true, we set it back to false. It doesn't clear the focus from CustomComponentWereFocusing, but lets us refocus with a new button click if needed.Here, again, the order of the modifiers matters — semantics needs to be before the focusability-applying modifier, which is toggleable in the example.Changing Traversal OrderThe final topic for this blog post is changing traversal order. Let’s say we have a layout with two rows and two columns. The layout looks like this:The default focus order would be as follows: first top row, then bottom row — meaning First, Third, Second, Fourth. And we want it to be in numerical order.The solutions for accessibility and keyboard focus are different, so let’s discuss them separately, starting with accessibility focus.Accessibility FocusFor accessibility focus, using the semantics modifier, isTraversalGroup, and traversalIndex is the way to customise the focus order.First, let’s set the isTraversalGroup property to true for the parent component wrapping the two rows. Why? It's to create a border for our changes in traversal order. You see, if we don't set it, and set the traversalIndex to the buttons, they'd be last in the screen's focus order, because their traversal index is greater than 0. Zero is the default traversal index for elements that don't have the traversal index explicitly set. However, if we set the border with isTraversalGroup, then the changes will only affect the focus order within the traversal group, not the screen's focus order.So, in code it would look like the following:Column( modifier = Modifier .semantics { isTraversalGroup = true }) { ...}And then we set the traversalIndex for each of the buttons to match the focus order we want to create:Row(...) { Button( modifier = Modifier.semantics { traversalIndex = 1f }, ... ) { Text(\"First\") } Button( modifier = Modifier.semantics { traversalIndex = 3f }, ... ) { Text(\"Third\") } }I’ve omitted the other row, which contains the “Second” and “Fourth” buttons, from the example, but the idea remains the same.And that’s it. With these changes, the focus order for accessibility focus changes. Let’s talk about keyboard focus-related changes next.Keyboard FocusFor keyboard focus, we first need to create FocusRequesters for each button with FocusRequester.createRefs(), and then attach them with focusRequester modifier, and finally, set the focus order with focusProperties modifier.Creating the FocusRequesters looks like the following code:val (first, second, third, fourth) = remember { FocusRequester.createRefs() }Next, we set the FocusRequesters with focusRequester modifier and the next element to focus on with focusProperties modifier:Row(...) { Button( modifier = Modifier .focusRequester(first) .focusProperties { next = second}, ... ) { Text(\"First\") } Button( modifier = Modifier .focusRequester(third) .focusProperties { next = fourth}, ... ) { Text(\"Third\") }}I’ve omitted the second row from the example, but it would be similar.This way, keyboard and keyboard-emulating device navigating users would first get to the “First” button, then “Second”, then “Third”, and finally, “Fourth”.Wrapping UpIn this blog post, I’ve discussed the differences between focusing with screen readers (e.g., TalkBack) and navigating with the keyboard. I’ve also demonstrated the differences between the two in changing the currently focused element and altering the traversal/focus order.If you want to read the docs, Modify traversal order is the page to check for accessibility focus, and Focus in Compose summarizes the information about keyboard focus.Links in the Blog PostKotlinlang Slack’s Compose channelModify traversal orderFocus in Compose",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*NVkB7QzSgcWiZP_AMsZ-qQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"2a9e\" data-testid=\"storyTitle\"\u003eIt’s All About (Accessibility) Focus And Compose\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@eevajonna?source=post_page---byline--de1ec352649a---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Eevis Panula\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*NhMD_9eOS1kF9_b3VomDEQ.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5a2e\"\u003eI’ve seen multiple questions in various Slack communities, Stack Overflow, and other places related to focus on Android and how it doesn’t behave as expected. The question typically concerns the use of \u003ccode\u003efocusRequester\u003c/code\u003e and then inquires why Talkback or other assistive technologies fail to set focus correctly.\u003c/p\u003e\u003cp id=\"d362\"\u003eThe simple answer is that these APIs are different, and focus behaves differently with accessibility focus and keyboard focus.\u003c/p\u003e\u003cp id=\"10b5\"\u003eIn this blog post, I’ll discuss the differences and what you can do in different cases. Let’s first look at what I mean when I talk about accessibility focus and keyboard focus.\u003c/p\u003e\u003ch2 id=\"4beb\"\u003eAccessibility Focus\u003c/h2\u003e\u003cp id=\"9416\"\u003eIn this blog post, accessibility focus refers to the focus related to screen readers, such as TalkBack. It could include focus for switch access as well, but I’m leaving it out of the scope of this blog post.\u003c/p\u003e\u003cp id=\"0aaf\"\u003eWhen using a screen reader, accessibility focus can be set to any element relevant to the user, such as interactive elements, text, images with text alternatives (content descriptions), and other meaningful elements. The focus indicator can look different on different phones, but here’s an example from my phone:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"41fd\"\u003eIt’s set by the system, so the app developer can’t edit it, and there shouldn’t be any need to do that either.\u003c/p\u003e\u003ch2 id=\"03e4\"\u003eKeyboard Focus\u003c/h2\u003e\u003cp id=\"75c9\"\u003eKeyboard focus, on the other hand, is the focus that interactive elements receive when a user uses a keyboard, D-pad, or other keyboard-emulating device for navigation.\u003c/p\u003e\u003cp id=\"169d\"\u003eOnly interactive elements should be focusable; never, for example, headings or other text. The default focus indicator is the ripple, so it’s not that visible:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8370\"\u003eLater, I will write a blog post about customising and making the focus indicator pass the accessibility legal requirements with color contrast and other requirements.\u003c/p\u003e\u003ch2 id=\"7ecf\"\u003eMaking a Component Focusable\u003c/h2\u003e\u003cp id=\"2b37\"\u003eSo you’re creating a custom component, and wondering if it’s the kind that should be focusable. The short and simple answer is that every component that the user can interact with via touch input should most likely be focusable. The actual interaction should be handled with accessibility actions and key events, depending on the component.\u003c/p\u003e\u003cp id=\"3051\"\u003eTo put it even more clearly: every button, checkbox, editable text, swipeable element, and graph that has touch input for either/both scrolling or/and data point exploration, should usually be focusable.\u003c/p\u003e\u003cp id=\"b866\"\u003eHowever, note that when using Material components, such as buttons and other interactive elements, they are already focusable, so you don’t need to add it manually. Adding, for example, a \u003ccode\u003efocusable\u003c/code\u003e modifier makes the element appear twice in the focus order.\u003c/p\u003e\u003cp id=\"8ebd\"\u003eThere are several ways to make a custom interactive element focusable for both screen readers and keyboard navigation.\u003c/p\u003e\u003cp id=\"493c\"\u003e\u003cstrong\u003eUsing \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eclickable\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e, \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003etoggleable\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e, or \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eselectable\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e modifiers\u003c/strong\u003e. If you\u0026#39;re creating a component that the user should be able to either click, toggle, or select, use the respective modifiers. They make the component focusable as well.\u003c/p\u003e\u003cp id=\"7828\"\u003e\u003cstrong\u003eUsing \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003efocusable\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e-modifier\u003c/strong\u003e. Sometimes a component needs to be focusable, but it\u0026#39;s not clickable, toggleable, or selectable. It might, for example, require custom keyboard shortcuts, such as a chart with touch input that reveals more data with touch gestures. In these cases, using the focusable modifier is the right choice for making the component focusable.\u003c/p\u003e\u003ch2 id=\"29e6\"\u003eMoving Focus Programmatically to a Component\u003c/h2\u003e\u003cp id=\"e2ab\"\u003eThe next thing we need to discuss is moving the focus programmatically based on the user’s actions. For keyboard and keyboard-emulating navigation methods, this is relatively straightforward. For screen readers, it requires a little bit more. Let’s first discuss the keyboard focus and then the accessibility focus.\u003c/p\u003e\u003ch2 id=\"5888\"\u003eKeyboard Focus\u003c/h2\u003e\u003cp id=\"f6ee\"\u003eIf you want to move keyboard focus from an element when a new screen appears, or on, let’s say, a button click, \u003ccode\u003eFocusRequester\u003c/code\u003e is your friend.\u003c/p\u003e\u003cp id=\"5a3c\"\u003eHere’s what using it looks like in code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ec1e\"\u003e@Composable\u003cbr/\u003efun Component() {\u003cbr/\u003e  val focusRequester = remember { FocusRequester() }\u003cp\u003e    Button(\u003cbr/\u003e    onClick = { focusRequester.requestFocus() }\u003cbr/\u003e  ) { \u003cbr/\u003e    Text(\u0026#34;Move focus\u0026#34;) \u003cbr/\u003e  }\u003cbr/\u003e  CustomComponentWereFocusing(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e      .focusRequester(focusRequester)\u003cbr/\u003e      .toggleable(...)\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fadd\"\u003eIn this example, when the user clicks the \u003ccode\u003eButton\u003c/code\u003e, focus moves to the \u003ccode\u003eCustomComponentWereFocusing\u003c/code\u003e. We first define the \u003ccode\u003efocusRequester\u003c/code\u003e by remembering \u003ccode\u003eFocusRequester()\u003c/code\u003e, then set it to the \u003ccode\u003efocusRequester\u003c/code\u003e modifier for the \u003ccode\u003eCustomComponentWereFocusing\u003c/code\u003e. Finally, we call \u003ccode\u003eFocusRequester\u003c/code\u003e\u0026#39;s \u003ccode\u003erequestFocus()\u003c/code\u003e method on button click.\u003c/p\u003e\u003cp id=\"4261\"\u003eOne important thing to remember here, as with other modifiers, is that the order of modifiers matters. So, when setting the focusRequester modifier, it must be placed before the modifier that adds focusability to the component. Otherwise, it doesn’t work at all.\u003c/p\u003e\u003ch2 id=\"2184\"\u003eAccessibility Focus\u003c/h2\u003e\u003cp id=\"3738\"\u003eMoving the accessibility focus for screen readers needs a little bit more work. The \u003ccode\u003efocusRequester\u003c/code\u003e doesn\u0026#39;t work here, so we need to resort to workarounds to accomplish it. I\u0026#39;ll share some ideas; the final implementation, naturally, depends on the actual use case.\u003c/p\u003e\u003cp id=\"e851\"\u003eThe first suggestion is that, in some cases, changing the traversal order may be the solution. The following section discusses this topic, so keep reading for tips on how to do that.\u003c/p\u003e\u003cp id=\"8eca\"\u003eThen there’s a solution for changing the \u003ccode\u003efocused\u003c/code\u003e property on the \u003ccode\u003esemantics\u003c/code\u003e modifier. I found this solution from \u003ca href=\"https://slack-chats.kotlinlang.org/t/10509998/is-there-a-way-to-request-talkback-focus-on-a-particular-ele\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlinlang Slack\u0026#39;s Compose channel\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"84f4\"\u003eThe example from the keyboard navigation section with the ability to focus with a screen reader would look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0f27\"\u003e@Composable\u003cbr/\u003efun Component() {\u003cbr/\u003e  val isFocused by remember { mutableStateOf(false) }\u003cp\u003e    LaunchedEffect(isFocused) {\u003cbr/\u003e    if (isFocused) isFocused = false\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  Button(\u003cbr/\u003e    onClick = { isFocused = true }\u003cbr/\u003e  ) { \u003cbr/\u003e    Text(\u0026#34;Move focus\u0026#34;) \u003cbr/\u003e  }\u003cbr/\u003e  CustomComponentWereFocusing(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e      .semantics { focused = isFocused }\u003cbr/\u003e      .toggleable(...)\u003cbr/\u003e  )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2d12\"\u003eSo, here we first define a boolean variable \u003ccode\u003eisFocused\u003c/code\u003e, which we remember. Then, we set the \u003ccode\u003efocused\u003c/code\u003e property of the \u003ccode\u003esemantics\u003c/code\u003e modifier to \u003ccode\u003eisFocused\u003c/code\u003e for \u003ccode\u003eCustomComponentWereFocusing\u003c/code\u003e. On the button click, we set the \u003ccode\u003eisFocused\u003c/code\u003e to true to move the focus to \u003ccode\u003eCustomComponentWereFocusing\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"329e\"\u003eAnd finally, we have a \u003ccode\u003eLaunchedEffect\u003c/code\u003e listening for changes to \u003ccode\u003eisFocused\u003c/code\u003e, and if it\u0026#39;s true, we set it back to false. It doesn\u0026#39;t clear the focus from \u003ccode\u003eCustomComponentWereFocusing\u003c/code\u003e, but lets us refocus with a new button click if needed.\u003c/p\u003e\u003cp id=\"ce9a\"\u003eHere, again, the order of the modifiers matters — \u003ccode\u003esemantics\u003c/code\u003e needs to be before the focusability-applying modifier, which is \u003ccode\u003etoggleable\u003c/code\u003e in the example.\u003c/p\u003e\u003ch2 id=\"5fc0\"\u003eChanging Traversal Order\u003c/h2\u003e\u003cp id=\"f9db\"\u003eThe final topic for this blog post is changing traversal order. Let’s say we have a layout with two rows and two columns. The layout looks like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d7bf\"\u003eThe default focus order would be as follows: first top row, then bottom row — meaning First, Third, Second, Fourth. And we want it to be in numerical order.\u003c/p\u003e\u003cp id=\"8203\"\u003eThe solutions for accessibility and keyboard focus are different, so let’s discuss them separately, starting with accessibility focus.\u003c/p\u003e\u003ch2 id=\"f01c\"\u003eAccessibility Focus\u003c/h2\u003e\u003cp id=\"dc2d\"\u003eFor accessibility focus, using the \u003ccode\u003esemantics\u003c/code\u003e modifier, \u003ccode\u003eisTraversalGroup\u003c/code\u003e, and \u003ccode\u003etraversalIndex\u003c/code\u003e is the way to customise the focus order.\u003c/p\u003e\u003cp id=\"3f0f\"\u003eFirst, let’s set the \u003ccode\u003eisTraversalGroup\u003c/code\u003e property to \u003ccode\u003etrue\u003c/code\u003e for the parent component wrapping the two rows. Why? It\u0026#39;s to create a border for our changes in traversal order. You see, if we don\u0026#39;t set it, and set the \u003ccode\u003etraversalIndex\u003c/code\u003e to the buttons, they\u0026#39;d be last in the screen\u0026#39;s focus order, because their traversal index is greater than 0. Zero is the default traversal index for elements that don\u0026#39;t have the traversal index explicitly set. However, if we set the border with \u003ccode\u003eisTraversalGroup\u003c/code\u003e, then the changes will only affect the focus order within the traversal group, not the screen\u0026#39;s focus order.\u003c/p\u003e\u003cp id=\"5980\"\u003eSo, in code it would look like the following:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"93c2\"\u003eColumn(\u003cbr/\u003e  modifier = Modifier\u003cbr/\u003e    .semantics {\u003cbr/\u003e      isTraversalGroup = true\u003cbr/\u003e    }\u003cbr/\u003e) {\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c040\"\u003eAnd then we set the \u003ccode\u003etraversalIndex\u003c/code\u003e for each of the buttons to match the focus order we want to create:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1458\"\u003eRow(...) {\u003cbr/\u003e    Button(\u003cbr/\u003e        modifier = Modifier.semantics { \u003cbr/\u003e            traversalIndex = 1f\u003cbr/\u003e        },\u003cbr/\u003e        ... \u003cbr/\u003e    ) { Text(\u0026#34;First\u0026#34;) }\u003cbr/\u003e    Button(\u003cbr/\u003e        modifier = Modifier.semantics { \u003cbr/\u003e            traversalIndex = 3f\u003cbr/\u003e        },\u003cbr/\u003e        ... \u003cbr/\u003e    ) { Text(\u0026#34;Third\u0026#34;) }\u003cbr/\u003e }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0309\"\u003eI’ve omitted the other row, which contains the “Second” and “Fourth” buttons, from the example, but the idea remains the same.\u003c/p\u003e\u003cp id=\"d70b\"\u003eAnd that’s it. With these changes, the focus order for accessibility focus changes. Let’s talk about keyboard focus-related changes next.\u003c/p\u003e\u003ch2 id=\"2136\"\u003eKeyboard Focus\u003c/h2\u003e\u003cp id=\"a404\"\u003eFor keyboard focus, we first need to create \u003ccode\u003eFocusRequester\u003c/code\u003es for each button with \u003ccode\u003eFocusRequester.createRefs()\u003c/code\u003e, and then attach them with \u003ccode\u003efocusRequester\u003c/code\u003e modifier, and finally, set the focus order with \u003ccode\u003efocusProperties\u003c/code\u003e modifier.\u003c/p\u003e\u003cp id=\"49fc\"\u003eCreating the \u003ccode\u003eFocusRequester\u003c/code\u003es looks like the following code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1959\"\u003eval (first, second, third, fourth) = remember { \u003cbr/\u003e  FocusRequester.createRefs() \u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d59f\"\u003eNext, we set the \u003ccode\u003eFocusRequester\u003c/code\u003es with \u003ccode\u003efocusRequester\u003c/code\u003e modifier and the next element to focus on with \u003ccode\u003efocusProperties\u003c/code\u003e modifier:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0951\"\u003eRow(...) {\u003cbr/\u003e  Button(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e      .focusRequester(first)\u003cbr/\u003e      .focusProperties { next = second},\u003cbr/\u003e    ... \u003cbr/\u003e  ) { Text(\u0026#34;First\u0026#34;) }\u003cbr/\u003e  Button(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e      .focusRequester(third)\u003cbr/\u003e      .focusProperties { next = fourth},\u003cbr/\u003e    ... \u003cbr/\u003e  ) { Text(\u0026#34;Third\u0026#34;) }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d206\"\u003eI’ve omitted the second row from the example, but it would be similar.\u003c/p\u003e\u003cp id=\"9ee2\"\u003eThis way, keyboard and keyboard-emulating device navigating users would first get to the “First” button, then “Second”, then “Third”, and finally, “Fourth”.\u003c/p\u003e\u003ch2 id=\"8a06\"\u003eWrapping Up\u003c/h2\u003e\u003cp id=\"ab82\"\u003eIn this blog post, I’ve discussed the differences between focusing with screen readers (e.g., TalkBack) and navigating with the keyboard. I’ve also demonstrated the differences between the two in changing the currently focused element and altering the traversal/focus order.\u003c/p\u003e\u003cp id=\"1a7e\"\u003eIf you want to read the docs, \u003ca href=\"https://developer.android.com/develop/ui/compose/accessibility/traversal\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eModify traversal order\u003c/a\u003e is the page to check for accessibility focus, and \u003ca href=\"https://developer.android.com/develop/ui/compose/touch-input/focus\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFocus in Compose\u003c/a\u003e summarizes the information about keyboard focus.\u003c/p\u003e\u003ch2 id=\"3fd3\"\u003eLinks in the Blog Post\u003c/h2\u003e\u003cul\u003e\u003cli id=\"39b0\"\u003e\u003ca href=\"https://slack-chats.kotlinlang.org/t/10509998/is-there-a-way-to-request-talkback-focus-on-a-particular-ele\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlinlang Slack’s Compose channel\u003c/a\u003e\u003c/li\u003e\u003cli id=\"0c8c\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/accessibility/traversal\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eModify traversal order\u003c/a\u003e\u003c/li\u003e\u003cli id=\"2e0e\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/touch-input/focus\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFocus in Compose\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-07-07T12:56:53.158Z",
  "modifiedTime": null
}
