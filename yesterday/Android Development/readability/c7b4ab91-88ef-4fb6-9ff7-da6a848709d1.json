{
  "id": "c7b4ab91-88ef-4fb6-9ff7-da6a848709d1",
  "title": "Animation and Masking in Jetpack Compose with the grahpicsLayer() and Drawing Modifiers",
  "link": "https://proandroiddev.com/animation-and-masking-in-jetpack-compose-with-the-grahpicslayer-and-drawing-modifiers-138d3496c624?source=rss----c72404660798---4",
  "description": "",
  "author": "Omar Sahl",
  "published": "Mon, 14 Oct 2024 07:51:07 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "mobile-development",
    "animation",
    "android",
    "jetpack-compose",
    "kotlin"
  ],
  "byline": "Omar Sahl",
  "length": 21020,
  "excerpt": "Jetpack Compose’s animation API is both powerful and enjoyable to work with. And when combined with the graphicsLayer() and drawing modifiers, it really open up possibilities for creating some really…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Jetpack Compose’s animation API is both powerful and enjoyable to work with. And when combined with the graphicsLayer() and drawing modifiers, it really open up possibilities for creating some really cool animations. In this article, we'll dive into exactly that by exploring how to create the following loading animation:Let’s get started.Why use the drawing modifiers for animations?Before we look at how to create that loading animation, let’s first talk about why the drawing modifiers are particularly useful for animations.To answer this question, let’s quickly go over Compose’s three main phases for rendering a frame: Composition, Layout, and Drawing.If you are already familiar with that, feel free to skip this section and jump directly to the animation implementation section below.Let’s examine a simple composable example:@Preview@Composablefun SlidingBox() { val infiniteTransition = rememberInfiniteTransition(label = \"infiniteTransition\") val progress = infiniteTransition.animateFloat( label = \"offset\", initialValue = -1f, targetValue = 1f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 1_000, easing = EaseInOut ), repeatMode = RepeatMode.Reverse ) ) val offset = 100.dp Box( contentAlignment = Alignment.Center, modifier = Modifier .fillMaxSize() .background(AppColors.DarkBlue) ) { Box( modifier = Modifier .size(100.dp) .offset(offset * progress.value) .background(AppColors.Pink, RoundedCornerShape(10.dp)) ) }}In this code, the SlidingBox composable uses an InfiniteTransition to continuously animate the offset of a small 100x100 dp Box. The key part of the code is the use of the offset() modifier to achieve this effect.The result is the following animation:This works, but if we take a closer look in the Layout Inspector, we’ll see that it’s definitely not the most efficient way to create such animation:Notice that number? That’s not good. You see, in the offset(offset * progress.value) call, we’re reading the progress state during the composition phase. Since Compose tracks state reads for each phase, it invalidates and recomposes the entire SlidingBox composable with every animation frame, leading to this huge recomposition count.However, if we think about it, the composition phase’s responsibility is to basically convert data into UI. When data changes, we recompose to reflect the new content. But in our case, the content itself has changed — only its offset.To optimize this, we should defer the state reading to the layout phase. To do that, let’s update our offset() modifier call to use the one with the lambda argument:@Preview@Composablefun SlidingBox() { // ... val offsetPx = with(LocalDensity.current) { 100.dp.toPx() } Box(...) { Box( modifier = Modifier .size(100.dp) // We now use the offset modifier with the lambda argument. .offset { IntOffset( x = (offsetPx * progress.value).roundToInt(), y = 0 ) } .background(AppColors.Pink, RoundedCornerShape(10.dp)) ) }}With this change, we achieve the same animation, but we now read the progress state’s value inside a lambda that’s executed during the layout phase. This means that whenever the state changes, only the layout (and potentially the drawing) phase needs to be re-executed.If we check the Layout Inspector now, we’ll see that we no longer recompose with each animation frame. That’s a significant improvement compared to before.Up until now, we haven’t used any drawing modifiers, so let’s change that with one final example:@Preview@Composablefun ColoredBox() { val infiniteTransition = rememberInfiniteTransition(label = \"infiniteTransition\") val color = infiniteTransition.animateColor( label = \"color\", initialValue = AppColors.Pink, targetValue = AppColors.Purple, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 1_000, easing = EaseInOut ), repeatMode = RepeatMode.Reverse ) ) Box( contentAlignment = Alignment.Center, modifier = Modifier .fillMaxSize() .background(AppColors.DarkBlue) ) { Box( modifier = Modifier .size(100.dp) .background(color.value, RoundedCornerShape(10.dp)) ) }}In this snippet, we have code similar to the previous example, but this time we’re animating the color of the Box, not its offset.When we run this code, we’ll see the following animation:However, we run into the same problem as before: a high recomposition count. And once again, the content itself hasn’t changed, in fact, neither the size nor the placement has changed either, only a single graphics property — the color.To optimize this, we’ll apply the same technique we used earlier by deferring the color state read to the drawing phase. To do this, we’ll use the drawBehind() drawing modifier:@Preview@Composablefun ColoredBox() { // ... val color = infiniteTransition.animateColor(...) Box(...) { Box( modifier = Modifier .size(100.dp) .drawBehind { drawRoundRect( color = color.value, cornerRadius = CornerRadius(10.dp.toPx()) ) } ) }}With this change, we’re now reading the color state in the drawing phase, which means that whenever the state changes, only the drawing phase is re-executed. Cool!Now, with that in mind, let’s jump into creating the loading animation.Creating the loading animationThere are two main components involved in drawing this loading animation:The content we’re animating in and revealing — in this example, a simple text that says: “Loading\\nPlease\\nWait.”The shape that acts as a mask, drawn on top of the content to create the reveal effect.The following image illustrates this (no masking applied):Creating the Animation ContentSo, let’s start by creating the content:@Composableprivate fun Content(modifier: Modifier = Modifier) { Text( text = \"Loading\\nPlease\\nWait.\", modifier = modifier, fontSize = 100.sp, lineHeight = 90.sp, fontWeight = FontWeight.Black, color = MaterialTheme.colorScheme.surfaceContainer // 0xFF11112A )}As you can see, it’s a simple Text composable with a large font size and a default color.Creating the Animation Screen and Control UINow let’s create the screen where we’ll show our animation and add some driver code to control the animation, allowing us to play, pause, and reset it:@Composablefun LoadingAnimation() { val coroutineScope = rememberCoroutineScope() val progressAnimation = remember { Animatable(0f) } val forwardAnimationSpec = remember { tween\u003cFloat\u003e( durationMillis = 10_000, easing = LinearEasing ) } val resetAnimationSpec = remember { tween\u003cFloat\u003e( durationMillis = 1_000, easing = EaseInSine ) } fun reset() { coroutineScope.launch { progressAnimation.stop() progressAnimation.animateTo(0f, resetAnimationSpec) } } fun togglePlay() { coroutineScope.launch { if (progressAnimation.isRunning) { progressAnimation.stop() } else { if (progressAnimation.value == 1f) { progressAnimation.snapTo(0f) } progressAnimation.animateTo(1f, forwardAnimationSpec) } } } Box( modifier = Modifier .fillMaxSize() .background(MaterialTheme.colorScheme.background) ) { CompositionLocalProvider( LocalContentColor provides MaterialTheme.colorScheme.onBackground ) { Content( modifier = Modifier .align(Alignment.Center) // This is the most important part, which we will create next. .loadingRevealAnimation( progress = progressAnimation.asState() ) ) Row( horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier .padding(24.dp) .safeContentPadding() .align(Alignment.BottomCenter) ) { FilledIconButton(onClick = ::reset) { Icon( painter = painterResource(R.drawable.ic_skip_back), contentDescription = \"Reset\" ) } Button(onClick = ::togglePlay) { AnimatedContent( label = \"playPauseButton\", targetState = progressAnimation.isRunning ) { val icon = if (it) R.drawable.ic_pause else R.drawable.ic_play Icon( painter = painterResource(icon), contentDescription = \"Play\" ) } Text(\"Play\") } } } }}That might look like a lot of code, but it’s pretty straightforward. Here’s a breakdown of what’s going on:We create an Animatable object (progressAnimation) that serves as the main driver of our animation, controlling the animation's progress.The forwardAnimationSpec and resetAnimationSpec are both TweenSpecs that define the duration and easing of our animation. The forwardAnimationSpec is used when the animation is playing forward, running for 10 seconds with LinearEasing. The resetAnimationSpec is used when we reset the animation, and it’s pretty quick, just runs for 1 second with an EaseInSine easing.Next, we define two functions: togglePlay and reset. The togglePlay function toggles the animation between playing and pausing. The reset function resets the animation back to the beginning by stopping any ongoing animation and then setting the progress back to 0f.Both functions manipulate the Animatable object by calling a combination of stop(), animateTo(), and snapTo(), passing the appropriate TweenSpec.Finally, we set up our UI by creating a Box that contains our Content composable and two buttons in a Row. The first button resets the animation, and the second button toggles between playing and pausing the animation.The key part of the animation is the loadingRevealAnimation() modifier we apply to the Content composable. We’ll implement that next.Here’s the result of the above code:Creating the Mask and Reveal EffectTo create the reveal effect, we draw a custom shape with a gradient that acts as a mask over the content. This mask defines which parts of the content will be drawn with the gradient. Wherever the mask and the content overlap, the content is drawn using that gradient, while the areas outside the mask are drawn using their original color. Then by animating the mask, we gradually reveal more of the content over time. This is exactly what the loadingRevealAnimation() modifier does:private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e): Modifier = this .drawWithCache { onDrawWithContent { drawContent() drawRect( brush = Gradient, size = size.copy(width = size.width * progress.value) ) } }private val Gradient = Brush.linearGradient( colorStops = arrayOf( 0.0f to AppColors.Pink, 0.4f to AppColors.Purple, 0.7f to AppColors.LightOrange, 1.0f to AppColors.Yellow ))In this code, we create a modifier factory called loadingRevealAnimation() that uses Compose's drawWithContent(). We first call drawContent(), which is important because it draws the composable’s content. Then, we draw a rectangle over that content using drawRect(). We then animate the width of this rectangle by multiplying the total width by progress, which is the state we pass into the modifier. This gives us the following animation:We’re getting there. Now, to achieve the desired reveal effect, we need to implement masking by telling Compose to draw the rectangle only where it overlaps the content. We can do this by applying a blend mode — specifically, the SrcAtop blend mode.private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e): Modifier = this .drawWithContent { drawContent() drawRect( brush = Gradient, // We added the SrcAtop blend mode. blendMode = BlendMode.SrcAtop, size = size.copy(width = size.width * progress.value) ) }This would actually give us the same result as before. So, to actually see the magic of the custom blend mode, this is where the graphicsLayer() modifier comes into play. You see, for the custom blend mode to work, we need to set something called a CompositingStrategy—specifically, CompositingStrategy.Offscreen. Let's check the documentation for CompositingStrategy.Offscreen:Rendering of content will always be rendered into an offscreen buffer first then drawn to the destination regardless of the other parameters configured on the graphics layer. This is useful for leveraging different blending algorithms for masking content.For example, the contents can be drawn into this graphics layer and masked out by drawing additional shapes with [BlendMode.Clear]This is exactly what we need. Let’s add that:private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e): Modifier = this // We added this graphicsLayer() modifier call along with the compositingStrategy. .graphicsLayer( compositingStrategy = CompositingStrategy.Offscreen ) .drawWithContent { drawContent() drawRect( brush = Gradient, blendMode = BlendMode.SrcAtop, size = size.copy(width = size.width * progress.value) ) }Now, if we run this code, we’d get exactly what we’re looking for:Now, let’s take it a step further and use a custom shape instead of the simple rectangle we’re using. I decided to use a rectangle with one edge having an animated sine-ish wave pattern, like so:To draw the wave, we will use a custom path with some Bézier curves, which would allow us to mimic the smooth, flowing shape of a sine wave. We will also need to know three things: the wave count, the wavelength, and the amplitude:The wavelength and amplitude of a sine waveAdditionally, we will introduce an offset on the y-axis to animate the wave downward.So, let’s modify our loadingRevealAnimation() modifier to accept these arguments (the wavelength will be calculated dynamically later on):private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e, yOffset: State\u003cFloat\u003e, wavesCount: Int = 2, amplitudeProvider: (totalSize: Size) -\u003e Float = { it.minDimension * 0.1f}): ModifierThe amplitudeProvider lambda takes the total canvas size and returns the value for the amplitude. By default, we use 10% of the minimum dimension of the canvas size.Next, we’ll use the drawWithCache() modifier along with onDrawWithContent to draw our wave path. The drawWithCache modifier allows us to cache the Path object, avoiding unnecessary reallocations:private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e, yOffset: State\u003cFloat\u003e, wavesCount: Int = 2, amplitudeProvider: (totalSize: Size) -\u003e Float = { it.minDimension * 0.1f}): Modifier = this .graphicsLayer( compositingStrategy = CompositingStrategy.Offscreen ) .drawWithCache { val height = size.height val waveLength = height / wavesCount val nextPointOffset = waveLength / 2f val controlPointOffset = nextPointOffset / 2f val amplitude = amplitudeProvider(size) val wavePath = Path() onDrawWithContent { // We'll construct the wave path next. ... drawPath( path = wavePath, brush = Gradient, blendMode = BlendMode.SrcAtop ) } }Here we calculate the waveLength based on the height and the wavesCount. We also create a Path instance (wavePath). Finally, both nextPointOffset and controlPointOffset will be used to add Bézier curves to the path, which we'll implement next:...onDrawWithContent { drawContent() val wavesStartX = (size.width + 2 * amplitude) * progress.value - amplitude wavePath.reset() wavePath.relativeLineTo(wavesStartX, -waveLength) wavePath.relativeLineTo(0f, waveLength * yOffset.value) repeat((wavesCount + 1) * 2) { i -\u003e val direction = if (i and 1 == 0) -1 else 1 wavePath.relativeQuadraticBezierTo( dx1 = direction * amplitude, dy1 = controlPointOffset, dx2 = 0f, dy2 = nextPointOffset ) } wavePath.lineTo(0f, height) wavePath.close() drawPath( path = wavePath, brush = Gradient, blendMode = BlendMode.SrcAtop )}Here’s a breakdown of what this code does:We start by calling drawContent(). Without this, the composable’s original content would not be drawn.Next, we calculate the wave’s starting coordinate on the x-axis (wavesStartX). Notice that we multiply the width by progress to animate the width of the rectangle as the animation progresses. Additionally, we add 2 * amplitude to ensure the waves extend outside the bounds when progress is 1. Finally, we subtract amplitude to make the waves start outside the bounds when progress is 0.Then we start constructing the wave by first moving (using relativeLineTo) the starting point to (wavesStartX, -waveLength). We’ll explain why we use -waveLength later on.After setting the starting point, we use relativeLineTo() again to shift the starting point based on the animated yOffset. This creates the effect of the wave moving downward as the animation progresses.We then loop (wavesCount + 1) * 2 times and in each iteration, we add a quadratic Bézier curve to the path using the controlPointOffset and nextPointOffset values that we calculated earlier. This creates the sine wave pattern.Once the waves are added to the path, we use lineTo() to move the path to the end position, and then we close the path.Finally, we draw the wavePath on the canvas using the gradient and the SrcAtop blend mode.To reason why we start the wave path at -waveLength is to take advantage of the periodic nature of the sine wave. By starting the wave one cycle before the bounds of the canvas and extending it one cycle beyond the bounds of the canvas, we create the illusion of an infinitely moving downward wave.The following GIF illustrates this:So, if we clip the drawing area to the red rectangle, we get the effect we’re looking for:To sum up, here’s the full implementation of the loadingRevealAnimation() modifier:private fun Modifier.loadingRevealAnimation( progress: State\u003cFloat\u003e, yOffset: State\u003cFloat\u003e, wavesCount: Int = 2, amplitudeProvider: (totalSize: Size) -\u003e Float = { it.minDimension * 0.1f }): Modifier = this .graphicsLayer( compositingStrategy = CompositingStrategy.Offscreen ) .drawWithCache { val height = size.height val waveLength = height / wavesCount val nextPointOffset = waveLength / 2f val controlPointOffset = nextPointOffset / 2f val amplitude = amplitudeProvider(size) val wavePath = Path() onDrawWithContent { drawContent() val wavesStartX = (size.width + 2 * amplitude) * progress.value - amplitude wavePath.reset() wavePath.relativeLineTo(wavesStartX, -waveLength) wavePath.relativeLineTo(0f, waveLength * yOffset.value) repeat((wavesCount + 1) * 2) { i -\u003e val direction = if (i and 1 == 0) -1 else 1 wavePath.relativeQuadraticBezierTo( dx1 = direction * amplitude, dy1 = controlPointOffset, dx2 = 0f, dy2 = nextPointOffset ) } wavePath.lineTo(0f, height) wavePath.close() drawPath( path = wavePath, brush = Gradient, blendMode = BlendMode.SrcAtop ) } }And with that, our loading animation is ready.Thank you for reading! I hope this article has been helpful. If you have any questions or suggestions, feel free to share them in the comments below.Happy coding!If you enjoyed this article, consider giving it a clap (or 50 😉) and follow me for more content on Android development. See you!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*KALhC6r9lo-8E_M7QGVvhw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@omarsahl?source=post_page-----138d3496c624--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Omar Sahl\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*TB_nVStV_doFD3tJYIwjsA@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----138d3496c624--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"eace\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/animation/choose-api\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose’s animation API\u003c/a\u003e is both powerful and enjoyable to work with. And when combined with the \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#graphics-modifiers\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egraphicsLayer()\u003c/a\u003e\u003c/code\u003e and drawing modifiers, it really open up possibilities for creating some really cool animations. In this article, we\u0026#39;ll dive into exactly that by exploring how to create the following loading animation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"086a\"\u003eLet’s get started.\u003c/p\u003e\u003ch2 id=\"0aa0\"\u003eWhy use the drawing modifiers for animations?\u003c/h2\u003e\u003cp id=\"5112\"\u003eBefore we look at how to create that loading animation, let’s first talk about why the \u003ca href=\"https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#drawing-modifiers\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edrawing modifiers\u003c/a\u003e are particularly useful for animations.\u003c/p\u003e\u003cp id=\"0e7e\"\u003eTo answer this question, let’s quickly go over \u003ca href=\"https://developer.android.com/develop/ui/compose/phases\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCompose’s three main phases\u003c/a\u003e for rendering a frame: Composition, Layout, and Drawing.\u003c/p\u003e\u003cp id=\"def5\"\u003eIf you are already familiar with that, feel free to skip this section and jump directly to the animation implementation section below.\u003c/p\u003e\u003cp id=\"d4d7\"\u003eLet’s examine a simple composable example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4488\"\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun SlidingBox() {\u003cbr/\u003e    val infiniteTransition = rememberInfiniteTransition(label = \u0026#34;infiniteTransition\u0026#34;)\u003cbr/\u003e    val progress = infiniteTransition.animateFloat(\u003cbr/\u003e        label = \u0026#34;offset\u0026#34;,\u003cbr/\u003e        initialValue = -1f,\u003cbr/\u003e        targetValue = 1f,\u003cbr/\u003e        animationSpec = infiniteRepeatable(\u003cbr/\u003e            animation = tween(\u003cbr/\u003e                durationMillis = 1_000,\u003cbr/\u003e                easing = EaseInOut\u003cbr/\u003e            ),\u003cbr/\u003e            repeatMode = RepeatMode.Reverse\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e    val offset = 100.dp\u003cp\u003e    Box(\u003cbr/\u003e        contentAlignment = Alignment.Center,\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(AppColors.DarkBlue)\u003cbr/\u003e    ) {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(100.dp)\u003cbr/\u003e                .offset(offset * progress.value)\u003cbr/\u003e                .background(AppColors.Pink, RoundedCornerShape(10.dp))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"793f\"\u003eIn this code, the \u003ccode\u003eSlidingBox\u003c/code\u003e composable uses an \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/InfiniteTransition\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInfiniteTransition\u003c/a\u003e\u003c/code\u003e to continuously animate the offset of a small 100x100 dp \u003ccode\u003eBox\u003c/code\u003e. The key part of the code is the use of the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoffset()\u003c/a\u003e\u003c/code\u003e modifier to achieve this effect.\u003c/p\u003e\u003cp id=\"5b66\"\u003eThe result is the following animation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"016d\"\u003eThis works, but if we take a closer look in the \u003ca href=\"https://developer.android.com/studio/debug/layout-inspector\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLayout Inspector\u003c/a\u003e, we’ll see that it’s definitely not the most efficient way to create such animation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a028\"\u003eNotice that number? That’s not good. You see, in the \u003ccode\u003eoffset(offset * progress.value)\u003c/code\u003e call, we’re reading the \u003ccode\u003eprogress\u003c/code\u003e state during the composition phase. Since Compose tracks state reads for each phase, it invalidates and recomposes the entire \u003ccode\u003eSlidingBox\u003c/code\u003e composable with every animation frame, leading to this huge recomposition count.\u003c/p\u003e\u003cp id=\"b037\"\u003eHowever, if we think about it, the composition phase’s responsibility is to basically convert data into UI. When data changes, we recompose to reflect the new content. But in our case, the content itself has changed — only its offset.\u003c/p\u003e\u003cp id=\"2d54\"\u003eTo optimize this, we should defer the state reading to the layout phase. To do that, let’s update our \u003ccode\u003eoffset()\u003c/code\u003e modifier call to use \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).offset(kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe one with the lambda argument\u003c/a\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"84c5\"\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun SlidingBox() {\u003cbr/\u003e    // ...\u003cbr/\u003e    val offsetPx = with(LocalDensity.current) {\u003cbr/\u003e        100.dp.toPx()\u003cbr/\u003e    }\u003cp\u003e    Box(...) {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(100.dp)\u003cbr/\u003e                // We now use the offset modifier with the lambda argument.\u003cbr/\u003e                .offset {\u003cbr/\u003e                    IntOffset(\u003cbr/\u003e                        x = (offsetPx * progress.value).roundToInt(),\u003cbr/\u003e                        y = 0\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e                .background(AppColors.Pink, RoundedCornerShape(10.dp))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"87bc\"\u003eWith this change, we achieve the same animation, but we now read the \u003ccode\u003eprogress\u003c/code\u003e state’s value inside a lambda that’s executed during the layout phase. This means that whenever the state changes, only the layout (and potentially the drawing) phase needs to be re-executed.\u003c/p\u003e\u003cp id=\"965f\"\u003eIf we check the Layout Inspector now, we’ll see that we no longer recompose with each animation frame. That’s a significant improvement compared to before.\u003c/p\u003e\u003cp id=\"b6e4\"\u003eUp until now, we haven’t used any drawing modifiers, so let’s change that with one final example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2a98\"\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun ColoredBox() {\u003cbr/\u003e    val infiniteTransition = rememberInfiniteTransition(label = \u0026#34;infiniteTransition\u0026#34;)\u003cbr/\u003e    val color = infiniteTransition.animateColor(\u003cbr/\u003e        label = \u0026#34;color\u0026#34;,\u003cbr/\u003e        initialValue = AppColors.Pink,\u003cbr/\u003e        targetValue = AppColors.Purple,\u003cbr/\u003e        animationSpec = infiniteRepeatable(\u003cbr/\u003e            animation = tween(\u003cbr/\u003e                durationMillis = 1_000,\u003cbr/\u003e                easing = EaseInOut\u003cbr/\u003e            ),\u003cbr/\u003e            repeatMode = RepeatMode.Reverse\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cp\u003e    Box(\u003cbr/\u003e        contentAlignment = Alignment.Center,\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(AppColors.DarkBlue)\u003cbr/\u003e    ) {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(100.dp)\u003cbr/\u003e                .background(color.value, RoundedCornerShape(10.dp))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4634\"\u003eIn this snippet, we have code similar to the previous example, but this time we’re animating the color of the \u003ccode\u003eBox\u003c/code\u003e, not its offset.\u003c/p\u003e\u003cp id=\"738d\"\u003eWhen we run this code, we’ll see the following animation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d1e2\"\u003eHowever, we run into the same problem as before: a high recomposition count. And once again, the content itself hasn’t changed, in fact, neither the size nor the placement has changed either, only a single graphics property — the color.\u003c/p\u003e\u003cp id=\"5164\"\u003eTo optimize this, we’ll apply the same technique we used earlier by deferring the \u003ccode\u003ecolor\u003c/code\u003e state read to the drawing phase. To do this, we’ll use the \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#drawbehind\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edrawBehind()\u003c/a\u003e\u003c/code\u003e drawing modifier:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e4a6\"\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun ColoredBox() {\u003cbr/\u003e    // ...\u003cbr/\u003e    val color = infiniteTransition.animateColor(...)\u003cp\u003e    Box(...) {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(100.dp)\u003cbr/\u003e                .drawBehind {\u003cbr/\u003e                    drawRoundRect(\u003cbr/\u003e                        color = color.value,\u003cbr/\u003e                        cornerRadius = CornerRadius(10.dp.toPx())\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a95e\"\u003eWith this change, we’re now reading the \u003ccode\u003ecolor\u003c/code\u003e state in the drawing phase, which means that whenever the state changes, only the drawing phase is re-executed. Cool!\u003c/p\u003e\u003cp id=\"3395\"\u003eNow, with that in mind, let’s jump into creating the loading animation.\u003c/p\u003e\u003ch2 id=\"0111\"\u003eCreating the loading animation\u003c/h2\u003e\u003cp id=\"6c96\"\u003eThere are two main components involved in drawing this loading animation:\u003c/p\u003e\u003cul\u003e\u003cli id=\"13db\"\u003eThe content we’re animating in and revealing — in this example, a simple text that says: \u003ccode\u003e“Loading\\nPlease\\nWait.”\u003c/code\u003e\u003c/li\u003e\u003cli id=\"62dd\"\u003eThe shape that acts as a mask, drawn on top of the content to create the reveal effect.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e8ef\"\u003eThe following image illustrates this (no masking applied):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3099\"\u003eCreating the Animation Content\u003c/h2\u003e\u003cp id=\"26e6\"\u003eSo, let’s start by creating the content:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dabb\"\u003e@Composable\u003cbr/\u003eprivate fun Content(modifier: Modifier = Modifier) {\u003cbr/\u003e    Text(\u003cbr/\u003e        text = \u0026#34;Loading\\nPlease\\nWait.\u0026#34;,\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        fontSize = 100.sp,\u003cbr/\u003e        lineHeight = 90.sp,\u003cbr/\u003e        fontWeight = FontWeight.Black,\u003cbr/\u003e        color = MaterialTheme.colorScheme.surfaceContainer // 0xFF11112A\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7be2\"\u003eAs you can see, it’s a simple \u003ccode\u003eText\u003c/code\u003e composable with a large font size and a default color.\u003c/p\u003e\u003ch2 id=\"3aad\"\u003eCreating the Animation Screen and Control UI\u003c/h2\u003e\u003cp id=\"58aa\"\u003eNow let’s create the screen where we’ll show our animation and add some driver code to control the animation, allowing us to play, pause, and reset it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a738\"\u003e\u003cbr/\u003e@Composable\u003cbr/\u003efun LoadingAnimation() {\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    val progressAnimation = remember { Animatable(0f) }\u003cbr/\u003e    val forwardAnimationSpec = remember {\u003cbr/\u003e        tween\u0026lt;Float\u0026gt;(\u003cbr/\u003e            durationMillis = 10_000,\u003cbr/\u003e            easing = LinearEasing\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e    val resetAnimationSpec = remember {\u003cbr/\u003e        tween\u0026lt;Float\u0026gt;(\u003cbr/\u003e            durationMillis = 1_000,\u003cbr/\u003e            easing = EaseInSine\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cp\u003e    fun reset() {\u003cbr/\u003e        coroutineScope.launch {\u003cbr/\u003e            progressAnimation.stop()\u003cbr/\u003e            progressAnimation.animateTo(0f, resetAnimationSpec)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun togglePlay() {\u003cbr/\u003e        coroutineScope.launch {\u003cbr/\u003e            if (progressAnimation.isRunning) {\u003cbr/\u003e                progressAnimation.stop()\u003cbr/\u003e            } else {\u003cbr/\u003e                if (progressAnimation.value == 1f) {\u003cbr/\u003e                    progressAnimation.snapTo(0f)\u003cbr/\u003e                }\u003cbr/\u003e                progressAnimation.animateTo(1f, forwardAnimationSpec)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e            .background(MaterialTheme.colorScheme.background)\u003cbr/\u003e    ) {\u003cbr/\u003e        CompositionLocalProvider(\u003cbr/\u003e            LocalContentColor provides MaterialTheme.colorScheme.onBackground\u003cbr/\u003e        ) {\u003cbr/\u003e            Content(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .align(Alignment.Center)\u003cbr/\u003e                    // This is the most important part, which we will create next.\u003cbr/\u003e                    .loadingRevealAnimation(\u003cbr/\u003e                        progress = progressAnimation.asState()\u003cbr/\u003e                    )\u003cbr/\u003e            )\u003c/p\u003e\u003cp\u003e            Row(\u003cbr/\u003e                horizontalArrangement = Arrangement.spacedBy(8.dp),\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .padding(24.dp)\u003cbr/\u003e                    .safeContentPadding()\u003cbr/\u003e                    .align(Alignment.BottomCenter)\u003cbr/\u003e            ) {\u003cbr/\u003e                FilledIconButton(onClick = ::reset) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        painter = painterResource(R.drawable.ic_skip_back),\u003cbr/\u003e                        contentDescription = \u0026#34;Reset\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e                Button(onClick = ::togglePlay) {\u003cbr/\u003e                    AnimatedContent(\u003cbr/\u003e                        label = \u0026#34;playPauseButton\u0026#34;,\u003cbr/\u003e                        targetState = progressAnimation.isRunning\u003cbr/\u003e                    ) {\u003cbr/\u003e                        val icon = if (it) R.drawable.ic_pause else R.drawable.ic_play\u003cbr/\u003e                        Icon(\u003cbr/\u003e                            painter = painterResource(icon),\u003cbr/\u003e                            contentDescription = \u0026#34;Play\u0026#34;\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                    Text(\u0026#34;Play\u0026#34;)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"615f\"\u003eThat might look like a lot of code, but it’s pretty straightforward. Here’s a breakdown of what’s going on:\u003c/p\u003e\u003cul\u003e\u003cli id=\"809a\"\u003eWe create an \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnimatable\u003c/a\u003e\u003c/code\u003e object (\u003ccode\u003eprogressAnimation\u003c/code\u003e) that serves as the main driver of our animation, controlling the animation\u0026#39;s progress.\u003c/li\u003e\u003cli id=\"a9e4\"\u003eThe \u003ccode\u003eforwardAnimationSpec\u003c/code\u003e and \u003ccode\u003eresetAnimationSpec\u003c/code\u003e are both \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/TweenSpec\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTweenSpec\u003c/a\u003e\u003c/code\u003es that define the duration and easing of our animation. The \u003ccode\u003eforwardAnimationSpec\u003c/code\u003e is used when the animation is playing forward, running for 10 seconds with \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#LinearEasing()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinearEasing\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003eresetAnimationSpec\u003c/code\u003e is used when we reset the animation, and it’s pretty quick, just runs for 1 second with an \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#EaseInSine()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEaseInSine\u003c/a\u003e\u003c/code\u003e easing.\u003c/li\u003e\u003cli id=\"b7dd\"\u003eNext, we define two functions: \u003ccode\u003etogglePlay\u003c/code\u003e and \u003ccode\u003ereset\u003c/code\u003e. The \u003ccode\u003etogglePlay\u003c/code\u003e function toggles the animation between playing and pausing. The \u003ccode\u003ereset\u003c/code\u003e function resets the animation back to the beginning by stopping any ongoing animation and then setting the progress back to \u003ccode\u003e0f\u003c/code\u003e.\u003cbr/\u003eBoth functions manipulate the \u003ccode\u003eAnimatable\u003c/code\u003e object by calling a combination of \u003ccode\u003estop()\u003c/code\u003e, \u003ccode\u003eanimateTo()\u003c/code\u003e, and \u003ccode\u003esnapTo()\u003c/code\u003e, passing the appropriate \u003ccode\u003eTweenSpec\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"80be\"\u003eFinally, we set up our UI by creating a \u003ccode\u003eBox\u003c/code\u003e that contains our \u003ccode\u003eContent\u003c/code\u003e composable and two buttons in a \u003ccode\u003eRow\u003c/code\u003e. The first button resets the animation, and the second button toggles between playing and pausing the animation.\u003c/li\u003e\u003cli id=\"0acf\"\u003e\u003cstrong\u003eThe key part of the animation is the \u003c/strong\u003e\u003ccode\u003eloadingRevealAnimation()\u003c/code\u003e\u003cstrong\u003e modifier we apply to the \u003c/strong\u003e\u003ccode\u003eContent\u003c/code\u003e\u003cstrong\u003e composable\u003c/strong\u003e. We’ll implement that next.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f1ec\"\u003eHere’s the result of the above code:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"67f4\"\u003eCreating the Mask and Reveal Effect\u003c/h2\u003e\u003cp id=\"1cdd\"\u003eTo create the reveal effect, we draw a custom shape with a gradient that acts as a mask over the content. This mask defines which parts of the content will be drawn with the gradient. Wherever the mask and the content overlap, the content is drawn using that gradient, while the areas outside the mask are drawn using their original color. Then by animating the mask, we gradually reveal more of the content over time. This is exactly what the \u003ccode\u003eloadingRevealAnimation()\u003c/code\u003e modifier does:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2ebc\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;\u003cbr/\u003e): Modifier = this\u003cbr/\u003e    .drawWithCache {\u003cbr/\u003e        onDrawWithContent {\u003cbr/\u003e            drawContent()\u003cbr/\u003e            drawRect(\u003cbr/\u003e                brush = Gradient,\u003cbr/\u003e                size = size.copy(width = size.width * progress.value)\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cp\u003eprivate val Gradient = Brush.linearGradient(\u003cbr/\u003e    colorStops = arrayOf(\u003cbr/\u003e        0.0f to AppColors.Pink,\u003cbr/\u003e        0.4f to AppColors.Purple,\u003cbr/\u003e        0.7f to AppColors.LightOrange,\u003cbr/\u003e        1.0f to AppColors.Yellow\u003cbr/\u003e    )\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e22c\"\u003eIn this code, we create a \u003ca href=\"https://developer.android.com/develop/ui/compose/custom-modifiers#chain-existing\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emodifier factory\u003c/a\u003e called \u003ccode\u003eloadingRevealAnimation()\u003c/code\u003e that uses Compose\u0026#39;s \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#drawwithcontent\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edrawWithContent()\u003c/a\u003e\u003c/code\u003e. We first call \u003ccode\u003edrawContent()\u003c/code\u003e, which is important because it draws the composable’s content. Then, we draw a rectangle over that content using \u003ccode\u003edrawRect()\u003c/code\u003e. We then animate the width of this rectangle by multiplying the total width by \u003ccode\u003eprogress\u003c/code\u003e, which is the state we pass into the modifier. This gives us the following animation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e805\"\u003eWe’re getting there. Now, to achieve the desired reveal effect, we need to implement masking by telling Compose to draw the rectangle only where it overlaps the content. We can do this by applying a blend mode — specifically, the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/BlendMode\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSrcAtop\u003c/a\u003e\u003c/code\u003e blend mode.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8cc8\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;\u003cbr/\u003e): Modifier = this\u003cbr/\u003e    .drawWithContent {\u003cbr/\u003e        drawContent()\u003cbr/\u003e        drawRect(\u003cbr/\u003e            brush = Gradient,\u003cbr/\u003e            // We added the SrcAtop blend mode.\u003cbr/\u003e            blendMode = BlendMode.SrcAtop,\u003cbr/\u003e            size = size.copy(width = size.width * progress.value)\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"326a\"\u003eThis would actually give us the same result as before. So, to actually see the magic of the custom blend mode, this is where the \u003ccode\u003egraphicsLayer()\u003c/code\u003e modifier comes into play. You see, for the custom blend mode to work, we need to set something called a \u003ccode\u003eCompositingStrategy\u003c/code\u003e—specifically, \u003ccode\u003eCompositingStrategy.Offscreen\u003c/code\u003e. Let\u0026#39;s check the documentation for \u003ccode\u003eCompositingStrategy.Offscreen\u003c/code\u003e:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"5f5d\"\u003eRendering of content will always be rendered into an offscreen buffer first then drawn to the destination regardless of the other parameters configured on the graphics layer. \u003cstrong\u003eThis is useful for leveraging different blending algorithms for masking content\u003c/strong\u003e.\u003cbr/\u003eFor example, the contents can be drawn into this graphics layer and masked out by drawing additional shapes with [BlendMode.Clear]\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"2d7a\"\u003eThis is exactly what we need. Let’s add that:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b4c2\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;\u003cbr/\u003e): Modifier = this\u003cbr/\u003e    // We added this graphicsLayer() modifier call along with the compositingStrategy.\u003cbr/\u003e    .graphicsLayer(\u003cbr/\u003e        compositingStrategy = CompositingStrategy.Offscreen\u003cbr/\u003e    )\u003cbr/\u003e    .drawWithContent {\u003cbr/\u003e        drawContent()\u003cbr/\u003e        drawRect(\u003cbr/\u003e            brush = Gradient,\u003cbr/\u003e            blendMode = BlendMode.SrcAtop,\u003cbr/\u003e            size = size.copy(width = size.width * progress.value)\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0421\"\u003eNow, if we run this code, we’d get exactly what we’re looking for:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"52aa\"\u003eNow, let’s take it a step further and use a custom shape instead of the simple rectangle we’re using. I decided to use a rectangle with one edge having an animated sine-ish wave pattern, like so:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4377\"\u003eTo draw the wave, we will use a custom path with some \u003ca href=\"https://en.wikipedia.org/wiki/B%C3%A9zier_curve\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBézier curves\u003c/a\u003e, which would allow us to mimic the smooth, flowing shape of a sine wave. We will also need to know three things: the \u003cstrong\u003ewave count\u003c/strong\u003e, the \u003cstrong\u003ewavelength\u003c/strong\u003e, and the \u003cstrong\u003eamplitude\u003c/strong\u003e:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe wavelength and amplitude of a sine wave\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"782b\"\u003eAdditionally, we will introduce an offset on the y-axis to animate the wave downward.\u003c/p\u003e\u003cp id=\"118f\"\u003eSo, let’s modify our \u003ccode\u003eloadingRevealAnimation()\u003c/code\u003e modifier to accept these arguments (the wavelength will be calculated dynamically later on):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"519f\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    yOffset: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    wavesCount: Int = 2,\u003cbr/\u003e    amplitudeProvider: (totalSize: Size) -\u0026gt; Float = { it.minDimension * 0.1f}\u003cbr/\u003e): Modifier\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4e2a\"\u003eThe \u003ccode\u003eamplitudeProvider\u003c/code\u003e lambda takes the total canvas size and returns the value for the amplitude. By default, we use 10% of the minimum dimension of the canvas size.\u003c/p\u003e\u003cp id=\"b773\"\u003eNext, we’ll use the \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/graphics/draw/modifiers#drawwithcache\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edrawWithCache()\u003c/a\u003e\u003c/code\u003e modifier along with \u003ccode\u003eonDrawWithContent\u003c/code\u003e to draw our wave path. The \u003ccode\u003edrawWithCache\u003c/code\u003e modifier allows us to cache the \u003ccode\u003ePath\u003c/code\u003e object, avoiding unnecessary reallocations:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3b83\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    yOffset: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    wavesCount: Int = 2,\u003cbr/\u003e    amplitudeProvider: (totalSize: Size) -\u0026gt; Float = { it.minDimension * 0.1f}\u003cbr/\u003e): Modifier = this\u003cbr/\u003e    .graphicsLayer(\u003cbr/\u003e        compositingStrategy = CompositingStrategy.Offscreen\u003cbr/\u003e    )\u003cbr/\u003e    .drawWithCache {\u003cbr/\u003e        val height = size.height\u003cbr/\u003e        val waveLength = height / wavesCount\u003cbr/\u003e        val nextPointOffset = waveLength / 2f\u003cbr/\u003e        val controlPointOffset = nextPointOffset / 2f\u003cbr/\u003e        val amplitude = amplitudeProvider(size)\u003cbr/\u003e        val wavePath = Path()\u003cp\u003e        onDrawWithContent {\u003cbr/\u003e            // We\u0026#39;ll construct the wave path next.\u003cbr/\u003e            ...\u003c/p\u003e\u003cp\u003e            drawPath(\u003cbr/\u003e                path = wavePath,\u003cbr/\u003e                brush = Gradient,\u003cbr/\u003e                blendMode = BlendMode.SrcAtop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"57af\"\u003eHere we calculate the \u003ccode\u003ewaveLength\u003c/code\u003e based on the height and the \u003ccode\u003ewavesCount\u003c/code\u003e. We also create a \u003ccode\u003ePath\u003c/code\u003e instance (\u003ccode\u003ewavePath\u003c/code\u003e). Finally, both \u003ccode\u003enextPointOffset\u003c/code\u003e and \u003ccode\u003econtrolPointOffset\u003c/code\u003e will be used to add Bézier curves to the path, which we\u0026#39;ll implement next:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b2fc\"\u003e...\u003cp\u003eonDrawWithContent {\u003cbr/\u003e    drawContent()\u003c/p\u003e\u003cp\u003e    val wavesStartX = (size.width + 2 * amplitude) * progress.value - amplitude\u003c/p\u003e\u003cp\u003e        wavePath.reset()\u003cbr/\u003e    wavePath.relativeLineTo(wavesStartX, -waveLength)\u003cbr/\u003e    wavePath.relativeLineTo(0f, waveLength * yOffset.value)\u003c/p\u003e\u003cp\u003e    repeat((wavesCount + 1) * 2) { i -\u0026gt;\u003cbr/\u003e        val direction = if (i and 1 == 0) -1 else 1\u003c/p\u003e\u003cp\u003e        wavePath.relativeQuadraticBezierTo(\u003cbr/\u003e            dx1 = direction * amplitude,\u003cbr/\u003e            dy1 = controlPointOffset,\u003cbr/\u003e            dx2 = 0f,\u003cbr/\u003e            dy2 = nextPointOffset\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    wavePath.lineTo(0f, height)\u003cbr/\u003e    wavePath.close()\u003c/p\u003e\u003cp\u003e    drawPath(\u003cbr/\u003e        path = wavePath,\u003cbr/\u003e        brush = Gradient,\u003cbr/\u003e        blendMode = BlendMode.SrcAtop\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fc75\"\u003eHere’s a breakdown of what this code does:\u003c/p\u003e\u003col\u003e\u003cli id=\"891c\"\u003eWe start by calling \u003ccode\u003edrawContent()\u003c/code\u003e. Without this, the composable’s original content would not be drawn.\u003c/li\u003e\u003cli id=\"b412\"\u003eNext, we calculate the wave’s starting coordinate on the x-axis (\u003ccode\u003ewavesStartX\u003c/code\u003e). Notice that we multiply the width by \u003ccode\u003eprogress\u003c/code\u003e to animate the width of the rectangle as the animation progresses. Additionally, we add \u003ccode\u003e2 * amplitude\u003c/code\u003e to ensure the waves extend outside the bounds when \u003ccode\u003eprogress\u003c/code\u003e is 1. Finally, we subtract \u003ccode\u003eamplitude\u003c/code\u003e to make the waves start outside the bounds when \u003ccode\u003eprogress\u003c/code\u003e is 0.\u003c/li\u003e\u003cli id=\"8a0c\"\u003eThen we start constructing the wave by first moving (using \u003ccode\u003erelativeLineTo\u003c/code\u003e) the starting point to \u003ccode\u003e(wavesStartX, -waveLength)\u003c/code\u003e. We’ll explain why we use \u003ccode\u003e-waveLength\u003c/code\u003e later on.\u003c/li\u003e\u003cli id=\"311b\"\u003eAfter setting the starting point, we use \u003ccode\u003erelativeLineTo()\u003c/code\u003e again to shift the starting point based on the animated \u003ccode\u003eyOffset\u003c/code\u003e. This creates the effect of the wave moving downward as the animation progresses.\u003c/li\u003e\u003cli id=\"44a9\"\u003eWe then loop \u003ccode\u003e(wavesCount + 1) * 2\u003c/code\u003e times and in each iteration, we add a quadratic Bézier curve to the path using the \u003ccode\u003econtrolPointOffset\u003c/code\u003e and \u003ccode\u003enextPointOffset\u003c/code\u003e values that we calculated earlier. This creates the sine wave pattern.\u003c/li\u003e\u003cli id=\"0e9b\"\u003eOnce the waves are added to the path, we use \u003ccode\u003elineTo()\u003c/code\u003e to move the path to the end position, and then we close the path.\u003c/li\u003e\u003cli id=\"320b\"\u003eFinally, we draw the \u003ccode\u003ewavePath\u003c/code\u003e on the canvas using the gradient and the \u003ccode\u003eSrcAtop\u003c/code\u003e blend mode.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"aa4f\"\u003eTo reason why we start the wave path at \u003ccode\u003e-waveLength\u003c/code\u003e is to take advantage of the periodic nature of the sine wave. By starting the wave one cycle before the bounds of the canvas and extending it one cycle beyond the bounds of the canvas, we create the illusion of an infinitely moving downward wave.\u003c/p\u003e\u003cp id=\"aa04\"\u003eThe following GIF illustrates this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"98d0\"\u003eSo, if we clip the drawing area to the red rectangle, we get the effect we’re looking for:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b65a\"\u003eTo sum up, here’s the full implementation of the \u003ccode\u003eloadingRevealAnimation()\u003c/code\u003e modifier:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1ae5\"\u003eprivate fun Modifier.loadingRevealAnimation(\u003cbr/\u003e    progress: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    yOffset: State\u0026lt;Float\u0026gt;,\u003cbr/\u003e    wavesCount: Int = 2,\u003cbr/\u003e    amplitudeProvider: (totalSize: Size) -\u0026gt; Float = { it.minDimension * 0.1f }\u003cbr/\u003e): Modifier = this\u003cbr/\u003e    .graphicsLayer(\u003cbr/\u003e        compositingStrategy = CompositingStrategy.Offscreen\u003cbr/\u003e    )\u003cbr/\u003e    .drawWithCache {\u003cbr/\u003e        val height = size.height\u003cbr/\u003e        val waveLength = height / wavesCount\u003cbr/\u003e        val nextPointOffset = waveLength / 2f\u003cbr/\u003e        val controlPointOffset = nextPointOffset / 2f\u003cbr/\u003e        val amplitude = amplitudeProvider(size)\u003cbr/\u003e        val wavePath = Path()\u003cp\u003e        onDrawWithContent {\u003cbr/\u003e            drawContent()\u003c/p\u003e\u003cp\u003e            val wavesStartX = (size.width + 2 * amplitude) * progress.value - amplitude\u003c/p\u003e\u003cp\u003e            wavePath.reset()\u003cbr/\u003e            wavePath.relativeLineTo(wavesStartX, -waveLength)\u003cbr/\u003e            wavePath.relativeLineTo(0f, waveLength * yOffset.value)\u003c/p\u003e\u003cp\u003e            repeat((wavesCount + 1) * 2) { i -\u0026gt;\u003cbr/\u003e                val direction = if (i and 1 == 0) -1 else 1\u003c/p\u003e\u003cp\u003e                wavePath.relativeQuadraticBezierTo(\u003cbr/\u003e                    dx1 = direction * amplitude,\u003cbr/\u003e                    dy1 = controlPointOffset,\u003cbr/\u003e                    dx2 = 0f,\u003cbr/\u003e                    dy2 = nextPointOffset\u003cbr/\u003e                )\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            wavePath.lineTo(0f, height)\u003cbr/\u003e            wavePath.close()\u003c/p\u003e\u003cp\u003e            drawPath(\u003cbr/\u003e                path = wavePath,\u003cbr/\u003e                brush = Gradient,\u003cbr/\u003e                blendMode = BlendMode.SrcAtop\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f4c1\"\u003eAnd with that, our loading animation is ready.\u003c/p\u003e\u003cp id=\"aa3b\"\u003eThank you for reading! I hope this article has been helpful. If you have any questions or suggestions, feel free to share them in the comments below.\u003c/p\u003e\u003cp id=\"e444\"\u003eHappy coding!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"db38\"\u003e\u003cem\u003eIf you enjoyed this article, consider giving it a clap (or 50 😉) and follow me for more content on Android development. See you!\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2024-09-22T21:08:50.503Z",
  "modifiedTime": null
}
