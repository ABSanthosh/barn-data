{
  "id": "af9ca421-18b0-4b56-975b-b6cab8fbd6eb",
  "title": "Common Android UseCase Pattern Mistakes",
  "link": "https://proandroiddev.com/common-android-usecase-pattern-mistakes-382b6d0e7c03?source=rss----c72404660798---4",
  "description": "",
  "author": "Hlayan Htet Aung",
  "published": "Mon, 23 Dec 2024 19:09:20 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "use-cases",
    "viewmodel",
    "domain-layer",
    "architecture"
  ],
  "byline": "Hlayan Htet Aung",
  "length": 4048,
  "excerpt": "A common bad practice I frequently encounter is the misuse of the UseCase pattern in Android development. While UseCases are commonly used in many applications, developers often implement them in…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo from Android DocumentationIntroductionA common bad practice I frequently encounter is the misuse of the UseCase pattern in Android development. While UseCases are commonly used in many applications, developers often implement them in ways that move away from their intended purpose.What are UseCases?UseCases are tools that help organize complex app logic into simple, reusable pieces. Think of them as containers that hold specific tasks or operations your app needs to perform. They follow a basic programming rule: each UseCase should do one thing and do it well.Here are the main benefits of using UseCases:Promotes code reusability across different parts of the applicationSeparates business logic from implementation details for better organizationImproves testability by isolating complex business operationsEnables modular architecture that’s easier to maintain and modifyCommon Implementation MistakesIn Android development, I’ve observed two common mistakes:Enforcing strict ViewModel-to-UseCase-only accessCreating one-to-one mappings between Repository methods and UseCases1. Strict ViewModel-to-UseCase AccessA common implementation pattern strictly enforces that ViewModels can only access UseCases, completely restricting direct repository access. While this approach is part of the Domain Layer pattern, Google’s Android team recommends keeping it optional. This decision should depend on your application’s specific requirements.This restriction often leads to an explosion of UseCase classes. For instance, if a Repository has 10 methods, you end up creating 10 corresponding UseCases. In scenarios where a ViewModel needs most of the repository’s functionality, injecting a single repository would be more efficient than injecting multiple UseCases.2. One-to-One Method MappingThe second mistake involves creating UseCases that simply proxy repository methods. For example, creating a GetUserUseCase that only calls and returns the repository’s getUser method. Sometimes, developers add a simple mapper but essentially maintain the same one-to-one relationship. In such cases, direct repository access from the ViewModel would be more appropriate.Proper UseCase ImplementationUse cases are specifically designed to handle complex business logic. Here’s an example of a well-implemented use case from Google’s Domain Layer documentation:/** * This use case fetches the latest news and the associated author. */class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default) { suspend operator fun invoke(): List\u003cArticleWithAuthor\u003e = withContext(defaultDispatcher) { val news = newsRepository.fetchLatestNews() val result: MutableList\u003cArticleWithAuthor\u003e = mutableListOf() // This is not parallelized, the use case is linearly slow. for (article in news) { // The repository exposes suspend functions val author = authorsRepository.getAuthor(article.authorId) result.add(ArticleWithAuthor(article, author)) } result }}This UseCase demonstrates proper implementation by combining data from multiple repositories and performing business logic to create a new model.Google’s RecommendationA good approach is to add use cases only when required. They should be used when there’s complex business logic that needs to be encapsulated, not as a mandatory layer between ViewModels and Repositories.ConclusionWhen implementing UseCases, focus on their primary purpose: encapsulating complex business logic. Avoid creating unnecessary abstractions and evaluate whether a UseCase is truly needed based on your specific use case. Remember that direct repository access is perfectly acceptable when there’s no complex business logic to encapsulate.For more detailed information about Google’s Domain Layer guidelines, check out their official guide on Domain Layer.",
  "image": "https://miro.medium.com/v2/resize:fit:480/0*l3ToxNuH3DKbBOVR.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@hlayan.kt?source=post_page---byline--382b6d0e7c03--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Hlayan Htet Aung\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*i3Ig31XxcYKPhNJyXczbPQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--382b6d0e7c03--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto from \u003ca href=\"https://developer.android.com/topic/architecture/domain-layer#data-access-restriction\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Documentation\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"6307\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"9da9\"\u003eA common bad practice I frequently encounter is the misuse of the UseCase pattern in Android development. While UseCases are commonly used in many applications, developers often implement them in ways that move away from their intended purpose.\u003c/p\u003e\u003ch2 id=\"12ad\"\u003eWhat are UseCases?\u003c/h2\u003e\u003cp id=\"3d93\"\u003eUseCases are tools that help organize complex app logic into simple, reusable pieces. Think of them as containers that hold specific tasks or operations your app needs to perform. They follow a basic programming rule: each UseCase should do one thing and do it well.\u003c/p\u003e\u003cp id=\"4688\"\u003eHere are the main benefits of using UseCases:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5458\"\u003ePromotes code reusability across different parts of the application\u003c/li\u003e\u003cli id=\"135b\"\u003eSeparates business logic from implementation details for better organization\u003c/li\u003e\u003cli id=\"8af4\"\u003eImproves testability by isolating complex business operations\u003c/li\u003e\u003cli id=\"4d17\"\u003eEnables modular architecture that’s easier to maintain and modify\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5cea\"\u003eCommon Implementation Mistakes\u003c/h2\u003e\u003cp id=\"3c80\"\u003eIn Android development, I’ve observed two common mistakes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c3e5\"\u003eEnforcing strict ViewModel-to-UseCase-only access\u003c/li\u003e\u003cli id=\"3ae6\"\u003eCreating one-to-one mappings between Repository methods and UseCases\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a8c3\"\u003e1. Strict ViewModel-to-UseCase Access\u003c/h2\u003e\u003cp id=\"ce00\"\u003eA common implementation pattern strictly enforces that ViewModels can only access UseCases, completely restricting direct repository access. While this approach is part of the Domain Layer pattern, Google’s Android team recommends keeping it optional. This decision should depend on your application’s specific requirements.\u003c/p\u003e\u003cp id=\"7efc\"\u003eThis restriction often leads to an explosion of UseCase classes. For instance, if a Repository has 10 methods, you end up creating 10 corresponding UseCases. In scenarios where a ViewModel needs most of the repository’s functionality, injecting a single repository would be more efficient than injecting multiple UseCases.\u003c/p\u003e\u003ch2 id=\"ac80\"\u003e2. One-to-One Method Mapping\u003c/h2\u003e\u003cp id=\"1a89\"\u003eThe second mistake involves creating UseCases that simply proxy repository methods. For example, creating a GetUserUseCase that only calls and returns the repository’s getUser method. Sometimes, developers add a simple mapper but essentially maintain the same one-to-one relationship. In such cases, direct repository access from the ViewModel would be more appropriate.\u003c/p\u003e\u003ch2 id=\"97a4\"\u003eProper UseCase Implementation\u003c/h2\u003e\u003cp id=\"d863\"\u003eUse cases are specifically designed to handle complex business logic. Here’s an example of a well-implemented use case from Google’s Domain Layer documentation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bda8\"\u003e/**\u003cbr/\u003e * This use case fetches the latest news and the associated author.\u003cbr/\u003e */\u003cbr/\u003eclass GetLatestNewsWithAuthorsUseCase(\u003cbr/\u003e  private val newsRepository: NewsRepository,\u003cbr/\u003e  private val authorsRepository: AuthorsRepository,\u003cbr/\u003e  private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default\u003cbr/\u003e) {\u003cbr/\u003e    suspend operator fun invoke(): List\u0026lt;ArticleWithAuthor\u0026gt; =\u003cbr/\u003e        withContext(defaultDispatcher) {\u003cbr/\u003e            val news = newsRepository.fetchLatestNews()\u003cbr/\u003e            val result: MutableList\u0026lt;ArticleWithAuthor\u0026gt; = mutableListOf()\u003cbr/\u003e            // This is not parallelized, the use case is linearly slow.\u003cbr/\u003e            for (article in news) {\u003cbr/\u003e                // The repository exposes suspend functions\u003cbr/\u003e                val author = authorsRepository.getAuthor(article.authorId)\u003cbr/\u003e                result.add(ArticleWithAuthor(article, author))\u003cbr/\u003e            }\u003cbr/\u003e            result\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d507\"\u003eThis UseCase demonstrates proper implementation by combining data from multiple repositories and performing business logic to create a new model.\u003c/p\u003e\u003ch2 id=\"0ef5\"\u003eGoogle’s Recommendation\u003c/h2\u003e\u003cp id=\"25a7\"\u003eA good approach is to add use cases \u003cstrong\u003eonly when required\u003c/strong\u003e. They should be used when there’s complex business logic that needs to be encapsulated, not as a mandatory layer between ViewModels and Repositories.\u003c/p\u003e\u003ch2 id=\"d033\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"cdbc\"\u003eWhen implementing UseCases, focus on their primary purpose: encapsulating complex business logic. Avoid creating unnecessary abstractions and evaluate whether a UseCase is truly needed based on your specific use case. Remember that direct repository access is perfectly acceptable when there’s no complex business logic to encapsulate.\u003c/p\u003e\u003cp id=\"0706\"\u003eFor more detailed information about Google’s Domain Layer guidelines, check out their official guide on \u003ca href=\"https://developer.android.com/topic/architecture/domain-layer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDomain Layer\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-11-29T16:41:44.741Z",
  "modifiedTime": null
}
