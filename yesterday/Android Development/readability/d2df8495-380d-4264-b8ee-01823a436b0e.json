{
  "id": "d2df8495-380d-4264-b8ee-01823a436b0e",
  "title": "Material 3 Expressive Design: A New Era",
  "link": "https://proandroiddev.com/material-3-expressive-design-a-new-era-9ea77959a262?source=rss----c72404660798---4",
  "description": "",
  "author": "Stefano Natali",
  "published": "Fri, 23 May 2025 12:55:54 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "material-3-expressive",
    "jetpack-compose",
    "android-app-development",
    "material3"
  ],
  "byline": "Stefano Natali",
  "length": 11560,
  "excerpt": "Material Design, Google’s design system, has continuously evolved to provide a better user experience. The latest iteration, Material 3, introduces a new approach called “Expressive Design”…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Material 3 Expressive Design: A New EraTransform Android UI with LoadingIndicator, SplitButtonLayout, and ButtonGroupGenerated by gemini.google.comMaterial Design, Google’s design system, has continuously evolved to provide a better user experience. The latest iteration, Material 3, introduces a new approach called “Expressive Design”. According to Google’s research on expressive design, expressive design aims to make UIs more human.Expressive Design focuses on several key elements. It uses a richer, more detailed color palette to emphasize key elements and create visual hierarchy. A variety of shapes and corner are employed to direct user focus and establish a unique visual tone. Size variations are leveraged to draw attention to important UI elements. Fluid and natural animations enhance interactions and provide delightful feedback. Containers strategically used to group related elements and improve clarity.New Components for AndroidMaterial 3 introduces several new and updated components that embody the principles of Expressive Design. These components provide developers with more tools to create engaging and user-friendly interfaces.To provide a practical understanding of these enhancements, I’ve explored the updated components and their implementation. This article is structured in two parts: the first, presented here, covers loading indicators, split buttons, and button groups. A subsequent article will focus on toolbars, which have significant updates. All the examples discussed here are available in my GitHub repository.To get started with the latest Material 3 features, ensure your project’s gradle file is updated with the necessary dependencies. The following snippet demonstrates how I updated the material3 version:[versions]material3 = \"1.4.0-alpha14\"[libraries]androidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\", version.ref = \"material3\"Loading indicatorsLoading indicators are visual signals that inform the user that a process is underway. They are essential for providing feedback during operations such as fetching data, processing information, or loading content.Instead of the standard CircularProgressIndicator, Material 3's expressive design introduces two new components: LoadingIndicator and ContainedLoadingIndicator. These offer enhanced visual styling and behavior for a more engaging user experience.The LoadingIndicator() animates and morphs between various shapes as long as it is visible.The ContainedLoadingIndicator() is similar, but its shapes are contained within a colored containerShape.For both LoadingIndicator() and ContainedLoadingIndicator(), you can customize the animated shapes using the polygons parameter and their colors, like this:LoadingIndicator( color = Color.Blue, polygons = listOf( // MaterialShapes.SoftBurst, // MaterialShapes.Cookie9Sided, // MaterialShapes.Pentagon, MaterialShapes.Pill, // MaterialShapes.Sunny, // MaterialShapes.Cookie4Sided, MaterialShapes.Oval ))For ContainedLoadingIndicator(), you can also modify the container's appearance with the containerShape parameter:ContainedLoadingIndicator( containerShape = MaterialShapes.Pill.toShape())By effectively using loading indicators, you can create a more responsive and user-friendly experience in your Android applications.Split buttonsA SplitButtonLayout lets the user define a button group consisting of two buttons. The leading button performs a primary action, and the trailing button performs a secondary action that is contextually related to the primary action. This UI pattern is particularly useful when a user needs quick access to a frequently used action but also needs the flexibility to choose from a set of related options.Here’s an example of a split button with a menu offering secondary actions:var checked2 by remember { mutableStateOf(false) }Box( modifier = Modifier .fillMaxSize() .wrapContentSize()) { SplitButtonLayout(leadingButton = { SplitButtonDefaults.LeadingButton( onClick = { }, ) { Icon( Icons.Filled.Edit, modifier = Modifier.size(SplitButtonDefaults.LeadingIconSize), contentDescription = \"Localized description\", ) Spacer(Modifier.size(ButtonDefaults.IconSpacing)) Text(\"My Button\") } }, trailingButton = { SplitButtonDefaults.TrailingButton( checked = checked2, onCheckedChange = { checked2 = it }, ) { val rotation: Float by animateFloatAsState( targetValue = if (checked2) 180f else 0f, label = \"Trailing Icon Rotation\" ) Icon( Icons.Filled.KeyboardArrowDown, modifier = Modifier .size(SplitButtonDefaults.TrailingIconSize) .graphicsLayer { this.rotationZ = rotation }, contentDescription = \"Localized description\" ) } }) DropdownMenu(expanded = checked2, onDismissRequest = { checked2 = false }) { DropdownMenuItem( text = { Text(\"Edit\") }, onClick = {}, leadingIcon = { Icon(Icons.Outlined.Edit, contentDescription = null) }) DropdownMenuItem( text = { Text(\"Settings\") }, onClick = {}, leadingIcon = { Icon(Icons.Outlined.Settings, contentDescription = null) }) HorizontalDivider() DropdownMenuItem( text = { Text(\"Send Feedback\") }, onClick = {}, leadingIcon = { Icon(Icons.Outlined.Email, contentDescription = null) }}You can customize the leading and trailing buttons using your own composables or by constructing them with three different styles: SplitButtonDefaults.LeadingButton, SplitButtonDefaults.OutlinedLeadingButton and SplitButtonDefaults.ElevatedLeadingButton.Here’s an example of a customized SplitButton with two different styles applied to the leading and trailing buttons:var checked by remember { mutableStateOf(false) }SplitButtonLayout( modifier = Modifier.fillMaxWidth(), leadingButton = { SplitButtonDefaults.OutlinedLeadingButton( onClick = { }, ) { Icon( Icons.Filled.Edit, modifier = Modifier.size(SplitButtonDefaults.LeadingIconSize), contentDescription = null, ) Spacer(Modifier.size(ButtonDefaults.IconSpacing)) Text(\"My Button\") }}, trailingButton = { SplitButtonDefaults.ElevatedTrailingButton( checked = checked, onCheckedChange = { checked = it }, modifier = Modifier.semantics { stateDescription = if (checked) \"Expanded\" else \"Collapsed\" contentDescription = \"Toggle Button\" }, ) { val rotation: Float by animateFloatAsState( targetValue = if (checked) 180f else 0f, label = \"Trailing Icon Rotation\" ) Icon( Icons.Filled.KeyboardArrowDown, modifier = Modifier .size(SplitButtonDefaults.TrailingIconSize) .graphicsLayer { this.rotationZ = rotation }, contentDescription = null ) }})Button groupsButton groups organize buttons in a horizontal layout. They manage how buttons resize and animate when clicked. This enables buttons to expand and compress their neighbors in response to user interaction.Here are some key features:Overflow Handling: The overflowIndicator allows you to handle situations where the buttons don't fit on the screen. This example demonstrates how to create a button group with an overflow indicator. When the screen is too small to display all the buttons, a “More” icon is displayed. Clicking this icon shows a menu with the remaining buttons.val numButtons = 10ButtonGroup( overflowIndicator = { menuState -\u003e IconButton( onClick = { if (menuState.isExpanded) { menuState.dismiss() } else { menuState.show() } } ) { Icon( imageVector = Icons.Filled.MoreVert, contentDescription = \"Localized description\" ) } }) { for (i in 0 until numButtons) { clickableItem(onClick = {}, label = \"$i\") }}Toggleable Buttons: You can create buttons that can be toggled (selected/deselected), supporting both single and multiple selection scenarios. This example shows how to create a button group where one button can be selected at a time.val options = listOf(\"Work\", \"Restaurant\", \"Coffee\") val unCheckedIcons = listOf(Icons.Outlined.Work, Icons.Outlined.Restaurant, Icons.Outlined.Coffee) val checkedIcons = listOf(Icons.Filled.Work, Icons.Filled.Restaurant, Icons.Filled.Coffee) var selectedIndex by remember { mutableIntStateOf(0) } ButtonGroup( modifier = Modifier.padding(horizontal = 8.dp), overflowIndicator = {} ) { options.forEachIndexed { index, label -\u003e toggleableItem( checked = selectedIndex == index, onCheckedChange = { selectedIndex = index }, label = label, icon = { Icon( if (selectedIndex == index) checkedIcons[index] else unCheckedIcons[index], contentDescription = \"Localized description\" ) } ) }And now an example with multiple buttons selected at the same time:val options = listOf(\"Work\", \"Restaurant\", \"Coffee\") val unCheckedIcons = listOf(Icons.Outlined.Work, Icons.Outlined.Restaurant, Icons.Outlined.Coffee) val checkedIcons = listOf(Icons.Filled.Work, Icons.Filled.Restaurant, Icons.Filled.Coffee) val checked = remember { mutableStateListOf(false, false, false) } ButtonGroup( modifier = Modifier.padding(horizontal = 8.dp), overflowIndicator = {} ) { options.forEachIndexed { index, label -\u003e toggleableItem( checked = checked[index], onCheckedChange = { checked[index] = it }, label = label, icon = { Icon( if (checked[index]) checkedIcons[index] else unCheckedIcons[index], contentDescription = \"Localized description\" ) } ) } }ConclusionExpressive design is not just about aesthetics, it’s about improving usability. By using more dynamic colors, shapes, and animations, Material 3 allows developers to create Android UIs that are more intuitive, engaging, and reflective of the user’s personal style.The new components, like the LoadingIndicator, SplitButtonLayout, and ButtonGroup, provide practical tools for building these enhanced user experiences. As developers, embracing these changes will enable us to craft applications that are not only visually appealing but also more user-friendly and effective.If you liked these components, believe me that you will love the new toolbars. I will speak about these in the next post.If you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on Bluesky or LinkedIn for further discussions.Have a great day, and happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*BlghFgNi2lx8ZB6z_Hg0WA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"c760\" data-testid=\"storyTitle\"\u003eMaterial 3 Expressive Design: A New Era\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"9ecd\"\u003eTransform Android UI with \u003cstrong\u003eLoadingIndicator\u003c/strong\u003e, \u003cstrong\u003eSplitButtonLayout\u003c/strong\u003e, and \u003cstrong\u003eButtonGroup\u003c/strong\u003e\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@stefanoq21?source=post_page---byline--9ea77959a262---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Stefano Natali\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*nJT9nmRwE28kmJAEiRyHMw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated by gemini.google.com\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1ad1\"\u003eMaterial Design, Google’s design system, has continuously evolved to provide a better user experience. The latest iteration, \u003cstrong\u003eMaterial 3\u003c/strong\u003e, introduces a new approach called “\u003cstrong\u003eExpressive Design\u003c/strong\u003e”. According to Google’s \u003ca href=\"https://design.google/library/expressive-material-design-google-research\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eresearch on expressive design\u003c/a\u003e, expressive design aims to make UIs more human.\u003c/p\u003e\u003cp id=\"172f\"\u003eExpressive Design focuses on several key elements. It uses a richer, more detailed \u003cstrong\u003ecolor palette\u003c/strong\u003e to emphasize key elements and create visual hierarchy. A variety of \u003cstrong\u003eshapes and corner\u003c/strong\u003e are employed to direct user focus and establish a unique visual tone. \u003cstrong\u003eSize variations\u003c/strong\u003e are leveraged to draw attention to important UI elements. \u003cstrong\u003eFluid and natural animations\u003c/strong\u003e enhance interactions and provide delightful feedback. \u003cstrong\u003eContainers strategically used\u003c/strong\u003e to group related elements and improve clarity.\u003c/p\u003e\u003ch2 id=\"86cf\"\u003eNew Components for Android\u003c/h2\u003e\u003cp id=\"f1bc\"\u003e\u003ca href=\"https://m3.material.io/blog/building-with-m3-expressive\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eMaterial 3\u003c/strong\u003e\u003c/a\u003e introduces several new and updated components that embody the principles of Expressive Design. These components provide developers with more tools to create engaging and user-friendly interfaces.\u003c/p\u003e\u003cp id=\"f4f5\"\u003eTo provide a practical understanding of these enhancements, I’ve explored the updated components and their implementation. This article is structured in two parts: the first, presented here, covers \u003cstrong\u003eloading indicators\u003c/strong\u003e, \u003cstrong\u003esplit buttons\u003c/strong\u003e, and \u003cstrong\u003ebutton groups\u003c/strong\u003e. A subsequent article will focus on \u003cstrong\u003etoolbars\u003c/strong\u003e, which have significant updates. All the examples discussed here are available in my \u003ca href=\"https://github.com/stefanoq21/ComposePlayground\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGitHub repository\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"4a8b\"\u003eTo get started with the latest Material 3 features, ensure your project’s \u003cstrong\u003egradle\u003c/strong\u003e file is updated with the necessary dependencies. The following snippet demonstrates how I updated the \u003cstrong\u003ematerial3\u003c/strong\u003e version:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"605e\"\u003e[versions]\u003cbr/\u003ematerial3 = \u0026#34;1.4.0-alpha14\u0026#34;\u003cbr/\u003e[libraries]\u003cbr/\u003eandroidx-material3 = { group = \u0026#34;androidx.compose.material3\u0026#34;, name = \u0026#34;material3\u0026#34;, version.ref = \u0026#34;material3\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5a6b\"\u003eLoading indicators\u003c/h2\u003e\u003cp id=\"fbe1\"\u003e\u003cstrong\u003eLoading indicators\u003c/strong\u003e are visual signals that inform the user that a process is underway. They are essential for providing feedback during operations such as fetching data, processing information, or loading content.\u003c/p\u003e\u003cp id=\"7d42\"\u003eInstead of the standard \u003cstrong\u003eCircularProgressIndicator\u003c/strong\u003e, Material 3\u0026#39;s expressive design introduces two new components: \u003cstrong\u003eLoadingIndicator \u003c/strong\u003eand \u003cstrong\u003eContainedLoadingIndicator\u003c/strong\u003e. These offer enhanced visual styling and behavior for a more engaging user experience.\u003c/p\u003e\u003cp id=\"2ccc\"\u003eThe \u003cstrong\u003eLoadingIndicator()\u003c/strong\u003e animates and morphs between various shapes as long as it is visible.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ec05\"\u003eThe \u003cstrong\u003eContainedLoadingIndicator()\u003c/strong\u003e is similar, but its shapes are contained within a colored \u003cstrong\u003econtainerShape\u003c/strong\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f9b0\"\u003eFor both \u003cstrong\u003eLoadingIndicator()\u003c/strong\u003e and \u003cstrong\u003eContainedLoadingIndicator()\u003c/strong\u003e, you can customize the animated shapes using the \u003cstrong\u003epolygons \u003c/strong\u003eparameter and their colors, like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f9fe\"\u003eLoadingIndicator(\u003cbr/\u003e    color = Color.Blue,\u003cbr/\u003e    polygons = listOf(\u003cbr/\u003e        // MaterialShapes.SoftBurst,\u003cbr/\u003e        // MaterialShapes.Cookie9Sided,\u003cbr/\u003e        // MaterialShapes.Pentagon,\u003cbr/\u003e        MaterialShapes.Pill,\u003cbr/\u003e        // MaterialShapes.Sunny,\u003cbr/\u003e        // MaterialShapes.Cookie4Sided,\u003cbr/\u003e        MaterialShapes.Oval\u003cbr/\u003e    )\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"cac0\"\u003eFor \u003cstrong\u003eContainedLoadingIndicator()\u003c/strong\u003e, you can also modify the container\u0026#39;s appearance with the \u003cstrong\u003econtainerShape\u003c/strong\u003e parameter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c4f\"\u003eContainedLoadingIndicator(\u003cbr/\u003e    containerShape = MaterialShapes.Pill.toShape()\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5915\"\u003eBy effectively using loading indicators, you can create a more responsive and user-friendly experience in your Android applications.\u003c/p\u003e\u003ch2 id=\"db4e\"\u003eSplit buttons\u003c/h2\u003e\u003cp id=\"e4aa\"\u003eA \u003cstrong\u003eSplitButtonLayout \u003c/strong\u003elets the user define a button group consisting of two buttons. The \u003cstrong\u003eleading button\u003c/strong\u003e performs a primary action, and the \u003cstrong\u003etrailing button\u003c/strong\u003e performs a secondary action that is contextually related to the primary action. This UI pattern is particularly useful when a user needs quick access to a frequently used action but also needs the flexibility to choose from a set of related options.\u003c/p\u003e\u003cp id=\"cc73\"\u003eHere’s an example of a split button with a menu offering secondary actions:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ebed\"\u003evar checked2 by remember { mutableStateOf(false) }\u003cbr/\u003eBox(\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e        .fillMaxSize()\u003cbr/\u003e        .wrapContentSize()\u003cbr/\u003e) {\u003cbr/\u003e    SplitButtonLayout(leadingButton = {\u003cbr/\u003e        SplitButtonDefaults.LeadingButton(\u003cbr/\u003e            onClick = { },\u003cbr/\u003e        ) {\u003cbr/\u003e            Icon(\u003cbr/\u003e                Icons.Filled.Edit,\u003cbr/\u003e                modifier = Modifier.size(SplitButtonDefaults.LeadingIconSize),\u003cbr/\u003e                contentDescription = \u0026#34;Localized description\u0026#34;,\u003cbr/\u003e            )\u003cbr/\u003e            Spacer(Modifier.size(ButtonDefaults.IconSpacing))\u003cbr/\u003e            Text(\u0026#34;My Button\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }, trailingButton = {\u003cbr/\u003e        SplitButtonDefaults.TrailingButton(\u003cbr/\u003e            checked = checked2,\u003cbr/\u003e            onCheckedChange = { checked2 = it },\u003cbr/\u003e        ) {\u003cbr/\u003e            val rotation: Float by animateFloatAsState(\u003cbr/\u003e                targetValue = if (checked2) 180f else 0f, label = \u0026#34;Trailing Icon Rotation\u0026#34;\u003cbr/\u003e            )\u003cbr/\u003e            Icon(\u003cbr/\u003e                Icons.Filled.KeyboardArrowDown,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .size(SplitButtonDefaults.TrailingIconSize)\u003cbr/\u003e                    .graphicsLayer {\u003cbr/\u003e                        this.rotationZ = rotation\u003cbr/\u003e                    },\u003cbr/\u003e                contentDescription = \u0026#34;Localized description\u0026#34;\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    })\u003cp\u003e    DropdownMenu(expanded = checked2, onDismissRequest = { checked2 = false }) {\u003cbr/\u003e        DropdownMenuItem(\u003cbr/\u003e            text = { Text(\u0026#34;Edit\u0026#34;) },\u003cbr/\u003e            onClick = {},\u003cbr/\u003e            leadingIcon = { Icon(Icons.Outlined.Edit, contentDescription = null) })\u003cbr/\u003e        DropdownMenuItem(\u003cbr/\u003e            text = { Text(\u0026#34;Settings\u0026#34;) },\u003cbr/\u003e            onClick = {},\u003cbr/\u003e            leadingIcon = { Icon(Icons.Outlined.Settings, contentDescription = null) })\u003cbr/\u003e        HorizontalDivider()\u003cbr/\u003e        DropdownMenuItem(\u003cbr/\u003e            text = { Text(\u0026#34;Send Feedback\u0026#34;) },\u003cbr/\u003e            onClick = {},\u003cbr/\u003e            leadingIcon = { Icon(Icons.Outlined.Email, contentDescription = null) }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5fbc\"\u003eYou can customize the leading and trailing buttons using your own composables or by constructing them with three different styles: \u003cstrong\u003eSplitButtonDefaults.LeadingButton\u003c/strong\u003e, \u003cstrong\u003eSplitButtonDefaults.OutlinedLeadingButton\u003c/strong\u003e and \u003cstrong\u003eSplitButtonDefaults.ElevatedLeadingButton\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"ffb5\"\u003eHere’s an example of a customized \u003cstrong\u003eSplitButton \u003c/strong\u003ewith two different styles applied to the leading and trailing buttons:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"77f1\"\u003evar checked by remember { mutableStateOf(false) }\u003cp\u003eSplitButtonLayout(\u003cbr/\u003e    modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e    leadingButton = {\u003cbr/\u003e    SplitButtonDefaults.OutlinedLeadingButton(\u003cbr/\u003e        onClick = { },\u003cbr/\u003e    ) {\u003cbr/\u003e        Icon(\u003cbr/\u003e            Icons.Filled.Edit,\u003cbr/\u003e            modifier = Modifier.size(SplitButtonDefaults.LeadingIconSize),\u003cbr/\u003e            contentDescription = null,\u003cbr/\u003e        )\u003cbr/\u003e        Spacer(Modifier.size(ButtonDefaults.IconSpacing))\u003cbr/\u003e        Text(\u0026#34;My Button\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}, trailingButton = {\u003cbr/\u003e    SplitButtonDefaults.ElevatedTrailingButton(\u003cbr/\u003e        checked = checked,\u003cbr/\u003e        onCheckedChange = { checked = it },\u003cbr/\u003e        modifier = Modifier.semantics {\u003cbr/\u003e            stateDescription = if (checked) \u0026#34;Expanded\u0026#34; else \u0026#34;Collapsed\u0026#34;\u003cbr/\u003e            contentDescription = \u0026#34;Toggle Button\u0026#34;\u003cbr/\u003e        },\u003cbr/\u003e    ) {\u003cbr/\u003e        val rotation: Float by animateFloatAsState(\u003cbr/\u003e            targetValue = if (checked) 180f else 0f, label = \u0026#34;Trailing Icon Rotation\u0026#34;\u003cbr/\u003e        )\u003cbr/\u003e        Icon(\u003cbr/\u003e            Icons.Filled.KeyboardArrowDown,\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(SplitButtonDefaults.TrailingIconSize)\u003cbr/\u003e                .graphicsLayer {\u003cbr/\u003e                    this.rotationZ = rotation\u003cbr/\u003e                },\u003cbr/\u003e            contentDescription = null\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e})\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3090\"\u003eButton groups\u003c/h2\u003e\u003cp id=\"70a6\"\u003eButton groups organize buttons in a horizontal layout. They manage how buttons resize and animate when clicked. This enables buttons to expand and compress their neighbors in response to user interaction.\u003c/p\u003e\u003cp id=\"340c\"\u003eHere are some key features:\u003c/p\u003e\u003cp id=\"1aac\"\u003e\u003cstrong\u003eOverflow Handling\u003c/strong\u003e: The \u003cstrong\u003eoverflowIndicator \u003c/strong\u003eallows you to handle situations where the buttons don\u0026#39;t fit on the screen. This example demonstrates how to create a button group with an overflow indicator. When the screen is too small to display all the buttons, a “More” icon is displayed. Clicking this icon shows a menu with the remaining buttons.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9a6d\"\u003eval numButtons = 10\u003cbr/\u003eButtonGroup(\u003cbr/\u003e    overflowIndicator = { menuState -\u0026gt;\u003cbr/\u003e        IconButton(\u003cbr/\u003e            onClick = {\u003cbr/\u003e                if (menuState.isExpanded) {\u003cbr/\u003e                    menuState.dismiss()\u003cbr/\u003e                } else {\u003cbr/\u003e                    menuState.show()\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        ) {\u003cbr/\u003e            Icon(\u003cbr/\u003e                imageVector = Icons.Filled.MoreVert,\u003cbr/\u003e                contentDescription = \u0026#34;Localized description\u0026#34;\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e) {\u003cbr/\u003e    for (i in 0 until numButtons) {\u003cbr/\u003e        clickableItem(onClick = {}, label = \u0026#34;$i\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"02e3\"\u003e\u003cstrong\u003eToggleable Buttons\u003c/strong\u003e: You can create buttons that can be toggled (selected/deselected), supporting both single and multiple selection scenarios. This example shows how to create a button group where one button can be selected at a time.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4e92\"\u003eval options = listOf(\u0026#34;Work\u0026#34;, \u0026#34;Restaurant\u0026#34;, \u0026#34;Coffee\u0026#34;)\u003cbr/\u003e    val unCheckedIcons =\u003cbr/\u003e        listOf(Icons.Outlined.Work, Icons.Outlined.Restaurant, Icons.Outlined.Coffee)\u003cbr/\u003e    val checkedIcons = listOf(Icons.Filled.Work, Icons.Filled.Restaurant, Icons.Filled.Coffee)\u003cbr/\u003e    var selectedIndex by remember { mutableIntStateOf(0) }\u003cp\u003e    ButtonGroup(\u003cbr/\u003e        modifier = Modifier.padding(horizontal = 8.dp),\u003cbr/\u003e        overflowIndicator = {}\u003cbr/\u003e    ) {\u003cbr/\u003e        options.forEachIndexed { index, label -\u0026gt;\u003cbr/\u003e            toggleableItem(\u003cbr/\u003e                checked = selectedIndex == index,\u003cbr/\u003e                onCheckedChange = { selectedIndex = index },\u003cbr/\u003e                label = label,\u003cbr/\u003e                icon = {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        if (selectedIndex == index) checkedIcons[index] else unCheckedIcons[index],\u003cbr/\u003e                        contentDescription = \u0026#34;Localized description\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ac1c\"\u003eAnd now an example with multiple buttons selected at the same time:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"41b5\"\u003eval options = listOf(\u0026#34;Work\u0026#34;, \u0026#34;Restaurant\u0026#34;, \u0026#34;Coffee\u0026#34;)\u003cbr/\u003e    val unCheckedIcons =\u003cbr/\u003e        listOf(Icons.Outlined.Work, Icons.Outlined.Restaurant, Icons.Outlined.Coffee)\u003cbr/\u003e    val checkedIcons = listOf(Icons.Filled.Work, Icons.Filled.Restaurant, Icons.Filled.Coffee)\u003cbr/\u003e    val checked = remember { mutableStateListOf(false, false, false) }\u003cp\u003e    ButtonGroup(\u003cbr/\u003e        modifier = Modifier.padding(horizontal = 8.dp),\u003cbr/\u003e        overflowIndicator = {}\u003cbr/\u003e    ) {\u003cbr/\u003e        options.forEachIndexed { index, label -\u0026gt;\u003cbr/\u003e            toggleableItem(\u003cbr/\u003e                checked = checked[index],\u003cbr/\u003e                onCheckedChange = { checked[index] = it },\u003cbr/\u003e                label = label,\u003cbr/\u003e                icon = {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        if (checked[index]) checkedIcons[index] else unCheckedIcons[index],\u003cbr/\u003e                        contentDescription = \u0026#34;Localized description\u0026#34;\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"249a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"e898\"\u003e\u003cstrong\u003eExpressive design\u003c/strong\u003e is not just about aesthetics, it’s about improving usability. By using more dynamic colors, shapes, and animations, \u003cstrong\u003eMaterial 3\u003c/strong\u003e allows developers to create\u003cstrong\u003e Android UIs\u003c/strong\u003e that are more intuitive, engaging, and reflective of the user’s personal style.\u003c/p\u003e\u003cp id=\"4947\"\u003eThe new components, like the \u003cstrong\u003eLoadingIndicator\u003c/strong\u003e, \u003cstrong\u003eSplitButtonLayout\u003c/strong\u003e, and \u003cstrong\u003eButtonGroup\u003c/strong\u003e, provide practical tools for building these enhanced user experiences. As developers, embracing these changes will enable us to craft applications that are not only visually appealing but also more user-friendly and effective.\u003c/p\u003e\u003cp id=\"4e70\"\u003eIf you liked these components, believe me that you will love the new \u003cstrong\u003etoolbars\u003c/strong\u003e. I will speak about these in the next post.\u003c/p\u003e\u003cp id=\"6bee\"\u003eIf you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on \u003ca href=\"https://bsky.app/profile/stefanoq21.bsky.social\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eBluesky\u003c/strong\u003e\u003c/a\u003e or \u003ca href=\"http://www.linkedin.com/in/stefano-natali-q21\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003efor further discussions.\u003c/p\u003e\u003cp id=\"e825\"\u003eHave a great day, and happy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-05-20T13:00:00.403Z",
  "modifiedTime": null
}
