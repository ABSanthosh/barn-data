{
  "id": "6d6a2210-811e-4bda-8604-807824a2c925",
  "title": "Coding by Magic",
  "link": "https://blog.danlew.net/2025/05/13/coding-by-magic/",
  "description": "Most of my programming ventures begin with a single line of code I’m curious about. Who is calling the code, and how does this code fit into the larger jigsaw puzzle?As a result, “find usages”, “go to declaration”, and “go to implementations\u0026",
  "author": "Dan Lew",
  "published": "Tue, 13 May 2025 14:00:05 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "code design"
  ],
  "byline": "Dan Lew",
  "length": 2623,
  "excerpt": "Most of my programming ventures begin with a single line of code I’m curious about. Who is calling the code, and how does this code fit into the larger jigsaw puzzle? As a result, “find usages”, “go to declaration”, and “go to implementations” are three of my most often used IDE features. I use them to jump between caller and callee, interface and implementation, functions and the tests that verify them. I develop a mind map, tracing the possible logical routes through the codebase. There are,",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "Most of my programming ventures begin with a single line of code I’m curious about. Who is calling the code, and how does this code fit into the larger jigsaw puzzle?As a result, “find usages”, “go to declaration”, and “go to implementations” are three of my most often used IDE features. I use them to jump between caller and callee, interface and implementation, functions and the tests that verify them. I develop a mind map, tracing the possible logical routes through the codebase.There are, unfortunately, ways to obfuscate these connections:Invoking functions or retrieving variables indirectly by name (e.g. reflective programming) makes it difficult to find the caller.Coding by convention uses implicit connections between components (e.g., “foo.xml uses the logic in foo.ts because they are named the same.”)App behavior controlled by global state that changes at mysterious times (one part of the app flips a global boolean that is used by an entirely different part of the app much later).I colloquially call these obfuscations “coding by magic.” With magic tricks, seemingly impossible things happen before your eyes. You know magic isn’t real, so there’s got to be a logical explanation for what just happened - but it’s hard to figure it out!It can be a nightmare when you have to interact with magic code:My tools (like “find usages”) no longer work, so I often have to fire up the debugger just to find out how a function is being invoked.It makes refactoring dangerous - you never know if that function you just changed might be invoked from a place you weren’t expecting (resulting in magical runtime exceptions).Constraints make otherwise complex codebases manageable. Magic code often breaks these constraints and you’re more likely you are to end up in a spaghetti code situation.Sometimes the only answer is to code by magic (e.g., a plugin system requires dynamic code invocation). But, generally, I avoid coding by magic because it makes understanding codebases more difficult.Usually we use code by magic because it adds a convenience: e.g., instead of having to write out a list of API endpoint modules, why not just look for all modules with the name *_api.py? But in the long run, I find that these short-term wins turn into long-term losses, where the added complexity of magic code bogs down your ability to maintain the codebase.The most effective way to avoid coding by magic is to embrace explicit connections in coding, even if it is a bit more laborious (at first). The more a codebase grows, the harder it is to understand, and at that point you’ll take whatever blessings you can get.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n\n        \n\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eMost of my programming ventures begin with a single line of code I’m curious about. Who is calling the code, and how does this code fit into the larger jigsaw puzzle?\u003c/p\u003e\u003cp\u003eAs a result, “find usages”, “go to declaration”, and “go to implementations” are three of my most often used IDE features. I use them to jump between caller and callee, interface and implementation, functions and the tests that verify them. I develop a mind map, tracing the possible logical routes through the codebase.\u003c/p\u003e\u003cp\u003eThere are, unfortunately, ways to obfuscate these connections:\u003c/p\u003e\u003cul\u003e\u003cli\u003eInvoking functions or retrieving variables indirectly by name (e.g. \u003ca href=\"https://en.wikipedia.org/wiki/Reflective_programming?ref=blog.danlew.net\"\u003e\u003cu\u003ereflective programming\u003c/u\u003e\u003c/a\u003e) makes it difficult to find the caller.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Convention_over_configuration?ref=blog.danlew.net\"\u003e\u003cu\u003eCoding by convention\u003c/u\u003e\u003c/a\u003e uses implicit connections between components (e.g., “foo.xml uses the logic in foo.ts because they are named the same.”)\u003c/li\u003e\u003cli\u003eApp behavior controlled by global state that changes at mysterious times (one part of the app flips a global boolean that is used by an entirely different part of the app much later).\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI colloquially call these obfuscations “\u003cstrong\u003ecoding by magic\u003c/strong\u003e.” With magic tricks, seemingly impossible things happen before your eyes. You know magic isn’t real, so there’s got to be a logical explanation for what just happened - but it’s hard to figure it out!\u003c/p\u003e\u003cp\u003eIt can be a nightmare when you have to interact with magic code:\u003c/p\u003e\u003cul\u003e\u003cli\u003eMy tools (like “find usages”) no longer work, so I often have to fire up the debugger just to find out \u003cem\u003ehow\u003c/em\u003e a function is being invoked.\u003c/li\u003e\u003cli\u003eIt makes refactoring dangerous - you never know if that function you just changed might be invoked from a place you weren’t expecting (resulting in magical runtime exceptions).\u003c/li\u003e\u003cli\u003eConstraints make otherwise complex codebases manageable. Magic code often breaks these constraints and you’re more likely you are to end up in a \u003ca href=\"https://en.wikipedia.org/wiki/Spaghetti_code?ref=blog.danlew.net\"\u003e\u003cu\u003espaghetti code\u003c/u\u003e\u003c/a\u003e situation.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSometimes the only answer is to code by magic (e.g., a plugin system requires dynamic code invocation). But, generally, \u003cstrong\u003eI avoid coding by magic because it makes understanding codebases more difficult\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eUsually we use code by magic because it adds a convenience: e.g., instead of having to write out a list of API endpoint modules, why not just look for all modules with the name \u003ccode\u003e*_api.py\u003c/code\u003e? But in the long run, I find that these short-term wins turn into long-term losses, where the added complexity of magic code bogs down your ability to maintain the codebase.\u003c/p\u003e\u003cp\u003eThe most effective way to avoid coding by magic is to embrace explicit connections in coding, even if it is a bit more laborious (at first). The more a codebase grows, the harder it is to understand, and at that point you’ll take whatever blessings you can get.\u003c/p\u003e\n    \u003c/section\u003e\n\n    \n    \n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-05-13T14:00:05Z",
  "modifiedTime": "2025-05-13T14:00:06Z"
}
