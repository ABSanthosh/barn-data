{
  "id": "a82d0a8a-634a-4eed-b303-7c22f061f66c",
  "title": "Kotlin Under the Hood: Exploring Constructors and Init Blocks",
  "link": "https://proandroiddev.com/kotlin-under-the-hood-exploring-constructors-and-init-blocks-869fc1f85a8e?source=rss----c72404660798---4",
  "description": "",
  "author": "Abhaysing Bhosale",
  "published": "Tue, 22 Oct 2024 15:53:44 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "java",
    "kotlin",
    "under-the-hood",
    "kotlin-beginners"
  ],
  "byline": "Abhaysing Bhosale",
  "length": 7256,
  "excerpt": "Hello! Have you ever wondered how Kotlin’s constructors and init blocks work under the hood? In this blog, we’ll dive into it. Before we dive into the details, let’s first understand what…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hello! Have you ever wondered how Kotlin’s constructors and init blocks work under the hood? In this blog, we’ll dive into it.Before we dive into the details, let’s first understand what constructors and init blocks are.Kotlin has two main types of constructors: the Primary Constructor and Secondary Constructors.Primary ConstructorThe primary constructor is defined in the class header, directly after the class name, and is part of the class declaration itself. It has the following features:You can use val for read-only properties and var for mutable properties.No need to use the constructor keyword, unlike in other languages.It’s implicitly called when an instance of the class is created.class User(val name: String, val age: Int){ // Properties 'name' and 'age' are automatically initialized via the primary constructor.}Secondary ConstructorA secondary constructor which also known as an auxiliary constructor is an additional constructor you can define within the class body using the constructor keyword. It allows you to provide alternative ways to instantiate an object when the primary constructor doesn’t meet your specific requirements.Here are some key points about secondary constructors:Defined within the class using the constructor keyword.Can call the primary constructor using this(...).Useful for providing different ways to create instances of a class.Each secondary constructor can delegate to the primary constructor or to another secondary constructor.There can be multiple secondary constructors.class User(val name: String, val age: Int) { constructor(name: String) : this(name, 22) { println(\"User created with name: $name, age: $age\") }}In this example:The primary constructor takes both name and age.The secondary constructor allows you to create a User object by passing only a name. It automatically assigns a default age of 22.this(name, 22) is a constructor delegation.Constructor delegation refers to the mechanism by which a secondary constructor can call a primary constructor or another secondary constructor to reuse initialization logic.Init BlockThe init block is used for initializing properties or executing startup logic right after an object is created. It runs after the primary constructor and before any secondary constructors.Key Characteristics:The init block is called automatically when an instance of the class is created.You can have multiple init blocks, and they will execute in the order they are defined within the class.Any properties initialized in the primary constructor can be accessed and used inside the init block.class User(val name: String, val age: Int) { init { println(\"name: $name and age: $age\") }}Decoding Kotlin Constructors and Init BlocksNow, let’s dive into how it works. First, to gain deeper insights, we can use IntelliJ IDEA’s decompilation feature. By navigating to Tools -\u003e Kotlin -\u003e Kotlin Bytecode and selecting Decompile, we can view the underlying Java code generated from our Kotlin constructs.Now, let’s check what happens when we create a primary constructor in Kotlin. Here’s our code:class User(val name: String, val age: Int) {}Now, let’s take a look at the underlying Java code generated from this Kotlin class:public final class User { @NotNull private final String name; private final int age; @NotNull public final String getName() { return this.name; } public final int getAge() { return this.age; } public User(@NotNull String name, int age) { super(); this.name = name; this.age = age; }}I’ve simplified it by removing assertions and other metadata for clarity.So, what do we see here?The User class is final because Kotlin classes are final by default.The primary constructor is translated into a Java constructor.getName() and getAge() methods provide access to these properties.The @NotNull annotation indicates that name cannot be null, ensuring safety.There are no setter methods since the properties are defined as immutable in the constructor.Let’s discuss the init block.class User(val name: String, val age: Int) { init { println(\"This is the first init block. Name: $name \u0026 Age: $age\") } init { println(\"This is the second init block.\") }}Here’s the underlying Java code:public final class User { @NotNull private final String name; private final int age; @NotNull public final String getName() { return this.name; } public final int getAge() { return this.age; } public User(@NotNull String name, int age) { super(); this.name = name; this.age = age; String var3 = \"This is the first init block. Name: \" + this.name + \" \u0026 Age: \" + this.age; System.out.println(var3); var3 = \"This is the second init block.\"; System.out.println(var3); }}So, what do we observe here?The code from the init blocks is added to the primary constructor and executes after the properties in the constructor are initialized.The init blocks execute in the order they appear, right after the primary constructor and before any secondary constructors.When we create an instance of the User class using User(\"Abhay\", 22), the output will be:This is the first init block. Name: Abhay \u0026 Age: 22This is the second init block.Let’s explore the secondary constructor.class User(val name: String, val age: Int){ init { println(\"This is the first init block. Name: $name \u0026 Age: $age\") } // secondary constructor constructor(name: String): this(name, 22){ println(\"This is the secondary constructor: Name: $name \u0026 Age: $age\") } init { println(\"This is the second init block.\") }}Here’s the underlying Java code:public final class User { @NotNull private final String name; private final int age; @NotNull public final String getName() { return this.name; } public final int getAge() { return this.age; } public User(@NotNull String name, int age) { super(); this.name = name; this.age = age; String var3 = \"This is the first init block. Name: \" + this.name + \" \u0026 Age: \" + this.age; System.out.println(var3); var3 = \"This is the second init block.\"; System.out.println(var3); } public User(@NotNull String name) { this(name, 22); String var2 = \"This is the secondary constructor: Name: \" + name + \" \u0026 Age: \" + this.age; System.out.println(var2); }}A secondary constructor in Kotlin overloads the constructor in Java.The secondary constructor can call the primary constructor or another secondary constructor using this().The secondary constructor executes after all init blocks have been processed.In this example, when you create an instance of User using the secondary constructor with just a name, it initializes the age property to a default value of 22.When you create an instance of User using the secondary constructor, as shown in the following code:fun main() { // Calling the secondary constructor User(\"Abhay\")}You’ll get the output:This is the first init block. Name: Abhay \u0026 Age: 22This is the second init block.This is the secondary constructor: Name: Abhay \u0026 Age: 22Here, you can see that all the init blocks are executed first, followed by the secondary constructor.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Tv7ztrOoDi14tOZfgVR4cw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@abhaysingbhosale123?source=post_page-----869fc1f85a8e--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Abhaysing Bhosale\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*KsTj5Ua9kAg5BaW53QhV0A.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----869fc1f85a8e--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e645\"\u003eHello! Have you ever wondered how Kotlin’s constructors and \u003ccode\u003einit\u003c/code\u003e blocks work under the hood? In this blog, we’ll dive into it.\u003c/p\u003e\u003cp id=\"1576\"\u003eBefore we dive into the details, let’s first understand what constructors and \u003ccode\u003einit\u003c/code\u003e blocks are.\u003cbr/\u003eKotlin has two main types of constructors: the Primary Constructor and Secondary Constructors.\u003c/p\u003e\u003ch2 id=\"a8ff\"\u003ePrimary Constructor\u003c/h2\u003e\u003cp id=\"dda5\"\u003eThe primary constructor is defined in the class header, directly after the class name, and is part of the class declaration itself. It has the following features:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d927\"\u003eYou can use \u003ccode\u003eval\u003c/code\u003e for read-only properties and \u003ccode\u003evar\u003c/code\u003e for mutable properties.\u003c/li\u003e\u003cli id=\"2ff4\"\u003eNo need to use the \u003ccode\u003econstructor\u003c/code\u003e keyword, unlike in other languages.\u003c/li\u003e\u003cli id=\"1f1e\"\u003eIt’s implicitly called when an instance of the class is created.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"b2b4\"\u003eclass User(val name: String, val age: Int){\u003cbr/\u003e  // Properties \u0026#39;name\u0026#39; and \u0026#39;age\u0026#39; are automatically initialized via the primary constructor.\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7ccf\"\u003eSecondary Constructor\u003c/h2\u003e\u003cp id=\"ceb6\"\u003eA secondary constructor which also known as an \u003cstrong\u003eauxiliary \u003c/strong\u003econstructor is an additional constructor you can define within the class body using the \u003ccode\u003econstructor\u003c/code\u003e keyword. It allows you to provide alternative ways to instantiate an object when the primary constructor doesn’t meet your specific requirements.\u003c/p\u003e\u003cp id=\"4d9d\"\u003eHere are some key points about secondary constructors:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1eee\"\u003eDefined within the class using the \u003ccode\u003econstructor\u003c/code\u003e keyword.\u003c/li\u003e\u003cli id=\"18d9\"\u003eCan call the primary constructor using \u003ccode\u003ethis(...)\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"232f\"\u003eUseful for providing different ways to create instances of a class.\u003c/li\u003e\u003cli id=\"54e3\"\u003e\u003cstrong\u003eEach secondary constructor can delegate to the primary constructor or to another secondary constructor.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"5168\"\u003eThere can be multiple secondary constructors.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"206d\"\u003eclass User(val name: String, val age: Int) {\u003cp\u003e    constructor(name: String) : this(name, 22) {\u003cbr/\u003e        println(\u0026#34;User created with name: $name, age: $age\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"090a\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9f8d\"\u003eThe primary constructor takes both \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eage\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"f778\"\u003eThe secondary constructor allows you to create a \u003ccode\u003eUser\u003c/code\u003e object by passing only a \u003ccode\u003ename\u003c/code\u003e. It automatically assigns a default \u003ccode\u003eage\u003c/code\u003e of 22.\u003c/li\u003e\u003cli id=\"4e4a\"\u003e\u003ccode\u003ethis(name, 22)\u003c/code\u003e is a \u003cstrong\u003econstructor delegation.\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8498\"\u003e\u003cstrong\u003e\u003cem\u003eConstructor delegation\u003c/em\u003e\u003c/strong\u003e refers to the mechanism by which a secondary constructor can call a primary constructor or another secondary constructor to reuse initialization logic.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"01c2\"\u003e\u003ccode\u003eInit\u003c/code\u003e Block\u003c/h2\u003e\u003cp id=\"b19a\"\u003eThe \u003ccode\u003einit\u003c/code\u003e block is used for initializing properties or executing startup logic right after an object is created. It runs \u003cstrong\u003eafter the primary constructor\u003c/strong\u003e and \u003cstrong\u003ebefore any secondary constructors\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"0f98\"\u003e\u003cstrong\u003eKey Characteristics:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4b04\"\u003eThe \u003ccode\u003einit\u003c/code\u003e block is called automatically when an instance of the class is created.\u003c/li\u003e\u003cli id=\"1074\"\u003eYou can have multiple \u003ccode\u003einit\u003c/code\u003e blocks, and they will execute in the order they are defined within the class.\u003c/li\u003e\u003cli id=\"c19c\"\u003eAny properties initialized in the primary constructor can be accessed and used inside the \u003ccode\u003einit\u003c/code\u003e block.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"523c\"\u003eclass User(val name: String, val age: Int) {\u003cp\u003e    init {\u003cbr/\u003e        println(\u0026#34;name: $name and age: $age\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e56b\"\u003eDecoding Kotlin Constructors and Init Blocks\u003c/h2\u003e\u003cp id=\"48da\"\u003eNow, let’s dive into how it works. First, to gain deeper insights, we can use IntelliJ IDEA’s decompilation feature. By navigating to \u003cstrong\u003eTools -\u0026gt; Kotlin -\u0026gt; Kotlin Bytecode\u003c/strong\u003e and selecting \u003cstrong\u003eDecompile\u003c/strong\u003e, we can view the underlying Java code generated from our Kotlin constructs.\u003c/p\u003e\u003cp id=\"ee11\"\u003eNow, let’s check what happens when we create a \u003cstrong\u003eprimary constructor\u003c/strong\u003e in Kotlin. Here’s our code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5920\"\u003eclass User(val name: String, val age: Int) {}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c8f0\"\u003eNow, let’s take a look at the underlying Java code generated from this Kotlin class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a349\"\u003epublic final class User {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   private final String name;\u003cbr/\u003e   private final int age;\u003cp\u003e   @NotNull\u003cbr/\u003e   public final String getName() {\u003cbr/\u003e      return this.name;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public final int getAge() {\u003cbr/\u003e      return this.age;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public User(@NotNull String name, int age) {\u003cbr/\u003e      super();\u003cbr/\u003e      this.name = name;\u003cbr/\u003e      this.age = age;\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9aa0\"\u003eI’ve simplified it by removing assertions and other metadata for clarity.\u003c/p\u003e\u003cp id=\"b08d\"\u003eSo, what do we see here?\u003c/p\u003e\u003cul\u003e\u003cli id=\"3bfe\"\u003eThe \u003ccode\u003eUser\u003c/code\u003e class is final because Kotlin classes are final by default.\u003c/li\u003e\u003cli id=\"7441\"\u003eThe primary constructor is translated into a Java constructor.\u003c/li\u003e\u003cli id=\"a2f0\"\u003e\u003ccode\u003egetName()\u003c/code\u003e and \u003ccode\u003egetAge()\u003c/code\u003e methods provide access to these properties.\u003c/li\u003e\u003cli id=\"4b2e\"\u003eThe \u003ccode\u003e@NotNull\u003c/code\u003e annotation indicates that \u003ccode\u003ename\u003c/code\u003e cannot be null, ensuring safety.\u003c/li\u003e\u003cli id=\"b2e5\"\u003eThere are no setter methods since the properties are defined as immutable in the constructor.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"1ceb\"\u003eLet’s discuss the \u003ccode\u003einit\u003c/code\u003e block.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2ebd\"\u003eclass User(val name: String, val age: Int) {\u003cbr/\u003e    init {\u003cbr/\u003e        println(\u0026#34;This is the first init block. Name: $name \u0026amp; Age: $age\u0026#34;)\u003cbr/\u003e    }\u003cp\u003e    init {\u003cbr/\u003e        println(\u0026#34;This is the second init block.\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"11ae\"\u003eHere’s the underlying Java code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fbc3\"\u003epublic final class User {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   private final String name;\u003cbr/\u003e   private final int age;\u003cp\u003e   @NotNull\u003cbr/\u003e   public final String getName() {\u003cbr/\u003e      return this.name;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public final int getAge() {\u003cbr/\u003e      return this.age;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public User(@NotNull String name, int age) {\u003cbr/\u003e      super();\u003cbr/\u003e      this.name = name;\u003cbr/\u003e      this.age = age;\u003cbr/\u003e      String var3 = \u0026#34;This is the first init block. Name: \u0026#34; + this.name + \u0026#34; \u0026amp; Age: \u0026#34; + this.age;\u003cbr/\u003e      System.out.println(var3);\u003cbr/\u003e      var3 = \u0026#34;This is the second init block.\u0026#34;;\u003cbr/\u003e      System.out.println(var3);\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9ac0\"\u003eSo, what do we observe here?\u003c/p\u003e\u003cul\u003e\u003cli id=\"8f37\"\u003eThe code from the \u003ccode\u003einit\u003c/code\u003e blocks is added to the primary constructor and executes after the properties in the constructor are initialized.\u003c/li\u003e\u003cli id=\"8e5d\"\u003eThe \u003ccode\u003einit\u003c/code\u003e blocks execute in the order they appear, right after the primary constructor and before any secondary constructors.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"267a\"\u003eWhen we create an instance of the \u003ccode\u003eUser\u003c/code\u003e class using \u003ccode\u003eUser(\u0026#34;Abhay\u0026#34;, 22)\u003c/code\u003e, the output will be:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a876\"\u003eThis is the first init block. Name: Abhay \u0026amp; Age: 22\u003cbr/\u003eThis is the second init block.\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"72e3\"\u003eLet’s explore the secondary constructor.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aeae\"\u003eclass User(val name: String, val age: Int){\u003cbr/\u003e    init {\u003cbr/\u003e        println(\u0026#34;This is the first init block. Name: $name \u0026amp; Age: $age\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    // secondary constructor\u003cbr/\u003e    constructor(name: String): this(name, 22){\u003cbr/\u003e        println(\u0026#34;This is the secondary constructor: Name: $name \u0026amp; Age: $age\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    init {\u003cbr/\u003e        println(\u0026#34;This is the second init block.\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e6c8\"\u003eHere’s the underlying Java code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a908\"\u003epublic final class User {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   private final String name;\u003cbr/\u003e   private final int age;\u003cp\u003e   @NotNull\u003cbr/\u003e   public final String getName() {\u003cbr/\u003e      return this.name;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public final int getAge() {\u003cbr/\u003e      return this.age;\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public User(@NotNull String name, int age) {\u003cbr/\u003e      super();\u003cbr/\u003e      this.name = name;\u003cbr/\u003e      this.age = age;\u003cbr/\u003e      String var3 = \u0026#34;This is the first init block. Name: \u0026#34; + this.name + \u0026#34; \u0026amp; Age: \u0026#34; + this.age;\u003cbr/\u003e      System.out.println(var3);\u003cbr/\u003e      var3 = \u0026#34;This is the second init block.\u0026#34;;\u003cbr/\u003e      System.out.println(var3);\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public User(@NotNull String name) {\u003cbr/\u003e      this(name, 22);\u003cbr/\u003e      String var2 = \u0026#34;This is the secondary constructor: Name: \u0026#34; + name + \u0026#34; \u0026amp; Age: \u0026#34; + this.age;\u003cbr/\u003e      System.out.println(var2);\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"960c\"\u003eA secondary constructor in Kotlin overloads the constructor in Java.\u003c/li\u003e\u003cli id=\"abea\"\u003eThe secondary constructor can call the primary constructor or another secondary constructor using \u003ccode\u003ethis()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"d9c1\"\u003eThe secondary constructor executes after all \u003ccode\u003einit\u003c/code\u003e blocks have been processed.\u003c/li\u003e\u003cli id=\"497e\"\u003eIn this example, when you create an instance of \u003ccode\u003eUser\u003c/code\u003e using the secondary constructor with just a name, it initializes the \u003ccode\u003eage\u003c/code\u003e property to a default value of 22.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a4e9\"\u003eWhen you create an instance of \u003ccode\u003eUser\u003c/code\u003e using the secondary constructor, as shown in the following code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3f55\"\u003efun main() {\u003cbr/\u003e    // Calling the secondary constructor\u003cbr/\u003e    User(\u0026#34;Abhay\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f6cc\"\u003eYou’ll get the output:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f53a\"\u003eThis is the first init block. Name: Abhay \u0026amp; Age: 22\u003cbr/\u003eThis is the second init block.\u003cbr/\u003eThis is the secondary constructor: Name: Abhay \u0026amp; Age: 22\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5cf9\"\u003eHere, you can see that all the \u003ccode\u003einit\u003c/code\u003e blocks are executed first, followed by the secondary constructor.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-10-16T12:09:59.096Z",
  "modifiedTime": null
}
