{
  "id": "584a3e94-a2ca-437d-bcf8-b902f56c6aab",
  "title": "Kotlin Tips and Tricks You May Not Know: #5 — Simplify Functional Composition with let",
  "link": "https://proandroiddev.com/kotlin-tips-and-tricks-you-may-not-know-5-simplify-functional-composition-with-let-0ae48d91c860?source=rss----c72404660798---4",
  "description": "",
  "author": "Elena van Engelen - Maslova",
  "published": "Mon, 16 Dec 2024 23:38:41 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "functional-programming",
    "java",
    "kotlin-beginners",
    "kotlin-scope-functions",
    "kotlin"
  ],
  "byline": "Elena van Engelen - Maslova",
  "length": 5577,
  "excerpt": "Use let scope function to make your functional composition easier to follow",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin Tips and Tricks You May Not Know: #5 — Simplify Functional Composition with letImprove your functional composition using the let scope functionIntroductionFunctional composition, that is, chaining simple functions into a more complex one, is a common practice in Kotlin. However, in doing this, you can end up with deeply nested code that makes it less readable and harder to maintain.Consider an example where you are calculating a product’s final price by applying a discount and adding shipping costs and tax. This can result in multiple nested function calls:val finalPrice = addTax( addShipping( applyDiscount( getProduct(123) ) ))While this structure works, it is difficult to follow or reason about. The let function simplifies functional composition, allowing functions to be called in the correct sequence and thus easier to read.In functional programming, functions are first-class citizens, meaning they can be passed, returned, and combined to form complex operations. Functional composition — chaining simple functions to create readable and testable workflows — is a key concept. As Kotlin Crash Course, Chapter 8: Functional programming explains, this style makes code modular and easier to maintain.In this article, you will learn how let can simplify functional composition in Kotlin and when to consider other scope functions.What is the let Function?Scope functions such as let allow you to execute a piece of code in the context of an object, making code more clear and concise. The following is an overview of how let works and its use cases:Purpose: let is primarily used to apply a transformation to an object or perform additional operations without modifying the object itself.Syntax: let takes a lambda with a context object (it), and returns the lambda’s result, allowing for further operations to be chained.Typical use cases:Data transformation: You can use the ⁣let function to transform data without changing the original object.Safe calls on nullable objects: If you have a nullable object and want to make a safe call, you can put the piece of code inside a let function and thus run it only if the context object is not null.Isolating logic: let can help you to visually isolate a chunk of logic that is associated with the context object, thus grouping it in a readable, maintainable way.Basic Usage of letSuppose you want to display a product’s details only if the product is not null:val product = getProduct(123)product?.let { val finalDetails = formatProductDetails(it) println(finalDetails)}In the above example, let is used to print product details if product is not null.How let Enhances Functional CompositionWhen performing more complex operations, using let can significantly improve the structure and clarity of your code. It permits not just the application of a function to the result of an expression but also taking that result and using it in subsequent expressions. The clean, cascading use of let allows expressions to flow one into another as if they were a series of dominoes falling in sequence. You can see this in action when considering a fairly typical and straightforward series of operations.Let us go back to the scenario where you have to:Fetch a productApply a discount to product’s priceAdd shipping costsAnd finally add taxWithout let (Nested Functional Composition):val finalPrice = addTax( addShipping( applyDiscount( getProduct(123) ) ))This nested structure works, but because each function is embedded within one another, the flow is harder to follow.val finalPrice = getProduct(123) .let(::applyDiscount) .let(::addShipping) .let(::addTax)This version shows a considerable improvement in readability. Using let in this way makes each transformation within functional composition explicit and sequential.When to Consider Other Scope Functions in Functional CompositionWhile let is excellent for chaining transformations, there are cases in functional composition where other scope functions may be more suitable, for instance when modifying properties of the same object within a chain:Use apply for Modifying Properties: If one of the functions in your chain needs to modify properties directly on the context object itself, apply is a better choice.Use also for Additional Actions: Use also to perform side-effect operations, like printing the final price, without altering the flow.Combine scope functions in Mixed Chains: Combine scope functions for more complex chains, such as using let for transformations and apply for configuration.Understanding when to use each scope function ensures your functional compositions in Kotlin are both clear and concise.ConclusionIn Kotlin, the ⁣let scope function can simplify functional composition and enhance code readability. By understanding when to use let and how to structure transformation chains, you can write cleaner, more expressive code that aligns with functional programming principles.For hands-on, in-depth guidance on when and how to use scope functions like let, apply, also, run, and with, see Chapter 7 of Kotlin Crash Course.Tip RecapUse let to Simplify Functional Composition: let is a great choice for chaining transformations in a readable way. By isolating each step, you create a clear flow that is easier to follow.Avoid let for Property Modifications: When the goal is to modify properties of an object, consider using apply instead, as it is designed for object property modifications.For more Kotlin tips and tricks, visit my Medium blog homepage.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*rTFrwaUwwTN7PAUFWR3ASA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"09f5\" data-testid=\"storyTitle\"\u003e\u003cstrong\u003eKotlin Tips and Tricks You May Not Know: #5 — Simplify Functional Composition with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003elet\u003c/strong\u003e\u003c/code\u003e\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"2ef8\"\u003eImprove your functional composition using the \u003ccode\u003elet\u003c/code\u003e scope function\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@elenavanengelen?source=post_page---byline--0ae48d91c860--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Elena van Engelen - Maslova\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*N-t_FroIxVl5WDVcCO45jw@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--0ae48d91c860--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"ee0a\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"8d4d\"\u003eFunctional composition, that is, chaining simple functions into a more complex one, is a common practice in Kotlin. However, in doing this, you can end up with deeply nested code that makes it less readable and harder to maintain.\u003c/p\u003e\u003cp id=\"21b1\"\u003eConsider an example where you are calculating a product’s final price by applying a discount and adding shipping costs and tax. This can result in multiple nested function calls:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9dd0\"\u003eval finalPrice = addTax(\u003cbr/\u003e    addShipping(\u003cbr/\u003e        applyDiscount(\u003cbr/\u003e            getProduct(123)\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7cba\"\u003eWhile this structure works, it is difficult to follow or reason about. The \u003ccode\u003elet\u003c/code\u003e function simplifies functional composition, allowing functions to be called in the correct sequence and thus easier to read.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"8250\"\u003eIn functional programming, functions are first-class citizens, meaning they can be passed, returned, and combined to form complex operations. Functional composition — chaining simple functions to create readable and testable workflows — is a key concept. As\u003cem\u003e \u003c/em\u003e\u003ca href=\"https://www.amazon.com/dp/9355516304\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Crash Course, Chapter 8: Functional programming\u003c/a\u003e explains, this style makes code modular and easier to maintain.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"40d4\"\u003eIn this article, you will learn how \u003ccode\u003elet\u003c/code\u003e can simplify functional composition in Kotlin and when to consider other scope functions.\u003c/p\u003e\u003ch2 id=\"a530\"\u003eWhat is the \u003ccode\u003elet\u003c/code\u003e Function?\u003c/h2\u003e\u003cp id=\"b19c\"\u003eScope functions such as \u003ccode\u003elet\u003c/code\u003e allow you to execute a piece of code in the context of an object, making code more clear and concise. The following is an overview of how \u003ccode\u003elet\u003c/code\u003e works and its use cases:\u003c/p\u003e\u003cp id=\"c7ab\"\u003e\u003cstrong\u003ePurpose\u003c/strong\u003e: \u003ccode\u003elet\u003c/code\u003e is primarily used to apply a transformation to an object or perform additional operations without modifying the object itself.\u003c/p\u003e\u003cp id=\"95c4\"\u003e\u003cstrong\u003eSyntax\u003c/strong\u003e: \u003ccode\u003elet\u003c/code\u003e takes a lambda with a context object (\u003ccode\u003eit\u003c/code\u003e), and returns the lambda’s result, allowing for further operations to be chained.\u003c/p\u003e\u003cp id=\"8211\"\u003e\u003cstrong\u003eTypical use cases\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6395\"\u003e\u003cstrong\u003eData transformation\u003c/strong\u003e: You can use the ⁣\u003ccode\u003elet\u003c/code\u003e function to transform data without changing the original object.\u003c/li\u003e\u003cli id=\"90af\"\u003e\u003cstrong\u003eSafe calls on nullable objects\u003c/strong\u003e: If you have a nullable object and want to make a safe call, you can put the piece of code inside a let function and thus run it only if the context object is not null.\u003c/li\u003e\u003cli id=\"f111\"\u003e\u003cstrong\u003eIsolating logic\u003c/strong\u003e: \u003ccode\u003elet\u003c/code\u003e can help you to visually isolate a chunk of logic that is associated with the context object, thus grouping it in a readable, maintainable way.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5be9\"\u003eBasic Usage of \u003ccode\u003elet\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"8544\"\u003eSuppose you want to display a product’s details only if the product is not null:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df39\"\u003eval product = getProduct(123)\u003cbr/\u003eproduct?.let {\u003cbr/\u003e    val finalDetails = formatProductDetails(it)\u003cbr/\u003e    println(finalDetails)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f3c9\"\u003eIn the above example, \u003ccode\u003elet\u003c/code\u003e is used to print product details if \u003ccode\u003eproduct\u003c/code\u003e is not null.\u003c/p\u003e\u003ch2 id=\"43c2\"\u003eHow \u003ccode\u003elet\u003c/code\u003e Enhances Functional Composition\u003c/h2\u003e\u003cp id=\"03b6\"\u003eWhen performing more complex operations, using \u003ccode\u003elet\u003c/code\u003e can significantly improve the structure and clarity of your code. It permits not just the application of a function to the result of an expression but also taking that result and using it in subsequent expressions. The clean, cascading use of \u003ccode\u003elet\u003c/code\u003e allows expressions to flow one into another as if they were a series of dominoes falling in sequence. You can see this in action when considering a fairly typical and straightforward series of operations.\u003c/p\u003e\u003cp id=\"9673\"\u003eLet us go back to the scenario where you have to:\u003c/p\u003e\u003col\u003e\u003cli id=\"eb19\"\u003eFetch a product\u003c/li\u003e\u003cli id=\"0ef0\"\u003eApply a discount to product’s price\u003c/li\u003e\u003cli id=\"38d7\"\u003eAdd shipping costs\u003c/li\u003e\u003cli id=\"4ea2\"\u003eAnd finally add tax\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"2f7b\"\u003eWithout \u003ccode\u003elet\u003c/code\u003e (Nested Functional Composition):\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"62da\"\u003eval finalPrice = addTax(\u003cbr/\u003e    addShipping(\u003cbr/\u003e        applyDiscount(\u003cbr/\u003e            getProduct(123)\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"91ed\"\u003eThis nested structure works, but because each function is embedded within one another, the flow is harder to follow.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7d49\"\u003eval finalPrice = getProduct(123)\u003cbr/\u003e    .let(::applyDiscount)\u003cbr/\u003e    .let(::addShipping)\u003cbr/\u003e    .let(::addTax)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3d81\"\u003eThis version shows a considerable improvement in readability. Using \u003ccode\u003elet\u003c/code\u003e in this way makes each transformation within functional composition explicit and sequential.\u003c/p\u003e\u003ch2 id=\"2058\"\u003eWhen to Consider Other Scope Functions in Functional Composition\u003c/h2\u003e\u003cp id=\"0217\"\u003eWhile \u003ccode\u003elet\u003c/code\u003e is excellent for chaining transformations, there are cases in functional composition where other scope functions may be more suitable, for instance when modifying properties of the same object within a chain:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a259\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eapply\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for Modifying Properties\u003c/strong\u003e: If one of the functions in your chain needs to modify properties directly on the context object itself, \u003ccode\u003eapply\u003c/code\u003e is a better choice.\u003c/li\u003e\u003cli id=\"df38\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ealso\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for Additional Actions:\u003c/strong\u003e Use \u003ccode\u003ealso\u003c/code\u003e to perform side-effect operations, like printing the final price, without altering the flow.\u003c/li\u003e\u003cli id=\"42a0\"\u003e\u003cstrong\u003eCombine scope functions in Mixed Chains\u003c/strong\u003e: Combine scope functions for more complex chains, such as using \u003ccode\u003elet\u003c/code\u003e for transformations and \u003ccode\u003eapply\u003c/code\u003e for configuration.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"209c\"\u003eUnderstanding when to use each scope function ensures your functional compositions in Kotlin are both clear and concise.\u003c/p\u003e\u003ch2 id=\"9b21\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"268c\"\u003eIn Kotlin, the ⁣\u003ccode\u003elet\u003c/code\u003e scope function can simplify functional composition and enhance code readability. By understanding when to use \u003ccode\u003elet\u003c/code\u003e and how to structure transformation chains, you can write cleaner, more expressive code that aligns with functional programming principles.\u003c/p\u003e\u003cp id=\"198d\"\u003eFor hands-on, in-depth guidance on when and how to use scope functions like \u003ccode\u003elet\u003c/code\u003e, \u003ccode\u003eapply\u003c/code\u003e, \u003ccode\u003ealso\u003c/code\u003e, \u003ccode\u003erun\u003c/code\u003e, and \u003ccode\u003ewith\u003c/code\u003e, see \u003ca href=\"https://www.amazon.com/dp/9355516304\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChapter 7 of Kotlin Crash Course\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"6775\"\u003eTip Recap\u003c/h2\u003e\u003cul\u003e\u003cli id=\"c051\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003elet\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e to Simplify Functional Composition\u003c/strong\u003e: \u003ccode\u003elet\u003c/code\u003e is a great choice for chaining transformations in a readable way. By isolating each step, you create a clear flow that is easier to follow.\u003c/li\u003e\u003cli id=\"86f7\"\u003e\u003cstrong\u003eAvoid \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003elet\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for Property Modifications\u003c/strong\u003e: When the goal is to modify properties of an object, consider using \u003ccode\u003eapply\u003c/code\u003e instead, as it is designed for object property modifications.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1f81\"\u003eFor more Kotlin tips and tricks, visit my \u003ca href=\"https://medium.com/@elenavanengelen\" rel=\"noopener\"\u003eMedium blog homepage\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-11-23T09:19:59.682Z",
  "modifiedTime": null
}
