{
  "id": "e662a95c-fedd-4740-9b1d-9b08b2ac7b44",
  "title": "Mobile System Design‚Ää‚Äî‚ÄäInstagram Stories",
  "link": "https://proandroiddev.com/mobile-system-design-instagram-stories-786e910d17a6?source=rss----c72404660798---4",
  "description": "",
  "author": "Rahul Ray",
  "published": "Wed, 16 Jul 2025 01:58:28 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "instagram-stories",
    "mobile-app-development",
    "android",
    "system-design-interview",
    "programming"
  ],
  "byline": "Rahul Ray",
  "length": 9950,
  "excerpt": "Modern social apps rely heavily on ephemeral, media‚Äërich features. Instagram Stories is a marquee example: it must feel snappy, work offline, handle millions of users, and recover from network‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "üöÄ Mobile System Design ‚Äî Instagram StoriesModern social apps rely heavily on ephemeral, media‚Äërich features. Instagram Stories is a marquee example: it must feel snappy, work offline, handle millions of users, and recover from network glitches. Here‚Äôs how you can architect such a system for mobile-first environments.üì∫ Watch the video explanation on Youtube1. üéØ RequirementsBefore drawing any boxes, we define what the system must do and how it must behave under load, poor connectivity, and stringent SLAs.1.1 Functional RequirementsCapture \u0026 EditWhy? Users expect in‚Äëapp filters, stickers, and text overlays.Key Challenges: GPU‚Äëaccelerated image/video pipelines, handling device rotations or interruptions (phone calls), and previewing changes in real time.Segmented UploadWhy? Limiting segment length to 15 s keeps uploads manageable, enables resumability.Key Challenges: Splitting without re‚Äëencoding every frame (zero‚Äëcopy slicing), handling out‚Äëof‚Äëorder uploads, merging segment metadata.Offline Draft \u0026 RetryWhy? Mobile users often lose connectivity; the feature must be reliable.Key Challenges: Persisting drafts across app restarts, scheduling background jobs that respect OS battery modes (Doze on Android), avoiding data corruption.Paginated FetchWhy? Stories could be numerous. Pagination keeps initial payload small.Key Challenges: Cursor vs offset pagination, handling new stories arriving mid‚Äëscroll, cache invalidation strategies.Smooth PlaybackWhy? Janky playback kills engagement.Key Challenges: Preloading via CDN, memory vs disk cache trade‚Äëoffs, frame‚Äëaccurate gesture responses (tap, swipe, long‚Äëpress).Ephemeral ExpiryWhy? Stories vanish after 24 h by design.Key Challenges: Syncing client cache eviction with server TTL, avoiding stale content, handling offline expiry.Analytics \u0026 View TrackingWhy? Creators need insights; product needs metrics.Key Challenges: Real‚Äëtime vs batch, ensuring no data loss on app kill, GDPR/privacy compliance.1.2 Non‚ÄëFunctional RequirementsLow Latency: ‚â§ 200 ms story load. Achieved via aggressive prefetch and cache-first logic.High Throughput: Scales to hundreds of stories per user, millions of concurrent viewers.Reliability: ‚â• 99.9% uptime; robust retries via WorkManager.Efficiency: Battery‚Äëaware prefetch; batch analytics to reduce radio wakeups.Security \u0026 Privacy: Signed CDN URLs, HTTPS, token auth, minimal PII in payloads.Consistency: Cache coherence with server state ‚Äî draft vs published vs expired.Interview Tip: Always start by scoping requirements. Ask clarifying questions (e.g., expected user base, network assumptions) and map non‚Äëfunctional needs back to design decisions.2. üîÑ Data Flow Diagram (DFD)A DFD shows data movement ‚Äî it‚Äôs distinct from component diagrams, focusing on the journey rather than the structure.Upload FlowCapture UI triggers segmentation \u0026 enqueues to UploadManager.WorkManager jobs upload each chunk to Media API.On all‚Äësuccess, Metadata API persists story metadata.StoryCache is updated for immediate local visibility.Fetch \u0026 Playback FlowStoryFeedViewModel fetches pages of metadata via StoryRepository.If cached, return immediately; else fetch from network.PrefetchManager downloads upcoming media segments from CDN.StoryViewer renders from local cache or in‚Äëflight network streams.Analytics FlowViewTracker logs view events in memory.Periodic or threshold‚Äëtriggered flush to Analytics API.Pro Tip: In interviews, draw the DFD first to establish a shared understanding of flows before diving into components.3. üèóÔ∏è High‚ÄëLevel Design (HLD)We layer our architecture to isolate concerns and facilitate testing.UI Layer: Composables/Views for capture, feed, and playback.ViewModel Layer: Holds screen state, initiates use cases.UseCase Layer: Orchestrates business logic (e.g., file splitting, fetch strategy).Repository Layer: Mediates between cache, network, and upload manager.Infrastructure Layer:UploadManager: background segmented uploads (WorkManager).CacheManager: Room/MMKV, TTL eviction.PrefetchManager: smart preloading over Wi‚ÄëFi.ViewTracker: batching analytics.NetworkManager: Retrofit with interceptors for auth and signed URLs.Backend Services: REST or gRPC endpoints.Why Clean Architecture? It enforces the Dependency Rule (inner layers don‚Äôt depend on outer), enabling independent evolution and testability.4. ‚öôÔ∏è Low‚ÄëLevel Design (LLD)LLD dives into the classes, interfaces, and methods that make the HLD concrete.4.1 Domain LayerPure models without framework deps ensure portability (e.g., server, tests).data class Story( val id: String, val userId: String, val segments: List\u003cStorySegment\u003e, val createdAt: Instant, val expiresAt: Instant)data class StorySegment( val segmentId: String, val mediaUrl: String, val sequence: Int, val mediaType: MediaType)enum class MediaType { IMAGE, VIDEO }4.2 Data LayerDTOs mirror backend contracts; use codegen (Moshi/Gson) for serialization.data class StoryMetadata( val storyId: String, val userId: String, val segments: List\u003cSegmentMeta\u003e, val createdAt: Instant, val expiresAt: Instant)data class SegmentMeta( val filename: String, val sequence: Int, val mediaType: MediaType)4.3 ViewModel LayerExpose immutable state flows, collect in UI; no direct network calls here.class UploadStoryViewModel( private val uploadUseCase: UploadStoryUseCase) : ViewModel() { val uploadState = MutableStateFlow\u003cUploadStatus\u003e(Idle) fun upload(files: List\u003cFile\u003e, metadata: StoryMetadata) { /*‚Ä¶*/ }}class StoryFeedViewModel( private val fetchUseCase: FetchStoriesUseCase) : ViewModel() { val stories = MutableStateFlow\u003cList\u003cStory\u003e\u003e(emptyList()) fun loadMore() { /*‚Ä¶*/ }}4.4 UseCase LayerEncapsulate orchestration, keep ViewModel lean, test logic easily.class UploadStoryUseCase( private val repo: StoryRepository) { suspend operator fun invoke(files: List\u003cFile\u003e, meta: StoryMetadata): Result\u003cUnit\u003e { return repo.uploadStory(files, meta) }}class FetchStoriesUseCase( private val repo: StoryRepository) { suspend operator fun invoke(): List\u003cStory\u003e = repo.fetchStories()}4.5 Repository LayerSingle source of truth; merges cache/network results; delegates upload to infra.interface StoryRepository { suspend fun fetchStories(): List\u003cStory\u003e suspend fun uploadStory(files: List\u003cFile\u003e, meta: StoryMetadata): Result\u003cUnit\u003e fun observeStories(): Flow\u003cList\u003cStory\u003e\u003e}class StoryRepositoryImpl( private val api: StoryApi, private val cache: StoryCache, private val uploadMgr: UploadManager) : StoryRepository { override suspend fun fetchStories(): List\u003cStory\u003e { val local = cache.getStories() val remote = api.getStories() cache.saveStories(remote) return local + (remote ‚Äì local) } override suspend fun uploadStory(files: List\u003cFile\u003e, meta: StoryMetadata): Result\u003cUnit\u003e { uploadMgr.enqueueUpload(files, meta) return Result.success(Unit) }}4.6 UploadManagerUses Android WorkManager.Defines a OneTimeWorkRequest with BackoffPolicy.EXPONENTIAL.Worker uploads each chunk, commits metadata on success.Survives app kill, OS Doze, and network flakiness.class UploadWorker( context: Context, params: WorkerParameters) : CoroutineWorker(context, params) { override suspend fun doWork(): Result { val files = getInputFileList() val metadata = getMetadata() return try { val api = provideStoryApi() files.forEachIndexed { index, file -\u003e val part = file.toMultipart(\"segment_$index\") api.uploadSegment(part, sequence = index) } api.commitStory(StoryCommitRequest(metadata)) Result.success() } catch (e: Exception) { Result.retry() } }}4.7 CacheManager \u0026 PrefetchManagerCacheManager: Room DB + optional encrypted MMKV.TTL Eviction: SQL query deleting rows where expiresAt \u003c now().PrefetchManager: Downloads next n segments on Wi‚ÄëFi; uses OkHttp with priority.4.8 ViewTrackerReduces round‚Äëtrips, groups events to preserve battery.class ViewTracker(private val api: StoryApi) { private val buffer = mutableListOf\u003cViewEvent\u003e() fun track(event: ViewEvent) { buffer += event; if (buffer.size \u003e= 10) flush() } fun flush() = coroutineScope.launch { api.postViewEvents(buffer.toList()); buffer.clear() }}5. üß™ Design Trade‚Äëoffs \u0026 AlternativesCache‚ÄëFirst vs Network‚ÄëFirstWe chose cache‚Äëfirst to minimize load latency and avoid cold starts.Alternative: Network‚Äëfirst for always fresh data, with stale‚Äëwhile‚Äërevalidate UX.WorkManager vs Foreground ServiceWorkManager handles persistent, deferred tasks across device restarts.Foreground Service could provide real‚Äëtime progress, but at a UX cost (persistent notification).Prefetch ThresholdPrefetch next 2‚Äì3 stories for smooth UX.Too many prefetches wastes bandwidth; too few causes stalls.Batch Size for View EventsBatch of 10 events or 30 seconds interval.Balance between data freshness and mobile efficiency.Signed URLs SecuritySigned URLs embed expiry timestamps; prevents URL tampering.Alternative: Proxy through the app server (incurs extra latency).6. üéØ Interview‚ÄëReady TipsStart with Requirements. Repeat back what the interviewer said; ask clarifications (scale, locality, offline).Draw your DFD first. It shows you understand data interactions before naming components.Emphasise Clean Architecture. Mention Dependency Rule, testability, and independent deployments.Highlight Mobile‚ÄëSpecific Concerns. Offline support, battery, heat, background tasks, OS restrictions.Map Requirements to Your Design. Show traceability and intentionality.Discuss Trade‚Äëoffs. No design is free ‚Äî articulate the cost of each choice.üéâ ConclusionBy following this layered approach, Instagram Stories can be delivered with sub‚Äë200 ms load times, handle intermittent connectivity, scale to millions, and keep the user experience buttery smooth.Use this guide to wow your interviewers or to architect your next real-time, ephemeral feature with confidence.üîó Connect with me:LinkedIn ¬∑ Twitter ¬∑ Book a 1:1 session",
  "image": "https://miro.medium.com/v2/resize:fit:610/1*hw34v_0nKOJd0VVj6RBlmA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"692f\" data-testid=\"storyTitle\"\u003eüöÄ Mobile System Design ‚Äî Instagram Stories\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://rahul9650ray.medium.com/?source=post_page---byline--786e910d17a6---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Rahul Ray\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*UcWvM8PK5gRHTME0JM1dsQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"9b8f\"\u003eModern social apps rely heavily on ephemeral, media‚Äërich features. Instagram Stories is a marquee example: it must feel snappy, work offline, handle millions of users, and recover from network glitches. Here‚Äôs how you can architect such a system for mobile-first environments.\u003c/p\u003e\u003cp id=\"b9ab\"\u003eüì∫ \u003cstrong\u003eWatch the video explanation on Youtube\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"427c\"\u003e1. üéØ Requirements\u003c/h2\u003e\u003cp id=\"bb2e\"\u003eBefore drawing any boxes, we define \u003cstrong\u003ewhat\u003c/strong\u003e the system must do and \u003cstrong\u003ehow\u003c/strong\u003e it must behave under load, poor connectivity, and stringent SLAs.\u003c/p\u003e\u003ch2 id=\"949b\"\u003e1.1 Functional Requirements\u003c/h2\u003e\u003col\u003e\u003cli id=\"23c5\"\u003e\u003cstrong\u003eCapture \u0026amp; Edit\u003cbr/\u003eWhy?\u003c/strong\u003e Users expect in‚Äëapp filters, stickers, and text overlays.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e GPU‚Äëaccelerated image/video pipelines, handling device rotations or interruptions (phone calls), and previewing changes in real time.\u003c/li\u003e\u003cli id=\"4291\"\u003e\u003cstrong\u003eSegmented Upload\u003cbr/\u003eWhy?\u003c/strong\u003e Limiting segment length to 15 s keeps uploads manageable, enables resumability.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Splitting without re‚Äëencoding every frame (zero‚Äëcopy slicing), handling out‚Äëof‚Äëorder uploads, merging segment metadata.\u003c/li\u003e\u003cli id=\"d013\"\u003e\u003cstrong\u003eOffline Draft \u0026amp; Retry\u003cbr/\u003eWhy?\u003c/strong\u003e Mobile users often lose connectivity; the feature must be reliable.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Persisting drafts across app restarts, scheduling background jobs that respect OS battery modes (Doze on Android), avoiding data corruption.\u003c/li\u003e\u003cli id=\"58da\"\u003e\u003cstrong\u003ePaginated Fetch\u003cbr/\u003eWhy?\u003c/strong\u003e Stories could be numerous. Pagination keeps initial payload small.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Cursor vs offset pagination, handling new stories arriving mid‚Äëscroll, cache invalidation strategies.\u003c/li\u003e\u003cli id=\"aefe\"\u003e\u003cstrong\u003eSmooth Playback\u003cbr/\u003eWhy?\u003c/strong\u003e Janky playback kills engagement.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Preloading via CDN, memory vs disk cache trade‚Äëoffs, frame‚Äëaccurate gesture responses (tap, swipe, long‚Äëpress).\u003c/li\u003e\u003cli id=\"f1d7\"\u003e\u003cstrong\u003eEphemeral Expiry\u003cbr/\u003eWhy?\u003c/strong\u003e Stories vanish after 24 h by design.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Syncing client cache eviction with server TTL, avoiding stale content, handling offline expiry.\u003c/li\u003e\u003cli id=\"7262\"\u003e\u003cstrong\u003eAnalytics \u0026amp; View Tracking\u003cbr/\u003eWhy?\u003c/strong\u003e Creators need insights; product needs metrics.\u003cbr/\u003e\u003cstrong\u003eKey Challenges:\u003c/strong\u003e Real‚Äëtime vs batch, ensuring no data loss on app kill, GDPR/privacy compliance.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"b4d5\"\u003e1.2 Non‚ÄëFunctional Requirements\u003c/h2\u003e\u003cul\u003e\u003cli id=\"9764\"\u003e\u003cstrong\u003eLow Latency:\u003c/strong\u003e ‚â§ 200 ms story load. Achieved via aggressive prefetch and cache-first logic.\u003c/li\u003e\u003cli id=\"fc41\"\u003e\u003cstrong\u003eHigh Throughput:\u003c/strong\u003e Scales to hundreds of stories per user, millions of concurrent viewers.\u003c/li\u003e\u003cli id=\"674f\"\u003e\u003cstrong\u003eReliability:\u003c/strong\u003e ‚â• 99.9% uptime; robust retries via WorkManager.\u003c/li\u003e\u003cli id=\"0ddb\"\u003e\u003cstrong\u003eEfficiency:\u003c/strong\u003e Battery‚Äëaware prefetch; batch analytics to reduce radio wakeups.\u003c/li\u003e\u003cli id=\"f78c\"\u003e\u003cstrong\u003eSecurity \u0026amp; Privacy:\u003c/strong\u003e Signed CDN URLs, HTTPS, token auth, minimal PII in payloads.\u003c/li\u003e\u003cli id=\"e084\"\u003e\u003cstrong\u003eConsistency:\u003c/strong\u003e Cache coherence with server state ‚Äî draft vs published vs expired.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"611d\"\u003e\u003cstrong\u003e\u003cem\u003eInterview Tip:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e Always start by scoping requirements. Ask clarifying questions (e.g., expected user base, network assumptions) and map non‚Äëfunctional needs back to design decisions.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"3a63\"\u003e2. üîÑ Data Flow Diagram (DFD)\u003c/h2\u003e\u003cp id=\"4473\"\u003eA DFD shows \u003cstrong\u003edata movement\u003c/strong\u003e ‚Äî it‚Äôs distinct from component diagrams, focusing on the journey rather than the structure.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e31c\"\u003e\u003cstrong\u003eUpload Flow\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"a25f\"\u003e\u003cstrong\u003eCapture UI\u003c/strong\u003e triggers segmentation \u0026amp; enqueues to UploadManager.\u003c/li\u003e\u003cli id=\"9165\"\u003e\u003cstrong\u003eWorkManager\u003c/strong\u003e jobs upload each chunk to Media API.\u003c/li\u003e\u003cli id=\"3da3\"\u003eOn all‚Äësuccess, \u003cstrong\u003eMetadata API\u003c/strong\u003e persists story metadata.\u003c/li\u003e\u003cli id=\"50dd\"\u003e\u003cstrong\u003eStoryCache\u003c/strong\u003e is updated for immediate local visibility.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"e8b3\"\u003e\u003cstrong\u003eFetch \u0026amp; Playback Flow\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"77bf\"\u003e\u003cstrong\u003eStoryFeedViewModel\u003c/strong\u003e fetches pages of metadata via StoryRepository.\u003c/li\u003e\u003cli id=\"53a5\"\u003eIf cached, return immediately; else fetch from network.\u003c/li\u003e\u003cli id=\"0349\"\u003e\u003cstrong\u003ePrefetchManager\u003c/strong\u003e downloads upcoming media segments from CDN.\u003c/li\u003e\u003cli id=\"43bf\"\u003e\u003cstrong\u003eStoryViewer\u003c/strong\u003e renders from local cache or in‚Äëflight network streams.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"78c8\"\u003e\u003cstrong\u003eAnalytics Flow\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"d526\"\u003e\u003cstrong\u003eViewTracker\u003c/strong\u003e logs view events in memory.\u003c/li\u003e\u003cli id=\"f2b0\"\u003ePeriodic or threshold‚Äëtriggered flush to Analytics API.\u003c/li\u003e\u003c/ol\u003e\u003cblockquote\u003e\u003cp id=\"7006\"\u003e\u003cstrong\u003e\u003cem\u003ePro Tip:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e In interviews, draw the DFD first to establish a shared understanding of flows before diving into components.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b532\"\u003e3. üèóÔ∏è High‚ÄëLevel Design (HLD)\u003c/h2\u003e\u003cp id=\"b807\"\u003eWe layer our architecture to isolate concerns and facilitate testing.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"d1a1\"\u003e\u003cstrong\u003eUI Layer:\u003c/strong\u003e Composables/Views for capture, feed, and playback.\u003c/li\u003e\u003cli id=\"1367\"\u003e\u003cstrong\u003eViewModel Layer:\u003c/strong\u003e Holds screen state, initiates use cases.\u003c/li\u003e\u003cli id=\"819e\"\u003e\u003cstrong\u003eUseCase Layer:\u003c/strong\u003e Orchestrates business logic (e.g., file splitting, fetch strategy).\u003c/li\u003e\u003cli id=\"199c\"\u003e\u003cstrong\u003eRepository Layer:\u003c/strong\u003e Mediates between cache, network, and upload manager.\u003c/li\u003e\u003cli id=\"d085\"\u003e\u003cstrong\u003eInfrastructure Layer:\u003cbr/\u003eUploadManager\u003c/strong\u003e: background segmented uploads (WorkManager).\u003cbr/\u003e\u003cstrong\u003eCacheManager\u003c/strong\u003e: Room/MMKV, TTL eviction.\u003cbr/\u003e\u003cstrong\u003ePrefetchManager\u003c/strong\u003e: smart preloading over Wi‚ÄëFi.\u003cbr/\u003e\u003cstrong\u003eViewTracker\u003c/strong\u003e: batching analytics.\u003cbr/\u003e\u003cstrong\u003eNetworkManager\u003c/strong\u003e: Retrofit with interceptors for auth and signed URLs.\u003c/li\u003e\u003cli id=\"6626\"\u003e\u003cstrong\u003eBackend Services:\u003c/strong\u003e REST or gRPC endpoints.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"cdca\"\u003e\u003cstrong\u003e\u003cem\u003eWhy Clean Architecture?\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e It enforces the Dependency Rule (inner layers don‚Äôt depend on outer), enabling independent evolution and testability.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6c6c\"\u003e4. ‚öôÔ∏è Low‚ÄëLevel Design (LLD)\u003c/h2\u003e\u003cp id=\"0c94\"\u003eLLD dives into the classes, interfaces, and methods that make the HLD concrete.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a26a\"\u003e4.1 Domain Layer\u003c/h2\u003e\u003cp id=\"16e7\"\u003ePure models without framework deps ensure portability (e.g., server, tests).\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"57b5\"\u003edata class Story(\u003cbr/\u003e  val id: String,\u003cbr/\u003e  val userId: String,\u003cbr/\u003e  val segments: List\u0026lt;StorySegment\u0026gt;,\u003cbr/\u003e  val createdAt: Instant,\u003cbr/\u003e  val expiresAt: Instant\u003cbr/\u003e)\u003cbr/\u003edata class StorySegment(\u003cbr/\u003e  val segmentId: String,\u003cbr/\u003e  val mediaUrl: String,\u003cbr/\u003e  val sequence: Int,\u003cbr/\u003e  val mediaType: MediaType\u003cbr/\u003e)\u003cbr/\u003eenum class MediaType { IMAGE, VIDEO }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"322e\"\u003e4.2 Data Layer\u003c/h2\u003e\u003cp id=\"f773\"\u003eDTOs mirror backend contracts; use codegen (Moshi/Gson) for serialization.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1a88\"\u003edata class StoryMetadata(\u003cbr/\u003e  val storyId: String,\u003cbr/\u003e  val userId: String,\u003cbr/\u003e  val segments: List\u0026lt;SegmentMeta\u0026gt;,\u003cbr/\u003e  val createdAt: Instant,\u003cbr/\u003e  val expiresAt: Instant\u003cbr/\u003e)\u003cp\u003edata class SegmentMeta(\u003cbr/\u003e  val filename: String,\u003cbr/\u003e  val sequence: Int,\u003cbr/\u003e  val mediaType: MediaType\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c4d7\"\u003e4.3 ViewModel Layer\u003c/h2\u003e\u003cp id=\"10bb\"\u003eExpose immutable state flows, collect in UI; no direct network calls here.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f519\"\u003eclass UploadStoryViewModel(\u003cbr/\u003e  private val uploadUseCase: UploadStoryUseCase\u003cbr/\u003e) : ViewModel() {\u003cbr/\u003e  val uploadState = MutableStateFlow\u0026lt;UploadStatus\u0026gt;(Idle)\u003cbr/\u003e  fun upload(files: List\u0026lt;File\u0026gt;, metadata: StoryMetadata) { /*‚Ä¶*/ }\u003cbr/\u003e}\u003cp\u003eclass StoryFeedViewModel(\u003cbr/\u003e  private val fetchUseCase: FetchStoriesUseCase\u003cbr/\u003e) : ViewModel() {\u003cbr/\u003e  val stories = MutableStateFlow\u0026lt;List\u0026lt;Story\u0026gt;\u0026gt;(emptyList())\u003cbr/\u003e  fun loadMore() { /*‚Ä¶*/ }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c36e\"\u003e4.4 UseCase Layer\u003c/h2\u003e\u003cp id=\"3309\"\u003eEncapsulate orchestration, keep ViewModel lean, test logic easily.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0929\"\u003eclass UploadStoryUseCase(\u003cbr/\u003e  private val repo: StoryRepository\u003cbr/\u003e) {\u003cbr/\u003e  suspend operator fun invoke(files: List\u0026lt;File\u0026gt;, meta: StoryMetadata): Result\u0026lt;Unit\u0026gt; {\u003cbr/\u003e    return repo.uploadStory(files, meta)\u003cbr/\u003e  }\u003cbr/\u003e}\u003cp\u003eclass FetchStoriesUseCase(\u003cbr/\u003e  private val repo: StoryRepository\u003cbr/\u003e) {\u003cbr/\u003e  suspend operator fun invoke(): List\u0026lt;Story\u0026gt; = repo.fetchStories()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"43ee\"\u003e4.5 Repository Layer\u003c/h2\u003e\u003cp id=\"48fe\"\u003eSingle source of truth; merges cache/network results; delegates upload to infra.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"48e3\"\u003einterface StoryRepository {\u003cbr/\u003e  suspend fun fetchStories(): List\u0026lt;Story\u0026gt;\u003cbr/\u003e  suspend fun uploadStory(files: List\u0026lt;File\u0026gt;, meta: StoryMetadata): Result\u0026lt;Unit\u0026gt;\u003cbr/\u003e  fun observeStories(): Flow\u0026lt;List\u0026lt;Story\u0026gt;\u0026gt;\u003cbr/\u003e}\u003cp\u003eclass StoryRepositoryImpl(\u003cbr/\u003e  private val api: StoryApi,\u003cbr/\u003e  private val cache: StoryCache,\u003cbr/\u003e  private val uploadMgr: UploadManager\u003cbr/\u003e) : StoryRepository {\u003cbr/\u003e  override suspend fun fetchStories(): List\u0026lt;Story\u0026gt; {\u003cbr/\u003e    val local = cache.getStories()\u003cbr/\u003e    val remote = api.getStories()\u003cbr/\u003e    cache.saveStories(remote)\u003cbr/\u003e    return local + (remote ‚Äì local)\u003cbr/\u003e  }\u003cbr/\u003e  override suspend fun uploadStory(files: List\u0026lt;File\u0026gt;, meta: StoryMetadata): Result\u0026lt;Unit\u0026gt; {\u003cbr/\u003e    uploadMgr.enqueueUpload(files, meta)\u003cbr/\u003e    return Result.success(Unit)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e025\"\u003e4.6 UploadManager\u003c/h2\u003e\u003cp id=\"8ca6\"\u003e\u003cstrong\u003eUses\u003c/strong\u003e Android WorkManager.\u003cbr/\u003e\u003cstrong\u003eDefines\u003c/strong\u003e a \u003ccode\u003eOneTimeWorkRequest\u003c/code\u003e with \u003ccode\u003eBackoffPolicy.EXPONENTIAL\u003c/code\u003e.\u003cbr/\u003e\u003cstrong\u003eWorker\u003c/strong\u003e uploads each chunk, commits metadata on success.\u003cbr/\u003eSurvives app kill, OS Doze, and network flakiness.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1577\"\u003eclass UploadWorker(\u003cbr/\u003e    context: Context,\u003cbr/\u003e    params: WorkerParameters\u003cbr/\u003e) : CoroutineWorker(context, params) {\u003cp\u003e    override suspend fun doWork(): Result {\u003cbr/\u003e        val files = getInputFileList()\u003cbr/\u003e        val metadata = getMetadata()\u003c/p\u003e\u003cp\u003e        return try {\u003cbr/\u003e            val api = provideStoryApi()\u003cbr/\u003e            files.forEachIndexed { index, file -\u0026gt;\u003cbr/\u003e                val part = file.toMultipart(\u0026#34;segment_$index\u0026#34;)\u003cbr/\u003e                api.uploadSegment(part, sequence = index)\u003cbr/\u003e            }\u003cbr/\u003e            api.commitStory(StoryCommitRequest(metadata))\u003cbr/\u003e            Result.success()\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            Result.retry()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"89cc\"\u003e4.7 CacheManager \u0026amp; PrefetchManager\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a82d\"\u003e\u003cstrong\u003eCacheManager:\u003c/strong\u003e Room DB + optional encrypted MMKV.\u003c/li\u003e\u003cli id=\"3b84\"\u003e\u003cstrong\u003eTTL Eviction:\u003c/strong\u003e SQL query deleting rows where \u003ccode\u003eexpiresAt \u0026lt; now()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"ddb5\"\u003e\u003cstrong\u003ePrefetchManager:\u003c/strong\u003e Downloads next \u003ccode\u003en\u003c/code\u003e segments on Wi‚ÄëFi; uses OkHttp with priority.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f703\"\u003e4.8 ViewTracker\u003c/h2\u003e\u003cp id=\"22d3\"\u003eReduces round‚Äëtrips, groups events to preserve battery.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7391\"\u003eclass ViewTracker(private val api: StoryApi) {\u003cbr/\u003e  private val buffer = mutableListOf\u0026lt;ViewEvent\u0026gt;()\u003cbr/\u003e  fun track(event: ViewEvent) { buffer += event; if (buffer.size \u0026gt;= 10) flush() }\u003cbr/\u003e  fun flush() = coroutineScope.launch { api.postViewEvents(buffer.toList()); buffer.clear() }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"fdce\"\u003e5. üß™ Design Trade‚Äëoffs \u0026amp; Alternatives\u003c/h2\u003e\u003cp id=\"a5fd\"\u003e\u003cstrong\u003eCache‚ÄëFirst vs Network‚ÄëFirst\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9127\"\u003eWe chose cache‚Äëfirst to minimize load latency and avoid cold starts.\u003c/li\u003e\u003cli id=\"1e7d\"\u003eAlternative: Network‚Äëfirst for always fresh data, with stale‚Äëwhile‚Äërevalidate UX.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d573\"\u003e\u003cstrong\u003eWorkManager vs Foreground Service\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"3390\"\u003eWorkManager handles persistent, deferred tasks across device restarts.\u003c/li\u003e\u003cli id=\"3121\"\u003eForeground Service could provide real‚Äëtime progress, but at a UX cost (persistent notification).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"950f\"\u003e\u003cstrong\u003ePrefetch Threshold\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a608\"\u003ePrefetch next 2‚Äì3 stories for smooth UX.\u003c/li\u003e\u003cli id=\"3675\"\u003eToo many prefetches wastes bandwidth; too few causes stalls.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9696\"\u003e\u003cstrong\u003eBatch Size for View Events\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e59b\"\u003eBatch of 10 events or 30 seconds interval.\u003c/li\u003e\u003cli id=\"c5fb\"\u003eBalance between data freshness and mobile efficiency.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cfdc\"\u003e\u003cstrong\u003eSigned URLs Security\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"fa10\"\u003eSigned URLs embed expiry timestamps; prevents URL tampering.\u003c/li\u003e\u003cli id=\"02cc\"\u003eAlternative: Proxy through the app server (incurs extra latency).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a5f4\"\u003e6. üéØ Interview‚ÄëReady Tips\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e3df\"\u003e\u003cstrong\u003eStart with Requirements.\u003c/strong\u003e Repeat back what the interviewer said; ask clarifications (scale, locality, offline).\u003c/li\u003e\u003cli id=\"b4b0\"\u003e\u003cstrong\u003eDraw your DFD first.\u003c/strong\u003e It shows you understand data interactions before naming components.\u003c/li\u003e\u003cli id=\"0c04\"\u003e\u003cstrong\u003eEmphasise Clean Architecture.\u003c/strong\u003e Mention Dependency Rule, testability, and independent deployments.\u003c/li\u003e\u003cli id=\"5965\"\u003e\u003cstrong\u003eHighlight Mobile‚ÄëSpecific Concerns.\u003c/strong\u003e Offline support, battery, heat, background tasks, OS restrictions.\u003c/li\u003e\u003cli id=\"ced0\"\u003e\u003cstrong\u003eMap Requirements to Your Design.\u003c/strong\u003e Show traceability and intentionality.\u003c/li\u003e\u003cli id=\"4be1\"\u003e\u003cstrong\u003eDiscuss Trade‚Äëoffs.\u003c/strong\u003e No design is free ‚Äî articulate the cost of each choice.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"fa70\"\u003eüéâ Conclusion\u003c/h2\u003e\u003cp id=\"fe9d\"\u003eBy following this layered approach, Instagram Stories can be delivered with sub‚Äë200 ms load times, handle intermittent connectivity, scale to millions, and keep the user experience buttery smooth.\u003c/p\u003e\u003cp id=\"6b87\"\u003eUse this guide to \u003cstrong\u003ewow your interviewers\u003c/strong\u003e or to \u003cstrong\u003earchitect your next real-time, ephemeral feature\u003c/strong\u003e with confidence.\u003c/p\u003e\u003cp id=\"cf8f\"\u003eüîó \u003cstrong\u003eConnect with me:\u003cbr/\u003e\u003c/strong\u003e\u003ca href=\"https://www.linkedin.com/in/raystatic/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e ¬∑ \u003ca href=\"https://x.com/raystatic_\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTwitter\u003c/a\u003e ¬∑ \u003ca href=\"https://topmate.io/raystatic/465191\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBook a 1:1 session\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-06-28T21:44:35.575Z",
  "modifiedTime": null
}
