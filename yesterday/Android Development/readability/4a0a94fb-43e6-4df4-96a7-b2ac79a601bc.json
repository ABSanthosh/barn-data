{
  "id": "4a0a94fb-43e6-4df4-96a7-b2ac79a601bc",
  "title": "Avoid using Array in the data class constructor in Kotlin",
  "link": "https://proandroiddev.com/avoid-using-array-in-the-data-class-constructor-in-kotlin-ebc308e46a95?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Mon, 28 Apr 2025 13:49:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "best-practices",
    "androiddev",
    "android-app-development",
    "kotlin"
  ],
  "byline": "Anatolii Frolov",
  "length": 5903,
  "excerpt": "In a previous article, we discussed why using var in the constructor of a Kotlin data class can lead to unexpected behavior and subtle bugs. Now, let's look at another important detail that oftenâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image generated by the author using MidjourneyIn a previous article, we discussed why using var in the constructor of a Kotlin data class can lead to unexpected behavior and subtle bugs.Now, let's look at another important detail that often goes unnoticed:why you should avoid using Array types in the constructor of a data class.Kotlinâ€™s data class feature simplifies the creation of immutable models by automatically generating equals(), hashCode(), copy(), and toString() based on the primary constructor properties.For most use cases, this behavior works exactly as expected.However, when you use an Array as a property, the behavior of equals(), hashCode(), and toString() may not match your intentions.Instead of comparing the contents of the array, Kotlin (and Java) compare the object references.This can lead to subtle and hard-to-detect bugs â€” especially when your data classes are used in sets, maps, or caching systems.In this article, weâ€™ll see why using Array inside a data class constructor is risky, and what you should do instead.Working correctly with ListLetâ€™s start with a simple example where the friends property is a List inside a data class:data class Person( val name: String, val friends: List\u003cString\u003e)fun main() { val person1 = Person( name = \"Mike\", friends = listOf(\"Mary\", \"John\", \"Tom\") ) val person2 = Person( name = \"Mike\", friends = listOf(\"Mary\", \"John\", \"Tom\") ) println(person1 == person2)}Output:trueIn this case, the two Person instances are considered equal.This is because List in Kotlin overrides equals() and hashCode() to compare the contents of the list, not just the object references.Two lists are considered equal if:They contain the same elements,In the same order.As a result, Kotlinâ€™s generated equals() and hashCode() for the data class properly compare the friends list by value.Problem when using ArrayNow, letâ€™s modify the example slightly by changing the friends property to use an Array instead of a List:data class Person( val name: String, val friends: Array\u003cString\u003e)fun main() { val person1 = Person( name = \"Mike\", friends = arrayOf(\"Mary\", \"John\", \"Tom\") ) val person2 = Person( name = \"Mike\", friends = arrayOf(\"Mary\", \"John\", \"Tom\") ) println(person1 == person2)}Output:falseEven though both Person instances have the same name and the same friends, the comparison returns false.This happens because Array in Kotlin (and Java) does not override equals() and hashCode() to compare the contents of the array.In contrast, collections like List, Set, and Map correctly override these methods to compare contents structurally in both Kotlin and Java.Instead, Array uses reference equality â€” two arrays are considered equal only if they are the same instance in memory.As a result, even identical-looking objects are treated as different when arrays are involved.IDE warningModern IDEs like Android Studio and IntelliJ IDEA can detect this potential problem.If you declare an Array as a property inside a data class, the IDE will highlight it with a warning:Example warning from Android StudioProperty with â€˜Arrayâ€™ type in a â€˜dataâ€™ class: it is recommended to override equals() and hashCode()This warning is a strong signal that using arrays inside data classes can easily lead to incorrect or unpredictable behavior â€” even if the code compiles without errors.Why this causes real issuesIn some cases, data class instances are used as keys in HashMap or as elements in HashSet.Both collections rely on consistent implementations of hashCode() and equals() to work correctly.When a data class contains an Array, these operations are based on the reference of the array, not its contents.This leads to problems such as:Cache misses when using objects as keys in maps,Duplicate entries in sets,Incorrect behavior in collections that expect structural equality.Even if two objects have identical data, the program treats them as different â€” simply because their arrays are different instances in memory.How to avoid this problemThe solution is simple: avoid using Array types inside the primary constructor of a data class.Instead, use collection types that correctly override equals() and hashCode(), such as List, Set, or Map.These types compare their contents structurally, not by reference, and fully support the behavior expected from data classes.Choosing the right types ensures that equality checks, hashing, and collection behavior work as intended â€” even in large and complex applications.ConclusionKotlinâ€™s data class feature automatically generates equals(), hashCode(), and other utility methods based on the properties declared in the primary constructor.This works reliably â€” as long as the types used behave correctly.Array types in Kotlin (and Java) do not override equals() and hashCode() to compare contents.Instead, they use reference equality, which can lead to subtle and hard-to-detect bugs when comparing objects or working with collections.Modern IDEs like Android Studio can warn you about this issue.But they cannot explain why it happens, what consequences it brings, or how to design safer models.Understanding these details helps not only to fix isolated problems,but also to build predictable, safe, and maintainable data models as your applications grow.When working with collections inside a data class, prefer List, Set, or Map instead of Array.Choosing the right types is a small decision that helps prevent much larger problems later.If you found this article helpfulIf you enjoyed this article or learned something new, consider leaving a clap â€” it helps others discover it.You can also follow me on Medium for more articles about Kotlin, Android development, and practical engineering topics.Anatolii FrolovSenior Android DeveloperWriting honest, real-world Kotlin \u0026 Jetpack Compose insights.ðŸ“¬ Follow me on Medium",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*rJVtLrsra6UcKUrJ0_4EfA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@af2905g?source=post_page---byline--ebc308e46a95---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anatolii Frolov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PUwz5znLfXDNlKnDndJggA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage generated by the author using Midjourney\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2dfd\"\u003eIn a \u003ca href=\"https://medium.com/proandroiddev/avoid-using-var-in-the-data-class-constructor-in-kotlin-f40cfb8e16c7\" rel=\"noopener\"\u003eprevious article\u003c/a\u003e, we discussed why using \u003ccode\u003evar\u003c/code\u003e in the constructor of a Kotlin \u003ccode\u003edata class\u003c/code\u003e can lead to unexpected behavior and subtle bugs.\u003cbr/\u003eNow, let\u0026#39;s look at another important detail that often goes unnoticed:\u003cbr/\u003ewhy you should avoid using \u003ccode\u003eArray\u003c/code\u003e types in the constructor of a \u003ccode\u003edata class\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"6d7b\"\u003eKotlinâ€™s \u003ccode\u003edata class\u003c/code\u003e feature simplifies the creation of immutable models by automatically generating \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, \u003ccode\u003ecopy()\u003c/code\u003e, and \u003ccode\u003etoString()\u003c/code\u003e based on the primary constructor properties.\u003cbr/\u003eFor most use cases, this behavior works exactly as expected.\u003c/p\u003e\u003cp id=\"b016\"\u003eHowever, when you use an \u003ccode\u003eArray\u003c/code\u003e as a property, the behavior of \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and \u003ccode\u003etoString()\u003c/code\u003e may not match your intentions.\u003cbr/\u003eInstead of comparing the contents of the array, Kotlin (and Java) compare the object references.\u003c/p\u003e\u003cp id=\"c489\"\u003eThis can lead to subtle and hard-to-detect bugs â€” especially when your data classes are used in sets, maps, or caching systems.\u003c/p\u003e\u003cp id=\"a73a\"\u003eIn this article, weâ€™ll see why using \u003ccode\u003eArray\u003c/code\u003e inside a \u003ccode\u003edata class\u003c/code\u003e constructor is risky, and what you should do instead.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"994f\"\u003eWorking correctly with \u003ccode\u003eList\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"2657\"\u003eLetâ€™s start with a simple example where the \u003ccode\u003efriends\u003c/code\u003e property is a \u003ccode\u003eList\u003c/code\u003e inside a data class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d3d4\"\u003edata class Person(\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val friends: List\u0026lt;String\u0026gt;\u003cbr/\u003e)\u003cp\u003efun main() {\u003cbr/\u003e    val person1 = Person(\u003cbr/\u003e        name = \u0026#34;Mike\u0026#34;,\u003cbr/\u003e        friends = listOf(\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tom\u0026#34;)\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    val person2 = Person(\u003cbr/\u003e        name = \u0026#34;Mike\u0026#34;,\u003cbr/\u003e        friends = listOf(\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tom\u0026#34;)\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    println(person1 == person2)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5190\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3ebf\"\u003etrue\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6ec3\"\u003eIn this case, the two \u003ccode\u003ePerson\u003c/code\u003e instances are considered equal.\u003c/p\u003e\u003cp id=\"66cb\"\u003eThis is because \u003ccode\u003eList\u003c/code\u003e in Kotlin overrides \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e to compare the \u003cstrong\u003econtents\u003c/strong\u003e of the list, not just the object references.\u003c/p\u003e\u003cp id=\"0aa0\"\u003eTwo lists are considered equal if:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b9c1\"\u003eThey contain the same elements,\u003c/li\u003e\u003cli id=\"9299\"\u003eIn the same order.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5b63\"\u003eAs a result, Kotlinâ€™s generated \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e for the data class properly compare the \u003ccode\u003efriends\u003c/code\u003e list by value.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"33c0\"\u003eProblem when using \u003ccode\u003eArray\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"6371\"\u003eNow, letâ€™s modify the example slightly by changing the \u003ccode\u003efriends\u003c/code\u003e property to use an \u003ccode\u003eArray\u003c/code\u003e instead of a \u003ccode\u003eList\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b4d4\"\u003edata class Person(\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val friends: Array\u0026lt;String\u0026gt;\u003cbr/\u003e)\u003cp\u003efun main() {\u003cbr/\u003e    val person1 = Person(\u003cbr/\u003e        name = \u0026#34;Mike\u0026#34;,\u003cbr/\u003e        friends = arrayOf(\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tom\u0026#34;)\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    val person2 = Person(\u003cbr/\u003e        name = \u0026#34;Mike\u0026#34;,\u003cbr/\u003e        friends = arrayOf(\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tom\u0026#34;)\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    println(person1 == person2)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"aa93\"\u003eOutput:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e71\"\u003efalse\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1233\"\u003eEven though both \u003ccode\u003ePerson\u003c/code\u003e instances have the same \u003ccode\u003ename\u003c/code\u003e and the same \u003ccode\u003efriends\u003c/code\u003e, the comparison returns \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ba95\"\u003eThis happens because \u003ccode\u003eArray\u003c/code\u003e in Kotlin (and Java) does not override \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e to compare the contents of the array.\u003c/p\u003e\u003cp id=\"e45d\"\u003eIn contrast, collections like \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, and \u003ccode\u003eMap\u003c/code\u003e correctly override these methods to compare contents structurally in both Kotlin and Java.\u003c/p\u003e\u003cp id=\"c51e\"\u003eInstead, \u003ccode\u003eArray\u003c/code\u003e uses reference equality â€” two arrays are considered equal only if they are the same instance in memory.\u003c/p\u003e\u003cp id=\"1b4e\"\u003eAs a result, even identical-looking objects are treated as different when arrays are involved.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8233\"\u003eIDE warning\u003c/h2\u003e\u003cp id=\"06d4\"\u003eModern IDEs like Android Studio and IntelliJ IDEA can detect this potential problem.\u003cbr/\u003eIf you declare an \u003ccode\u003eArray\u003c/code\u003e as a property inside a \u003ccode\u003edata class\u003c/code\u003e, the IDE will highlight it with a warning:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eExample warning from Android Studio\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"750e\"\u003e\u003cem\u003eProperty with â€˜Arrayâ€™ type in a â€˜dataâ€™ class: it is recommended to override equals() and hashCode()\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"2cde\"\u003eThis warning is a strong signal that using arrays inside data classes can easily lead to incorrect or unpredictable behavior â€” even if the code compiles without errors.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"740b\"\u003eWhy this causes real issues\u003c/h2\u003e\u003cp id=\"5a78\"\u003eIn some cases, \u003ccode\u003edata class\u003c/code\u003e instances are used as keys in \u003ccode\u003eHashMap\u003c/code\u003e or as elements in \u003ccode\u003eHashSet\u003c/code\u003e.\u003cbr/\u003eBoth collections rely on consistent implementations of \u003ccode\u003ehashCode()\u003c/code\u003e and \u003ccode\u003eequals()\u003c/code\u003e to work correctly.\u003c/p\u003e\u003cp id=\"06bc\"\u003eWhen a \u003ccode\u003edata class\u003c/code\u003e contains an \u003ccode\u003eArray\u003c/code\u003e, these operations are based on the \u003cstrong\u003ereference\u003c/strong\u003e of the array, not its contents.\u003c/p\u003e\u003cp id=\"c7e2\"\u003eThis leads to problems such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"42a7\"\u003eCache misses when using objects as keys in maps,\u003c/li\u003e\u003cli id=\"16bf\"\u003eDuplicate entries in sets,\u003c/li\u003e\u003cli id=\"8df6\"\u003eIncorrect behavior in collections that expect structural equality.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8064\"\u003eEven if two objects have identical data, the program treats them as different â€” simply because their arrays are different instances in memory.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"034a\"\u003eHow to avoid this problem\u003c/h2\u003e\u003cp id=\"5485\"\u003eThe solution is simple: avoid using \u003ccode\u003eArray\u003c/code\u003e types inside the primary constructor of a \u003ccode\u003edata class\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"b04f\"\u003eInstead, use collection types that correctly override \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e, such as \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, or \u003ccode\u003eMap\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"da0f\"\u003eThese types compare their contents structurally, not by reference, and fully support the behavior expected from data classes.\u003c/p\u003e\u003cp id=\"0618\"\u003eChoosing the right types ensures that equality checks, hashing, and collection behavior work as intended â€” even in large and complex applications.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3b1b\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"8401\"\u003eKotlinâ€™s \u003ccode\u003edata class\u003c/code\u003e feature automatically generates \u003ccode\u003eequals()\u003c/code\u003e, \u003ccode\u003ehashCode()\u003c/code\u003e, and other utility methods based on the properties declared in the primary constructor.\u003cbr/\u003eThis works reliably â€” as long as the types used behave correctly.\u003c/p\u003e\u003cp id=\"6029\"\u003e\u003ccode\u003eArray\u003c/code\u003e types in Kotlin (and Java) do not override \u003ccode\u003eequals()\u003c/code\u003e and \u003ccode\u003ehashCode()\u003c/code\u003e to compare contents.\u003cbr/\u003eInstead, they use reference equality, which can lead to subtle and hard-to-detect bugs when comparing objects or working with collections.\u003c/p\u003e\u003cp id=\"634a\"\u003eModern IDEs like Android Studio can warn you about this issue.\u003cbr/\u003eBut they cannot explain why it happens, what consequences it brings, or how to design safer models.\u003c/p\u003e\u003cp id=\"d742\"\u003eUnderstanding these details helps not only to fix isolated problems,\u003cbr/\u003ebut also to build predictable, safe, and maintainable data models as your applications grow.\u003c/p\u003e\u003cp id=\"b51a\"\u003eWhen working with collections inside a \u003ccode\u003edata class\u003c/code\u003e, prefer \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, or \u003ccode\u003eMap\u003c/code\u003e instead of \u003ccode\u003eArray\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ccd3\"\u003eChoosing the right types is a small decision that helps prevent much larger problems later.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d92d\"\u003eIf you found this article helpful\u003c/h2\u003e\u003cp id=\"896a\"\u003eIf you enjoyed this article or learned something new, consider leaving a clap â€” it helps others discover it.\u003cbr/\u003eYou can also follow me on Medium for more articles about Kotlin, Android development, and practical engineering topics.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c146\"\u003e\u003cstrong\u003eAnatolii Frolov\u003c/strong\u003e\u003cbr/\u003eSenior Android Developer\u003cbr/\u003eWriting honest, real-world Kotlin \u0026amp; Jetpack Compose insights.\u003cbr/\u003eðŸ“¬ \u003ca href=\"https://medium.com/@af2905g\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-04-28T13:49:48.577Z",
  "modifiedTime": null
}
