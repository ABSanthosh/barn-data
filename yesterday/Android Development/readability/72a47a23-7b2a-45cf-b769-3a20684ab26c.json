{
  "id": "72a47a23-7b2a-45cf-b769-3a20684ab26c",
  "title": "Hidden cost of logging in Android",
  "link": "https://proandroiddev.com/hidden-cost-of-logging-in-android-1fdd7cd3149d?source=rss----c72404660798---4",
  "description": "",
  "author": "Yauhen Landarski",
  "published": "Tue, 17 Jun 2025 15:59:22 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "logging",
    "kotlin",
    "android-app-development",
    "android",
    "androiddev"
  ],
  "byline": "Yauhen Landarski",
  "length": 5867,
  "excerpt": "Logging is one of the first habits developers pick up — it’s a quick way to trace values, catch errors, or just understand what the code is doing. But in Android apps, logging isn’t always as…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hidden cost of logging in AndroidLogging is one of the first habits developers pick up — it’s a quick way to trace values, catch errors, or just understand what the code is doing. But in Android apps, logging isn’t always as harmless as it seems. That simple logger call might be quietly using CPU, creating objects, or even slowing down your UI.In this article, we’ll take a closer look at what can go wrong with something as simple as logging — and how to avoid unnecessary performance issues with just a few small changes.We will focus on a widely used logging method — allowing logs to be toggled during runtime. This technique is very useful because it allows logging even in release builds (for example, using remote config) to help diagnose problems.The downside of this approach is that Proguard/R8 keeps the parts of the code related to logging (like building the message and the log call itself) as is and that’s where things can get tricky — we’ll take a closer look shortly.A minimal version of this approach might look like:At first glance, everything looks fine — logs don’t show up unless we turn them on, so there’s nothing to worry about, right? Well, not quite. Even if nothing is printed to the console, we should ask ourselves: is the logger really doing nothing behind the scenes?Let’s look at a few real-world examples that can actually cause problems in production. What do they have in common? They seem harmless… but they’re not.Let’s say logging is turned off. We’ll start with a very basic example:After compilation, this line turns into the following equivalent Java code:Even when logging is turned off, the app still does extra work — it builds the log message, even though it’s never used and goes straight to garbage collection. If there are only a few such messages, it’s usually not a problem — modern garbage collectors handle short-lived objects pretty well, and this kind of code may not seem like something to worry about.But when there are many logs, even this “invisible” work can hurt performance, especially on low-end devices. And while phones are getting more powerful each year, there are still many older or weaker devices out there — and on those, it’s important to pay more attention to resource usage.But what if we want to log not just a primitive, but a class that has an overridden toString() method? For example, a Kotlin data class:You’ve probably already guessed that, on top of the harmless StringBuilder, we also get the serialization logic of the object itself:The example looks simple, but it can use more memory and CPU than you expect. It gets worse if your data class has a list — Kotlin will call toString() for each item. And this work happens every time, even if we don’t need the result at all. Here is a real OutOfMemory stack trace (with the app’s package and class names changed) from one of the apps I found on the web:Besides the obvious example above, there are some trickier cases too. For debugging, we often use formatters — especially when working with decimal numbers:As it often happens, the devil is in the details. Let’s take a closer look at what this simple piece of code actually turns into:And while StringBuilder is mostly harmless if we don’t have complex serialization, String.format is a much heavier call. It involves creating a Formatter object, which may access the system to get locale settings, and then it parses and goes through the given format string. And we should remember: our app won’t even use the result. In some cases, this can even lead to an ANR, here’s a real stack trace example (with the app’s package and class names changed) from my own experience:The solution? Lambdas!I’m sure you have already figured this out. Yes — just a small tweak to how you call your logger, and you’re cutting down system load as much as it can be:Logger method call:This implementation is almost literally a free way to handle logging. It doesn’t matter how complex the expression inside the lambda is — it won’t be evaluated unless logging is actually enabled.The only thing that happens at runtime is the creation of a new lambda instance and passing it to the logging method. And only if logging is turned on, the lambda is unwrapped and the expression is evaluated.To confirm that this solution is truly optimal, I ran a series of benchmarks on my Pixel 8 Pro. As a baseline, we’ll use a simple string passed to the logger without any concatenation:We’ll compare the baseline call above with the following set of methods:Results for each method (measured over 1,000 iterations):As you can see above, the cost of logging calls alone can sometimes noticeably impact performance — especially when complex objects are being serialized. And we’re not even considering the memory overhead of serializing objects to strings.Apps often log a huge amount of information, and when you add third-party SDKs (which usually wrap their logging behind a flag), it’s easy to end up with a lot of wasted work.That “empty” work can steal a few milliseconds from your app during critical frames — pushing you closer to janky frames, or even worse, to an ANR.In most real projects, you are unlikely to encounter the problems described in this article. But a good understanding of what’s going on under the hood will help you make smarter and more thoughtful decisions in your code.Let’s be honest — logger optimization is usually not the first thing you need to fix. There are often much bigger issues that deserve your attention.So no — you don’t need to rewrite your logger today, at least until you are directly faced with the problem.But keep this in mind: every tiny optimization, every avoided waste adds up. Especially when your app grows, scales, or just tries to survive under pressure.Profile first. Measure what matters. And when the time comes — don’t let your logger drag you down.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*JxBtbzEKaXKJ75StGAynYA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"ddc6\" data-testid=\"storyTitle\"\u003eHidden cost of logging in Android\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@landarskiy?source=post_page---byline--1fdd7cd3149d---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Yauhen Landarski\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*Ny-FL57VikX3Rau72PjOZA.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7d0c\"\u003eLogging is one of the first habits developers pick up — it’s a quick way to trace values, catch errors, or just understand what the code is doing. But in Android apps, logging isn’t always as harmless as it seems. That simple logger call might be quietly using CPU, creating objects, or even slowing down your UI.\u003c/p\u003e\u003cp id=\"e255\"\u003eIn this article, we’ll take a closer look at what can go wrong with something as simple as logging — and how to avoid unnecessary performance issues with just a few small changes.\u003c/p\u003e\u003cp id=\"da6d\"\u003eWe will focus on a widely used logging method — allowing logs to be toggled during runtime. This technique is very useful because it allows logging even in release builds (for example, using remote config) to help diagnose problems.\u003c/p\u003e\u003cp id=\"65fe\"\u003eThe downside of this approach is that Proguard/R8 keeps the parts of the code related to logging (like building the message and the log call itself) as is and that’s where things can get tricky — we’ll take a closer look shortly.\u003c/p\u003e\u003cp id=\"dd4a\"\u003eA minimal version of this approach might look like:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b3bb\"\u003eAt first glance, everything looks fine — logs don’t show up unless we turn them on, so there’s nothing to worry about, right? Well, not quite. Even if nothing is printed to the console, we should ask ourselves: is the logger really doing \u003cem\u003enothing\u003c/em\u003e behind the scenes?\u003c/p\u003e\u003cp id=\"2a32\"\u003eLet’s look at a few real-world examples that can actually cause problems in production. What do they have in common? They seem harmless… but they’re not.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"eceb\"\u003eLet’s say logging is turned off. We’ll start with a very basic example:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"475f\"\u003eAfter compilation, this line turns into the following equivalent Java code:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d2f1\"\u003eEven when logging is turned off, the app still does extra work — it builds the log message, even though it’s never used and goes straight to garbage collection. If there are only a few such messages, it’s usually not a problem — modern garbage collectors handle short-lived objects pretty well, and this kind of code may not seem like something to worry about.\u003c/p\u003e\u003cp id=\"8980\"\u003eBut when there are many logs, even this “invisible” work can hurt performance, especially on low-end devices. And while phones are getting more powerful each year, there are still many older or weaker devices out there — and on those, it’s important to pay more attention to resource usage.\u003c/p\u003e\u003cp id=\"9a88\"\u003eBut what if we want to log not just a primitive, but a class that has an overridden \u003ccode\u003etoString()\u003c/code\u003e method? For example, a Kotlin data class:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"76c5\"\u003eYou’ve probably already guessed that, on top of the harmless \u003ccode\u003eStringBuilder\u003c/code\u003e, we also get the serialization logic of the object itself:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0100\"\u003eThe example looks simple, but it can use more memory and CPU than you expect. It gets worse if your data class has a list — Kotlin will call \u003ccode\u003etoString()\u003c/code\u003e for each item. And this work happens every time, even if we don’t need the result at all. Here is a real \u003ccode\u003eOutOfMemory\u003c/code\u003e stack trace (with the app’s package and class names changed) from one of the apps I found on the web:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ffed\"\u003eBesides the obvious example above, there are some trickier cases too. For debugging, we often use formatters — especially when working with decimal numbers:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"91d0\"\u003eAs it often happens, the devil is in the details. Let’s take a closer look at what this simple piece of code actually turns into:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"201b\"\u003eAnd while \u003ccode\u003eStringBuilder\u003c/code\u003e is mostly harmless if we don’t have complex serialization, \u003ccode\u003eString.format\u003c/code\u003e is a much heavier call. It involves creating a \u003ccode\u003eFormatter\u003c/code\u003e object, which may access the system to get locale settings, and then it parses and goes through the given format string. And we should remember: our app won’t even use the result. In some cases, this can even lead to an ANR, here’s a real stack trace example (with the app’s package and class names changed) from my own experience:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2c2d\"\u003eThe solution? Lambdas!\u003c/h2\u003e\u003cp id=\"8f1a\"\u003eI’m sure you have already figured this out. Yes — just a small tweak to how you call your logger, and you’re cutting down system load as much as it can be:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a9fe\"\u003eLogger method call:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8b0e\"\u003eThis implementation is almost literally a \u003cem\u003efree\u003c/em\u003e way to handle logging. It doesn’t matter how complex the expression inside the lambda is — it won’t be evaluated unless logging is actually enabled.\u003c/p\u003e\u003cp id=\"5037\"\u003eThe only thing that happens at runtime is the creation of a new lambda instance and passing it to the logging method. And only if logging is turned on, the lambda is unwrapped and the expression is evaluated.\u003c/p\u003e\u003cp id=\"ba86\"\u003eTo confirm that this solution is truly optimal, I ran a series of benchmarks on my Pixel 8 Pro. As a baseline, we’ll use a simple string passed to the logger without any concatenation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ac21\"\u003eWe’ll compare the baseline call above with the following set of methods:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"334a\"\u003eResults for each method (measured over 1,000 iterations):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d0cc\"\u003eAs you can see above, the cost of logging calls alone can sometimes noticeably impact performance — especially when complex objects are being serialized. And we’re not even considering the memory overhead of serializing objects to strings.\u003c/p\u003e\u003cp id=\"6ce3\"\u003eApps often log a huge amount of information, and when you add third-party SDKs (which usually wrap their logging behind a flag), it’s easy to end up with a lot of wasted work.\u003c/p\u003e\u003cp id=\"863b\"\u003eThat “empty” work can steal a few milliseconds from your app during critical frames — pushing you closer to janky frames, or even worse, to an ANR.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"cd95\"\u003eIn most real projects, you are unlikely to encounter the problems described in this article. But a good understanding of what’s going on under the hood will help you make smarter and more thoughtful decisions in your code.\u003c/p\u003e\u003cp id=\"bf65\"\u003eLet’s be honest — logger optimization is usually not the first thing you need to fix. There are often much bigger issues that deserve your attention.\u003c/p\u003e\u003cp id=\"c42e\"\u003eSo no — you don’t need to rewrite your logger today, at least until you are directly faced with the problem.\u003c/p\u003e\u003cp id=\"c0e8\"\u003eBut keep this in mind: every tiny optimization, every avoided waste adds up. Especially when your app grows, scales, or just tries to survive under pressure.\u003c/p\u003e\u003cp id=\"d94c\"\u003e\u003cem\u003eProfile first. Measure what matters. And when the time comes — don’t let your logger drag you down.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-06-17T15:59:22.775Z",
  "modifiedTime": null
}
