{
  "id": "0d74874f-8c88-47c2-9ca3-acd2c8b7b761",
  "title": "Ensure Public Interface Reliability: Tracking API Compatibility for Android and Kotlin",
  "link": "https://proandroiddev.com/ensure-public-interface-reliability-tracking-api-compatibility-for-android-and-kotlin-05d276fd1efe?source=rss----c72404660798---4",
  "description": "",
  "author": "Jaewoong Eum",
  "published": "Mon, 21 Jul 2025 00:33:59 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "interface-design",
    "kotlin",
    "binary-compatabilit",
    "api",
    "android"
  ],
  "byline": "Jaewoong Eum",
  "length": 10771,
  "excerpt": "Whether you’re building open-source libraries, SDKs, or common modules for other teams, it’s important to make deliberate and careful changes to public APIs, as they directly impact development…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Whether you’re building open-source libraries, SDKs, or common modules for other teams, it’s important to make deliberate and careful changes to public APIs, as they directly impact development resources required for migration.Unintentional or drastic API (Application Programming Interface) changes can break dependent projects and force consuming developers to spend time adapting to the new APIs. In this context, those developers are essentially your API users.In large-scale projects, tracking public API changes manually is error-prone and often overlooked. This article covers how to ensure your team stays fully aware of API changes by integrating plugins like Binary Compatibility Validator and Metalava into your project by exploring real-world examples from RevenueCat’s Android SDK.The approachWhen building an independent module that exposes public APIs, whether as a library, SDK, or common module, those APIs become part of a contract with other developers who consume them. Any changes to parameters, method names, or interface/class hierarchies can directly affect these users, potentially causing breakages or requiring significant effort to adopt newer versions.It’s not necessarily a problem if you’re fully aware of the API changes and communicate them properly. However, unintended or unnoticed changes to the API surface can lead to frustrating developer experiences for your library or SDK users/customers, especially when they encounter breaking changes you never intended to expose.Also, since Kotlin’s default visibility modifier is public, it’s easy to unintentionally expose or change APIs, making these kinds of issues more likely than you’d expect. Even if you’re not building a library or SDK, you can still apply this approach in a multi-module architecture to track which classes or interfaces are publicly exposed and potentially accessible from other modules.There are two great tools that help you automatically track and monitor changes to your public APIs: Binary Compatibility Validator and Metalava. These tools ensure you’re aware of any modifications that could impact your users before releasing a new version.Kotlin binary compatibility validatorThe Binary Compatibility Validator, developed by JetBrains, allows you to generate and track a snapshot of your public API, comparing it against a previously recorded baseline to detect and alert you to any binary-incompatible changes.Dependency configurationIt’s a Kotlin Gradle plugin, making it easy to integrate into your project. You can simply apply it to the library module where you want to track and validate public API changes.Once you correctly added the plugin, you can configure the parameters for the plugin by using the apiValidation like the example below:RevenueCat’s Kotlin Multiplatform SDK already integrates this plugin to manage its public API surface effectively for a better developer experience. It serves as a great real-world example of how this plugin can be used in practice.Validating binary compatibilityWith the setup complete, you can now easily validate binary compatibility for your target library modules using the following command:./gradlew apiDumpYou’ll notice that an .api file has been automatically generated inside the library module’s api directory. Opening this file will show you the current public API surface, as illustrated below:public final class com/revenuecat/purchases/kmp/Purchases { public static final field Companion Lcom/revenuecat/purchases/kmp/Purchases$Companion; public synthetic fun \u003cinit\u003e (Lcom/revenuecat/purchases/Purchases;Lkotlin/jvm/internal/DefaultConstructorMarker;)V public static final fun canMakePayments (Ljava/util/List;Lkotlin/jvm/functions/Function1;)V public final fun checkTrialOrIntroPriceEligibility (Ljava/util/List;Lkotlin/jvm/functions/Function1;)V public final fun close ()V public final fun collectDeviceIdentifiers ()V public static final fun configure (Lcom/revenuecat/purchases/kmp/PurchasesConfiguration;)Lcom/revenuecat/purchases/kmp/Purchases; public final fun enableAdServicesAttributionTokenCollection ()V public final fun getAppUserID ()Ljava/lang/String;Another useful command is apiCheck, which builds the project and verifies that the current public API matches the contents of the generated .api file. This task is automatically integrated into the check lifecycle, meaning that both build and check tasks will validate the public API during execution, making it especially helpful for enforcing binary compatibility in CI pipelines.MetalavaAnother powerful tool is Metalava, developed by Google and widely used across the Android platform and AndroidX libraries. It’s a metadata generator designed for JVM-based projects, and it also works with non-Android libraries.Metalava offers several key features: it can extract public APIs into signature text files, generate stub API files (which can be compiled into artifacts like android.jar), export source-level annotations into external annotation files, and perform API diffs to compare versions and determine whether newer versions remain compatible with previous ones. You can read more about the meaning of the compatibility in Metalava documentation.So why might you choose Metalava over JetBrains’ Binary Compatibility Validator? One key reason is that, unfortunately, Binary Compatibility Validator doesn’t support modules configured with product flavors. If your library module includes multiple product flavors, you won’t be able to apply the plugin effectively or target specific variants, making Metalava the more flexible option in such cases.Dependency configurationYou can easily access the full functionality of Metalava by using the metalava-gradle plugin from the open-source community, which serves as a convenient Gradle wrapper around Google’s official Metalava tool.Once you correctly added the plugin, you can configure the parameters for the plugin by using the `metalava` like the example below:RevenueCat’s Android SDK recently integrated this plugin to effectively manage its public API surface and enhance the overall developer experience. It stands as a good real-world example of how this plugin can be applied in production projects.Validating binary compatibilityOnce the setup is complete, you can validate binary compatibility for your target library modules by running the following command:./gradlew metalavaGenerateSignatureLet’s assume you want to target the pro and demo product flavors with the release build type. In this case, you can validate binary compatibility using the following commands for each product flavor:./gradlew metalavaGenerateSignatureProRelease./gradlew metalavaGenerateSignatureDemoReleaseAfter running the command, you’ll see that an api.txt file has been automatically generated in the root directory of the library module. This file reflects the current public API surface, as shown in the example below:// Signature format: 4.0package com.revenuecat.purchases.ui.revenuecatui { @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY}) public @interface ExperimentalPreviewRevenueCatUIPurchasesAPI { } public final class PaywallDialogKt { method @androidx.compose.runtime.Composable public static void PaywallDialog(com.revenuecat.purchases.ui.revenuecatui.PaywallDialogOptions paywallDialogOptions); }Another valuable command is metalavaCheckCompatibility, which builds the project and checks that the current public API matches the contents of the generated api.txt file. This task is automatically included in the check lifecycle, so both build and check executions will validate the public API, making it particularly useful for maintaining binary compatibility in CI pipelines.Pre-check with Git hooks and CI pipelineWhen combined with CI checks, this plugin becomes especially powerful, allowing you to catch unintended public API changes before pushing or merging code into the project. There are two primary ways to enable this early validation: using Git hooks locally and integrating checks into your CI(Continuous Integration) pipeline, such as with GitHub Actions.Git hooksThis is one of the simplest ways to pre-check binary compatibility for your APIs. Git hooks let you run specific shell scripts before making a commit, helping prevent unchecked or breaking changes from being pushed to your remote repository by mistake../gradlew apiCheck -qEXIT_CODE=$?if [ $EXIT_CODE -ne 0 ]; then echo \"apiCheck failed, running apiDump for you...\" ./gradlew apiDump -q echo \"API dump done, please check the results and then try your commit again!\" exit $EXIT_CODEfiCI PipelineIf your project already uses CI tools like GitHub Actions or CircleCI, integrating binary compatibility checks into your pipeline is one of the most effective ways to automate validation. This ensures that if a commit introduces incompatible API changes, the CI pipeline will fail, preventing the changes from being merged into the main branch until the issue is resolved. It’s a reliable safeguard against accidentally pushing unchecked or breaking changes.RevenueCat’s Android SDK uses CircleCI, providing a real-world example of how to pre-check binary compatibility with Metalava in a production CI environment.ConclusionKey takeaways:Track public API changes automatically to avoid unintentional breakages that frustrate developers.Use Binary Compatibility Validator if you’re building Kotlin libraries without complex flavor configurations.Use Metalava if you need greater flexibility, such as supporting product flavors or JVM-based projects.Integrate API checks into your CI pipelines to catch breaking changes early, before they reach production.Apply these tools even in multi-module projects, not just SDKs, to maintain clean internal and external API boundaries.Reference RevenueCat SDK examples to see real-world, production-ready setups.In this article, you’ve explored how to improve module reliability by tracking public API changes using two powerful plugins. When developing libraries or SDKs, maintaining a stable and well-defined API surface is key to delivering a consistent and reliable developer experience.Monitoring public APIs helps prevent unintended changes that could break downstream usage. Even if you’re not building a library, these tools are still valuable, they help ensure that your library modules aren’t unintentionally exposing or changing classes/interfaces, allowing you to catch and restrict access before they’re used elsewhere in the project.As always, happy coding!— Jaewoong",
  "image": "https://miro.medium.com/v2/resize:fit:800/0*Tal0x88gB0ipAPRU.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://skydoves.medium.com/?source=post_page---byline--05d276fd1efe---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jaewoong Eum\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*to22-X47VSP4tZeElwVKKA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"ec60\"\u003eWhether you’re building open-source libraries, SDKs, or common modules for other teams, it’s important to make deliberate and careful changes to public APIs, as they directly impact development resources required for migration.\u003c/p\u003e\u003cp id=\"f197\"\u003eUnintentional or drastic API (Application Programming Interface) changes can break dependent projects and force consuming developers to spend time adapting to the new APIs. In this context, those developers are essentially your API users.\u003c/p\u003e\u003cp id=\"b576\"\u003eIn large-scale projects, tracking public API changes manually is error-prone and often overlooked. This article covers how to ensure your team stays fully aware of API changes by integrating plugins like \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBinary Compatibility Validator\u003c/a\u003e and \u003ca href=\"https://android.googlesource.com/platform/tools/metalava/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMetalava\u003c/a\u003e into your project by exploring real-world examples from \u003ca href=\"https://www.revenuecat.com/docs/getting-started/installation/android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRevenueCat’s Android SDK\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"ffbb\"\u003eThe approach\u003c/h2\u003e\u003cp id=\"a172\"\u003eWhen building an independent module that exposes public APIs, whether as a library, SDK, or common module, those APIs become part of a contract with other developers who consume them. Any changes to parameters, method names, or interface/class hierarchies can directly affect these users, potentially causing breakages or requiring significant effort to adopt newer versions.\u003c/p\u003e\u003cp id=\"3308\"\u003eIt’s not necessarily a problem if you’re fully aware of the API changes and communicate them properly. However, unintended or unnoticed changes to the API surface can lead to frustrating developer experiences for your library or SDK users/customers, especially when they encounter breaking changes you never intended to expose.\u003c/p\u003e\u003cp id=\"28df\"\u003eAlso, since Kotlin’s default visibility modifier is public, it’s easy to unintentionally expose or change APIs, making these kinds of issues more likely than you’d expect. Even if you’re not building a library or SDK, you can still apply this approach in a multi-module architecture to track which classes or interfaces are publicly exposed and potentially accessible from other modules.\u003c/p\u003e\u003cp id=\"9b26\"\u003eThere are two great tools that help you automatically track and monitor changes to your public APIs: Binary Compatibility Validator and Metalava. These tools ensure you’re aware of any modifications that could impact your users before releasing a new version.\u003c/p\u003e\u003ch2 id=\"6edc\"\u003eKotlin binary compatibility validator\u003c/h2\u003e\u003cp id=\"9990\"\u003eThe \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBinary Compatibility Validator\u003c/a\u003e, developed by JetBrains, allows you to generate and track a snapshot of your public API, comparing it against a previously recorded baseline to detect and alert you to any binary-incompatible changes.\u003c/p\u003e\u003ch2 id=\"c203\"\u003eDependency configuration\u003c/h2\u003e\u003cp id=\"aa3c\"\u003eIt’s a Kotlin Gradle plugin, making it easy to integrate into your project. You can simply apply it to the library module where you want to track and validate public API changes.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5638\"\u003eOnce you correctly added the plugin, you can \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator?tab=readme-ov-file#optional-parameters\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003econfigure the parameters\u003c/a\u003e for the plugin by using the \u003ccode\u003eapiValidation\u003c/code\u003e like the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6b07\"\u003e\u003ca href=\"https://www.revenuecat.com/docs/getting-started/installation/kotlin-multiplatform\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRevenueCat’s Kotlin Multiplatform SDK\u003c/a\u003e already integrates this plugin to manage its public API surface effectively for a better developer experience. It serves as \u003ca href=\"https://github.com/RevenueCat/purchases-kmp/blob/fdf69bd680c618c73885824eb31213b649df030d/build.gradle.kts#L102\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ea great real-world example\u003c/a\u003e of how this plugin can be used in practice.\u003c/p\u003e\u003ch2 id=\"de2e\"\u003eValidating binary compatibility\u003c/h2\u003e\u003cp id=\"0cb6\"\u003eWith the setup complete, you can now easily validate binary compatibility for your target library modules using the following command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3c81\"\u003e./gradlew apiDump\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6216\"\u003eYou’ll notice that an .api file has been automatically generated inside the library module’s api directory. Opening this file will show you the current public API surface, as illustrated below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8e02\"\u003epublic final class com/revenuecat/purchases/kmp/Purchases {\u003cbr/\u003e\tpublic static final field Companion Lcom/revenuecat/purchases/kmp/Purchases$Companion;\u003cbr/\u003e\tpublic synthetic fun \u0026lt;init\u0026gt; (Lcom/revenuecat/purchases/Purchases;Lkotlin/jvm/internal/DefaultConstructorMarker;)V\u003cbr/\u003e\tpublic static final fun canMakePayments (Ljava/util/List;Lkotlin/jvm/functions/Function1;)V\u003cbr/\u003e\tpublic final fun checkTrialOrIntroPriceEligibility (Ljava/util/List;Lkotlin/jvm/functions/Function1;)V\u003cbr/\u003e\tpublic final fun close ()V\u003cbr/\u003e\tpublic final fun collectDeviceIdentifiers ()V\u003cbr/\u003e\tpublic static final fun configure (Lcom/revenuecat/purchases/kmp/PurchasesConfiguration;)Lcom/revenuecat/purchases/kmp/Purchases;\u003cbr/\u003e\tpublic final fun enableAdServicesAttributionTokenCollection ()V\u003cbr/\u003e\tpublic final fun getAppUserID ()Ljava/lang/String;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4d05\"\u003eAnother useful command is \u003ccode\u003eapiCheck\u003c/code\u003e, which builds the project and verifies that the current public API matches the contents of the generated \u003ccode\u003e.api\u003c/code\u003e file. This task is automatically integrated into the check lifecycle, meaning that both build and check tasks will validate the public API during execution, making it especially helpful for enforcing binary compatibility in CI pipelines.\u003c/p\u003e\u003ch2 id=\"0534\"\u003eMetalava\u003c/h2\u003e\u003cp id=\"91d1\"\u003eAnother powerful tool is \u003ca href=\"https://android.googlesource.com/platform/tools/metalava/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMetalava\u003c/a\u003e, developed by Google and widely used across the Android platform and AndroidX libraries. It’s a metadata generator designed for JVM-based projects, and it also works with non-Android libraries.\u003c/p\u003e\u003cp id=\"4e5a\"\u003eMetalava offers several key features: it can extract public APIs into signature text files, generate stub API files (which can be compiled into artifacts like android.jar), export source-level annotations into external annotation files, and perform API diffs to compare versions and determine whether newer versions remain compatible with previous ones. You can read more about \u003ca href=\"https://android.googlesource.com/platform/tools/metalava/+/HEAD/COMPATIBILITY.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe meaning of the compatibility in Metalava documentation\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"bc6d\"\u003eSo why might you choose Metalava over JetBrains’ Binary Compatibility Validator? One key reason is that, unfortunately, \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator/issues/24\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBinary Compatibility Validator doesn’t support modules configured with product flavors\u003c/a\u003e. If your library module includes multiple product flavors, you won’t be able to apply the plugin effectively or target specific variants, making Metalava the more flexible option in such cases.\u003c/p\u003e\u003ch2 id=\"2838\"\u003eDependency configuration\u003c/h2\u003e\u003cp id=\"8d60\"\u003eYou can easily access the full functionality of Metalava by using the \u003ca href=\"https://github.com/tylerbwong/metalava-gradle\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emetalava-gradle\u003c/a\u003e plugin from the open-source community, which serves as a convenient Gradle wrapper around Google’s official Metalava tool.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ed3b\"\u003eOnce you correctly added the plugin, you can \u003ca href=\"https://github.com/tylerbwong/metalava-gradle?tab=readme-ov-file#usage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003econfigure the parameters\u003c/a\u003e for the plugin by using the `metalava` like the example below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"baf9\"\u003e\u003ca href=\"https://www.revenuecat.com/docs/getting-started/installation/android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRevenueCat’s Android SDK\u003c/a\u003e recently integrated this plugin to effectively manage its public API surface and enhance the overall developer experience. It stands as a \u003ca href=\"https://github.com/RevenueCat/purchases-android/blob/2ab891891ea5fe264e3fc37d73b73883ed5e885a/purchases/build.gradle.kts#L69\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egood real-world example\u003c/a\u003e of how this plugin can be applied in production projects.\u003c/p\u003e\u003ch2 id=\"7f5e\"\u003eValidating binary compatibility\u003c/h2\u003e\u003cp id=\"99ad\"\u003eOnce the setup is complete, you can validate binary compatibility for your target library modules by running the following command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0fbf\"\u003e./gradlew metalavaGenerateSignature\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2898\"\u003eLet’s assume you want to target the \u003ccode\u003epro\u003c/code\u003e and \u003ccode\u003edemo\u003c/code\u003e product flavors with the release build type. In this case, you can validate binary compatibility using the following commands for each product flavor:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ce7a\"\u003e./gradlew metalavaGenerateSignatureProRelease\u003cbr/\u003e./gradlew metalavaGenerateSignatureDemoRelease\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9d61\"\u003eAfter running the command, you’ll see that an \u003ccode\u003eapi.txt\u003c/code\u003e file has been automatically generated in the root directory of the library module. This file reflects the current public API surface, as shown in the example below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"72fc\"\u003e// Signature format: 4.0\u003cbr/\u003epackage com.revenuecat.purchases.ui.revenuecatui {\u003cp\u003e  @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.ERROR) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY}) public @interface ExperimentalPreviewRevenueCatUIPurchasesAPI {\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  public final class PaywallDialogKt {\u003cbr/\u003e    method @androidx.compose.runtime.Composable public static void PaywallDialog(com.revenuecat.purchases.ui.revenuecatui.PaywallDialogOptions paywallDialogOptions);\u003cbr/\u003e  }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"579a\"\u003eAnother valuable command is \u003ccode\u003emetalavaCheckCompatibility\u003c/code\u003e, which builds the project and checks that the current public API matches the contents of the generated api.txt file. This task is automatically included in the check lifecycle, so both build and check executions will validate the public API, making it particularly useful for maintaining binary compatibility in CI pipelines.\u003c/p\u003e\u003ch2 id=\"e35a\"\u003ePre-check with Git hooks and CI pipeline\u003c/h2\u003e\u003cp id=\"ca35\"\u003eWhen combined with CI checks, this plugin becomes especially powerful, allowing you to catch unintended public API changes before pushing or merging code into the project. There are two primary ways to enable this early validation: using \u003ca href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGit hooks\u003c/a\u003e locally and integrating checks into your CI(Continuous Integration) pipeline, such as with \u003ca href=\"https://github.com/features/actions\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Actions\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"1d3f\"\u003eGit hooks\u003c/h2\u003e\u003cp id=\"9813\"\u003eThis is one of the simplest ways to pre-check binary compatibility for your APIs. Git hooks let you run specific shell scripts before making a commit, helping prevent unchecked or breaking changes from being pushed to your remote repository by mistake.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4005\"\u003e./gradlew apiCheck -q\u003cbr/\u003eEXIT_CODE=$?\u003cbr/\u003eif [ $EXIT_CODE -ne 0 ]; then\u003cbr/\u003e  echo \u0026#34;apiCheck failed, running apiDump for you...\u0026#34;\u003cp\u003e  ./gradlew apiDump -q\u003c/p\u003e\u003cp\u003e  echo \u0026#34;API dump done, please check the results and then try your commit again!\u0026#34;\u003cbr/\u003e  exit $EXIT_CODE\u003cbr/\u003efi\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"aeb7\"\u003eCI Pipeline\u003c/h2\u003e\u003cp id=\"3e85\"\u003eIf your project already uses CI tools like GitHub Actions or CircleCI, integrating binary compatibility checks into your pipeline is one of the most effective ways to automate validation. This ensures that if a commit introduces incompatible API changes, the CI pipeline will fail, preventing the changes from being merged into the main branch until the issue is resolved. It’s a reliable safeguard against accidentally pushing unchecked or breaking changes.\u003c/p\u003e\u003cp id=\"af49\"\u003e\u003ca href=\"https://github.com/RevenueCat/purchases-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRevenueCat’s Android SDK uses CircleCI\u003c/a\u003e, providing \u003ca href=\"https://github.com/RevenueCat/purchases-android/blob/main/.circleci/config.yml#L284\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ea real-world example\u003c/a\u003e of how to pre-check binary compatibility with Metalava in a production CI environment.\u003c/p\u003e\u003ch2 id=\"5df4\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"3bf0\"\u003eKey takeaways:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5db3\"\u003eTrack public API changes automatically to avoid unintentional breakages that frustrate developers.\u003c/li\u003e\u003cli id=\"d599\"\u003eUse Binary Compatibility Validator if you’re building Kotlin libraries without complex flavor configurations.\u003c/li\u003e\u003cli id=\"c4b6\"\u003eUse Metalava if you need greater flexibility, such as supporting product flavors or JVM-based projects.\u003c/li\u003e\u003cli id=\"f1ef\"\u003eIntegrate API checks into your CI pipelines to catch breaking changes early, before they reach production.\u003c/li\u003e\u003cli id=\"86a0\"\u003eApply these tools even in multi-module projects, not just SDKs, to maintain clean internal and external API boundaries.\u003c/li\u003e\u003cli id=\"0710\"\u003eReference RevenueCat SDK examples to see real-world, production-ready setups.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f010\"\u003eIn this article, you’ve explored how to improve module reliability by tracking public API changes using two powerful plugins. When developing libraries or SDKs, maintaining a stable and well-defined API surface is key to delivering a consistent and reliable developer experience.\u003c/p\u003e\u003cp id=\"e90f\"\u003eMonitoring public APIs helps prevent unintended changes that could break downstream usage. Even if you’re not building a library, these tools are still valuable, they help ensure that your library modules aren’t unintentionally exposing or changing classes/interfaces, allowing you to catch and restrict access before they’re used elsewhere in the project.\u003c/p\u003e\u003cp id=\"a5c3\"\u003eAs always, happy coding!\u003c/p\u003e\u003cp id=\"b05a\"\u003e— \u003ca href=\"https://github.com/skydoves\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJaewoong\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-07-17T01:29:44.463Z",
  "modifiedTime": null
}
