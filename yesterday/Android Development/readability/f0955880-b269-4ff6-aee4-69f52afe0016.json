{
  "id": "f0955880-b269-4ff6-aee4-69f52afe0016",
  "title": "Advanced Exception Handling in Kotlin Coroutines: A Guide for Android Developers",
  "link": "https://proandroiddev.com/advanced-exception-handling-in-kotlin-coroutines-a-guide-for-android-developers-e1aede099252?source=rss----c72404660798---4",
  "description": "",
  "author": "Dobri Kostadinov",
  "published": "Wed, 12 Feb 2025 00:36:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "coroutine",
    "mobile-app-development",
    "kotlin",
    "android",
    "android-app-development"
  ],
  "byline": "Dobri Kostadinov",
  "length": 6729,
  "excerpt": "Exception handling in Kotlin Coroutines is often misunderstood, especially when dealing with structured concurrency, exception propagation, and parallel execution. A poorly handled coroutine failure‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Mastering Exception Handling in Kotlin Coroutines: Handling Failures Like a ProIntroductionException handling in Kotlin Coroutines is often misunderstood, especially when dealing with structured concurrency, exception propagation, and parallel execution. A poorly handled coroutine failure can crash your Android app or lead to silent failures, making debugging difficult.In this article, we will cover advanced scenarios of exception handling, including:‚úÖ How exceptions propagate in coroutine hierarchies‚úÖ Handling exceptions in async, launch, and supervisorScope‚úÖ Managing errors in Flow, SharedFlow, and StateFlow‚úÖ Retrying failed operations with exponential backoff‚úÖ Best practices for handling exceptions in ViewModel and WorkManagerBy the end of this guide, you‚Äôll be confidently handling coroutine failures in any Android project. üöÄ1. Exception Propagation in Structured ConcurrencyKotlin coroutines follow structured concurrency, meaning that when a parent coroutine is canceled, all of its children are also canceled. Likewise, when a child coroutine fails, the failure propagates up the hierarchy, canceling the entire coroutine scope.Example: How a Failure in a Child Cancels the Entire Scopeval scope = CoroutineScope(Job())scope.launch { launch { delay(500) throw IllegalArgumentException(\"Child coroutine failed\") } delay(1000) println(\"This line will never execute\")}‚è≥ What happens?The child coroutine throws an exception.The parent scope is canceled, and no other coroutines in the scope continue execution.Solution: Use supervisorScope to Prevent PropagationTo prevent failures from canceling all coroutines, wrap them inside a supervisorScope:scope.launch { supervisorScope { launch { delay(500) throw IllegalArgumentException(\"Child coroutine failed\") } delay(1000) println(\"This line will still execute\") }}üìå Key Takeaway: Use supervisorScope when you want sibling coroutines to run independently, even if one fails.2. async vs launch: Handling Exceptions DifferentlyHow launch and async Handle Exceptionslaunch {} immediately cancels the parent scope if an exception is thrown.async {} delays exception propagation until await() is called.Example: launch Cancels Everything on Failurescope.launch { launch { throw IOException(\"Network error\") } delay(1000) // This will never execute}Example: async Hides the Exception Until await()val deferred = scope.async { throw NullPointerException(\"Async failed\")}deferred.await() // Exception is thrown hereüö® Danger: If you forget to call await(), the exception is silently ignored.Solution: Wrap await() Calls in Try-Catchtry { val result = deferred.await()} catch (e: Exception) { Log.e(\"Coroutine\", \"Handled exception: $e\")}üìå Key Takeaway: Always wrap await() in a try-catch block to prevent unhandled exceptions.3. Handling Exceptions in ViewModelScopeIn Android development, viewModelScope is used to launch coroutines in ViewModels. However, uncaught exceptions in viewModelScope crash the app unless properly handled.Example: Crashing ViewModel Without Handlingclass MyViewModel : ViewModel() { fun fetchData() { viewModelScope.launch { throw IOException(\"Network failure\") } }}üìå Problem: The exception is uncaught and crashes the app.Solution: Use CoroutineExceptionHandlerclass MyViewModel : ViewModel() { private val handler = CoroutineExceptionHandler { _, throwable -\u003e Log.e(\"Coroutine\", \"Caught: $throwable\") } fun fetchData() { viewModelScope.launch(handler) { throw IOException(\"Network failure\") } }}üìå Key Takeaway: Always attach a CoroutineExceptionHandler to prevent crashes.4. Exception Handling in Parallel CoroutinesWhen executing multiple tasks in parallel, one coroutine failing cancels the others.Example: One Failing Coroutine Cancels the Otherval result1 = async { fetchUserData() }val result2 = async { fetchPosts() }val userData = result1.await() // If this fails, result2 is also canceledval posts = result2.await()üìå Problem: If fetchUserData() fails, fetchPosts() is also canceled.Solution: Use supervisorScope to Make Coroutines IndependentsupervisorScope { val userData = async { fetchUserData() } val posts = async { fetchPosts() } try { userData.await() posts.await() } catch (e: Exception) { Log.e(\"Coroutine\", \"One coroutine failed, but the other continued\") }}üìå Key Takeaway: supervisorScope ensures one failure does not cancel everything.5. Exception Handling in Flow (Cold Streams)Flows stop execution if an exception occurs inside collect().Example: Flow Crashes on Exceptionflow { emit(1) throw IllegalStateException(\"Error in flow\")}.collect { println(it) // This stops execution after first emit}Solution: Use catch {} to Handle Flow Exceptionsflow { emit(1) throw IllegalStateException(\"Error in flow\")} .catch { e -\u003e Log.e(\"Flow\", \"Caught exception: $e\") } .collect { println(it) }üìå Key Takeaway: Always use .catch {} to handle errors inside a Flow.6. Retrying Failed Coroutines with Exponential BackoffIf a coroutine fails due to a network error, we can retry with exponential backoff.suspend fun fetchDataWithRetry(): String { var attempt = 0 val maxAttempts = 3 while (attempt \u003c maxAttempts) { try { return fetchUserData() } catch (e: IOException) { attempt++ delay(1000L * attempt) // Exponential backoff } } throw IOException(\"Failed after 3 attempts\")}üìå Key Takeaway: Implement retries with increasing delay to handle transient failures.7. Exception Handling in WorkManager with CoroutineWorkerWhen using WorkManager with coroutines, exceptions inside workers do not automatically retry.Example: A Worker That Fails Silentlyclass MyWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) { override suspend fun doWork(): Result { fetchData() // May fail return Result.success() }}üìå Problem: If fetchData() fails, WorkManager does not retry.Solution: Return Result.retry() on Exceptionoverride suspend fun doWork(): Result { return try { fetchData() Result.success() } catch (e: Exception) { Result.retry() // Automatically retries on failure }}üìå Key Takeaway: Use Result.retry() to ensure automatic retries.ConclusionMastering exception handling in coroutines ensures that your app is resilient, fault-tolerant, and reliable.What tricky coroutine failures have you encountered? Let me know in the comments! üöÄDobri KostadinovAndroid Consultant | TrainerEmail me | Follow me on LinkedIn | Follow me on Medium | Buy me a coffee",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*IRz_qqPxsAT6kKUdl3jpcA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"4efc\"\u003eMastering Exception Handling in Kotlin Coroutines: Handling Failures Like a Pro\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dobri.kostadinov?source=post_page---byline--e1aede099252--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dobri Kostadinov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*PDWUz7RmoqP9kmFnZzGPUg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e1aede099252--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5084\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"01ec\"\u003eException handling in Kotlin Coroutines is often misunderstood, especially when dealing with \u003cstrong\u003estructured concurrency\u003c/strong\u003e, \u003cstrong\u003eexception propagation\u003c/strong\u003e, and \u003cstrong\u003eparallel execution\u003c/strong\u003e. A poorly handled coroutine failure can crash your Android app or lead to silent failures, making debugging difficult.\u003c/p\u003e\u003cp id=\"5bc7\"\u003eIn this article, we will cover \u003cstrong\u003eadvanced scenarios of exception handling\u003c/strong\u003e, including:\u003cbr/\u003e‚úÖ How exceptions propagate in coroutine hierarchies\u003cbr/\u003e‚úÖ Handling exceptions in \u003ccode\u003easync\u003c/code\u003e, \u003ccode\u003elaunch\u003c/code\u003e, and \u003ccode\u003esupervisorScope\u003c/code\u003e\u003cbr/\u003e‚úÖ Managing errors in \u003ccode\u003eFlow\u003c/code\u003e, \u003ccode\u003eSharedFlow\u003c/code\u003e, and \u003ccode\u003eStateFlow\u003c/code\u003e\u003cbr/\u003e‚úÖ Retrying failed operations with exponential backoff\u003cbr/\u003e‚úÖ Best practices for handling exceptions in ViewModel and WorkManager\u003c/p\u003e\u003cp id=\"50b6\"\u003eBy the end of this guide, you‚Äôll be \u003cstrong\u003econfidently handling coroutine failures\u003c/strong\u003e in any Android project. üöÄ\u003c/p\u003e\u003ch2 id=\"6237\"\u003e1. Exception Propagation in Structured Concurrency\u003c/h2\u003e\u003cp id=\"627e\"\u003eKotlin coroutines follow \u003cstrong\u003estructured concurrency\u003c/strong\u003e, meaning that when a parent coroutine is canceled, all of its children are also canceled. Likewise, when a child coroutine fails, the failure propagates \u003cstrong\u003eup the hierarchy\u003c/strong\u003e, canceling the entire coroutine scope.\u003c/p\u003e\u003ch2 id=\"23ad\"\u003eExample: How a Failure in a Child Cancels the Entire Scope\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"2f0b\"\u003eval scope = CoroutineScope(Job())\u003cp\u003escope.launch {\u003cbr/\u003e    launch { \u003cbr/\u003e        delay(500)\u003cbr/\u003e        throw IllegalArgumentException(\u0026#34;Child coroutine failed\u0026#34;) \u003cbr/\u003e    }\u003cbr/\u003e    delay(1000)\u003cbr/\u003e    println(\u0026#34;This line will never execute\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3741\"\u003e‚è≥ \u003cstrong\u003eWhat happens?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bd9d\"\u003eThe \u003cstrong\u003echild coroutine\u003c/strong\u003e throws an exception.\u003c/li\u003e\u003cli id=\"7445\"\u003eThe \u003cstrong\u003eparent scope is canceled\u003c/strong\u003e, and no other coroutines in the scope continue execution.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"7756\"\u003eSolution: Use \u003ccode\u003esupervisorScope\u003c/code\u003e to Prevent Propagation\u003c/h2\u003e\u003cp id=\"8676\"\u003eTo \u003cstrong\u003eprevent failures from canceling all coroutines\u003c/strong\u003e, wrap them inside a \u003ccode\u003esupervisorScope\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d145\"\u003escope.launch {\u003cbr/\u003e    supervisorScope {\u003cbr/\u003e        launch { \u003cbr/\u003e            delay(500)\u003cbr/\u003e            throw IllegalArgumentException(\u0026#34;Child coroutine failed\u0026#34;) \u003cbr/\u003e        }\u003cbr/\u003e        delay(1000)\u003cbr/\u003e        println(\u0026#34;This line will still execute\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7128\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Use \u003ccode\u003esupervisorScope\u003c/code\u003e when you want sibling coroutines to \u003cstrong\u003erun independently\u003c/strong\u003e, even if one fails.\u003c/p\u003e\u003ch2 id=\"3e01\"\u003e2. \u003ccode\u003easync\u003c/code\u003e vs \u003ccode\u003elaunch\u003c/code\u003e: Handling Exceptions Differently\u003c/h2\u003e\u003ch2 id=\"c0d8\"\u003eHow \u003ccode\u003elaunch\u003c/code\u003e and \u003ccode\u003easync\u003c/code\u003e Handle Exceptions\u003c/h2\u003e\u003cul\u003e\u003cli id=\"23a5\"\u003e\u003ccode\u003elaunch {}\u003c/code\u003e \u003cstrong\u003eimmediately cancels the parent scope\u003c/strong\u003e if an exception is thrown.\u003c/li\u003e\u003cli id=\"c1fb\"\u003e\u003ccode\u003easync {}\u003c/code\u003e \u003cstrong\u003edelays exception propagation\u003c/strong\u003e until \u003ccode\u003eawait()\u003c/code\u003e is called.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"32f0\"\u003eExample: \u003ccode\u003elaunch\u003c/code\u003e Cancels Everything on Failure\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"869f\"\u003escope.launch {\u003cbr/\u003e    launch {\u003cbr/\u003e        throw IOException(\u0026#34;Network error\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    delay(1000) // This will never execute\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e70a\"\u003eExample: \u003ccode\u003easync\u003c/code\u003e Hides the Exception Until \u003ccode\u003eawait()\u003c/code\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"2397\"\u003eval deferred = scope.async {\u003cbr/\u003e    throw NullPointerException(\u0026#34;Async failed\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003edeferred.await() // Exception is thrown here\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a981\"\u003eüö® \u003cstrong\u003eDanger:\u003c/strong\u003e If you forget to call \u003ccode\u003eawait()\u003c/code\u003e, the exception is silently ignored.\u003c/p\u003e\u003ch2 id=\"322f\"\u003eSolution: Wrap \u003ccode\u003eawait()\u003c/code\u003e Calls in Try-Catch\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"51c2\"\u003etry {\u003cbr/\u003e    val result = deferred.await()\u003cbr/\u003e} catch (e: Exception) {\u003cbr/\u003e    Log.e(\u0026#34;Coroutine\u0026#34;, \u0026#34;Handled exception: $e\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2082\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Always wrap \u003ccode\u003eawait()\u003c/code\u003e in a \u003ccode\u003etry-catch\u003c/code\u003e block to prevent unhandled exceptions.\u003c/p\u003e\u003ch2 id=\"7e96\"\u003e3. Handling Exceptions in ViewModelScope\u003c/h2\u003e\u003cp id=\"d0c7\"\u003eIn Android development, \u003ccode\u003eviewModelScope\u003c/code\u003e is used to launch coroutines in ViewModels. However, \u003cstrong\u003euncaught exceptions in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eviewModelScope\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e crash the app\u003c/strong\u003e unless properly handled.\u003c/p\u003e\u003ch2 id=\"3e8a\"\u003eExample: Crashing ViewModel Without Handling\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"ef2d\"\u003eclass MyViewModel : ViewModel() {\u003cbr/\u003e    fun fetchData() {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            throw IOException(\u0026#34;Network failure\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"71f3\"\u003eüìå \u003cstrong\u003eProblem:\u003c/strong\u003e The exception is uncaught and crashes the app.\u003c/p\u003e\u003ch2 id=\"0c51\"\u003eSolution: Use \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"7e72\"\u003eclass MyViewModel : ViewModel() {\u003cbr/\u003e    private val handler = CoroutineExceptionHandler { _, throwable -\u0026gt;\u003cbr/\u003e        Log.e(\u0026#34;Coroutine\u0026#34;, \u0026#34;Caught: $throwable\u0026#34;)\u003cbr/\u003e    }\u003cp\u003e    fun fetchData() {\u003cbr/\u003e        viewModelScope.launch(handler) {\u003cbr/\u003e            throw IOException(\u0026#34;Network failure\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ca2b\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Always attach a \u003ccode\u003eCoroutineExceptionHandler\u003c/code\u003e to prevent crashes.\u003c/p\u003e\u003ch2 id=\"4d00\"\u003e4. Exception Handling in Parallel Coroutines\u003c/h2\u003e\u003cp id=\"bea2\"\u003eWhen executing multiple tasks in parallel, \u003cstrong\u003eone coroutine failing cancels the others\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"fab2\"\u003eExample: One Failing Coroutine Cancels the Other\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"d59b\"\u003eval result1 = async { fetchUserData() }\u003cbr/\u003eval result2 = async { fetchPosts() }\u003cbr/\u003eval userData = result1.await() // If this fails, result2 is also canceled\u003cbr/\u003eval posts = result2.await()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b94f\"\u003eüìå \u003cstrong\u003eProblem:\u003c/strong\u003e If \u003ccode\u003efetchUserData()\u003c/code\u003e fails, \u003ccode\u003efetchPosts()\u003c/code\u003e \u003cstrong\u003eis also canceled\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"cea0\"\u003eSolution: Use \u003ccode\u003esupervisorScope\u003c/code\u003e to Make Coroutines Independent\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a4a6\"\u003esupervisorScope {\u003cbr/\u003e    val userData = async { fetchUserData() }\u003cbr/\u003e    val posts = async { fetchPosts() }\u003cp\u003e        try {\u003cbr/\u003e        userData.await()\u003cbr/\u003e        posts.await()\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        Log.e(\u0026#34;Coroutine\u0026#34;, \u0026#34;One coroutine failed, but the other continued\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e58d\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e \u003ccode\u003esupervisorScope\u003c/code\u003e ensures \u003cstrong\u003eone failure does not cancel everything\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"036e\"\u003e5. Exception Handling in Flow (Cold Streams)\u003c/h2\u003e\u003cp id=\"b019\"\u003eFlows \u003cstrong\u003estop execution\u003c/strong\u003e if an exception occurs inside \u003ccode\u003ecollect()\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"924b\"\u003eExample: Flow Crashes on Exception\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"16b8\"\u003eflow {\u003cbr/\u003e    emit(1)\u003cbr/\u003e    throw IllegalStateException(\u0026#34;Error in flow\u0026#34;)\u003cbr/\u003e}.collect {\u003cbr/\u003e    println(it) // This stops execution after first emit\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"f869\"\u003eSolution: Use \u003ccode\u003ecatch {}\u003c/code\u003e to Handle Flow Exceptions\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"d5d6\"\u003eflow {\u003cbr/\u003e    emit(1)\u003cbr/\u003e    throw IllegalStateException(\u0026#34;Error in flow\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003e    .catch { e -\u0026gt; Log.e(\u0026#34;Flow\u0026#34;, \u0026#34;Caught exception: $e\u0026#34;) }\u003cbr/\u003e    .collect { println(it) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4843\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Always use \u003ccode\u003e.catch {}\u003c/code\u003e to \u003cstrong\u003ehandle errors inside a Flow\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"6bf4\"\u003e6. Retrying Failed Coroutines with Exponential Backoff\u003c/h2\u003e\u003cp id=\"802d\"\u003eIf a coroutine fails due to a network error, we can \u003cstrong\u003eretry with exponential backoff\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1832\"\u003esuspend fun fetchDataWithRetry(): String {\u003cbr/\u003e    var attempt = 0\u003cbr/\u003e    val maxAttempts = 3\u003cbr/\u003e    while (attempt \u0026lt; maxAttempts) {\u003cbr/\u003e        try {\u003cbr/\u003e            return fetchUserData()\u003cbr/\u003e        } catch (e: IOException) {\u003cbr/\u003e            attempt++\u003cbr/\u003e            delay(1000L * attempt) // Exponential backoff\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    throw IOException(\u0026#34;Failed after 3 attempts\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3460\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Implement \u003cstrong\u003eretries\u003c/strong\u003e with increasing delay to \u003cstrong\u003ehandle transient failures\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"22b1\"\u003e7. Exception Handling in WorkManager with CoroutineWorker\u003c/h2\u003e\u003cp id=\"845a\"\u003eWhen using WorkManager with coroutines, \u003cstrong\u003eexceptions inside workers do not automatically retry\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"f038\"\u003eExample: A Worker That Fails Silently\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4693\"\u003eclass MyWorker(ctx: Context, params: WorkerParameters) :\u003cbr/\u003e    CoroutineWorker(ctx, params) {\u003cbr/\u003e    override suspend fun doWork(): Result {\u003cbr/\u003e        fetchData() // May fail\u003cbr/\u003e        return Result.success()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c4ad\"\u003eüìå \u003cstrong\u003eProblem:\u003c/strong\u003e If \u003ccode\u003efetchData()\u003c/code\u003e fails, WorkManager does not retry.\u003c/p\u003e\u003ch2 id=\"50be\"\u003eSolution: Return \u003ccode\u003eResult.retry()\u003c/code\u003e on Exception\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"fd4f\"\u003eoverride suspend fun doWork(): Result {\u003cbr/\u003e    return try {\u003cbr/\u003e        fetchData()\u003cbr/\u003e        Result.success()\u003cbr/\u003e    } catch (e: Exception) {\u003cbr/\u003e        Result.retry() // Automatically retries on failure\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"14ea\"\u003eüìå \u003cstrong\u003eKey Takeaway:\u003c/strong\u003e Use \u003ccode\u003eResult.retry()\u003c/code\u003e to ensure \u003cstrong\u003eautomatic retries\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"4c99\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"ac71\"\u003eMastering \u003cstrong\u003eexception handling in coroutines\u003c/strong\u003e ensures that your app is \u003cstrong\u003eresilient, fault-tolerant, and reliable\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"4389\"\u003eWhat tricky coroutine failures have you encountered? Let me know in the comments! üöÄ\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b628\"\u003e\u003cem\u003eDobri Kostadinov\u003c/em\u003e\u003cbr/\u003eAndroid Consultant | Trainer\u003cbr/\u003e\u003ca href=\"mailto:dobri.kostadinov@gmail.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEmail me\u003c/a\u003e | \u003ca href=\"https://www.linkedin.com/in/dobrikostadinov/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFollow me on LinkedIn\u003c/a\u003e | \u003ca href=\"https://medium.com/@dobri.kostadinov\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e | \u003ca href=\"https://www.buymeacoffee.com/dobri.kostadinov\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuy me a coffee\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-02-12T00:36:21.513Z",
  "modifiedTime": null
}
