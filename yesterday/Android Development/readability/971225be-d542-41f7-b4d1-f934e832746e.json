{
  "id": "971225be-d542-41f7-b4d1-f934e832746e",
  "title": "Hello Kotliners,",
  "link": "https://blog.kotlin-academy.com/hello-kotliners-e15daf378091?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Halina Kt Academy",
  "published": "Wed, 21 May 2025 12:01:04 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "kotlin",
    "kotlin-beginners",
    "kotlin-coroutines",
    "kotlin-multiplatform"
  ],
  "byline": "Halina Kt Academy",
  "length": 3187,
  "excerpt": "It‚Äôs a 5-week cohort-based course focused on real-world usage, advanced patterns, and testing strategies. Must know optimization for data flows‚ùóThanks to shareIn, one observer can be shared among‚Ä¶",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "Hello Kotliners,In this issue, a quick announcement: we have started preparing a new course ‚Äìüßµ Coroutines Master: Deep Dive \u0026 Best Practices.It‚Äôs a 5-week cohort-based course focused on real-world usage, advanced patterns, and testing strategies.üëâ More details hereHere‚Äôs what‚Äôs inside today:üîß Function of the dayüß† Main topicü§ñ The Final ByteEnjoy and let me know what you think!Function of the dayMust know optimization for data flows‚ùóThanks to shareIn, one observer can be shared among multiple subscribers. This way, we will open only one connection to the server, and all observers will receive the same data. The connection will be closed when the last observer is unsubscribed, and opened again when the first observer subscribes. This is a perfect solution for sharing data between multiple UI components or services.Main TopicStateFlow and SharedFlow seem similar, but they are designed for different use cases, and they should not be confused. Let‚Äôs discuss the key differences and usages.Let‚Äôs start with how they work. SharedFlow resembles a broadcast channel ‚Äî emitted values are delivered to all observers. It allows setting a replay parameter specifying how many past values should be emitted to new observers.StateFlow behaves a lot like SharedFlow with reply = 1, but StateFlow must always have a value, so an initial value must be specified when a StateFlow is created. This value can be accessed or changed using value property.StateFlow was designed for a concrete use case: to represent an observable state. In Android, it is used to represent the state of our application, and views observe it and redraw whenever it changes. That is the key source of differences.Redrawing view can be expensive, and state changes can be frequent. That is why two optimizations were introduced. First, updates are only emitted when they are different from the previous state. This behavior can be achieved on SharedFlow using distinctUntilChanged.Second, StateFlow is conflated, meaning if value changes faster than observer than handle it, it might lose some intermediate updates. That is appropriate for StateFlow, because we are not interested in drawing obsolete state.StateFlow also have some tools for state update, like update function, that lets us safely update state, by creating a new one based on the current one.That is why StateFlow should be used concretely to represent the observable state of our application. It should not be used as a ‚Äúbreadcast channel‚Äù. For that we use SharedFlow.However, SharedFlow values are not completely safe to be used in view models, because updates made when there is no observer will not be observed (unless we use reply, but then the same values can be displayed again). So it is best to represent our state with StateFlow.Learn more about StateFlow and SharedFlow, and how they should be used, in those two articles:SharedFlow vs StateFlowRepresenting ViewModel events with StateFlow vs. SharedFlow vs. ChannelThe Final ByteMany people ask me what the difference is between calling emit and setting value on MutableStateFlow. There is no difference, emit under the hood changes value.Hope you liked it!Marcin Moskala from Kt. Academy",
  "image": "https://miro.medium.com/v2/resize:fit:1200/0*L148yAKDpLT3QIwv.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a44e\"\u003eHello \u003cstrong\u003eKotliners\u003c/strong\u003e,\u003c/p\u003e\u003cp id=\"5aed\"\u003eIn this issue, a quick announcement: we have started preparing a new course ‚Äì\u003c/p\u003e\u003cp id=\"a3ee\"\u003eüßµ\u003cstrong\u003e Coroutines Master: Deep Dive \u0026amp; Best Practices.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9199\"\u003eIt‚Äôs a 5-week cohort-based course focused on real-world usage, advanced patterns, and testing strategies.\u003c/p\u003e\u003cp id=\"9af9\"\u003eüëâ \u003ca href=\"https://web.kt.academy/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMore details here\u003c/a\u003e\u003c/p\u003e\u003cp id=\"de0d\"\u003eHere‚Äôs what‚Äôs inside today:\u003c/p\u003e\u003cp id=\"217c\"\u003eüîß Function of the day\u003c/p\u003e\u003cp id=\"6cce\"\u003eüß† Main topic\u003c/p\u003e\u003cp id=\"4723\"\u003eü§ñ The Final Byte\u003c/p\u003e\u003cp id=\"1f0a\"\u003eEnjoy and let me know what you think!\u003c/p\u003e\u003ch2 id=\"0e9c\"\u003eFunction of the day\u003c/h2\u003e\u003cp id=\"5ecb\"\u003eMust know optimization for data flows‚ùóThanks to shareIn, one observer can be shared among multiple subscribers. This way, we will open only one connection to the server, and all observers will receive the same data. The connection will be closed when the last observer is unsubscribed, and opened again when the first observer subscribes. This is a perfect solution for sharing data between multiple UI components or services.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a600\"\u003eMain Topic\u003c/h2\u003e\u003cp id=\"9d1b\"\u003eStateFlow and SharedFlow seem similar, but they are designed for different use cases, and they should not be confused. Let‚Äôs discuss the key differences and usages.\u003c/p\u003e\u003cp id=\"dbf7\"\u003eLet‚Äôs start with how they work. SharedFlow resembles a broadcast channel ‚Äî emitted values are delivered to all observers. It allows setting a replay parameter specifying how many past values should be emitted to new observers.\u003c/p\u003e\u003cp id=\"6eef\"\u003eStateFlow behaves a lot like SharedFlow with reply = 1, but StateFlow must always have a value, so an initial value must be specified when a StateFlow is created. This value can be accessed or changed using value property.\u003c/p\u003e\u003cp id=\"bb11\"\u003eStateFlow was designed for a concrete use case: to represent an observable state. In Android, it is used to represent the state of our application, and views observe it and redraw whenever it changes. That is the key source of differences.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0cd0\"\u003eRedrawing view can be expensive, and state changes can be frequent. That is why two optimizations were introduced. First, updates are only emitted when they are different from the previous state. This behavior can be achieved on SharedFlow using distinctUntilChanged.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a007\"\u003eSecond, StateFlow is conflated, meaning if value changes faster than observer than handle it, it might lose some intermediate updates. That is appropriate for StateFlow, because we are not interested in drawing obsolete state.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3f5f\"\u003eStateFlow also have some tools for state update, like update function, that lets us safely update state, by creating a new one based on the current one.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d3f1\"\u003eThat is why StateFlow should be used concretely to represent the observable state of our application. It should not be used as a ‚Äúbreadcast channel‚Äù. For that we use SharedFlow.\u003c/p\u003e\u003cp id=\"3ca3\"\u003eHowever, SharedFlow values are not completely safe to be used in view models, because updates made when there is no observer will not be observed (unless we use reply, but then the same values can be displayed again). So it is best to represent our state with StateFlow.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e6a0\"\u003eLearn more about StateFlow and SharedFlow, and how they should be used, in those two articles:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a9c6\"\u003e\u003ca href=\"https://kt.academy/article/sharedflow_vs_stateflow\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSharedFlow vs StateFlow\u003c/a\u003e\u003c/li\u003e\u003cli id=\"60e3\"\u003e\u003ca href=\"https://kt.academy/article/viewmodel-stateflow-sharedflow-channel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRepresenting ViewModel events with StateFlow vs. SharedFlow vs. Channel\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"42b2\"\u003eThe Final Byte\u003c/h2\u003e\u003cp id=\"8397\"\u003eMany people ask me what the difference is between calling emit and setting value on MutableStateFlow. There is no difference, emit under the hood changes value.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"309a\"\u003eHope you liked it!\u003c/p\u003e\u003cp id=\"a9d1\"\u003eMarcin Moskala from Kt. Academy\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-05-21T12:01:04.695Z",
  "modifiedTime": null
}
