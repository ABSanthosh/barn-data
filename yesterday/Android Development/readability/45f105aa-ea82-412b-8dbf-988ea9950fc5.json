{
  "id": "45f105aa-ea82-412b-8dbf-988ea9950fc5",
  "title": "Programming Priorities",
  "link": "https://blog.danlew.net/2025/03/11/programming-priorities/",
  "description": "Software development (or, you know, life in general) is all about juggling priorities.For this post, I’m thinking specifically about code design priorities. You only have a limited amount of time to implement a feature, so you have to pick and choose which aspects of it to spend",
  "author": "Dan Lew",
  "published": "Tue, 11 Mar 2025 14:00:44 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "code design"
  ],
  "byline": "Dan Lew",
  "length": 3127,
  "excerpt": "Software development (or, you know, life in general) is all about juggling priorities. For this post, I’m thinking specifically about code design priorities. You only have a limited amount of time to implement a feature, so you have to pick and choose which aspects of it to spend time on. Do you spend your hours crafting the perfect architecture? Optimizing the shit out of it? Writing automated tests? Documenting your code? Once, a junior developer, having trouble figuring out what to focus on",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "Software development (or, you know, life in general) is all about juggling priorities.For this post, I’m thinking specifically about code design priorities. You only have a limited amount of time to implement a feature, so you have to pick and choose which aspects of it to spend time on. Do you spend your hours crafting the perfect architecture? Optimizing the shit out of it? Writing automated tests? Documenting your code?Once, a junior developer, having trouble figuring out what to focus on, asked me about what my personal priorities were. Here’s what I came up with:FunctionalMaintainableEverything else (distant third)Functional is obviously #1: if the software doesn’t work, what’s the point?What’s not as obvious is that maintainable is #2, and that everything else is below it.What do I mean by maintainable code? I like this answer from StackExchange (emphasis mine):“Maintainability isn't a binary property, either being maintainable or not. It's a continuum. Roughly speaking, maintainability is inversely proportional to the amount of time it takes a developer to make a change and the risk that change will break something. Improving readability, coupling, or consistency all contribute to maintainability because it won't take as long to make any given change.”In short, maintainability makes it easier to change code later.Focusing on maintainability now means you don’t need to focus as much on anything else because the malleability of the code gives you the option to refactor later. That saves you time now without blocking you from later altering the code to match new needs.For example, perhaps you didn’t focus on optimization at all, but it turns out that the new feature is bogging down your whole system. You need to make it faster - but lucky for you, there’s automated tests to verify your changes, and the slow part of the code is isolated such that you can optimize it without rewriting the whole feature. In this case, it only takes a day or two to optimize that small portion of the codebase and ship it safely.How do you write maintainable code? That’s a huge subject, such that there are entire books on the topic (e.g. Code Complete), but my tl;dr would be:Automated tests - so you can modify the code and know it still behaves the same as before.Good architecture - proper decoupling, encapsulation, etc. make it possible to refactor without rewriting everything.Readable - simple code with useful comments, so others (or yourself, years later) can actually understand what the code is doing.All easier said than done, sure, but those are the ideas.Is maintainability always my #2 priority? No!With software development, there are always exceptions. Sometimes you need to crank out code ASAP to put out a fire, tech debt be damned. Other times you know, in advance, that you’re working on a critical path and need to optimize as much as possible. Or you may be working on code that is already unmaintainable (from a previous developer, perhaps even yourself), and you just need to make a small tweak.But my default priorities are as above - functional, maintainable, then everything else.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n\n        \n\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eSoftware development (or, you know, life in general) is all about juggling priorities.\u003c/p\u003e\u003cp\u003eFor this post, I’m thinking specifically about \u003cstrong\u003ecode design priorities\u003c/strong\u003e. You only have a limited amount of time to implement a feature, so you have to pick and choose which aspects of it to spend time on. Do you spend your hours crafting the perfect architecture? Optimizing the shit out of it? Writing automated tests? Documenting your code?\u003c/p\u003e\u003cp\u003eOnce, a junior developer, having trouble figuring out what to focus on, asked me about what my personal priorities were. Here’s what I came up with:\u003c/p\u003e\u003col\u003e\u003cli\u003eFunctional\u003c/li\u003e\u003cli\u003eMaintainable\u003c/li\u003e\u003cli\u003eEverything else (distant third)\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cstrong\u003eFunctional\u003c/strong\u003e is obviously #1: if the software doesn’t work, what’s the point?\u003c/p\u003e\u003cp\u003eWhat’s not as obvious is that \u003cstrong\u003emaintainable\u003c/strong\u003e is #2, and that everything else is below it.\u003c/p\u003e\u003cp\u003eWhat do I mean by maintainable code? I like \u003ca href=\"https://softwareengineering.stackexchange.com/a/134863?ref=blog.danlew.net\"\u003e\u003cu\u003ethis answer\u003c/u\u003e\u003c/a\u003e from StackExchange (emphasis mine):\u003c/p\u003e\u003cp\u003e\u003cem\u003e“Maintainability isn\u0026#39;t a binary property, either being maintainable or not. It\u0026#39;s a continuum. Roughly speaking, \u003cstrong\u003emaintainability is inversely proportional to the amount of time it takes a developer to make a change and the risk that change will break something\u003c/strong\u003e. Improving readability, coupling, or consistency all contribute to maintainability because it won\u0026#39;t take as long to make any given change.”\u003c/em\u003e\u003c/p\u003e\u003cp\u003eIn short, \u003cstrong\u003emaintainability makes it easier to change code later\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eFocusing on maintainability now means you don’t need to focus as much on anything else because the malleability of the code gives you the option to refactor later. That saves you time now without blocking you from later altering the code to match new needs.\u003c/p\u003e\u003cp\u003eFor example, perhaps you didn’t focus on optimization at all, but it turns out that the new feature is bogging down your whole system. You need to make it faster - but lucky for you, there’s automated tests to verify your changes, and the slow part of the code is isolated such that you can optimize it without rewriting the whole feature. In this case, it only takes a day or two to optimize that small portion of the codebase and ship it safely.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eHow do you write maintainable code? That’s a huge subject, such that there are entire books on the topic (e.g. \u003ca href=\"https://en.wikipedia.org/wiki/Code_Complete?ref=blog.danlew.net\"\u003e\u003cu\u003eCode Complete\u003c/u\u003e\u003c/a\u003e), but my tl;dr would be:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAutomated tests\u003c/strong\u003e - so you can modify the code and know it still behaves the same as before.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eGood architecture\u003c/strong\u003e - proper decoupling, encapsulation, etc. make it possible to refactor without rewriting everything.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eReadable\u003c/strong\u003e - simple code with useful comments, so others (or yourself, years later) can actually understand what the code is doing.\u003c/p\u003e\u003cp\u003eAll easier said than done, sure, but those are the ideas.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eIs maintainability \u003cstrong\u003ealways\u003c/strong\u003e my #2 priority? No!\u003c/p\u003e\u003cp\u003eWith software development, there are always exceptions. Sometimes you need to crank out code ASAP to put out a fire, tech debt be damned. Other times you know, in advance, that you’re working on a critical path and need to optimize as much as possible. Or you may be working on code that is already unmaintainable (from a previous developer, \u003cem\u003eperhaps even yourself\u003c/em\u003e), and you just need to make a small tweak.\u003c/p\u003e\u003cp\u003eBut my default priorities are as above - functional, maintainable, then everything else.\u003c/p\u003e\n    \u003c/section\u003e\n\n    \n    \n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-03-11T14:00:44Z",
  "modifiedTime": "2025-03-11T14:00:43Z"
}
