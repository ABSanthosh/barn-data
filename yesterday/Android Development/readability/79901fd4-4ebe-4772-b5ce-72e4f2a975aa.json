{
  "id": "79901fd4-4ebe-4772-b5ce-72e4f2a975aa",
  "title": "Process Death Handling via Automatic StateFlow Persistence with Reanimator (Android \u0026 KMP)",
  "link": "https://proandroiddev.com/process-death-handling-via-automatic-stateflow-persistence-with-reanimator-android-kmp-9613e1ac9967?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Tue, 22 Apr 2025 13:34:41 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "android",
    "kotlin-multiplatform",
    "androiddev",
    "kotlin"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 18653,
  "excerpt": "Reanimator: Automatic StateFlow saving for Android \u0026 KMP ViewModels. Simplifies process death \u0026 MVI transient state handling.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Image Source — GPT 4oWhy Saving App Information is Very ImportantWhen we build mobile apps, for Android phones or using Kotlin Multiplatform (KMP), we need to carefully manage the information shown on the screen. This information is often called the app’s state. Users expect apps to remember where they were and what they were doing, even if they switch to another app for a moment or get a phone call.Now a big challenge, especially on Android, is something called “process death”. Think of your phone having limited energy and memory. To save these resources, the Android system might completely stop your app if it’s running in the background (not visible on the screen). This isn’t a crash; it’s a normal Android behavior.However, when the user comes back to your app, Android restarts it. If you haven’t saved the screen’s state properly before the app was stopped, the user might see the starting screen again, lose their typed text, or find their place in a list gone. This can be very frustrating for users.The Problem: Saving State Manually is Hard WorkAndroid gives developers a tool called SavedStateHandle. It's designed to help save and restore the screen's state during events like process death. SavedStateHandle is useful, but using it directly often feels like a lot of extra, repetitive work:Making Names (Keys): For every single piece of data you want to save (like a username, a score, a list position), you have to invent a unique text name, called a key. Managing many keys can get confusing.Saving and Loading by Hand: You must write specific code to load the data using its key every time the screen starts up after being stopped. You also have to write code to save the data using its key every time the data changes. It’s like carefully packing and unpacking a suitcase every time you add or remove one small item.Watching for Every Change: You need to constantly watch your app’s state (often held in tools like StateFlow) to know exactly when a piece of data changes so you can save it immediately. This adds more code just for watching.Limited Data Types: SavedStateHandle easily saves simple things like numbers or text. Saving more complex information, like a list of custom objects, often requires extra steps to convert it into a format SavedStateHandle understands (like Serializable or Parcelable).All this manual work makes the code in our ViewModels (the place where we usually manage screen logic and state) longer, messier, and harder to read. It takes focus away from building the app’s features and makes it easier to introduce bugs if we forget to save or load something.The MVI Problem: One State Object, Two Kinds of DataMany modern app developers like using patterns such as MVI (Model-View-Intent). A common idea in MVI is to have one single state object for each screen. This object holds all the information needed to draw the screen at any moment. This can make the app’s logic easier to follow and predict.However, this creates a specific problem for saving state: This single state object often contains two different kinds of information mixed together:Persistent State: Information that must be saved and restored after process death. Examples include data loaded from the network (like a list of products), user settings, text the user has typed, or which item is selected in a list.Transient State: Temporary information that should NOT be saved. This state should reset to its default value when the app restarts. Examples include loading indicators (like spinners), temporary error messages that should disappear, flags to trigger a one-time animation, or navigation commands.Let’s look at an example state object again:@Serializabledata class MyScreenState( // --- Save This --- val userProfile: UserProfile? = null, val items: List\u003cItem\u003e = emptyList(), // --- Do Not Save This (Transient) --- val isLoading: Boolean = false, val isDownloading: Boolean = false)If we simply save the entire MyScreenState object using SavedStateHandle, we run into trouble. When the app restarts after process death, the isLoading flag might still be true (showing a spinner forever!) or an old status might still show that doesn’t make sense anymore.To fix this manually, the developer would have to write extra code before saving to pick out only the userProfile and items, ignoring isLoading and showMessage. Then, when the app restarts, they'd need more code to make sure isLoading is set back to false and showMessage is set back to null. This manual filtering and resetting adds complexity and boilerplate code – exactly the kind of repetitive work MVI tries to help us avoid!Approach 1 — A Lightweight Snippet: @Transient + snippetthanks Joost KlitsieIf your state class is primarily used within a specific ViewModel and not serialized elsewhere with different needs, Kotlin's built-in @Transient annotation is often the simplest solution.You mark the fields directly in the data class:import androidx.lifecycle.SavedStateHandleimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.launchInimport kotlinx.coroutines.flow.onEachimport kotlinx.serialization.json.Jsonimport kotlin.properties.PropertyDelegateProviderimport kotlin.properties.ReadOnlyPropertyinline fun \u003creified T\u003e SavedStateHandle.getMutableStateFlow( defaultValue: T, coroutineScope: CoroutineScope, key: String? = null, json: Json = Json { ignoreUnknownKeys = true },) = PropertyDelegateProvider\u003cAny, ReadOnlyProperty\u003cAny, MutableStateFlow\u003cT\u003e\u003e\u003e { thisRef, property -\u003e val viewModelClassName = thisRef.let { it::class.simpleName } ?: \"UnknownViewModel\" val actualKey = key ?: \"${viewModelClassName}_${property.name}\" val stateFlow = MutableStateFlow( get\u003cString\u003e(actualKey)?.let { json.decodeFromString\u003cT\u003e(it) } ?: defaultValue ).also { flow -\u003e flow.onEach { set(actualKey, json.encodeToString(it)) }.launchIn(coroutineScope) } ReadOnlyProperty { _, _ -\u003e stateFlow }}And in your ViewModel:// YOUR SERIALZABLE DATA CLASS WITH TRANSIENT FIELDS@Serializabledata class MyScreenState( val userProfile: UserProfile? = null, val items: List\u003cItem\u003e = emptyList(), @Transient val isLoading: Boolean = false, @Transient val isDownloading: Boolean = false,)// YOUR STATE AT THE VIEWMODELprivate val _state by savedStateHandle.getMutableStateFlow( coroutineScope = viewModelScope, defaultValue = MyScreenState(),)val state = _state.asStateFlow()This simple snippet wires up loading/decoding, saving/encoding, and collection efficiently. If you control the model class and @Transient fits your needs perfectly, this solution is excellent and keeps dependencies minimal.Where the Snippet ShinesWhen you don’t have any @Transient properties in your state, otherwise a data class that doesn’t fall short in the “Falls Short” list!Where the Snippet Falls ShortThe @Transient approach works beautifully when the data class definition aligns perfectly with your persistence needs. However, you might encounter situations where it's less ideal:Transient Logic: Your Transient Logic is handled within the data class and not at the ViewModel— The most important problem.Reused Models: If the same MyScreenState class is also used for network DTOs, database caching, or logging where you do need the isLoading field serialized, marking it @Transient breaks those other use cases.Different Transient Needs: One screen might treat isLoading as transient, while another using a similar state structure might need a different field (isSaving, perhaps) treated as transient. @Transient is fixed in the class definition.Runtime Defaults: Sometimes the default value for a transient field isn’t a simple compile-time constant (e.g., clock.isNight()). @Transient always resets to the constructor default.External/Shared Models: You might be working with a data class from a shared KMP module or generated code that you cannot easily modify to add @Transient.If any of these apply, you might start writing more complex manual logic around the simple snippet. This is exactly the gap Reanimator aims to fill.Approach 2 — Reanimator Library: ViewModel-Controlled PersistenceReanimator provides an alternative way to handle state persistence, specifically promoting the idea that the ViewModel should control which parts of its state survive process death. It focuses on giving the ViewModel this control over transient fields, especially for the purpose of saving state via SavedStateHandle.It uses the familiar getMutableStateFlow extension function but adds the optional transientProperties parameter:// YOUR SERIALZABLE DATA CLASS WITH TRANSIENT FIELDS@Serializabledata class MyScreenState( val userProfile: UserProfile? = null, val items: List\u003cItem\u003e = emptyList(), val isLoading: Boolean = false, // no need to mark it @Transient val isDownloading: Boolean = false // no need to mark it @Transient)// In ViewModel:private val _state by savedStateHandle.getMutableStateFlow( defaultValue = MyScreenState(), // Your starting state object coroutineScope = viewModelScope, // Scope for background saving (usually viewModelScope) // Define transient fields HERE, not necessarily in MyScreenState transientProperties = listOf(\"isLoading\", \"isDownloading\"))val state: StateFlow\u003cMyScreenState\u003e = _state.asStateFlow()By defining transientProperties within the ViewModel call, you achieve several architectural advantages compared to embedding @Transient in the data class:Co-located Logic: The decision about which fields are temporary for this specific screen’s lifecycle (like isLoading or showMessage) lives right alongside the rest of the ViewModel's state management logic and its interaction with SavedStateHandle. This keeps related concerns together, potentially improving clarity and maintainability of the ViewModel's responsibilities.Model Integrity \u0026 Reusability: The MyScreenState data class remains \"pure\" – it doesn't contain annotations specific to one particular persistence mechanism (SavedStateHandle). This is crucial if MyScreenState is also used as a network DTO, a database entity, or in unit tests where you need all fields to be serializable without the fixed omission imposed by @Transient. Reanimator ensures the data class isn't \"polluted\" with persistence details specific to the ViewModel's process death handling.Flexibility: It easily supports scenarios where different ViewModels might use the same base MyScreenState but have slightly different transient needs (e.g., one screen has an extra temporary flag). It also works seamlessly with external or generated data classes that you cannot modify to add @Transient.Important: Reanimator does not replace the standard serializer. It uses kotlinx.serialization under the hood. If you don't pass any transientProperties list, Reanimator uses the same fast, direct serialization path as the simple snippet and will respect any @Transient annotations already present in your data class.The library's extra internal logic for filtering/merging only activates when you explicitly leverage the transientProperties feature to gain ViewModel-level control.How Reanimator Works (A Simple Look Inside)You don’t need to know the deep details, but here’s a simple idea of how Reanimator performs its magic using standard Kotlin features:Watching: It listens carefully for any new state updates coming from your MutableStateFlow.Converting \u0026 Filtering: When a new state arrives, it uses Kotlin’s serialization library to turn your state object into JSON text (like a recipe for recreating the object). Crucially, if you provided a transientProperties list, Reanimator looks at the JSON text and removes the parts that match those transient property names. Think of it like keeping your important documents but throwing away temporary sticky notes before filing.Saving: It saves the final JSON text (containing only the persistent data) into the SavedStateHandle.Loading \u0026 Combining: When the app restarts, Reanimator asks SavedStateHandle for the saved JSON text. It reads the persistent data from this text. Then, it looks at the defaultValue you provided initially and finds the starting values for your transient properties. It carefully combines the loaded persistent data with these default transient values to create the complete, correct starting state.Starting: This correctly combined state becomes the first value in your MutableStateFlow when the screen restarts. If no data was saved before (e.g., first app run), it simply uses your defaultValue.Reanimator in Action: A KMP Example ExplainedLet’s look at the code example again, explaining it more. Remember, you can get the full working code from the demo project: github.com/ioannisa/ReanimatorUIDemo.1. Add the Library (in build.gradle.kts): This line tells your project to include the Reanimator library.kotlin { sourceSets { commonMain.dependencies { implementation(\"eu.anifantakis:reanimator:1.0.2\") // ... other libraries } }}2. Define State \u0026 Intents (in commonMain): This data class holds all info for the product screen. @Serializable allows Reanimator to convert it.@Serializable // Needs to be Serializabledata class SimpleProductState( // --- Save This (Persistent) --- val products: List\u003cString\u003e = emptyList(), // The list should be saved val selectedProduct: String? = null, // The selection should be saved // --- Do Not Save This (Transient) --- val isLoading: Boolean = false, // Loading is temporary, reset it val errorMessage: String? = null // Errors are temporary, reset it)// User actionssealed interface SimpleProductIntent { /* ... LoadProducts, SelectProduct, etc. ... */ }We clearly see the mix: products and selectedProduct need saving, while isLoading and errorMessage are temporary.3. Create the ViewModel (in commonMain or androidMain): The ViewModel manages the state and logic.import androidx.lifecycle.SavedStateHandleimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport eu.anifantakis.lib.reanimator.getMutableStateFlow// ... other importsclass SimpleProductViewModel( private val savedStateHandle: SavedStateHandle // Tool for saving state) : ViewModel() { // Or your KMP ViewModel base // **Crucial:** List the names of properties NOT to save private val transientProperties = listOf(\"isLoading\", \"errorMessage\") // ✨ Reanimator makes saving state automatic here! ✨ private val _state: MutableStateFlow\u003cSimpleProductState\u003e by savedStateHandle.getMutableStateFlow( // Starting state, also provides defaults for transient parts on restore defaultValue = SimpleProductState(), // Scope for background saving work coroutineScope = viewModelScope, // Pass the list of properties to ignore when saving transientProperties = transientProperties ) // The UI screen will watch this StateFlow for updates val state: StateFlow\u003cSimpleProductState\u003e = _state.asStateFlow() // --- Handle User Actions --- fun processIntent(intent: SimpleProductIntent) { // When user does something, update the state // Example: User clicks \"Load\" button if (intent is SimpleProductIntent.LoadProducts) { // Set loading to true (transient change) _state.update { it.copy(isLoading = true, errorMessage = null) } // ... start loading data ... // When data arrives: // _state.update { it.copy(products = loadedProducts, isLoading = false) } // Reanimator automatically saves the new products list, // but ignores isLoading when saving! } // ... handle other intents ... } // ... other ViewModel functions ...}What happens with Reanimator here?When you call _state.update { ... }, Reanimator sees the change.It converts the SimpleProductState to JSON but removes isLoading and errorMessage fields.It saves the JSON containing only products and selectedProduct into SavedStateHandle.If process death occurs and the app restarts:Reanimator loads the saved JSON.It gets the products and selectedProduct values from the JSON.It looks at SimpleProductState() (the defaultValue) and sees isLoading is false and errorMessage is null.It combines them: the loaded products/selectedProduct + the default false/null.This combined state is the starting value for _state. The screen correctly shows the saved data without the old loading/error state. Perfect!Main BenefitsFixes the MVI State Problem: Effortlessly handles state objects that mix persistent and temporary data. No more manual filtering!Much Less Code: Dramatically reduces the repetitive code needed for using SavedStateHandle manually (no keys, no get/set, no manual watching).Clearer Code: Keeps your ViewModel logic clean and focused on the app’s features, not on saving mechanics.Works with Kotlin Multiplatform: Write your state saving logic once in commonMain and share it across Android, iOS, Desktop, etc.Safe and Reliable: Uses Kotlin’s standard and robust serialization library.Easy to Start: Very simple to add the library and use the getMutableStateFlow function.How to Get StartedReady to make state saving easier?Add Library: Add the dependency implementation(\"eu.anifantakis:reanimator:1.0.2\") to your build.gradle.kts file (usually in commonMain dependencies).Maven Central: You can find more library details here: https://central.sonatype.com/artifact/eu.anifantakis/reanimator.Source Code: See how it works on GitHub: https://github.com/ioannisa/reanimator.Demo App: See a working example on GitHub: https://github.com/ioannisa/ReanimatorUIDemo.How to Use: Just make sure your state data class is marked with @Serializable and use the savedStateHandle.getMutableStateFlow(...) delegate in your ViewModel.Conclusion: Save State Simply!Saving screen state correctly, especially when dealing with process death or complex state objects in MVI, is essential for creating good, professional apps. It used to involve a lot of difficult, repetitive code.Reanimator offers a wonderfully simple and powerful solution for Android and KMP developers. It automates the process of saving your StateFlow state using SavedStateHandle. Most importantly, it lets you easily tell it which parts of your state are temporary (transient properties) and should not be saved.This helps you write cleaner, safer, and much easier-to-maintain ViewModels. Give Reanimator a try in your next project! It can truly simplify how you handle state persistence, letting you focus your energy on building amazing features for your users.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*3U1qf1ynka6gvXKqdz4ghg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--9613e1ac9967---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*CPyc3y-sp02vMh239V_suQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--9613e1ac9967---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage Source — GPT 4o\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9c97\"\u003eWhy Saving App Information is Very Important\u003c/h2\u003e\u003cp id=\"b0ea\"\u003eWhen we build mobile apps, for \u003cstrong\u003eAndroid\u003c/strong\u003e phones or using \u003cstrong\u003eKotlin Multiplatform (KMP)\u003c/strong\u003e, we need to carefully manage the information shown on the screen. This information is often called the app’s \u003cstrong\u003estate\u003c/strong\u003e. Users expect apps to remember where they were and what they were doing, even if they switch to another app for a moment or get a phone call.\u003c/p\u003e\u003cp id=\"e8d7\"\u003eNow a big challenge, especially on Android, is something called \u003cstrong\u003e“process death”\u003c/strong\u003e. Think of your phone having limited energy and memory. To save these resources, the Android system might completely stop your app if it’s running in the background (not visible on the screen). This isn’t a crash; it’s a normal Android behavior.\u003c/p\u003e\u003cp id=\"1828\"\u003eHowever, when the user comes back to your app, Android restarts it. If you haven’t \u003cstrong\u003esaved the screen’s state\u003c/strong\u003e properly before the app was stopped, the user might see the starting screen again, lose their typed text, or find their place in a list gone. This can be very \u003cstrong\u003efrustrating\u003c/strong\u003e for users.\u003c/p\u003e\u003ch2 id=\"9a56\"\u003eThe Problem: Saving State Manually is Hard Work\u003c/h2\u003e\u003cp id=\"e4dc\"\u003eAndroid gives developers a tool called \u003ccode\u003e\u003cstrong\u003eSavedStateHandle\u003c/strong\u003e\u003c/code\u003e. It\u0026#39;s designed to help save and restore the screen\u0026#39;s state during events like process death. \u003ccode\u003eSavedStateHandle\u003c/code\u003e is useful, but using it directly often feels like a lot of \u003cstrong\u003eextra, repetitive work\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9440\"\u003e\u003cstrong\u003eMaking Names (Keys):\u003c/strong\u003e For every single piece of data you want to save (like a username, a score, a list position), you have to invent a unique text name, called a \u003cstrong\u003ekey\u003c/strong\u003e. Managing many keys can get confusing.\u003c/li\u003e\u003cli id=\"867b\"\u003e\u003cstrong\u003eSaving and Loading by Hand:\u003c/strong\u003e You must write specific code to \u003cstrong\u003eload\u003c/strong\u003e the data using its key every time the screen starts up after being stopped. You also have to write code to \u003cstrong\u003esave\u003c/strong\u003e the data using its key \u003cstrong\u003eevery time\u003c/strong\u003e the data changes. It’s like carefully packing and unpacking a suitcase every time you add or remove one small item.\u003c/li\u003e\u003cli id=\"62e8\"\u003e\u003cstrong\u003eWatching for Every Change:\u003c/strong\u003e You need to constantly watch your app’s state (often held in tools like \u003ccode\u003e\u003cstrong\u003eStateFlow\u003c/strong\u003e\u003c/code\u003e) to know exactly when a piece of data changes so you can save it immediately. This adds more code just for watching.\u003c/li\u003e\u003cli id=\"78e3\"\u003e\u003cstrong\u003eLimited Data Types:\u003c/strong\u003e \u003ccode\u003eSavedStateHandle\u003c/code\u003e easily saves simple things like numbers or text. Saving more complex information, like a list of custom objects, often requires extra steps to convert it into a format \u003ccode\u003eSavedStateHandle\u003c/code\u003e understands (like \u003ccode\u003eSerializable\u003c/code\u003e or \u003ccode\u003eParcelable\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9e11\"\u003eAll this manual work makes the code in our \u003cstrong\u003eViewModels\u003c/strong\u003e (the place where we usually manage screen logic and state) longer, messier, and harder to read. It takes focus away from building the app’s features and makes it easier to introduce bugs if we forget to save or load something.\u003c/p\u003e\u003ch2 id=\"ac97\"\u003eThe MVI Problem: One State Object, Two Kinds of Data\u003c/h2\u003e\u003cp id=\"0a8f\"\u003eMany modern app developers like using patterns such as \u003cstrong\u003eMVI (Model-View-Intent)\u003c/strong\u003e. A common idea in MVI is to have \u003cstrong\u003eone single state object\u003c/strong\u003e for each screen. This object holds \u003cem\u003eall\u003c/em\u003e the information needed to draw the screen at any moment. This can make the app’s logic easier to follow and predict.\u003c/p\u003e\u003cp id=\"4926\"\u003eHowever, this creates a specific problem for saving state: This single state object often contains \u003cstrong\u003etwo different kinds of information mixed together\u003c/strong\u003e:\u003c/p\u003e\u003col\u003e\u003cli id=\"3f1e\"\u003e\u003cstrong\u003ePersistent State:\u003c/strong\u003e Information that \u003cstrong\u003emust be saved\u003c/strong\u003e and restored after process death. Examples include data loaded from the network (like a list of products), user settings, text the user has typed, or which item is selected in a list.\u003c/li\u003e\u003cli id=\"6fb3\"\u003e\u003cstrong\u003eTransient State:\u003c/strong\u003e Temporary information that \u003cstrong\u003eshould NOT be saved\u003c/strong\u003e. This state should reset to its default value when the app restarts. Examples include loading indicators (like spinners), temporary error messages that should disappear, flags to trigger a one-time animation, or navigation commands.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a1b6\"\u003eLet’s look at an example state object again:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"07c3\"\u003e@Serializable\u003cbr/\u003edata class MyScreenState(\u003cp\u003e    // --- Save This ---\u003cbr/\u003e    val userProfile: UserProfile? = null,\u003cbr/\u003e    val items: List\u0026lt;Item\u0026gt; = emptyList(),\u003c/p\u003e\u003cp\u003e    // --- Do Not Save This (Transient) ---\u003cbr/\u003e    val isLoading: Boolean = false,\u003cbr/\u003e    val isDownloading: Boolean = false\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4623\"\u003eIf we simply save the \u003cem\u003eentire\u003c/em\u003e \u003ccode\u003eMyScreenState\u003c/code\u003e object using \u003ccode\u003eSavedStateHandle\u003c/code\u003e, we run into trouble. When the app restarts after process death, the \u003ccode\u003eisLoading\u003c/code\u003e flag might still be \u003ccode\u003etrue\u003c/code\u003e (showing a spinner forever!) or an old status might still show that doesn’t make sense anymore.\u003c/p\u003e\u003cp id=\"c585\"\u003eTo fix this manually, the developer would have to write extra code \u003cem\u003ebefore\u003c/em\u003e saving to pick out \u003cem\u003eonly\u003c/em\u003e the \u003ccode\u003euserProfile\u003c/code\u003e and \u003ccode\u003eitems\u003c/code\u003e, ignoring \u003ccode\u003eisLoading\u003c/code\u003e and \u003ccode\u003eshowMessage\u003c/code\u003e. Then, when the app restarts, they\u0026#39;d need more code to make sure \u003ccode\u003eisLoading\u003c/code\u003e is set back to \u003ccode\u003efalse\u003c/code\u003e and \u003ccode\u003eshowMessage\u003c/code\u003e is set back to \u003ccode\u003enull\u003c/code\u003e. This manual filtering and resetting adds complexity and \u003cstrong\u003eboilerplate code\u003c/strong\u003e – exactly the kind of repetitive work MVI tries to help us avoid!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"ac2f\"\u003eApproach 1 — A Lightweight Snippet: \u003ccode\u003e@Transient\u003c/code\u003e + snippet\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"ee1f\"\u003ethanks \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/84897886aded?source=post_page---user_mention--9613e1ac9967---------------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eJoost Klitsie\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"96c6\"\u003eIf your \u003cstrong\u003estate class is primarily used within a specific ViewModel and not serialized elsewhere\u003c/strong\u003e with different needs, Kotlin\u0026#39;s built-in \u003ccode\u003e@Transient\u003c/code\u003e annotation is often the simplest solution.\u003c/p\u003e\u003cp id=\"c829\"\u003eYou mark the fields directly in the data class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"26b6\"\u003eimport androidx.lifecycle.SavedStateHandle\u003cbr/\u003eimport kotlinx.coroutines.CoroutineScope\u003cbr/\u003eimport kotlinx.coroutines.flow.MutableStateFlow\u003cbr/\u003eimport kotlinx.coroutines.flow.launchIn\u003cbr/\u003eimport kotlinx.coroutines.flow.onEach\u003cbr/\u003eimport kotlinx.serialization.json.Json\u003cbr/\u003eimport kotlin.properties.PropertyDelegateProvider\u003cbr/\u003eimport kotlin.properties.ReadOnlyProperty\u003cp\u003einline fun \u0026lt;reified T\u0026gt; SavedStateHandle.getMutableStateFlow(\u003cbr/\u003e    defaultValue: T,\u003cbr/\u003e    coroutineScope: CoroutineScope,\u003cbr/\u003e    key: String? = null,\u003cbr/\u003e    json: Json = Json { ignoreUnknownKeys = true },\u003cbr/\u003e) = PropertyDelegateProvider\u0026lt;Any, ReadOnlyProperty\u0026lt;Any, MutableStateFlow\u0026lt;T\u0026gt;\u0026gt;\u0026gt; { thisRef, property -\u0026gt;\u003cbr/\u003e    val viewModelClassName = thisRef.let { it::class.simpleName } ?: \u0026#34;UnknownViewModel\u0026#34;\u003cbr/\u003e    val actualKey = key ?: \u0026#34;${viewModelClassName}_${property.name}\u0026#34;\u003c/p\u003e\u003cp\u003e    val stateFlow = MutableStateFlow(\u003cbr/\u003e        get\u0026lt;String\u0026gt;(actualKey)?.let { json.decodeFromString\u0026lt;T\u0026gt;(it) } ?: defaultValue\u003cbr/\u003e    ).also { flow -\u0026gt;\u003cbr/\u003e        flow.onEach { set(actualKey, json.encodeToString(it)) }.launchIn(coroutineScope)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    ReadOnlyProperty { _, _ -\u0026gt; stateFlow }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7951\"\u003eAnd in your ViewModel:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"47a7\"\u003e// YOUR SERIALZABLE DATA CLASS WITH TRANSIENT FIELDS\u003cbr/\u003e@Serializable\u003cbr/\u003edata class MyScreenState(\u003cbr/\u003e    val userProfile: UserProfile? = null,\u003cbr/\u003e    val items: List\u0026lt;Item\u0026gt; = emptyList(),\u003cbr/\u003e    @Transient val isLoading: Boolean = false,\u003cbr/\u003e    @Transient val isDownloading: Boolean = false,\u003cbr/\u003e)\u003cp\u003e// YOUR STATE AT THE VIEWMODEL\u003cbr/\u003eprivate val _state by savedStateHandle.getMutableStateFlow(\u003cbr/\u003e    coroutineScope = viewModelScope,\u003cbr/\u003e    defaultValue = MyScreenState(),\u003cbr/\u003e)\u003cbr/\u003eval state = _state.asStateFlow()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2588\"\u003eThis \u003cstrong\u003esimple snippet \u003c/strong\u003ewires up loading/decoding, saving/encoding, and collection efficiently. \u003cstrong\u003eIf you control the model class and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e@Transient\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e fits your needs perfectly, this solution is excellent and keeps dependencies minimal.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"8b30\"\u003eWhere the Snippet Shines\u003c/h2\u003e\u003cp id=\"afc1\"\u003eWhen you don’t have any \u003ccode\u003e@Transient\u003c/code\u003e properties in your state, otherwise a data class that doesn’t fall short in the “Falls Short” list!\u003c/p\u003e\u003ch2 id=\"09f9\"\u003eWhere the Snippet Falls Short\u003c/h2\u003e\u003cp id=\"8945\"\u003eThe \u003ccode\u003e@Transient\u003c/code\u003e approach works beautifully when the data class definition aligns perfectly with your persistence needs. However, you might encounter situations where it\u0026#39;s less ideal:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1abc\"\u003e\u003cstrong\u003eTransient Logic: \u003c/strong\u003eYour Transient Logic is handled within the data class and not at the ViewModel— The most important problem.\u003c/li\u003e\u003cli id=\"8348\"\u003e\u003cstrong\u003eReused Models:\u003c/strong\u003e If the same \u003ccode\u003eMyScreenState\u003c/code\u003e class is also used for network DTOs, database caching, or logging where you \u003cem\u003edo\u003c/em\u003e need the \u003ccode\u003eisLoading\u003c/code\u003e field serialized, marking it \u003ccode\u003e@Transient\u003c/code\u003e breaks those other use cases.\u003c/li\u003e\u003cli id=\"576c\"\u003e\u003cstrong\u003eDifferent Transient Needs:\u003c/strong\u003e One screen might treat \u003ccode\u003eisLoading\u003c/code\u003e as transient, while another using a similar state structure might need a different field (\u003ccode\u003eisSaving\u003c/code\u003e, perhaps) treated as transient. \u003ccode\u003e@Transient\u003c/code\u003e is fixed in the class definition.\u003c/li\u003e\u003cli id=\"c5ea\"\u003e\u003cstrong\u003eRuntime Defaults:\u003c/strong\u003e Sometimes the default value for a transient field isn’t a simple compile-time constant (e.g., \u003ccode\u003eclock.isNight()\u003c/code\u003e). \u003ccode\u003e@Transient\u003c/code\u003e always resets to the constructor default.\u003c/li\u003e\u003cli id=\"7602\"\u003e\u003cstrong\u003eExternal/Shared Models:\u003c/strong\u003e You might be working with a data class from a shared KMP module or generated code that you cannot easily modify to add \u003ccode\u003e@Transient\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2066\"\u003eIf any of these apply, you might start writing more complex manual logic around the simple snippet. \u003cstrong\u003eThis is exactly the gap Reanimator aims to fill.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"03be\"\u003eApproach 2 — Reanimator Library: ViewModel-Controlled Persistence\u003c/h2\u003e\u003cp id=\"2c92\"\u003eReanimator provides an alternative way to handle state persistence, specifically promoting the idea that the \u003cstrong\u003eViewModel should control which parts of its state survive process death\u003c/strong\u003e. It focuses on giving the ViewModel this control over transient fields, especially for the purpose of saving state via \u003ccode\u003eSavedStateHandle\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"af2e\"\u003eIt uses the familiar \u003ccode\u003egetMutableStateFlow\u003c/code\u003e extension function but adds the optional \u003ccode\u003etransientProperties\u003c/code\u003e parameter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"990d\"\u003e// YOUR SERIALZABLE DATA CLASS WITH TRANSIENT FIELDS\u003cbr/\u003e@Serializable\u003cbr/\u003edata class MyScreenState(\u003cbr/\u003e    val userProfile: UserProfile? = null,\u003cbr/\u003e    val items: List\u0026lt;Item\u0026gt; = emptyList(),\u003cbr/\u003e    val isLoading: Boolean = false,    // no need to mark it @Transient\u003cbr/\u003e    val isDownloading: Boolean = false // no need to mark it @Transient\u003cbr/\u003e)\u003cp\u003e// In ViewModel:\u003cbr/\u003eprivate val _state by savedStateHandle.getMutableStateFlow(\u003cbr/\u003e    defaultValue = MyScreenState(),  // Your starting state object\u003cbr/\u003e    coroutineScope = viewModelScope, // Scope for background saving (usually viewModelScope)\u003c/p\u003e\u003cp\u003e        // Define transient fields HERE, not necessarily in MyScreenState\u003cbr/\u003e    transientProperties = listOf(\u0026#34;isLoading\u0026#34;, \u0026#34;isDownloading\u0026#34;)\u003cbr/\u003e)\u003cbr/\u003eval state: StateFlow\u0026lt;MyScreenState\u0026gt; = _state.asStateFlow()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f9a6\"\u003eBy defining \u003ccode\u003etransientProperties\u003c/code\u003e within the ViewModel call, you achieve several architectural advantages compared to embedding \u003ccode\u003e@Transient\u003c/code\u003e in the data class:\u003c/p\u003e\u003col\u003e\u003cli id=\"592d\"\u003e\u003cstrong\u003eCo-located Logic:\u003c/strong\u003e The decision about which fields are temporary \u003cem\u003efor this specific screen’s lifecycle\u003c/em\u003e (like \u003ccode\u003eisLoading\u003c/code\u003e or \u003ccode\u003eshowMessage\u003c/code\u003e) lives right alongside the rest of the ViewModel\u0026#39;s state management logic and its interaction with \u003ccode\u003eSavedStateHandle\u003c/code\u003e. This keeps related concerns together, potentially improving clarity and maintainability of the ViewModel\u0026#39;s responsibilities.\u003c/li\u003e\u003cli id=\"14db\"\u003e\u003cstrong\u003eModel Integrity \u0026amp; Reusability:\u003c/strong\u003e The \u003ccode\u003eMyScreenState\u003c/code\u003e data class remains \u0026#34;pure\u0026#34; – it doesn\u0026#39;t contain annotations specific to one particular persistence mechanism (\u003ccode\u003eSavedStateHandle\u003c/code\u003e). This is crucial if \u003ccode\u003eMyScreenState\u003c/code\u003e is also used as a network DTO, a database entity, or in unit tests where you \u003cem\u003eneed\u003c/em\u003e all fields to be serializable without the fixed omission imposed by \u003ccode\u003e@Transient\u003c/code\u003e. Reanimator ensures the data class isn\u0026#39;t \u0026#34;polluted\u0026#34; with persistence details specific to the ViewModel\u0026#39;s process death handling.\u003c/li\u003e\u003cli id=\"5785\"\u003e\u003cstrong\u003eFlexibility:\u003c/strong\u003e It easily supports scenarios where different ViewModels might use the same base \u003ccode\u003eMyScreenState\u003c/code\u003e but have slightly different transient needs (e.g., one screen has an extra temporary flag). It also works seamlessly with external or generated data classes that you cannot modify to add \u003ccode\u003e@Transient\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"ec15\"\u003e\u003cstrong\u003eImportant:\u003c/strong\u003e Reanimator \u003cstrong\u003edoes not replace the standard serializer\u003c/strong\u003e. It uses \u003ccode\u003ekotlinx.serialization\u003c/code\u003e under the hood. If you \u003cem\u003edon\u0026#39;t\u003c/em\u003e pass any \u003ccode\u003etransientProperties\u003c/code\u003e list, Reanimator uses the same fast, direct serialization path as the simple snippet and \u003cstrong\u003ewill respect any \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e@Transient\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e annotations\u003c/strong\u003e already present in your data class.\u003c/p\u003e\u003cp id=\"234d\"\u003eThe library\u0026#39;s extra internal logic for filtering/merging only activates when you explicitly leverage the \u003ccode\u003etransientProperties\u003c/code\u003e feature to gain ViewModel-level control.\u003c/p\u003e\u003ch2 id=\"5df0\"\u003eHow Reanimator Works (A Simple Look Inside)\u003c/h2\u003e\u003cp id=\"c049\"\u003eYou don’t need to know the deep details, but here’s a simple idea of how Reanimator performs its magic using standard Kotlin features:\u003c/p\u003e\u003col\u003e\u003cli id=\"8b84\"\u003e\u003cstrong\u003eWatching:\u003c/strong\u003e It listens carefully for any new state updates coming from your \u003ccode\u003eMutableStateFlow\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"abe6\"\u003e\u003cstrong\u003eConverting \u0026amp; Filtering:\u003c/strong\u003e When a new state arrives, it uses Kotlin’s serialization library to turn your state object into JSON text (like a recipe for recreating the object). \u003cstrong\u003eCrucially\u003c/strong\u003e, if you provided a \u003ccode\u003etransientProperties\u003c/code\u003e list, Reanimator looks at the JSON text and removes the parts that match those transient property names. Think of it like keeping your important documents but throwing away temporary sticky notes before filing.\u003c/li\u003e\u003cli id=\"2e39\"\u003e\u003cstrong\u003eSaving:\u003c/strong\u003e It saves the final JSON text (containing only the persistent data) into the \u003ccode\u003eSavedStateHandle\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"49c4\"\u003e\u003cstrong\u003eLoading \u0026amp; Combining:\u003c/strong\u003e When the app restarts, Reanimator asks \u003ccode\u003eSavedStateHandle\u003c/code\u003e for the saved JSON text. It reads the persistent data from this text. Then, it looks at the \u003ccode\u003edefaultValue\u003c/code\u003e you provided initially and finds the starting values for your transient properties. It \u003cstrong\u003ecarefully combines\u003c/strong\u003e the loaded persistent data with these default transient values to create the complete, correct starting state.\u003c/li\u003e\u003cli id=\"e94c\"\u003e\u003cstrong\u003eStarting:\u003c/strong\u003e This correctly combined state becomes the first value in your \u003ccode\u003eMutableStateFlow\u003c/code\u003e when the screen restarts. If no data was saved before (e.g., first app run), it simply uses your \u003ccode\u003edefaultValue\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"1bcc\"\u003eReanimator in Action: A KMP Example Explained\u003c/h2\u003e\u003cp id=\"1687\"\u003eLet’s look at the code example again, explaining it more. Remember, you can get the full working code from the demo project: \u003ca href=\"https://github.com/ioannisa/ReanimatorUIDemo\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003egithub.com/ioannisa/ReanimatorUIDemo\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"59e5\"\u003e\u003cstrong\u003e1. Add the Library (in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e This line tells your project to include the Reanimator library.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f005\"\u003ekotlin {\u003cbr/\u003e    sourceSets {\u003cbr/\u003e        commonMain.dependencies {\u003cbr/\u003e            implementation(\u0026#34;eu.anifantakis:reanimator:1.0.2\u0026#34;)\u003cbr/\u003e            // ... other libraries\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a558\"\u003e\u003cstrong\u003e2. Define State \u0026amp; Intents (in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e This data class holds all info for the product screen. \u003ccode\u003e@Serializable\u003c/code\u003e allows Reanimator to convert it.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b4e1\"\u003e@Serializable // Needs to be Serializable\u003cbr/\u003edata class SimpleProductState(\u003cbr/\u003e    // --- Save This (Persistent) ---\u003cbr/\u003e    val products: List\u0026lt;String\u0026gt; = emptyList(),   // The list should be saved\u003cbr/\u003e    val selectedProduct: String? = null,        // The selection should be saved\u003cp\u003e    // --- Do Not Save This (Transient) ---\u003cbr/\u003e    val isLoading: Boolean = false,      // Loading is temporary, reset it\u003cbr/\u003e    val errorMessage: String? = null     // Errors are temporary, reset it\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003e// User actions\u003cbr/\u003esealed interface SimpleProductIntent { /* ... LoadProducts, SelectProduct, etc. ... */ }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eea8\"\u003eWe clearly see the mix: \u003ccode\u003eproducts\u003c/code\u003e and \u003ccode\u003eselectedProduct\u003c/code\u003e need saving, while \u003ccode\u003eisLoading\u003c/code\u003e and \u003ccode\u003eerrorMessage\u003c/code\u003e are temporary.\u003c/p\u003e\u003cp id=\"4db6\"\u003e\u003cstrong\u003e3. Create the ViewModel (in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e or \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eandroidMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e The ViewModel manages the state and logic.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a4df\"\u003eimport androidx.lifecycle.SavedStateHandle\u003cbr/\u003eimport androidx.lifecycle.ViewModel\u003cbr/\u003eimport androidx.lifecycle.viewModelScope\u003cbr/\u003eimport eu.anifantakis.lib.reanimator.getMutableStateFlow\u003cbr/\u003e// ... other imports\u003cp\u003eclass SimpleProductViewModel(\u003cbr/\u003e    private val savedStateHandle: SavedStateHandle // Tool for saving state\u003cbr/\u003e) : ViewModel() { // Or your KMP ViewModel base\u003c/p\u003e\u003cp\u003e    // **Crucial:** List the names of properties NOT to save\u003cbr/\u003e    private val transientProperties = listOf(\u0026#34;isLoading\u0026#34;, \u0026#34;errorMessage\u0026#34;)\u003c/p\u003e\u003cp\u003e    // ✨ Reanimator makes saving state automatic here! ✨\u003cbr/\u003e    private val _state: MutableStateFlow\u0026lt;SimpleProductState\u0026gt; by savedStateHandle.getMutableStateFlow(\u003cbr/\u003e        // Starting state, also provides defaults for transient parts on restore\u003cbr/\u003e        defaultValue = SimpleProductState(),\u003cbr/\u003e        // Scope for background saving work\u003cbr/\u003e        coroutineScope = viewModelScope,\u003cbr/\u003e        // Pass the list of properties to ignore when saving\u003cbr/\u003e        transientProperties = transientProperties\u003cbr/\u003e    )\u003cbr/\u003e    // The UI screen will watch this StateFlow for updates\u003cbr/\u003e    val state: StateFlow\u0026lt;SimpleProductState\u0026gt; = _state.asStateFlow()\u003c/p\u003e\u003cp\u003e    // --- Handle User Actions ---\u003cbr/\u003e    fun processIntent(intent: SimpleProductIntent) {\u003cbr/\u003e        // When user does something, update the state\u003cbr/\u003e        // Example: User clicks \u0026#34;Load\u0026#34; button\u003cbr/\u003e        if (intent is SimpleProductIntent.LoadProducts) {\u003cbr/\u003e            // Set loading to true (transient change)\u003cbr/\u003e            _state.update { it.copy(isLoading = true, errorMessage = null) }\u003cbr/\u003e            // ... start loading data ...\u003cbr/\u003e            // When data arrives:\u003cbr/\u003e            // _state.update { it.copy(products = loadedProducts, isLoading = false) }\u003cbr/\u003e            // Reanimator automatically saves the new products list,\u003cbr/\u003e            // but ignores isLoading when saving!\u003cbr/\u003e        }\u003cbr/\u003e        // ... handle other intents ...\u003cbr/\u003e    }\u003cbr/\u003e    // ... other ViewModel functions ...\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8cd2\"\u003e\u003cstrong\u003eWhat happens with Reanimator here?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0cc1\"\u003eWhen you call \u003ccode\u003e_state.update { ... }\u003c/code\u003e, Reanimator sees the change.\u003c/li\u003e\u003cli id=\"dc4f\"\u003eIt converts the \u003ccode\u003eSimpleProductState\u003c/code\u003e to JSON but \u003cstrong\u003eremoves\u003c/strong\u003e \u003ccode\u003eisLoading\u003c/code\u003e and \u003ccode\u003eerrorMessage\u003c/code\u003e fields.\u003c/li\u003e\u003cli id=\"da92\"\u003eIt saves the JSON containing only \u003ccode\u003eproducts\u003c/code\u003e and \u003ccode\u003eselectedProduct\u003c/code\u003e into \u003ccode\u003eSavedStateHandle\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"d0c0\"\u003eIf \u003cstrong\u003eprocess death\u003c/strong\u003e occurs and the app restarts:\u003c/li\u003e\u003cli id=\"4e54\"\u003eReanimator loads the saved JSON.\u003c/li\u003e\u003cli id=\"cc7b\"\u003eIt gets the \u003ccode\u003eproducts\u003c/code\u003e and \u003ccode\u003eselectedProduct\u003c/code\u003e values from the JSON.\u003c/li\u003e\u003cli id=\"35eb\"\u003eIt looks at \u003ccode\u003eSimpleProductState()\u003c/code\u003e (the \u003ccode\u003edefaultValue\u003c/code\u003e) and sees \u003ccode\u003eisLoading\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e and \u003ccode\u003eerrorMessage\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c59b\"\u003eIt \u003cstrong\u003ecombines\u003c/strong\u003e them: the loaded \u003ccode\u003eproducts\u003c/code\u003e/\u003ccode\u003eselectedProduct\u003c/code\u003e + the default \u003ccode\u003efalse\u003c/code\u003e/\u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"f922\"\u003eThis combined state is the starting value for \u003ccode\u003e_state\u003c/code\u003e. The screen correctly shows the saved data without the old loading/error state. \u003cstrong\u003ePerfect!\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ea8c\"\u003eMain Benefits\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e203\"\u003e\u003cstrong\u003eFixes the MVI State Problem:\u003c/strong\u003e \u003cstrong\u003eEffortlessly\u003c/strong\u003e handles state objects that mix persistent and temporary data. No more manual filtering!\u003c/li\u003e\u003cli id=\"7e5e\"\u003e\u003cstrong\u003eMuch Less Code:\u003c/strong\u003e \u003cstrong\u003eDramatically reduces\u003c/strong\u003e the repetitive code needed for using \u003ccode\u003eSavedStateHandle\u003c/code\u003e manually (no keys, no get/set, no manual watching).\u003c/li\u003e\u003cli id=\"8aab\"\u003e\u003cstrong\u003eClearer Code:\u003c/strong\u003e Keeps your ViewModel logic \u003cstrong\u003eclean and focused\u003c/strong\u003e on the app’s features, not on saving mechanics.\u003c/li\u003e\u003cli id=\"ebe9\"\u003e\u003cstrong\u003eWorks with Kotlin Multiplatform:\u003c/strong\u003e Write your state saving logic \u003cstrong\u003eonce\u003c/strong\u003e in \u003ccode\u003ecommonMain\u003c/code\u003e and share it across Android, iOS, Desktop, etc.\u003c/li\u003e\u003cli id=\"ecb2\"\u003e\u003cstrong\u003eSafe and Reliable:\u003c/strong\u003e Uses Kotlin’s standard and \u003cstrong\u003erobust\u003c/strong\u003e serialization library.\u003c/li\u003e\u003cli id=\"98a7\"\u003e\u003cstrong\u003eEasy to Start:\u003c/strong\u003e \u003cstrong\u003eVery simple\u003c/strong\u003e to add the library and use the \u003ccode\u003egetMutableStateFlow\u003c/code\u003e function.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f538\"\u003eHow to Get Started\u003c/h2\u003e\u003cp id=\"7b61\"\u003eReady to make state saving easier?\u003c/p\u003e\u003col\u003e\u003cli id=\"3fc8\"\u003e\u003cstrong\u003eAdd Library:\u003c/strong\u003e Add the dependency \u003ccode\u003eimplementation(\u0026#34;eu.anifantakis:reanimator:1.0.2\u0026#34;)\u003c/code\u003e to your \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e file (usually in \u003ccode\u003ecommonMain\u003c/code\u003e dependencies).\u003c/li\u003e\u003cli id=\"8986\"\u003e\u003cstrong\u003eMaven Central:\u003c/strong\u003e You can find more library details here: \u003cbr/\u003e\u003ca href=\"https://central.sonatype.com/artifact/eu.anifantakis/reanimator\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://central.sonatype.com/artifact/eu.anifantakis/reanimator\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"9e02\"\u003e\u003cstrong\u003eSource Code:\u003c/strong\u003e See how it works on GitHub: \u003ca href=\"https://github.com/ioannisa/reanimator\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/ioannisa/reanimator\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"d308\"\u003e\u003cstrong\u003eDemo App:\u003c/strong\u003e See a working example on GitHub: \u003ca href=\"https://github.com/ioannisa/ReanimatorUIDemo\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/ioannisa/ReanimatorUIDemo\u003c/a\u003e.\u003c/li\u003e\u003cli id=\"a7ef\"\u003e\u003cstrong\u003eHow to Use:\u003c/strong\u003e Just make sure your state data class is marked with \u003ccode\u003e@Serializable\u003c/code\u003e and use the \u003ccode\u003esavedStateHandle.getMutableStateFlow(...)\u003c/code\u003e delegate in your ViewModel.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"4ad7\"\u003eConclusion: Save State Simply!\u003c/h2\u003e\u003cp id=\"a649\"\u003eSaving screen state correctly, especially when dealing with \u003cstrong\u003eprocess death\u003c/strong\u003e or complex state objects in \u003cstrong\u003eMVI\u003c/strong\u003e, is \u003cstrong\u003eessential\u003c/strong\u003e for creating good, professional apps. It used to involve a lot of difficult, repetitive code.\u003c/p\u003e\u003cp id=\"b8fb\"\u003e\u003cstrong\u003eReanimator\u003c/strong\u003e offers a \u003cstrong\u003ewonderfully simple and powerful\u003c/strong\u003e solution for \u003cstrong\u003eAndroid and KMP\u003c/strong\u003e developers. It \u003cstrong\u003eautomates\u003c/strong\u003e the process of saving your \u003ccode\u003eStateFlow\u003c/code\u003e state using \u003ccode\u003eSavedStateHandle\u003c/code\u003e. Most importantly, it lets you easily tell it which parts of your state are temporary (\u003cstrong\u003etransient properties\u003c/strong\u003e) and should \u003cem\u003enot\u003c/em\u003e be saved.\u003c/p\u003e\u003cp id=\"b5cb\"\u003eThis helps you write \u003cstrong\u003ecleaner, safer, and much easier-to-maintain\u003c/strong\u003e ViewModels. Give \u003cstrong\u003eReanimator\u003c/strong\u003e a try in your next project! It can truly \u003cstrong\u003esimplify\u003c/strong\u003e how you handle state persistence, letting you focus your energy on building amazing features for your users.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2025-04-22T13:34:40.865Z",
  "modifiedTime": null
}
