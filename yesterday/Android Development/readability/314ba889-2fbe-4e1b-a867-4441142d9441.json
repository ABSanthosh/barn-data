{
  "id": "314ba889-2fbe-4e1b-a867-4441142d9441",
  "title": "The greatest KotlinConf 2025 announcements!",
  "link": "https://blog.kotlin-academy.com/the-greatest-kotlinconf-2025-announcements-c6eb497bf389?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Marcin Moskala",
  "published": "Tue, 03 Jun 2025 11:01:20 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "kotlin-coroutines",
    "kotlinconf",
    "kotlin",
    "kotlin-multiplatform"
  ],
  "byline": "Marcin Moskala",
  "length": 6591,
  "excerpt": "Oh man, this KotlinConf was something. Certainly better than the last one, when the greatest announcement was faster Kotlin build time. This year, K2 is finally stable, and new features have begun to‚Ä¶",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "The greatest KotlinConf 2025 announcements!Hello Kotliners,Oh man, this KotlinConf was something. Certainly better than the last one, when the greatest announcement was faster Kotlin build time. This year, K2 is finally stable, and new features have begun to flow into Kotlin. We had some great announcements, like rich errors, name-based destructuring, and much more. Today I summarized them, and I am ready to share them with you. Let‚Äôs dive in after a short announcement.üì¢ Registration is now open for the upcoming webinar:‚ÄúUnderstanding Structured Concurrency in Kotlin Coroutines‚Äùüóì Date: 12.06.2025üïí Time: 2 time zones to choose fromLet‚Äôs explore structured concurrency! We will learn why it was introduced, how it helps with cancellation and synchronization, and why other languages introduced it after Kotlin popularized this revolutionary concept. Then we will understand how it is implemented in Kotlin, and learn about common patterns using it, and anti-patterns that break structured concurrency.üëâ Sign up hereThe greatest KotlinConf 2025 announcementsName-Based DestructuringThat might seem minor, but you wouldn‚Äôt believe how many people asked me about this feature. As I am teaching people with JavaScript or Swift background, they constantly ask me about name-based destructuring, that now seems to be an absolute mast-have in many languages. It will soon be available in Kotlin as well. The syntax will include using val or var inside the destructuring brackets, like this:For this code to compile, variable names must match property names, but they can be specified in any order. It will work in lambdas or loops.This feature was announced to become experimental in Kotlin 2.4 (so next year). I am not that sure about the syntax, but I do not have any better idea. I am just happy that it is finally coming.Rich ErrorsThat is going to be the greatest change in Kotlin since it became stable. Kotlin does not support checked exceptions because, according to best practices, exceptions should not be used to signal expected situations. To deal with such situations, it is best practice to either use Result type or nullable result.However, those options are not always satisfactory. Result cannot type-safely express what kind of exceptions it can contain. It can also be easily ignored, and it does not have any idioms that would allow operating on it in a simple way. That is why we need a better way to express errors in Kotlin.I already wrote about rich errors last year, when they were still known as ‚ÄúUnion types with errors‚Äù. Their original name was longer, but it clearly expressed what they are ‚Äî types that express either a result or an error. A lot like Either from Arrow, but with build-in support in the language.Rich errors will have similar support as nullable types. So they should support:?. safe call operator - that will call the right-hand side only if the left-hand side is not an error, otherwise it will return the error.?: elvis operator - that will return the right-hand side if the left-hand side is an error, otherwise it will return the left-hand side.!! not-error assertion operator - that will throw an exception if the left-hand side is an error, otherwise it will return the left-hand side.Overall, experience with rich errors should be similar to nullable types, but with more information about the error. More about it here.Plugins joining Kotlin ecosystemI was a bit surprised by this announcement. For years, Kotlin was intentionally extracting many features into external plugins, like Power Assert, Kotlin Serialization, Binary Compatibility Validator, Dokka, or Kover. Now, Vsevolod Tolstopyatov announced that those plugins will be distributed as part of the Kotlin plugin. You will not need to add separate dependencies to use them, they will be available out of the box, and they might only need to be enabled or configured in the Gradle build script.More about it here.Agents and MCP in KotlinMan, there was a lot about AI in KotlinConf 2025. It is quite clearly a priority for JetBrains (do not worry, new teams were formed to work on those new features, so it will not slow down the development of other features).The opening keynote included a substantial section on AI, and there were several sessions dedicated to the topic. Except for a very simple things, like Kotlin SDK to use different AI models (come on, one could write a custom Open AI or Anthropic SDK in a couple of hours, and Spring AI is currently just a more straightforward way to use those on Spring), I think the most interesting announcement was MCP Kotlin SDK, and a library to define agents in Kotlin.MCP (Model context protocol) is a protocol created by OpenAI that standardizes how applications provide context to LLMs. It is now widely adopted by many AI providers (surprisingly even Google adopted it instead of creating their own). Good that we can now use it simply in Kotlin as well.The second big announcement was Koog, a new framework from JetBrains to define agents in Kotlin. I must say, it looks very promising, and I am looking forward to trying it out.Compose Multiplatform for iOS is now stableQuite clearly JetBrains works hard on making Compose Multiplatform work nicely on all platforms. There were many improvements made over the last year, and now Compose for iOS is finally stable.I am happy with this announcement, I am just waiting now until Compose for Wasm becomes stable as well.Coroutines Debugging has been improvedThat was announced in a lightning talk, not in the main keynote, but I think it is worth mentioning. Coroutines debugging has been significantly improved. Since Kotlin 2.2, local variables will not be optimized out in debug mode. In recent versions of IntelliJ and Android Studio, step over, step into, and step out actions will guarantee to stop at the same coroutine. They also announced that exception stack traces will soon include not only the last function call, but all suspending function that were called before the exception was thrown. That will be a great improvement, and I am looking forward to it.Coroutines MasteryTime for our announcement. As a part of Kt. Academy vision to create a next-level learning experience for Kotlin developers, I am happy to announce that we will start the first edition of the Coroutines Mastery course. During 5-weeks of course, our aspiration will be to turn all participants into experts in coroutines. We hope to make another generation of conscious Kotlin users, introducing new quality standards, and uplifting our whole community. Keep your fingers crossed for us.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*fEsQCqAYq20ttRYkGcYOLw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"2772\" data-testid=\"storyTitle\"\u003eThe greatest KotlinConf 2025 announcements!\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@marcinmoskala?source=post_page---byline--c6eb497bf389---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Marcin Moskala\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*2o0KnikamZji_OvyyIotuQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"8753\"\u003eHello Kotliners,\u003c/p\u003e\u003cp id=\"5caf\"\u003eOh man, this KotlinConf was something. Certainly better than the last one, when the greatest announcement was faster Kotlin build time. This year, K2 is finally stable, and new features have begun to flow into Kotlin. We had some great announcements, like rich errors, name-based destructuring, and much more. Today I summarized them, and I am ready to share them with you. Let‚Äôs dive in after a short announcement.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bddd\"\u003e\u003cstrong\u003eüì¢ Registration is now open for the upcoming webinar:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"faa6\"\u003e\u003cstrong\u003e‚Äú\u003c/strong\u003e\u003ca href=\"https://webinar.kt.academy/structured-concurrency05\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eUnderstanding Structured Concurrency in Kotlin Coroutines\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e‚Äù\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"6d42\"\u003eüóì \u003cstrong\u003eDate:\u003c/strong\u003e 12.06.2025\u003c/p\u003e\u003cp id=\"bf81\"\u003eüïí \u003cstrong\u003eTime:\u003c/strong\u003e 2 time zones to choose from\u003c/p\u003e\u003cp id=\"559b\"\u003eLet‚Äôs explore structured concurrency! We will learn why it was introduced, how it helps with cancellation and synchronization, and why other languages introduced it after Kotlin popularized this revolutionary concept. Then we will understand how it is implemented in Kotlin, and learn about common patterns using it, and anti-patterns that break structured concurrency.\u003c/p\u003e\u003cp id=\"bb28\"\u003eüëâ Sign up \u003ca href=\"https://webinar.kt.academy/structured-concurrency05\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b6b3\"\u003eThe greatest KotlinConf 2025 announcements\u003c/h2\u003e\u003ch2 id=\"b10c\"\u003eName-Based Destructuring\u003c/h2\u003e\u003cp id=\"be1d\"\u003eThat might seem minor, but you wouldn‚Äôt believe how many people asked me about this feature. As I am teaching people with JavaScript or Swift background, they constantly ask me about name-based destructuring, that now seems to be an absolute mast-have in many languages. It will soon be available in Kotlin as well. The syntax will include using \u003ccode\u003eval\u003c/code\u003e or \u003ccode\u003evar\u003c/code\u003e \u003cstrong\u003einside\u003c/strong\u003e the destructuring brackets, like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"93e4\"\u003eFor this code to compile, variable names must match property names, but they can be specified in any order. It will work in lambdas or loops.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"127e\"\u003eThis feature was announced to become experimental in Kotlin 2.4 (so next year). I am not that sure about the syntax, but I do not have any better idea. I am just happy that it is finally coming.\u003c/p\u003e\u003ch2 id=\"e2d7\"\u003eRich Errors\u003c/h2\u003e\u003cp id=\"8e0a\"\u003eThat is going to be the greatest change in Kotlin since it became stable. Kotlin does not support checked exceptions because, according to best practices, exceptions should not be used to signal expected situations. To deal with such situations, it is best practice to either use \u003ccode\u003eResult\u003c/code\u003e type or nullable result.\u003c/p\u003e\u003cp id=\"6536\"\u003eHowever, those options are not always satisfactory. \u003ccode\u003eResult\u003c/code\u003e cannot type-safely express what kind of exceptions it can contain. It can also be easily ignored, and it does not have any idioms that would allow operating on it in a simple way. That is why we need a better way to express errors in Kotlin.\u003c/p\u003e\u003cp id=\"8674\"\u003eI \u003ca href=\"https://kt.academy/article/union-types-into\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ealready wrote\u003c/a\u003e about rich errors last year, when they were still known as ‚ÄúUnion types with errors‚Äù. Their original name was longer, but it clearly expressed what they are ‚Äî types that express either a result or an error. A lot like \u003ccode\u003eEither\u003c/code\u003e from Arrow, but with build-in support in the language.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a96f\"\u003eRich errors will have similar support as nullable types. So they should support:\u003c/p\u003e\u003cul\u003e\u003cli id=\"188a\"\u003e\u003ccode\u003e?.\u003c/code\u003e safe call operator - that will call the right-hand side only if the left-hand side is not an error, otherwise it will return the error.\u003c/li\u003e\u003cli id=\"265e\"\u003e\u003ccode\u003e?:\u003c/code\u003e elvis operator - that will return the right-hand side if the left-hand side is an error, otherwise it will return the left-hand side.\u003c/li\u003e\u003cli id=\"ec2c\"\u003e\u003ccode\u003e!!\u003c/code\u003e not-error assertion operator - that will throw an exception if the left-hand side is an error, otherwise it will return the left-hand side.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"225b\"\u003eOverall, experience with rich errors should be similar to nullable types, but with more information about the error. More about it \u003ca href=\"https://youtu.be/F5NaqGF9oT4?si=nTzAJ9lnWeG0UTrM\u0026amp;t=735\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"1190\"\u003ePlugins joining Kotlin ecosystem\u003c/h2\u003e\u003cp id=\"1505\"\u003eI was a bit surprised by this announcement. For years, Kotlin was intentionally extracting many features into external plugins, like Power Assert, Kotlin Serialization, Binary Compatibility Validator, Dokka, or Kover. Now, Vsevolod Tolstopyatov announced that those plugins will be distributed as part of the Kotlin plugin. You will not need to add separate dependencies to use them, they will be available out of the box, and they might only need to be enabled or configured in the Gradle build script.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c758\"\u003eMore about it \u003ca href=\"https://youtu.be/F5NaqGF9oT4?si=uRzW7VStR-2p8xIA\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"8a70\"\u003eAgents and MCP in Kotlin\u003c/h2\u003e\u003cp id=\"dd75\"\u003eMan, there was a lot about AI in KotlinConf 2025. It is quite clearly a priority for JetBrains (do not worry, new teams were formed to work on those new features, so it will not slow down the development of other features).\u003c/p\u003e\u003cp id=\"5a1b\"\u003eThe opening keynote included a substantial section on AI, and there were several sessions dedicated to the topic. Except for a very simple things, like Kotlin SDK to use different AI models (come on, one could write a custom Open AI or Anthropic SDK in a couple of hours, and Spring AI is currently just a more straightforward way to use those on Spring), I think the most interesting announcement was MCP Kotlin SDK, and a library to define agents in Kotlin.\u003c/p\u003e\u003cp id=\"1a91\"\u003eMCP (Model context protocol) is a protocol created by OpenAI that standardizes how applications provide context to LLMs. It is now widely adopted by many AI providers (surprisingly even Google adopted it instead of creating their own). Good that we can now use it simply in Kotlin as well.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9e70\"\u003eThe second big announcement was \u003ca href=\"https://github.com/JetBrains/koog/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKoog\u003c/a\u003e, a new framework from JetBrains to define agents in Kotlin. I must say, it looks very promising, and I am looking forward to trying it out.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"d3c6\"\u003eCompose Multiplatform for iOS is now stable\u003c/h2\u003e\u003cp id=\"45cf\"\u003eQuite clearly JetBrains works hard on making Compose Multiplatform work nicely on all platforms. There were many improvements made over the last year, and now Compose for iOS is finally stable.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f51c\"\u003eI am happy with this announcement, I am just waiting now until Compose for Wasm becomes stable as well.\u003c/p\u003e\u003ch2 id=\"62eb\"\u003eCoroutines Debugging has been improved\u003c/h2\u003e\u003cp id=\"f39b\"\u003eThat was announced in a lightning talk, not in the main keynote, but I think it is worth mentioning. Coroutines debugging has been significantly improved. Since Kotlin 2.2, local variables will not be optimized out in debug mode. In recent versions of IntelliJ and Android Studio, step over, step into, and step out actions will guarantee to stop at the same coroutine. They also announced that exception stack traces will soon include not only the last function call, but all suspending function that were called before the exception was thrown. That will be a great improvement, and I am looking forward to it.\u003c/p\u003e\u003ch2 id=\"691f\"\u003eCoroutines Mastery\u003c/h2\u003e\u003cp id=\"6333\"\u003eTime for our announcement. As a part of Kt. Academy vision to create a next-level learning experience for Kotlin developers, I am happy to announce that we will start the first edition of the \u003ca href=\"https://web.kt.academy/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoroutines Mastery course\u003c/a\u003e. During 5-weeks of course, our aspiration will be to turn all participants into experts in coroutines. We hope to make another generation of conscious Kotlin users, introducing new quality standards, and uplifting our whole community. Keep your fingers crossed for us.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-06-03T11:01:20.502Z",
  "modifiedTime": null
}
