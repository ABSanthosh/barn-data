{
  "id": "faebf6c4-ee2e-44bb-89af-4da2a28f2c2c",
  "title": "Building a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 4",
  "link": "https://proandroiddev.com/building-a-space-flight-news-app-with-compose-multiplatform-for-android-ios-and-desktop-part-4-dc9f978b6942?source=rss----c72404660798---4",
  "description": "",
  "author": "Domen Lanišnik",
  "published": "Tue, 22 Jul 2025 14:44:08 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin-multiplatform",
    "ios-app-development",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Domen Lanišnik",
  "length": 28445,
  "excerpt": "The fourth part of building a Compose Multiplatform app: navigating to a details screen.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Building a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 4 — Screen NavigationThis is the fourth part of a series of articles focusing on Compose Multiplatform. We are building an app for Android, iOS, and Desktop that displays the latest Space Flight news.This part will focus on the following:adding an article details screen,and navigating to it using Compose Navigation.Showcase of the final app.Recap of the first three partsThis article continues where the third part left off, so make sure to start there if you haven’t yet.So far, we’ve learned the following:how Kotlin Multiplatform workssharing UI using Compose Multiplatform on iOS, Android, and Desktoploading remote images with Coiladding network layer for fetching remote data with Ktoradding dependency injection with Koinhandling loading and error statesadding a local database and offline support with SQLDelight.You can find the code after part 3, and what will be our starting point for this article, here:1. Add navigationTo later open a new screen, we first need to set up the navigation structure. We’re going to leverage the Navigation Compose library to navigate between the list and detail screen.Add navigation libraryOpen the gradle/libs.versions.toml file and add the new library.[versions]androidx-compose-navigation = \"2.9.0-beta03\"[libraries]androidx-compose-navigation = { module = \"org.jetbrains.androidx.navigation:navigation-compose\", version.ref=\"androidx-compose-navigation\" }Next, let’s open the composeApp/build.gradle.kts file and declare the dependency in the commonMain source set.commonMain.dependencies { implementation(libs.androidx.compose.navigation)}Define navigation routesWe need to declare the supported navigation routes or screens that the app can navigate to. To do that, we need to create serializable classes for each screen.Let’s create a new file and sealed interface MainNavigationDestination in composeApp/commonMain/your.package.spaceflightnews/ui/navigation directory. It will have two sub-types, both of which need to be marked with @Serializable:Home which is a simple data object used to represent the home screen (list of articles)Details which is a data class representing the article detail screen and containing the article identifier argumentimport kotlinx.serialization.Serializablesealed interface MainNavigationDestination { @Serializable data object Home : MainNavigationDestination @Serializable data class Details(val articleId: Long) : MainNavigationDestination}Create a NavigationHostOpen the App file and create a new private composable function MainNavigationHost.In Compose navigation, we start by defining a new NavHost, which is the main navigation composable. Inside it, we have to define the composables that should be displayed when a specific route is requested using the composable\u003cRoute\u003e function. Finally, an instance of NavController is needed to navigate between routes.import androidx.navigation.compose.NavHostimport androidx.navigation.compose.composableimport androidx.navigation.compose.rememberNavController@Composableprivate fun MainNavigationHost() { val navController = rememberNavController() NavHost( navController, startDestination = MainNavigationDestination.Home, modifier = Modifier.fillMaxSize() ) { composable\u003cMainNavigationDestination.Home\u003e { ArticleListScreen() } composable\u003cMainNavigationDestination.Details\u003e { Box { // TODO } } }}Next, we have to replace the direct call to ArticleListScreen in the App() composable function with a call to the new MainNavigationHost() composable function.Trigger navigationWe want to open a new screen when the user clicks on an article. To do that, we have to add a click listener to each article and receive the callback inside the MainNavigationHost function so we can perform the navigation using the NavController.Open the ArticleListScreen and scroll down to the ArticleItem composable function. Add a click callback as a new argument that sends the id of the article that was clicked. Next, call the new onArticleClick callback inside the onClick function of the Card composable and pass in the article.id.@Composableprivate fun ArticleItem( article: Article, onArticleClick: (Long) -\u003e Unit) { Card( modifier = Modifier.fillMaxWidth(), onClick = { onArticleClick(article.id) } ) { ... }}Next, scroll up to ArticleListContent and add the same onArticleClick callback as an argument. Pass that argument forward to ArticleItem.@Composableprivate fun ArticleListContent( articles: List\u003cArticle\u003e, onArticleClick: (Long) -\u003e Unit) { LazyColumn( ... ) { items(articles) { article -\u003e ArticleItem( article = article, onArticleClick = onArticleClick, ) } }}We now need to add that same callback argument to the ArticleListScreen composable function and pass it to the ArticleListContent function.@Composableinternal fun ArticleListScreen(onArticleClick: (Long) -\u003e Unit) { ... is ArticleListViewState.Success -\u003e { val articles = currentState.articles ArticleListContent( articles = articles, onArticleClick = onArticleClick, ) } ...}And finally, go back to the App file and implement the callback in MainNavigationHost. We’ve now successfully returned the callback from the child article card to the main app composable.composable\u003cMainNavigationDestination.Home\u003e { ArticleListScreen(onArticleClick = { // TODO open details screen })}We can now use navController to trigger navigation to the Details route.composable\u003cMainNavigationDestination.Home\u003e { ArticleListScreen(onArticleClick = { articleId -\u003e navController.navigate(MainNavigationDestination.Details(articleId)) })}If we run the app now and click on an article, an empty screen will open. Pressing the back button returns to the article list screen.Navigation to an empty screen after clicking on an article.2. Add detail screenOur app currently displays a list of news articles with a two-line description. Wouldn’t it be great to be able to read the whole article? To do that, we’ll add a new detail screen.Create a new ArticleDetailsScreen file under the composeApp/commonMain/your.package.spaceflightnews/ui/details directory. For now, it should just have a single Composable function called ArticleDetailsScreen that accepts an articleId that will be used to load the data, and a onBackClick callback to navigate back to the list screen.@Composableinternal fun ArticleDetailsScreen( articleId: Long, onBackClick: () -\u003e Unit,) { }Why are we passing only the article id to the details screen and not the whole Article object? It’s best practice to avoid passing complex data like objects to routes as it requires custom serialization and deserialization to and from strings. Since we have the data cached locally, it’s easy to retrieve it.If we needed to make a network request to fetch the same data we already previously fetched, it would be worth considering passing in the whole object instead to avoid that expensive network request.Create a ViewModelCreate a new class ArticleDetailsViewModel in the same directory. It should extend the ViewModel class and accept a ArticlesRepository as an argument.internal class ArticleDetailsViewModel( private val repository: ArticlesRepository,) : ViewModel() {}We will need to load the data from the database based on the article identifier, which should be fast. However, it’s still a good practice to handle loading and error states. For that purpose, let’s define a ArticleDetailsViewState sealed interface at the bottom of the ArticleDetailsViewModel class.internal class ArticleDetailsViewModel( private val repository: ArticlesRepository,) : ViewModel() { sealed interface ArticleDetailsViewState { data object Loading : ArticleDetailsViewState data class Success(val article: Article) : ArticleDetailsViewState data class Error(val errorType: ErrorType) : ArticleDetailsViewState }}As is necessary for the UI to observe the state changes, let’s define a MutableStateFlow property to propagate the changes to the UI.internal class ArticleDetailsViewModel( private val repository: ArticlesRepository,) : ViewModel() { private val _state = MutableStateFlow\u003cArticleDetailsViewState\u003e(ArticleDetailsViewState.Loading) val state: StateFlow\u003cArticleDetailsViewState\u003e = _state sealed interface ArticleDetailsViewState { data object Loading : ArticleDetailsViewState data class Success(val article: Article) : ArticleDetailsViewState data class Error(val errorType: ErrorType) : ArticleDetailsViewState }}All that‘s missing now is the actual logic to fetch the article from the database based on the id. To do that, create a new function onFetchArticle(id: Long) that will be called by the UI and load the data.We’re starting with a loading state, then if the article is found (which it should be in most cases), we emit a success state. If the article is not found or an exception happens, we emit an error state.fun onFetch(id: Long) { viewModelScope.launch { _state.value = ArticleDetailsViewState.Loading try { val article = repository.getArticleById(id) if (article != null) { _state.value = ArticleDetailsViewState.Success(article) } else { _state.value = ArticleDetailsViewState.Error(ErrorType.Unknown) } } catch (_: Exception) { _state.value = ArticleDetailsViewState.Error(ErrorType.Unknown) } }}Our View Model is now ready to use.Provide ViewModel via dependency injectionTo use the new ViewModel, we have to make it available via Koin. Process is the same as how we added the existing ArticleListViewModel in part 2.Open AppModule and provide the ArticleDetailsViewModel via the viewModel function.val appModule = module { single\u003cApiService\u003e { ApiService() } single\u003cArticlesRepository\u003e { ArticlesRepository( databaseDriverFactory = get(), api = get() ) } viewModel { ArticleListViewModel(repository = get()) } // NEW: provide the newly added ArticleDetailsViewModel viewModel { ArticleDetailsViewModel(repository = get()) }}Setup icons and stringsBefore we start writing our article details screen UI, we need to add some icons and strings. Because Compose doesn’t include icons as standard, we need to add the Compose Icons Extended dependency to our project.As you’re probably already used to, open the gradle/libs.versions.toml file and add the new library.[versions]androidx-material-icons-extended = \"1.7.3\"[libraries]androidx-material-icons-extended = { module = \"org.jetbrains.compose.material:material-icons-extended\", version.ref = \"androidx-material-icons-extended\" }Next, let’s open the composeApp/build.gradle.kts file and declare the dependency in the commonMain source set. Make sure to perform a new gradle sync afterwards.commonMain.dependencies { implementation(libs.androidx.material.icons.extended)}For the new strings, open the composeApp/src/commonMain/composeResources/values/strings.xml file and add the following new strings. The %1$s is a string placeholder that we will later replace with the name of the news site.\u003cstring name=\"read_more_at\"\u003eRead full article at %1$s\u003c/string\u003e\u003cstring name=\"back_content_description\"\u003eBack\u003c/string\u003e\u003cstring name=\"share_content_description\"\u003eShare\u003c/string\u003eTip: If you find you can not reference the strings from code later, rebuild the app.Define the details UILet’s start by getting an instance of the ArticleDetailsViewModel and reading the state from it inside the ArticleDetailsScreen composable function.@Composableinternal fun ArticleDetailsScreen( articleId: Long, onBackClick: () -\u003e Unit,) { val viewModel = koinViewModel\u003cArticleDetailsViewModel\u003e() val state by viewModel.state.collectAsStateWithLifecycle()}Next, we need to propagate articleId to the View Model. One way would be to use a SavedStateHandle to read the argument directly in the ArticleDetailsViewModel. However, to keep things simple, we’re just going to use a LaunchedEffect and call the viewModel.onFetchArticle() function.@Composableinternal fun ArticleDetailsScreen( articleId: Long, onBackClick: () -\u003e Unit,) { val viewModel = koinViewModel\u003cArticleDetailsViewModel\u003e() val state by viewModel.state.collectAsStateWithLifecycle() LaunchedEffect(Unit) { viewModel.onFetch(articleId) }}We’re going to keep the screen layout in a new Composable function called ArticleDetailsScreenContent. It should accept the screen state, and several callbacks for UI actions.@Composableprivate fun ArticleDetailsScreenContent( state: ArticleDetailsViewModel.ArticleDetailsViewState, onRetryClick: () -\u003e Unit, onBackClick: () -\u003e Unit, onShareClick: () -\u003e Unit, onReadMoreClick: (String) -\u003e Unit,) { }For the actual screen, we’re going to use the Scaffold composable to handle the basic skeleton for us. We need to support loading, error, and success states.@Composableprivate fun ArticleDetailsScreenContent( state: ArticleDetailsViewModel.ArticleDetailsViewState, onRetryClick: () -\u003e Unit, onBackClick: () -\u003e Unit, onShareClick: () -\u003e Unit, onReadMoreClick: (String) -\u003e Unit,) { Scaffold { innerPadding -\u003e Box(modifier = Modifier.padding(innerPadding)) { when (val currentState = state) { is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u003e { // TODO } ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u003e { // TODO } is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u003e { // TODO } } } }}For the loading and error states, we’re going to reuse the same layouts from the ArticleListScreen. However, it would be bad practice to duplicate them, so we’ll extract them into standalone composable functions that we can then also reference on the new screen.Open ArticleListScreen and create two functions: LoadingContent and ErrorContent. Copy over the content from the when statement and update the ErrorContent so that it receives the error type as input argument, and a callback for the retry button click. Make sure to update the when statement so it calls these two new functions.@Composablefun BoxScope.LoadingContent() { CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))}@Composablefun BoxScope.ErrorContent( errorType: ErrorType, onRetryClick: () -\u003e Unit) { val errorMessage = when (errorType) { ErrorType.NoInternet -\u003e stringResource(Res.string.no_internet) ErrorType.ServerError -\u003e stringResource(Res.string.server_error) ErrorType.Unknown -\u003e stringResource(Res.string.something_went_wrong) } Column( horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.align(Alignment.Center) ) { Text( text = errorMessage, color = Color.Red, style = MaterialTheme.typography.bodyMedium, modifier = Modifier.padding(16.dp) ) Button(onClick = onRetryClick) { Text(text = stringResource(Res.string.retry)) } }}We can now use the two new functions in the ArticleDetailsScreenContent.@Composableprivate fun ArticleDetailsScreenContent( state: ArticleDetailsViewModel.ArticleDetailsViewState, onRetryClick: () -\u003e Unit, onBackClick: () -\u003e Unit, onShareClick: () -\u003e Unit, onReadMoreClick: (String) -\u003e Unit,) { Scaffold { innerPadding -\u003e Box(modifier = Modifier.padding(innerPadding)) { when (val currentState = state) { is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u003e { ErrorContent( errorType = currentState.errorType, onRetryClick = onRetryClick, ) } ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u003e { LoadingContent() } is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u003e { // TODO } } } }}Next, we need to define the success UI. Create a new composable function named ArticleDetailsSuccessContent that accepts the loadedArticle object, and callbacks for back button, share button, and read more button clicks.For the actual content, we want to display the following elements:cover image of the articleback button shown on the top left of the imageshare button shown on the top right of the imagearticle titlename of the news site where the article was publisheddate and time the article was publishedfull description/content of the article“read more” button.The image below shows the design we want to achieve. Feel free to try and do it yourself before moving forward.Zoom image will be displayedArticle details screen layout on Android.Here is the full implementation of ArticleDetailsSuccessContent based on the requirements above. We’re using a Column to vertically arrange all the elements.Similar to the list screen, we're using Coil’s AsyncImage to load the article image from the URL. We’re wrapping it in a Box, so we can overlay the back and share buttons over it.The date and time at which the article was published is formatted using the LocalDateTime.Format builder, which gives us the option to specify the exact format we want.@Composableprivate fun ArticleDetailsSuccessContent( article: Article, onBackClick: () -\u003e Unit, onShareClick: () -\u003e Unit, onReadMoreClick: (String) -\u003e Unit,) { Column( verticalArrangement = Arrangement.Top, modifier = Modifier.fillMaxSize() ) { Box(modifier = Modifier.fillMaxWidth()) { AsyncImage( model = article.imageUrl, contentDescription = null, contentScale = ContentScale.Crop, modifier = Modifier .fillMaxWidth() .aspectRatio(16f / 9f), ) IconButton(onClick = onBackClick, modifier = Modifier.align(Alignment.TopStart)) { Icon( Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(Res.string.back_content_description), tint = Color.White ) } IconButton(onClick = onShareClick, modifier = Modifier.align(Alignment.TopEnd)) { Icon( Icons.Default.Share, contentDescription = stringResource(Res.string.share_content_description), tint = Color.White ) } } Column( verticalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth().padding(16.dp) ) { Text( text = article.title, style = MaterialTheme.typography.titleLarge, fontWeight = FontWeight.Bold, overflow = TextOverflow.Ellipsis, ) Row( verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(2.dp) ) { Text( text = article.newsSite, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary, ) Text( text = \" • \", style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary, ) Text( text = article.publishedAt.toLocalDateTime(TimeZone.currentSystemDefault()) .format( LocalDateTime.Format { year() char('-') monthNumber() char('-') dayOfMonth() chars(\" at \") hour() char(':') minute() }), style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.secondary, ) } Spacer(modifier = Modifier.height(8.dp)) Text( text = article.summary, style = MaterialTheme.typography.bodyMedium, overflow = TextOverflow.Ellipsis ) TextButton(onClick = { onReadMoreClick(article.url) }, modifier = Modifier.fillMaxWidth()) { Text(text = stringResource(Res.string.read_more_at, article.newsSite)) } } }}Now that we have defined our success layout, we can go back to the ArticleDetailsScreenContent and update the success branch of the when statement to call the new ArticleDetailsSuccessContent.@Composableprivate fun ArticleDetailsScreenContent( state: ArticleDetailsViewModel.ArticleDetailsViewState, onRetryClick: () -\u003e Unit, onBackClick: () -\u003e Unit, onShareClick: () -\u003e Unit, onReadMoreClick: (String) -\u003e Unit,) { Scaffold { innerPadding -\u003e Box(modifier = Modifier.padding(innerPadding)) { when (val currentState = state) { is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u003e { ErrorContent( errorType = currentState.errorType, onRetryClick = onRetryClick, ) } ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u003e { LoadingContent() } is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u003e { ArticleDetailsSuccessContent( article = currentState.article, onBackClick = onBackClick, onReadMoreClick = onReadMoreClick, onShareClick = onShareClick, ) } } } }}And finally, we can call the ArticleDetailsScreenContent from the root ArticleDetailsScreen composable function.@Composableinternal fun ArticleDetailsScreen( articleId: Long, onBackClick: () -\u003e Unit,) { val viewModel = koinViewModel\u003cArticleDetailsViewModel\u003e() val state by viewModel.state.collectAsStateWithLifecycle() LaunchedEffect(Unit) { viewModel.onFetch(articleId) } ArticleDetailsScreenContent( state = state, onRetryClick = { viewModel.onFetch(articleId) }, onBackClick = onBackClick, onShareClick = { // TODO Open share sheet }, onReadMoreClick = { // TODO Open browser } )}We’re going to implement the share and read more functionality in next part of the series.Add the composable to the navigation graphNow that we have defined the ArticleDetailsScreen composable, we can add it to our navigation graph and open it.Open the App and replace the Box with the TODO at the bottom of the file with a call to ArticleDetailsScreen. We passed the article identifier when we triggered the navigation to the details screen, and to retrieve it, we have to use the toRoute extension function on theNavBackStackEntry.On back click, we call navController.popBackStack() which navigates back from the details screen to the list screen.@Composableprivate fun MainNavigationHost() { val navController = rememberNavController() NavHost( navController, startDestination = MainNavigationDestination.Home, modifier = Modifier.fillMaxSize() ) { composable\u003cMainNavigationDestination.Home\u003e { ArticleListScreen(onArticleClick = { articleId -\u003e navController.navigate(MainNavigationDestination.Details(articleId)) }) } composable\u003cMainNavigationDestination.Details\u003e { val route = it.toRoute\u003cMainNavigationDestination.Details\u003e() ArticleDetailsScreen( articleId = route.articleId, onBackClick = { navController.popBackStack() }) } }}3. Run and test the appAll that is remaining is to run the app and try out the navigation.Navigating to the new details screen on iOS.While the navigation itself works great — we can open and close a new details screen — there is a small design issue on the details screen. The top app bar showing the app name on the home screen is also visible on the details screen.It’s taking up valuable vertical space and not offering much value on the details screen, so we’ll remove it. However, to do that, we need to change both how our main app and the ArticleListScreen are set up.Move the Scaffold from App to ArticleListScreenThe reason why the top app bar is visible on both screens is that we use a Scaffold at the root of our app. The MainNavigationHost is then part of the content of the Scaffold composable, and the top app bar is part of the Scaffold.header composable, which means it‘s always displayed above the content.We want to let each screen define how they want to be presented, so we’re going to remove the Scaffold from the App composable, and add it instead to the ArticleListScreen composable.Navigate to App and remove the entire Scaffold, leaving just a direct call to MainNavigationHost.@Composablefun App(koinAppDeclaration: KoinAppDeclaration? = null) { KoinApplication(application = { koinAppDeclaration?.invoke(this) modules(appModule, platformModule) }) { AppTheme { MainNavigationHost() } }}Then open the ArticleListScreen and wrap the existing Box with the Scaffold from before. One small change that we need to make is to add a Modifier.padding(innerPadding) to the Box‘s modifier. This is needed to properly support screen notches and cut-outs.@OptIn(ExperimentalMaterial3Api::class)@Composableinternal fun ArticleListScreen(onArticleClick: (Long) -\u003e Unit) { val viewModel = koinViewModel\u003cArticleListViewModel\u003e() val state by viewModel.state.collectAsStateWithLifecycle() Scaffold( topBar = { TopAppBar( title = { Text(text = stringResource(Res.string.app_name)) } ) } ) { innerPadding -\u003e Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) { when (val currentState = state) { is ArticleListViewState.Loading -\u003e { LoadingContent() } is ArticleListViewState.Success -\u003e { val articles = currentState.articles ArticleListContent( articles = articles, onArticleClick = onArticleClick, ) } is ArticleListViewState.Error -\u003e { ErrorContent( errorType = currentState.errorType, onRetryClick = { viewModel.fetchArticles() } ) } } } }}Final testingAfter the change, we can see that the details screen now takes the entire available space and looks much better.Updated details screen on iOS.This is how the details screen looks on all platforms.Zoom image will be displayedThe new details screen on all three platforms: Android, iOS, and desktop.4. ConclusionIf you followed along to the end, great job! This is the end of the fourth part in the series on Kotlin Multiplatform and Compose Multiplatform. We’ve taken a look at how to use the Compose Navigation library to navigate to a new details screen.In the next part of the series, we are going to:Add a system share functionality to share links to articles with different apps.Show how to open the article URL in a web browser.Stay tuned!You can find the source code for this part here:",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*h0WH2jvdiUa941OVQbIcRw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"9f62\" data-testid=\"storyTitle\"\u003eBuilding a Space Flight News App with Compose Multiplatform for Android, iOS, and Desktop: Part 4 — Screen Navigation\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\" role=\"tooltip\"\u003e\u003ca href=\"https://medium.com/@domen.lanisnik?source=post_page---byline--dc9f978b6942---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Domen Lanišnik\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*CHMrHH5mrrGDp0Vsm-UtKw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"0595\"\u003eThis is the fourth part of a series of articles focusing on Compose Multiplatform. We are building an app for Android, iOS, and Desktop that displays the latest Space Flight news.\u003c/p\u003e\u003cp id=\"d03e\"\u003eThis part will focus on the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c8cf\"\u003eadding an article details screen,\u003c/li\u003e\u003cli id=\"7541\"\u003eand navigating to it using Compose Navigation.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eShowcase of the final app.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"57d4\"\u003eRecap of the first three parts\u003c/h2\u003e\u003cp id=\"a28d\"\u003eThis article continues where the third part left off, so make sure to start there if you haven’t yet.\u003c/p\u003e\u003cp id=\"609d\"\u003eSo far, we’ve learned the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b60f\"\u003ehow Kotlin Multiplatform works\u003c/li\u003e\u003cli id=\"4642\"\u003esharing UI using Compose Multiplatform on iOS, Android, and Desktop\u003c/li\u003e\u003cli id=\"2bc8\"\u003eloading remote images with Coil\u003c/li\u003e\u003cli id=\"7485\"\u003eadding network layer for fetching remote data with Ktor\u003c/li\u003e\u003cli id=\"82e9\"\u003eadding dependency injection with Koin\u003c/li\u003e\u003cli id=\"3d4a\"\u003ehandling loading and error states\u003c/li\u003e\u003cli id=\"d8ad\"\u003eadding a local database and offline support with SQLDelight.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"09c0\"\u003eYou can find the code after part 3, and what will be our starting point for this article, here:\u003c/p\u003e\u003ch2 id=\"645f\"\u003e1. Add navigation\u003c/h2\u003e\u003cp id=\"2616\"\u003eTo later open a new screen, we first need to set up the navigation structure. We’re going to leverage the \u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-navigation-routing.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNavigation Compose\u003c/a\u003e library to navigate between the list and detail screen.\u003c/p\u003e\u003ch2 id=\"8d6a\"\u003eAdd navigation library\u003c/h2\u003e\u003cp id=\"fd7a\"\u003eOpen the \u003ccode\u003egradle/libs.versions.toml\u003c/code\u003e file and add the new library.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c01e\"\u003e[versions]\u003cbr/\u003eandroidx-compose-navigation = \u0026#34;2.9.0-beta03\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-compose-navigation = { module = \u0026#34;org.jetbrains.androidx.navigation:navigation-compose\u0026#34;, version.ref=\u0026#34;androidx-compose-navigation\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"204a\"\u003eNext, let’s open the \u003ccode\u003ecomposeApp/build.gradle.kts\u003c/code\u003e file and declare the dependency in the \u003ccode\u003ecommonMain\u003c/code\u003e source set.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb60\"\u003ecommonMain.dependencies {\u003cbr/\u003e    implementation(libs.androidx.compose.navigation)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4dfb\"\u003eDefine navigation routes\u003c/h2\u003e\u003cp id=\"0861\"\u003eWe need to declare the supported navigation routes or screens that the app can navigate to. To do that, we need to create serializable classes for each screen.\u003c/p\u003e\u003cp id=\"2b8d\"\u003eLet’s create a new file and sealed interface \u003ccode\u003eMainNavigationDestination\u003c/code\u003e in \u003ccode\u003ecomposeApp/commonMain/your.package.spaceflightnews/ui/navigation\u003c/code\u003e directory. It will have two sub-types, both of which need to be marked with \u003ccode\u003e@Serializable\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"adb6\"\u003e\u003ccode\u003eHome\u003c/code\u003e which is a simple data object used to represent the home screen (list of articles)\u003c/li\u003e\u003cli id=\"c3c7\"\u003e\u003ccode\u003eDetails\u003c/code\u003e which is a data class representing the article detail screen and containing the article identifier argument\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"0503\"\u003eimport kotlinx.serialization.Serializable\u003cp\u003esealed interface MainNavigationDestination {\u003cbr/\u003e    @Serializable\u003cbr/\u003e    data object Home : MainNavigationDestination\u003cbr/\u003e    @Serializable\u003cbr/\u003e    data class Details(val articleId: Long) : MainNavigationDestination\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"173b\"\u003eCreate a NavigationHost\u003c/h2\u003e\u003cp id=\"61e9\"\u003eOpen the \u003ccode\u003eApp\u003c/code\u003e file and create a new private composable function \u003ccode\u003eMainNavigationHost\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"6d85\"\u003eIn Compose navigation, we start by defining a new \u003ccode\u003eNavHost\u003c/code\u003e, which is the main navigation composable. Inside it, we have to define the composables that should be displayed when a specific route is requested using the \u003ccode\u003ecomposable\u0026lt;Route\u0026gt;\u003c/code\u003e function. Finally, an instance of \u003ccode\u003eNavController\u003c/code\u003e is needed to navigate between routes.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd3c\"\u003eimport androidx.navigation.compose.NavHost\u003cbr/\u003eimport androidx.navigation.compose.composable\u003cbr/\u003eimport androidx.navigation.compose.rememberNavController\u003cp\u003e@Composable\u003cbr/\u003eprivate fun MainNavigationHost() {\u003cbr/\u003e    val navController = rememberNavController()\u003cbr/\u003e    NavHost(\u003cbr/\u003e        navController,\u003cbr/\u003e        startDestination = MainNavigationDestination.Home,\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        composable\u0026lt;MainNavigationDestination.Home\u0026gt; {\u003cbr/\u003e            ArticleListScreen()\u003cbr/\u003e        }\u003cbr/\u003e        composable\u0026lt;MainNavigationDestination.Details\u0026gt; {\u003cbr/\u003e            Box {\u003cbr/\u003e                // TODO\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4eb8\"\u003eNext, we have to replace the direct call to \u003ccode\u003eArticleListScreen\u003c/code\u003e in the \u003ccode\u003eApp()\u003c/code\u003e composable function with a call to the new \u003ccode\u003eMainNavigationHost()\u003c/code\u003e composable function.\u003c/p\u003e\u003ch2 id=\"e13a\"\u003eTrigger navigation\u003c/h2\u003e\u003cp id=\"5199\"\u003eWe want to open a new screen when the user clicks on an article. To do that, we have to add a click listener to each article and receive the callback inside the \u003ccode\u003eMainNavigationHost\u003c/code\u003e function so we can perform the navigation using the \u003ccode\u003eNavController\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"5547\"\u003eOpen the \u003ccode\u003eArticleListScreen\u003c/code\u003e and scroll down to the \u003ccode\u003eArticleItem\u003c/code\u003e composable function. Add a click callback as a new argument that sends the id of the article that was clicked. Next, call the new \u003ccode\u003eonArticleClick\u003c/code\u003e callback inside the \u003ccode\u003eonClick\u003c/code\u003e function of the \u003ccode\u003eCard\u003c/code\u003e composable and pass in the \u003ccode\u003earticle.id\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dca1\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleItem(\u003cbr/\u003e    article: Article,\u003cbr/\u003e    onArticleClick: (Long) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    Card(\u003cbr/\u003e        modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e        onClick = { onArticleClick(article.id) }\u003cbr/\u003e    ) {\u003cbr/\u003e        ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"18ca\"\u003eNext, scroll up to \u003ccode\u003eArticleListContent\u003c/code\u003e and add the same \u003ccode\u003eonArticleClick\u003c/code\u003e callback as an argument. Pass that argument forward to \u003ccode\u003eArticleItem\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"53b2\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleListContent(\u003cbr/\u003e    articles: List\u0026lt;Article\u0026gt;,\u003cbr/\u003e    onArticleClick: (Long) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    LazyColumn(\u003cbr/\u003e        ...\u003cbr/\u003e    ) {\u003cbr/\u003e        items(articles) { article -\u0026gt;\u003cbr/\u003e            ArticleItem(\u003cbr/\u003e                article = article,\u003cbr/\u003e                onArticleClick = onArticleClick,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3239\"\u003eWe now need to add that same callback argument to the \u003ccode\u003eArticleListScreen\u003c/code\u003e composable function and pass it to the \u003ccode\u003eArticleListContent\u003c/code\u003e function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"76d5\"\u003e@Composable\u003cbr/\u003einternal fun ArticleListScreen(onArticleClick: (Long) -\u0026gt; Unit) {\u003cbr/\u003e    ...\u003cbr/\u003e            is ArticleListViewState.Success -\u0026gt; {\u003cbr/\u003e                val articles = currentState.articles\u003cbr/\u003e                ArticleListContent(\u003cbr/\u003e                    articles = articles,\u003cbr/\u003e                    onArticleClick = onArticleClick,\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e    ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bbe2\"\u003eAnd finally, go back to the \u003ccode\u003eApp\u003c/code\u003e file and implement the callback in \u003ccode\u003eMainNavigationHost\u003c/code\u003e. We’ve now successfully returned the callback from the child article card to the main app composable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9430\"\u003ecomposable\u0026lt;MainNavigationDestination.Home\u0026gt; {\u003cbr/\u003e    ArticleListScreen(onArticleClick = {\u003cbr/\u003e        // TODO open details screen\u003cbr/\u003e    })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4b44\"\u003eWe can now use \u003ccode\u003enavController\u003c/code\u003e to trigger navigation to the \u003ccode\u003eDetails\u003c/code\u003e route.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b98a\"\u003ecomposable\u0026lt;MainNavigationDestination.Home\u0026gt; {\u003cbr/\u003e    ArticleListScreen(onArticleClick = { articleId -\u0026gt;\u003cbr/\u003e        navController.navigate(MainNavigationDestination.Details(articleId))\u003cbr/\u003e    })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b356\"\u003eIf we run the app now and click on an article, an empty screen will open. Pressing the back button returns to the article list screen.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNavigation to an empty screen after clicking on an article.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"fac7\"\u003e2. Add detail screen\u003c/h2\u003e\u003cp id=\"fa69\"\u003eOur app currently displays a list of news articles with a two-line description. Wouldn’t it be great to be able to read the whole article? To do that, we’ll add a new detail screen.\u003c/p\u003e\u003cp id=\"bd8f\"\u003eCreate a new \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e file under the \u003ccode\u003ecomposeApp/commonMain/your.package.spaceflightnews/ui/details\u003c/code\u003e directory. For now, it should just have a single \u003ccode\u003eComposable\u003c/code\u003e function called \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e that accepts an \u003ccode\u003earticleId\u003c/code\u003e that will be used to load the data, and a \u003ccode\u003eonBackClick\u003c/code\u003e callback to navigate back to the list screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a8a2\"\u003e@Composable\u003cbr/\u003einternal fun ArticleDetailsScreen(\u003cbr/\u003e    articleId: Long,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e) {\u003cp\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"5381\"\u003e\u003cstrong\u003eWhy are we passing only the article id to the details screen and not the whole Article object?\u003c/strong\u003e It’s best practice to avoid passing complex data like objects to routes as it requires custom serialization and deserialization to and from strings. Since we have the data cached locally, it’s easy to retrieve it.\u003c/p\u003e\u003cp id=\"b481\"\u003eIf we needed to make a network request to fetch the same data we already previously fetched, it would be worth considering passing in the whole object instead to avoid that expensive network request.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"38c0\"\u003eCreate a ViewModel\u003c/h2\u003e\u003cp id=\"703d\"\u003eCreate a new class \u003ccode\u003eArticleDetailsViewModel\u003c/code\u003e in the same directory. It should extend the \u003ccode\u003eViewModel\u003c/code\u003e class and accept a \u003ccode\u003eArticlesRepository\u003c/code\u003e as an argument.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fcb3\"\u003einternal class ArticleDetailsViewModel(\u003cbr/\u003e    private val repository: ArticlesRepository,\u003cbr/\u003e) : ViewModel() {\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a6db\"\u003eWe will need to load the data from the database based on the article identifier, which should be fast. However, it’s still a good practice to handle loading and error states. For that purpose, let’s define a \u003ccode\u003eArticleDetailsViewState\u003c/code\u003e sealed interface at the bottom of the \u003ccode\u003eArticleDetailsViewModel\u003c/code\u003e class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e09\"\u003einternal class ArticleDetailsViewModel(\u003cbr/\u003e    private val repository: ArticlesRepository,\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    sealed interface ArticleDetailsViewState {\u003cbr/\u003e        data object Loading : ArticleDetailsViewState\u003cbr/\u003e        data class Success(val article: Article) : ArticleDetailsViewState\u003cbr/\u003e        data class Error(val errorType: ErrorType) : ArticleDetailsViewState\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"04b4\"\u003eAs is necessary for the UI to observe the state changes, let’s define a \u003ccode\u003eMutableStateFlow\u003c/code\u003e property to propagate the changes to the UI.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8820\"\u003einternal class ArticleDetailsViewModel(\u003cbr/\u003e    private val repository: ArticlesRepository,\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    private val _state = MutableStateFlow\u0026lt;ArticleDetailsViewState\u0026gt;(ArticleDetailsViewState.Loading)\u003cbr/\u003e    val state: StateFlow\u0026lt;ArticleDetailsViewState\u0026gt; = _state\u003c/p\u003e\u003cp\u003e    sealed interface ArticleDetailsViewState {\u003cbr/\u003e        data object Loading : ArticleDetailsViewState\u003cbr/\u003e        data class Success(val article: Article) : ArticleDetailsViewState\u003cbr/\u003e        data class Error(val errorType: ErrorType) : ArticleDetailsViewState\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"33fc\"\u003eAll that‘s missing now is the actual logic to fetch the article from the database based on the id. To do that, create a new function \u003ccode\u003eonFetchArticle(id: Long)\u003c/code\u003e that will be called by the UI and load the data.\u003c/p\u003e\u003cp id=\"108f\"\u003eWe’re starting with a loading state, then if the article is found (which it should be in most cases), we emit a success state. If the article is not found or an exception happens, we emit an error state.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e9fb\"\u003efun onFetch(id: Long) {\u003cbr/\u003e    viewModelScope.launch {\u003cbr/\u003e        _state.value = ArticleDetailsViewState.Loading\u003cbr/\u003e        try {\u003cbr/\u003e            val article = repository.getArticleById(id)\u003cbr/\u003e            if (article != null) {\u003cbr/\u003e                _state.value = ArticleDetailsViewState.Success(article)\u003cbr/\u003e            } else {\u003cbr/\u003e                _state.value = ArticleDetailsViewState.Error(ErrorType.Unknown)\u003cbr/\u003e            }\u003cbr/\u003e        } catch (_: Exception) {\u003cbr/\u003e            _state.value = ArticleDetailsViewState.Error(ErrorType.Unknown)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e1aa\"\u003eOur View Model is now ready to use.\u003c/p\u003e\u003ch2 id=\"c586\"\u003eProvide ViewModel via dependency injection\u003c/h2\u003e\u003cp id=\"e01f\"\u003eTo use the new ViewModel, we have to make it available via Koin. Process is the same as how we added the existing \u003ccode\u003eArticleListViewModel\u003c/code\u003e in part 2.\u003c/p\u003e\u003cp id=\"b933\"\u003eOpen \u003ccode\u003eAppModule\u003c/code\u003e and provide the \u003ccode\u003eArticleDetailsViewModel\u003c/code\u003e via the \u003ccode\u003eviewModel\u003c/code\u003e function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0771\"\u003eval appModule = module {\u003cbr/\u003e    single\u0026lt;ApiService\u0026gt; { ApiService() }\u003cbr/\u003e    single\u0026lt;ArticlesRepository\u0026gt; {\u003cbr/\u003e        ArticlesRepository(\u003cbr/\u003e            databaseDriverFactory = get(),\u003cbr/\u003e            api = get()\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cp\u003e    viewModel { ArticleListViewModel(repository = get()) }\u003cbr/\u003e    // NEW: provide the newly added ArticleDetailsViewModel\u003cbr/\u003e    viewModel { ArticleDetailsViewModel(repository = get()) }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3c84\"\u003eSetup icons and strings\u003c/h2\u003e\u003cp id=\"4259\"\u003eBefore we start writing our article details screen UI, we need to add some icons and strings. Because Compose doesn’t include icons as standard, we need to add the Compose Icons Extended dependency to our project.\u003c/p\u003e\u003cp id=\"be76\"\u003eAs you’re probably already used to, open the \u003ccode\u003egradle/libs.versions.toml\u003c/code\u003e file and add the new library.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1a33\"\u003e[versions]\u003cbr/\u003eandroidx-material-icons-extended = \u0026#34;1.7.3\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-material-icons-extended = { module = \u0026#34;org.jetbrains.compose.material:material-icons-extended\u0026#34;, version.ref = \u0026#34;androidx-material-icons-extended\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"46dc\"\u003eNext, let’s open the \u003ccode\u003ecomposeApp/build.gradle.kts\u003c/code\u003e file and declare the dependency in the \u003ccode\u003ecommonMain\u003c/code\u003e source set. Make sure to perform a new gradle sync afterwards.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c19f\"\u003ecommonMain.dependencies {\u003cbr/\u003e    implementation(libs.androidx.material.icons.extended)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4df8\"\u003eFor the new strings, open the \u003ccode\u003ecomposeApp/src/commonMain/composeResources/values/strings.xml\u003c/code\u003e file and add the following new strings. The \u003ccode\u003e%1$s\u003c/code\u003e is a string placeholder that we will later replace with the name of the news site.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9ce1\"\u003e\u0026lt;string name=\u0026#34;read_more_at\u0026#34;\u0026gt;Read full article at %1$s\u0026lt;/string\u0026gt;\u003cbr/\u003e\u0026lt;string name=\u0026#34;back_content_description\u0026#34;\u0026gt;Back\u0026lt;/string\u0026gt;\u003cbr/\u003e\u0026lt;string name=\u0026#34;share_content_description\u0026#34;\u0026gt;Share\u0026lt;/string\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"a85f\"\u003eTip: If you find you can not reference the strings from code later, rebuild the app.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"25bd\"\u003eDefine the details UI\u003c/h2\u003e\u003cp id=\"8a4c\"\u003eLet’s start by getting an instance of the \u003ccode\u003eArticleDetailsViewModel\u003c/code\u003e and reading the state from it inside the \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e composable function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3856\"\u003e@Composable\u003cbr/\u003einternal fun ArticleDetailsScreen(\u003cbr/\u003e    articleId: Long,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    val viewModel = koinViewModel\u0026lt;ArticleDetailsViewModel\u0026gt;()\u003cbr/\u003e    val state by viewModel.state.collectAsStateWithLifecycle()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8fc5\"\u003eNext, we need to propagate \u003ccode\u003earticleId\u003c/code\u003e to the View Model. One way would be to use a \u003ccode\u003eSavedStateHandle\u003c/code\u003e to read the argument directly in the \u003ccode\u003eArticleDetailsViewModel\u003c/code\u003e. However, to keep things simple, we’re just going to use a \u003ccode\u003eLaunchedEffect\u003c/code\u003e and call the \u003ccode\u003eviewModel.onFetchArticle()\u003c/code\u003e function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d1d7\"\u003e@Composable\u003cbr/\u003einternal fun ArticleDetailsScreen(\u003cbr/\u003e    articleId: Long,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    val viewModel = koinViewModel\u0026lt;ArticleDetailsViewModel\u0026gt;()\u003cbr/\u003e    val state by viewModel.state.collectAsStateWithLifecycle()\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        viewModel.onFetch(articleId)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6c40\"\u003eWe’re going to keep the screen layout in a new Composable function called \u003ccode\u003eArticleDetailsScreenContent\u003c/code\u003e. It should accept the screen state, and several callbacks for UI actions.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aaf0\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleDetailsScreenContent(\u003cbr/\u003e    state: ArticleDetailsViewModel.ArticleDetailsViewState,\u003cbr/\u003e    onRetryClick: () -\u0026gt; Unit,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e    onShareClick: () -\u0026gt; Unit,\u003cbr/\u003e    onReadMoreClick: (String) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cp\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"df6f\"\u003eFor the actual screen, we’re going to use the \u003ccode\u003eScaffold\u003c/code\u003e composable to handle the basic skeleton for us. We need to support loading, error, and success states.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f77f\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleDetailsScreenContent(\u003cbr/\u003e    state: ArticleDetailsViewModel.ArticleDetailsViewState,\u003cbr/\u003e    onRetryClick: () -\u0026gt; Unit,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e    onShareClick: () -\u0026gt; Unit,\u003cbr/\u003e    onReadMoreClick: (String) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    Scaffold { innerPadding -\u0026gt;\u003cbr/\u003e        Box(modifier = Modifier.padding(innerPadding)) {\u003cbr/\u003e            when (val currentState = state) {\u003cbr/\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u0026gt; {\u003cbr/\u003e                    // TODO\u003cbr/\u003e                }\u003cp\u003e                ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u0026gt; {\u003cbr/\u003e                    // TODO\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u0026gt; {\u003cbr/\u003e                    // TODO\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"27e7\"\u003eFor the loading and error states, we’re going to reuse the same layouts from the \u003ccode\u003eArticleListScreen\u003c/code\u003e. However, it would be bad practice to duplicate them, so we’ll extract them into standalone composable functions that we can then also reference on the new screen.\u003c/p\u003e\u003cp id=\"daf5\"\u003eOpen \u003ccode\u003eArticleListScreen\u003c/code\u003e and create two functions: \u003ccode\u003eLoadingContent\u003c/code\u003e and \u003ccode\u003eErrorContent\u003c/code\u003e. Copy over the content from the \u003ccode\u003ewhen\u003c/code\u003e statement and update the \u003ccode\u003eErrorContent\u003c/code\u003e so that it receives the error type as input argument, and a callback for the retry button click. Make sure to update the \u003ccode\u003ewhen\u003c/code\u003e statement so it calls these two new functions.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"45b0\"\u003e@Composable\u003cbr/\u003efun BoxScope.LoadingContent() {\u003cbr/\u003e    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))\u003cbr/\u003e}\u003cp\u003e@Composable\u003cbr/\u003efun BoxScope.ErrorContent(\u003cbr/\u003e    errorType: ErrorType,\u003cbr/\u003e    onRetryClick: () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val errorMessage = when (errorType) {\u003cbr/\u003e        ErrorType.NoInternet -\u0026gt; stringResource(Res.string.no_internet)\u003cbr/\u003e        ErrorType.ServerError -\u0026gt; stringResource(Res.string.server_error)\u003cbr/\u003e        ErrorType.Unknown -\u0026gt; stringResource(Res.string.something_went_wrong)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        horizontalAlignment = Alignment.CenterHorizontally,\u003cbr/\u003e        modifier = Modifier.align(Alignment.Center)\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = errorMessage,\u003cbr/\u003e            color = Color.Red,\u003cbr/\u003e            style = MaterialTheme.typography.bodyMedium,\u003cbr/\u003e            modifier = Modifier.padding(16.dp)\u003cbr/\u003e        )\u003cbr/\u003e        Button(onClick = onRetryClick) {\u003cbr/\u003e            Text(text = stringResource(Res.string.retry))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4ce7\"\u003eWe can now use the two new functions in the \u003ccode\u003eArticleDetailsScreenContent\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cd5f\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleDetailsScreenContent(\u003cbr/\u003e    state: ArticleDetailsViewModel.ArticleDetailsViewState,\u003cbr/\u003e    onRetryClick: () -\u0026gt; Unit,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e    onShareClick: () -\u0026gt; Unit,\u003cbr/\u003e    onReadMoreClick: (String) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    Scaffold { innerPadding -\u0026gt;\u003cbr/\u003e        Box(modifier = Modifier.padding(innerPadding)) {\u003cbr/\u003e            when (val currentState = state) {\u003cbr/\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u0026gt; {\u003cbr/\u003e                    ErrorContent(\u003cbr/\u003e                        errorType = currentState.errorType,\u003cbr/\u003e                        onRetryClick = onRetryClick,\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cp\u003e                ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u0026gt; {\u003cbr/\u003e                    LoadingContent()\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u0026gt; {\u003cbr/\u003e                    // TODO\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2f76\"\u003eNext, we need to define the success UI. Create a new composable function named \u003ccode\u003eArticleDetailsSuccessContent\u003c/code\u003e that accepts the loaded\u003ccode\u003eArticle\u003c/code\u003e object, and callbacks for back button, share button, and read more button clicks.\u003c/p\u003e\u003cp id=\"3c49\"\u003eFor the actual content, we want to display the following elements:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f9ac\"\u003ecover image of the article\u003c/li\u003e\u003cli id=\"f4d4\"\u003eback button shown on the top left of the image\u003c/li\u003e\u003cli id=\"f6af\"\u003eshare button shown on the top right of the image\u003c/li\u003e\u003cli id=\"07ac\"\u003earticle title\u003c/li\u003e\u003cli id=\"3278\"\u003ename of the news site where the article was published\u003c/li\u003e\u003cli id=\"e32b\"\u003edate and time the article was published\u003c/li\u003e\u003cli id=\"2518\"\u003efull description/content of the article\u003c/li\u003e\u003cli id=\"e24d\"\u003e“read more” button.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c5d3\"\u003eThe image below shows the design we want to achieve. Feel free to try and do it yourself before moving forward.\u003c/p\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003eArticle details screen layout on Android.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"5529\"\u003eHere is the full implementation of \u003ccode\u003eArticleDetailsSuccessContent\u003c/code\u003e based on the requirements above. We’re using a \u003ccode\u003eColumn\u003c/code\u003e to vertically arrange all the elements.\u003c/p\u003e\u003cp id=\"83e4\"\u003eSimilar to the list screen, we\u0026#39;re using Coil’s \u003ccode\u003eAsyncImage\u003c/code\u003e to load the article image from the URL. We’re wrapping it in a \u003ccode\u003eBox\u003c/code\u003e, so we can overlay the back and share buttons over it.\u003c/p\u003e\u003cp id=\"112e\"\u003eThe date and time at which the article was published is formatted using the \u003ccode\u003eLocalDateTime.Format\u003c/code\u003e builder, which gives us the option to specify the exact format we want.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2c2a\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleDetailsSuccessContent(\u003cbr/\u003e    article: Article,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e    onShareClick: () -\u0026gt; Unit,\u003cbr/\u003e    onReadMoreClick: (String) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    Column(\u003cbr/\u003e        verticalArrangement = Arrangement.Top,\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        Box(modifier = Modifier.fillMaxWidth()) {\u003cbr/\u003e            AsyncImage(\u003cbr/\u003e                model = article.imageUrl,\u003cbr/\u003e                contentDescription = null,\u003cbr/\u003e                contentScale = ContentScale.Crop,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .aspectRatio(16f / 9f),\u003cbr/\u003e            )\u003cp\u003e            IconButton(onClick = onBackClick, modifier = Modifier.align(Alignment.TopStart)) {\u003cbr/\u003e                Icon(\u003cbr/\u003e                    Icons.AutoMirrored.Filled.ArrowBack,\u003cbr/\u003e                    contentDescription = stringResource(Res.string.back_content_description),\u003cbr/\u003e                    tint = Color.White\u003cbr/\u003e                )\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            IconButton(onClick = onShareClick, modifier = Modifier.align(Alignment.TopEnd)) {\u003cbr/\u003e                Icon(\u003cbr/\u003e                    Icons.Default.Share,\u003cbr/\u003e                    contentDescription = stringResource(Res.string.share_content_description),\u003cbr/\u003e                    tint = Color.White\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        Column(\u003cbr/\u003e            verticalArrangement = Arrangement.spacedBy(8.dp),\u003cbr/\u003e            modifier = Modifier.fillMaxWidth().padding(16.dp)\u003cbr/\u003e        ) {\u003c/p\u003e\u003cp\u003e            Text(\u003cbr/\u003e                text = article.title,\u003cbr/\u003e                style = MaterialTheme.typography.titleLarge,\u003cbr/\u003e                fontWeight = FontWeight.Bold,\u003cbr/\u003e                overflow = TextOverflow.Ellipsis,\u003cbr/\u003e            )\u003c/p\u003e\u003cp\u003e            Row(\u003cbr/\u003e                verticalAlignment = Alignment.CenterVertically,\u003cbr/\u003e                horizontalArrangement = Arrangement.spacedBy(2.dp)\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = article.newsSite,\u003cbr/\u003e                    style = MaterialTheme.typography.bodySmall,\u003cbr/\u003e                    color = MaterialTheme.colorScheme.secondary,\u003cbr/\u003e                )\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = \u0026#34; • \u0026#34;,\u003cbr/\u003e                    style = MaterialTheme.typography.bodySmall,\u003cbr/\u003e                    color = MaterialTheme.colorScheme.secondary,\u003cbr/\u003e                )\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = article.publishedAt.toLocalDateTime(TimeZone.currentSystemDefault())\u003cbr/\u003e                        .format(\u003cbr/\u003e                            LocalDateTime.Format {\u003cbr/\u003e                                year()\u003cbr/\u003e                                char(\u0026#39;-\u0026#39;)\u003cbr/\u003e                                monthNumber()\u003cbr/\u003e                                char(\u0026#39;-\u0026#39;)\u003cbr/\u003e                                dayOfMonth()\u003c/p\u003e\u003cp\u003e                                chars(\u0026#34; at \u0026#34;)\u003c/p\u003e\u003cp\u003e                                hour()\u003cbr/\u003e                                char(\u0026#39;:\u0026#39;)\u003cbr/\u003e                                minute()\u003cbr/\u003e                            }),\u003cbr/\u003e                    style = MaterialTheme.typography.bodySmall,\u003cbr/\u003e                    color = MaterialTheme.colorScheme.secondary,\u003cbr/\u003e                )\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            Spacer(modifier = Modifier.height(8.dp))\u003c/p\u003e\u003cp\u003e            Text(\u003cbr/\u003e                text = article.summary,\u003cbr/\u003e                style = MaterialTheme.typography.bodyMedium,\u003cbr/\u003e                overflow = TextOverflow.Ellipsis\u003cbr/\u003e            )\u003c/p\u003e\u003cp\u003e            TextButton(onClick = {\u003cbr/\u003e                onReadMoreClick(article.url)\u003cbr/\u003e            }, modifier = Modifier.fillMaxWidth()) {\u003cbr/\u003e                Text(text = stringResource(Res.string.read_more_at, article.newsSite))\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7e7d\"\u003eNow that we have defined our success layout, we can go back to the \u003ccode\u003eArticleDetailsScreenContent\u003c/code\u003e and update the success branch of the \u003ccode\u003ewhen\u003c/code\u003e statement to call the new \u003ccode\u003eArticleDetailsSuccessContent\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"307f\"\u003e@Composable\u003cbr/\u003eprivate fun ArticleDetailsScreenContent(\u003cbr/\u003e    state: ArticleDetailsViewModel.ArticleDetailsViewState,\u003cbr/\u003e    onRetryClick: () -\u0026gt; Unit,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e    onShareClick: () -\u0026gt; Unit,\u003cbr/\u003e    onReadMoreClick: (String) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    Scaffold { innerPadding -\u0026gt;\u003cbr/\u003e        Box(modifier = Modifier.padding(innerPadding)) {\u003cbr/\u003e            when (val currentState = state) {\u003cbr/\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Error -\u0026gt; {\u003cbr/\u003e                    ErrorContent(\u003cbr/\u003e                        errorType = currentState.errorType,\u003cbr/\u003e                        onRetryClick = onRetryClick,\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cp\u003e                ArticleDetailsViewModel.ArticleDetailsViewState.Loading -\u0026gt; {\u003cbr/\u003e                    LoadingContent()\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                is ArticleDetailsViewModel.ArticleDetailsViewState.Success -\u0026gt; {\u003cbr/\u003e                    ArticleDetailsSuccessContent(\u003cbr/\u003e                        article = currentState.article,\u003cbr/\u003e                        onBackClick = onBackClick,\u003cbr/\u003e                        onReadMoreClick = onReadMoreClick,\u003cbr/\u003e                        onShareClick = onShareClick,\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b493\"\u003eAnd finally, we can call the \u003ccode\u003eArticleDetailsScreenContent\u003c/code\u003e from the root \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e composable function.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8add\"\u003e@Composable\u003cbr/\u003einternal fun ArticleDetailsScreen(\u003cbr/\u003e    articleId: Long,\u003cbr/\u003e    onBackClick: () -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    val viewModel = koinViewModel\u0026lt;ArticleDetailsViewModel\u0026gt;()\u003cbr/\u003e    val state by viewModel.state.collectAsStateWithLifecycle()\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        viewModel.onFetch(articleId)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    ArticleDetailsScreenContent(\u003cbr/\u003e        state = state,\u003cbr/\u003e        onRetryClick = {\u003cbr/\u003e            viewModel.onFetch(articleId)\u003cbr/\u003e        },\u003cbr/\u003e        onBackClick = onBackClick,\u003cbr/\u003e        onShareClick = {\u003cbr/\u003e            // TODO Open share sheet\u003cbr/\u003e        },\u003cbr/\u003e        onReadMoreClick = {\u003cbr/\u003e            // TODO Open browser\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"ce55\"\u003eWe’re going to implement the share and read more functionality in next part of the series.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"a481\"\u003eAdd the composable to the navigation graph\u003c/h2\u003e\u003cp id=\"b4e8\"\u003eNow that we have defined the \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e composable, we can add it to our navigation graph and open it.\u003c/p\u003e\u003cp id=\"84cb\"\u003eOpen the \u003ccode\u003eApp\u003c/code\u003e and replace the \u003ccode\u003eBox\u003c/code\u003e with the \u003ccode\u003eTODO\u003c/code\u003e at the bottom of the file with a call to \u003ccode\u003eArticleDetailsScreen\u003c/code\u003e. We passed the article identifier when we triggered the navigation to the details screen, and to retrieve it, we have to use the \u003ccode\u003etoRoute\u003c/code\u003e extension function on the\u003ccode\u003eNavBackStackEntry\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"bf3e\"\u003eOn back click, we call \u003ccode\u003enavController.popBackStack()\u003c/code\u003e which navigates back from the details screen to the list screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4c14\"\u003e@Composable\u003cbr/\u003eprivate fun MainNavigationHost() {\u003cbr/\u003e    val navController = rememberNavController()\u003cbr/\u003e    NavHost(\u003cbr/\u003e        navController,\u003cbr/\u003e        startDestination = MainNavigationDestination.Home,\u003cbr/\u003e        modifier = Modifier.fillMaxSize()\u003cbr/\u003e    ) {\u003cbr/\u003e        composable\u0026lt;MainNavigationDestination.Home\u0026gt; {\u003cbr/\u003e            ArticleListScreen(onArticleClick = { articleId -\u0026gt;\u003cbr/\u003e                navController.navigate(MainNavigationDestination.Details(articleId))\u003cbr/\u003e            })\u003cbr/\u003e        }\u003cbr/\u003e        composable\u0026lt;MainNavigationDestination.Details\u0026gt; {\u003cbr/\u003e            val route = it.toRoute\u0026lt;MainNavigationDestination.Details\u0026gt;()\u003cbr/\u003e            ArticleDetailsScreen(\u003cbr/\u003e                articleId = route.articleId,\u003cbr/\u003e                onBackClick = {\u003cbr/\u003e                    navController.popBackStack()\u003cbr/\u003e                })\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"397b\"\u003e3. Run and test the app\u003c/h2\u003e\u003cp id=\"f03f\"\u003eAll that is remaining is to run the app and try out the navigation.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNavigating to the new details screen on iOS.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"3276\"\u003eWhile the navigation itself works great — we can open and close a new details screen — there is a small design issue on the details screen. The top app bar showing the app name on the home screen is also visible on the details screen.\u003c/p\u003e\u003cp id=\"69f3\"\u003eIt’s taking up valuable vertical space and not offering much value on the details screen, so we’ll remove it. However, to do that, we need to change both how our main app and the \u003ccode\u003eArticleListScreen\u003c/code\u003e are set up.\u003c/p\u003e\u003ch2 id=\"b7d4\"\u003eMove the Scaffold from App to ArticleListScreen\u003c/h2\u003e\u003cp id=\"cced\"\u003eThe reason why the top app bar is visible on both screens is that we use a \u003ccode\u003eScaffold\u003c/code\u003e at the root of our app. The \u003ccode\u003eMainNavigationHost\u003c/code\u003e is then part of the content of the \u003ccode\u003eScaffold\u003c/code\u003e composable, and the top app bar is part of the \u003ccode\u003eScaffold.header\u003c/code\u003e composable, which means it‘s always displayed above the content.\u003c/p\u003e\u003cp id=\"dd3d\"\u003eWe want to let each screen define how they want to be presented, so we’re going to remove the \u003ccode\u003eScaffold\u003c/code\u003e from the \u003ccode\u003eApp\u003c/code\u003e composable, and add it instead to the \u003ccode\u003eArticleListScreen\u003c/code\u003e composable.\u003c/p\u003e\u003cp id=\"4781\"\u003eNavigate to \u003ccode\u003eApp\u003c/code\u003e and remove the entire \u003ccode\u003eScaffold\u003c/code\u003e, leaving just a direct call to \u003ccode\u003eMainNavigationHost\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7162\"\u003e@Composable\u003cbr/\u003efun App(koinAppDeclaration: KoinAppDeclaration? = null) {\u003cbr/\u003e    KoinApplication(application = {\u003cbr/\u003e        koinAppDeclaration?.invoke(this)\u003cbr/\u003e        modules(appModule, platformModule)\u003cbr/\u003e    }) {\u003cbr/\u003e        AppTheme {\u003cbr/\u003e            MainNavigationHost()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"66b4\"\u003eThen open the \u003ccode\u003eArticleListScreen\u003c/code\u003e and wrap the existing \u003ccode\u003eBox\u003c/code\u003e with the \u003ccode\u003eScaffold\u003c/code\u003e from before. One small change that we need to make is to add a \u003ccode\u003eModifier.padding(innerPadding)\u003c/code\u003e to the \u003ccode\u003eBox\u003c/code\u003e‘s modifier. This is needed to properly support screen notches and cut-outs.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1ca9\"\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003einternal fun ArticleListScreen(onArticleClick: (Long) -\u0026gt; Unit) {\u003cbr/\u003e    val viewModel = koinViewModel\u0026lt;ArticleListViewModel\u0026gt;()\u003cbr/\u003e    val state by viewModel.state.collectAsStateWithLifecycle()\u003cp\u003e    Scaffold(\u003cbr/\u003e        topBar = {\u003cbr/\u003e            TopAppBar(\u003cbr/\u003e                title = {\u003cbr/\u003e                    Text(text = stringResource(Res.string.app_name))\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    ) { innerPadding -\u0026gt;\u003cbr/\u003e        Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {\u003cbr/\u003e            when (val currentState = state) {\u003cbr/\u003e                is ArticleListViewState.Loading -\u0026gt; {\u003cbr/\u003e                    LoadingContent()\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                is ArticleListViewState.Success -\u0026gt; {\u003cbr/\u003e                    val articles = currentState.articles\u003cbr/\u003e                    ArticleListContent(\u003cbr/\u003e                        articles = articles,\u003cbr/\u003e                        onArticleClick = onArticleClick,\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003c/p\u003e\u003cp\u003e                is ArticleListViewState.Error -\u0026gt; {\u003cbr/\u003e                    ErrorContent(\u003cbr/\u003e                        errorType = currentState.errorType,\u003cbr/\u003e                        onRetryClick = { viewModel.fetchArticles() }\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9742\"\u003eFinal testing\u003c/h2\u003e\u003cp id=\"16fd\"\u003eAfter the change, we can see that the details screen now takes the entire available space and looks much better.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eUpdated details screen on iOS.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1749\"\u003eThis is how the details screen looks on all platforms.\u003c/p\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003eThe new details screen on all three platforms: Android, iOS, and desktop.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"470c\"\u003e4. Conclusion\u003c/h2\u003e\u003cp id=\"6bb0\"\u003eIf you followed along to the end, great job! This is the end of the fourth part in the series on Kotlin Multiplatform and Compose Multiplatform. We’ve taken a look at how to use the Compose Navigation library to navigate to a new details screen.\u003c/p\u003e\u003cp id=\"2444\"\u003eIn the next part of the series, we are going to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"79d7\"\u003eAdd a system share functionality to share links to articles with different apps.\u003c/li\u003e\u003cli id=\"035e\"\u003eShow how to open the article URL in a web browser.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c3e6\"\u003e\u003cstrong\u003eStay tuned!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"8ac1\"\u003eYou can find the source code for this part here:\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": "2025-07-22T14:44:08.812Z",
  "modifiedTime": null
}
