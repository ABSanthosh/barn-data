{
  "id": "69df2fe5-9815-4e7a-881b-49b98d5bc1d5",
  "title": "Dealing with Android’s peculiar bugs as an app developer",
  "link": "https://proandroiddev.com/dealing-with-androids-peculiar-bugs-as-an-app-developer-d1e2dd7654de?source=rss----c72404660798---4",
  "description": "",
  "author": "Ilya Fomichev",
  "published": "Thu, 07 Nov 2024 19:01:17 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "mobile-app-development",
    "android-app-development",
    "android",
    "androiddev"
  ],
  "byline": "Ilya Fomichev",
  "length": 15596,
  "excerpt": "In the article, you can learn how you can work around bugs and fragmentation in OS to make your software more reliable.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Art generated with recraft.aiWhen you use external dependencies in your apps, you expect them to work correctly. But it’s not always the case. Even with such seemingly well-maintained and tested external dependencies as Android itself.I maintain an open-source library which abstracts away PackageInstaller API. For you to understand what comes next, I should explain how to work with PackageInstaller first. My previous article already covers it, but I’ll provide a quick recap here.How PackageInstaller worksPackageInstaller is an API which allows to install APK files. It’s not so important here to know how exactly it should be used, but the key points are:First, we create an install Session from the PackageInstaller.Then we write our APK files into it.Finally, we commit the session. To receive session status updates, we need to provide an IntentSender to which install events will be sent by the system.I will focus on the last step a bit. We can create a BroadcastReceiver which will handle install events, such as launching a confirmation window for a user, or notifying about final success or failure. Then we create an IntentSender for it, which we can use to commit the session.A BroadcastReceiver can look like this:class PackageInstallerStatusReceiver : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { val status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, -1) when (status) { PackageInstaller.STATUS_PENDING_USER_ACTION -\u003e { // Here we get an Intent for an Activity containing // install confirmation window and start it. val confirmationIntent = intent.getParcelableExtra\u003cIntent\u003e(Intent.EXTRA_INTENT) if (confirmationIntent != null) { context.startActivity(confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)) } } PackageInstaller.STATUS_SUCCESS -\u003e { // Notify on success. } else -\u003e { // Notify on failure. } } }}So, it seems there should be no room for unexpected behavior, right? We just handle events from OS and call it a day. Well…Inconsistency and fragmentationOne day I received the following issue report:A comment describing the issue on GitHubOn Android 8+, Google added an explicit install permission for apps. So, when a user tries to install an app from another third-party app for the first time, Android redirects them to a special settings screen where they must allow installs for that particular installer app. Sounds reasonable.However, I couldn’t reproduce the above issue on my devices, both physical and virtual. After further discussion, it turned out that the reporter encounters the issue on a set-top box. I’ve gone to test the library on an Android SDK emulator with Android TV 9 image, and voilà! It was exactly how they described it.This is how it looks:Demonstration of the issue on Android TV 9Typically, Android returns you to an install confirmation window after you granted install permission. But on Android TV, this confirmation doesn’t reappear. Fragmentation yet again.Bugs in AndroidLet’s move a bit to another topic before I tell you how I fixed the issue.In reality, as you could’ve guessed already, BroadcastReceiver alone is not sufficient for reliable session status reports. For example, with some broken APK files, there would be a “There was a problem parsing the package” error on some Android versions. And this error won’t be reported to the IntentSender we provide when we commit a session!The error in questionHow can we get out of this situation?Wrapper Activity to the rescueI solved it by starting my own Activity when user’s confirmation is required, and I pass it the confirmation Intent that I got in BroadcastReceiver. Then, in my Activity, I start this Intent and wait for result. I examine PackageInstaller.Session’s state directly and act based on that. This can be done with startActivityForResult() method in Activity.As a side note, you may ask, why don’t I use Activity Result API from Jetpack? Well, because I specifically avoid androidx.activity dependency in the library and because I need to also finish started activity with request code (using Activity#finishActivity(int) method), and this is not possible with Activity Result API.So, instead of how it was in the first section, now it looks like this in BroadcastReceiver:when (status) { PackageInstaller.STATUS_PENDING_USER_ACTION -\u003e { val confirmationIntent = intent.getParcelableExtra\u003cIntent\u003e(Intent.EXTRA_INTENT) val wrapperIntent = Intent(context, InstallConfirmationActivity::class.java) .putExtra(Intent.EXTRA_INTENT, confirmationIntent) .putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId) .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) context.startActivity(wrapperIntent) } // ...}And in the newly created InstallConfirmationActivity we have this:class InstallConfirmationActivity : Activity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) if (savedInstanceState == null) { launchInstallActivity() } } private fun launchInstallActivity() { val extras = intent.extras ?: return val confirmationIntent = extras.getParcelable\u003cIntent\u003e(Intent.EXTRA_INTENT) if (confirmationIntent != null) { startActivityForResult(confirmationIntent, requestCode) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { // How to handle session's state here? }}How do we handle result when we return from the system’s confirmation Activity?There’s a workaround. We can query session’s progress, and if it did change, that means the installation continues normally. Otherwise, if we didn’t get result in our BroadcastReceiver, something went wrong.override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { val extras = intent.extras ?: return val sessionId = extras.getInt(PackageInstaller.EXTRA_SESSION_ID) val sessionInfo = packageManager.packageInstaller.getSessionInfo(sessionId) // Hacky workaround: progress not going higher after commit means session is dead. val isSessionAlive = sessionInfo != null \u0026\u0026 sessionInfo.progress \u003e= getProgressThresholdValue() if (!isSessionAlive) { handler.postDelayed( Runnable { // Here we notify that session failed (\"Session {id} is dead\"). // Why delay? We can’t be sure if BroadcastReceiver really // won’t promptly deliver some result. }, 1000 ) } else { // Everything went OK. Probably. finish() }}It worked great. But this solution didn’t take into account some other edge cases, which are in fact bugs in different Android versions. And one of these cases got reported in that GitHub comment.Workarounds journeyLet me remind you what the initial issue was. We don’t get a confirmation window after user grants install permission. It’s not guaranteed that this issue presents itself only on Android TV, we should think of it as a general possibility. So let’s somehow check whether the confirmation was or wasn’t present.How do we approach this? Well, if user didn’t confirm installation due to confirmation not appearing, that means install session’s progress didn’t change!val isSessionStuck = sessionInfo != null \u0026\u0026 sessionInfo.progress \u003c getProgressThresholdValue()If our app doesn’t have install permission, we can just cancel the session here.if (!canInstallPackages) abortSession(\"Install permission denied\")We also need to distinguish whether install permission request took place or not, because confirmation doesn’t appear only if user went to permission settings. We can check whether the install permission status changed after returning. If it changed, that means this request actually took place. It doesn’t matter if permission was denied, because we handled it earlier.// canInstallPackages is a field in our Activityval previousCanInstallPackagesValue = canInstallPackagescanInstallPackages = checkCanInstallPackages()val isInstallPermissionStatusChanged = previousCanInstallPackagesValue != canInstallPackagesAnd with this, we can finally relaunch confirmation:if (isSessionStuck \u0026\u0026 isInstallPermissionStatusChanged) { launchInstallActivity() return}Nice, now it works correctly in this case!However, while investigating the issue, I actually opened a whole can of worms. It turns out Android’s confirmation window is more bugged than I thought!Cursed dialogIf we dismiss the confirmation via clicking outside a dialog instead of clicking Cancel, install session becomes stuck, and BroadcastReceiver doesn’t receive failure status!If confirmation is dismissed via clicking on area highlighted with red, session’s going to stay stuckThis bug got fixed only on Android 14, so we have to work around it as well.This is quite easy. If the previous check didn’t succeed (which is when we got install permission and showed confirmation window), we check if the session was not stuck. If it progressed, we just finish our Activity:val isSessionAlive = sessionInfo != nullif (isSessionAlive \u0026\u0026 !isSessionStuck) { finish() return}But if it got stuck, it means that confirmation was dismissed.// Though confirmation Activity usually always returns RESULT_CANCELED// value, on some Android versions resultCode is not equal to RESULT_CANCELED// if Activity was finished normally via Cancel or Install buttons.val isActivityCancelled = resultCode == RESULT_CANCELEDif (isSessionAlive \u0026\u0026 isActivityCancelled) { abortSession() return}There are two other issues related to this.The first one is the most interesting. Remember that on some devices confirmation didn’t appear after we grant permission? Our fix for that issue turns into a problem on devices where it does appear, because in this case we will show confirmation twice! (Again, only if we dismiss the dialog by clicking outside of it).That happens because our initial fix doesn’t check if there is no confirmation Activity actually showing, but only if we possibly need to launch it. Improving our solution is a bit tricky, because we also have to account for process death, as on Android 11 changing install permission state always kills the process.Let’s remember Activity’s lifecycle. onStart() is called when Activity becomes visible, and onResume() is called when Activity gets focus to interact with user. Now we’ll see some logs with this in mind.First, let’s look at lifecycle callbacks order in cases when confirmation Activity does reappear after permission request.After each lifecycle method call you can see a class name of Activity which was on top at that time.First, our Activity is created, started and resumed.Then it goes to background (indicated by onStop) as ManageAppExternalSourcesActivity comes to top. ManageAppExternalSourcesActivity is the install permission settings screen.On Android 11, as I’ve already mentioned, process gets killed when install permission status changes, and when we go back, PackageInstallerActivity is displayed first. PackageInstallerActivity contains install confirmation dialog.While our Activity becomes visible, i.e., is started (because PackageInstallerActivity has transparent background), we see that PackageInstallerActivity is actually on top of activity stack and is visible above ours.Then we get result in onActivityResult().Let’s compare this with other logs.On Android 10 we don’t observe process death, otherwise the order is roughly the same as it was on Android 11. When we go back from permission settings, our Activity becomes visible, and PackageInstallerActivity is visible on top.On Android 9 and earlier versions, install confirmation is full-screen, not a dialog, so our Activity is not restarted until we confirm installation and go back. But we don’t need to check if our Activity is on top when started (it will always be anyway), because install session is going to be cancelled correctly via clicking Cancel button or going back. Therefore, our initial check (isSessionStuck \u0026\u0026 isInstallPermissionStatusChanged) is still necessary to avoid relaunching confirmation on correctly working Android versions.Now let’s see logs when confirmation Activity doesn’t reappear.Our Activity launches confirmation, and then PackageInstallerActivity redirects to install permission settings.After granting permission and returning, we get a result in onActivityResult(), and our Activity gets started and resumed again.As we can see, when our Activity becomes visible again, i.e., started, there are no other activities above it. It’s the same as on generic Android 9, but this time the check for stuck session succeeds. Compare this with earlier logs (Android 10+), where PackageInstallerActivity is displayed on top at this moment.So, we can conclude that in order to determine whether confirmation Activity needs to be relaunched, we also need to remember if our Activity was on top when it was started. If it was, then we check whether session is stuck and permission status has changed, and only then we start confirmation again from onActivityResult(). Otherwise, if there was another Activity in foreground, we just handle our stuff in onActivityResult() and we’re done!In code, it may look like this:private var wasOnTopOnStart = falseoverride fun onStart() { super.onStart() wasOnTopOnStart = isOnTop()}override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { // ... if (isSessionStuck \u0026\u0026 isInstallPermissionStatusChanged \u0026\u0026 wasOnTopOnStart) { launchInstallActivity() return } // ...}Now it’s time to fix the last issue.Since Android 12, a confirmation window appears immediately after granting install permission, not when returning from the settings screen.Android 11 on the left, Android 12 on the rightOn Android 12–13 our workarounds won’t do, because if we dismiss the dialog by clicking outside of it, we don’t receive result in onActivityResult(), so the checks will not even execute. Another bug.Here is a log of our Activity’s lifecycle on Android 12:As with the previous bug, we can circumvent it by determining whether our Activity is on top of activity stack when it’s started. It would mean there’s no confirmation Activity with the dialog above ours because it was already dismissed. Note that onActivityResult() is always called before onResume(). So if our Activity was on top when started and if onActivityResult() was not called when we enter onResume(), we cancel the session:private var isOnActivityResultCalled = false// We shouldn't do anything if our Activity is freshly created.private var isFirstResume = trueoverride fun onResume() { super.onResume() if (isFirstResume) { isFirstResume = false return } if (!isOnActivityResultCalled \u0026\u0026 wasOnTopOnStart) { abortSession() }}override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { isOnActivityResultCalled = true // ...}I omit code related to state saving and restoring which is needed to handle configuration changes and process restoration correctly, but the idea is there.ConclusionAs we saw, there may be a lot of frustrating peculiarities caused by incorrect Android behavior. I showed some examples of how you can work around non-trivial edge cases and ensure that your app handles all situations reliably.If you need this exact functionality in your app (installing APKs), you don’t have to implement it all yourself, because I already did it in my open-source library Ackpine! I’ll be happy if you give it a try and come with feedback! You can read my article about it, or visit a website with documentation:Thanks for reading and enjoy your coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*PAxb9cJzHnm0-x9acw3Qng.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@solrudev?source=post_page---byline--d1e2dd7654de--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ilya Fomichev\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*a1_X4yVkytGLJzgESFMw8w.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--d1e2dd7654de--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003cfigcaption\u003eArt generated with recraft.ai\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"4fca\"\u003eWhen you use external dependencies in your apps, you expect them to work correctly. But it’s not always the case. Even with such seemingly well-maintained and tested external dependencies as Android itself.\u003c/p\u003e\u003cp id=\"dadc\"\u003eI maintain an open-source library which abstracts away \u003cem\u003ePackageInstaller\u003c/em\u003e API. For you to understand what comes next, I should explain how to work with \u003cem\u003ePackageInstaller\u003c/em\u003e first. My \u003ca href=\"https://medium.com/@solrudev/painless-building-of-an-android-package-installer-app-d5a09b5df432\" rel=\"noopener\"\u003eprevious article\u003c/a\u003e already covers it, but I’ll provide a quick recap here.\u003c/p\u003e\u003ch2 id=\"ba08\"\u003e\u003cspan\u003eH\u003c/span\u003eow PackageInstaller works\u003c/h2\u003e\u003cp id=\"b892\"\u003e\u003cem\u003ePackageInstaller\u003c/em\u003e is an API which allows to install APK files. It’s not so important here to know how exactly it should be used, but the key points are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9896\"\u003eFirst, we create an install \u003cem\u003eSession\u003c/em\u003e from the \u003cem\u003ePackageInstaller\u003c/em\u003e.\u003c/li\u003e\u003cli id=\"1d8d\"\u003eThen we write our APK files into it.\u003c/li\u003e\u003cli id=\"bb07\"\u003eFinally, we commit the session. To receive session status updates, we need to provide an \u003cem\u003eIntentSender\u003c/em\u003e to which install events will be sent by the system.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5959\"\u003eI will focus on the last step a bit. We can create a \u003cem\u003eBroadcastReceiver\u003c/em\u003e which will handle install events, such as launching a confirmation window for a user, or notifying about final success or failure. Then we create an \u003cem\u003eIntentSender\u003c/em\u003e for it, which we can use to commit the session.\u003c/p\u003e\u003cp id=\"ec12\"\u003eA \u003cem\u003eBroadcastReceiver\u003c/em\u003e can look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"95e8\"\u003eclass PackageInstallerStatusReceiver : BroadcastReceiver() {\u003cp\u003e  override fun onReceive(context: Context, intent: Intent) {\u003cbr/\u003e    val status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, -1)\u003cbr/\u003e    when (status) {\u003cbr/\u003e      PackageInstaller.STATUS_PENDING_USER_ACTION -\u0026gt; {\u003cbr/\u003e        // Here we get an Intent for an Activity containing\u003cbr/\u003e        // install confirmation window and start it.\u003cbr/\u003e        val confirmationIntent = intent.getParcelableExtra\u0026lt;Intent\u0026gt;(Intent.EXTRA_INTENT)\u003cbr/\u003e        if (confirmationIntent != null) {\u003cbr/\u003e          context.startActivity(confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))\u003cbr/\u003e        }\u003cbr/\u003e      }\u003cbr/\u003e      PackageInstaller.STATUS_SUCCESS -\u0026gt; {\u003cbr/\u003e        // Notify on success.\u003cbr/\u003e      }\u003cbr/\u003e      else -\u0026gt; {\u003cbr/\u003e        // Notify on failure.\u003cbr/\u003e      }\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6187\"\u003eSo, it seems there should be no room for unexpected behavior, right? We just handle events from OS and call it a day. Well…\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"473a\"\u003eInconsistency and fragmentation\u003c/h2\u003e\u003cp id=\"1015\"\u003eOne day I received the following issue report:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eA comment describing the issue on GitHub\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d29c\"\u003eOn Android 8+, Google added an explicit install permission for apps. So, when a user tries to install an app from another third-party app for the first time, Android redirects them to a special settings screen where they must allow installs for that particular installer app. Sounds reasonable.\u003c/p\u003e\u003cp id=\"a120\"\u003eHowever, I couldn’t reproduce the above issue on my devices, both physical and virtual. After further discussion, it turned out that the reporter encounters the issue on a \u003cstrong\u003eset-top box\u003c/strong\u003e. I’ve gone to test the library on an Android SDK emulator with Android TV 9 image, and voilà! It was exactly how they described it.\u003c/p\u003e\u003cp id=\"8433\"\u003eThis is how it looks:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDemonstration of the issue on Android TV 9\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ab09\"\u003eTypically, Android returns you to an install confirmation window after you granted install permission. But on Android TV, this confirmation doesn’t reappear. Fragmentation yet again.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"710c\"\u003eBugs in Android\u003c/h2\u003e\u003cp id=\"e2a0\"\u003eLet’s move a bit to another topic before I tell you how I fixed the issue.\u003c/p\u003e\u003cp id=\"b2af\"\u003eIn reality, as you could’ve guessed already, \u003cem\u003eBroadcastReceiver\u003c/em\u003e alone is not sufficient for \u003cstrong\u003ereliable\u003c/strong\u003e session status reports. For example, with some broken APK files, there would be a “There was a problem parsing the package” error on some Android versions. And this error \u003cstrong\u003ewon’t\u003c/strong\u003e be reported to the \u003cem\u003eIntentSender\u003c/em\u003e we provide when we commit a session!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe error in question\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"130d\"\u003eHow can we get out of this situation?\u003c/p\u003e\u003ch2 id=\"5c31\"\u003eWrapper Activity to the rescue\u003c/h2\u003e\u003cp id=\"5ea5\"\u003eI solved it by starting my own Activity when user’s confirmation is required, and I pass it the confirmation \u003cem\u003eIntent\u003c/em\u003e that I got in \u003cem\u003eBroadcastReceiver\u003c/em\u003e. Then, in my Activity, I start this Intent and wait for result. I examine \u003cem\u003ePackageInstaller.Session\u003c/em\u003e’s state directly and act based on that. This can be done with \u003cem\u003estartActivityForResult()\u003c/em\u003e method in Activity.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"557e\"\u003eAs a side note, you may ask, why don’t I use Activity Result API from Jetpack? Well, because I specifically avoid \u003cstrong\u003eandroidx.activity\u003c/strong\u003e dependency in the library and because I need to also finish started activity with request code (using \u003cstrong\u003eActivity#finishActivity(int)\u003c/strong\u003e method), and this is not possible with Activity Result API.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e3a8\"\u003eSo, instead of how it was in the first section, now it looks like this in \u003cem\u003eBroadcastReceiver\u003c/em\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"47be\"\u003ewhen (status) {\u003cbr/\u003e  PackageInstaller.STATUS_PENDING_USER_ACTION -\u0026gt; {\u003cbr/\u003e    val confirmationIntent = intent.getParcelableExtra\u0026lt;Intent\u0026gt;(Intent.EXTRA_INTENT)\u003cbr/\u003e    val wrapperIntent = Intent(context, InstallConfirmationActivity::class.java)\u003cbr/\u003e      .putExtra(Intent.EXTRA_INTENT, confirmationIntent)\u003cbr/\u003e      .putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId)\u003cbr/\u003e      .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\u003cbr/\u003e    context.startActivity(wrapperIntent)\u003cbr/\u003e  }\u003cbr/\u003e  // ...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f2cf\"\u003eAnd in the newly created \u003cem\u003eInstallConfirmationActivity\u003c/em\u003e we have this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8c8d\"\u003eclass InstallConfirmationActivity : Activity() {\u003cp\u003e  override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e    super.onCreate(savedInstanceState)\u003cbr/\u003e    if (savedInstanceState == null) {\u003cbr/\u003e      launchInstallActivity()\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  private fun launchInstallActivity() {\u003cbr/\u003e    val extras = intent.extras ?: return\u003cbr/\u003e    val confirmationIntent = extras.getParcelable\u0026lt;Intent\u0026gt;(Intent.EXTRA_INTENT)\u003cbr/\u003e    if (confirmationIntent != null) {\u003cbr/\u003e      startActivityForResult(confirmationIntent, requestCode)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\u003cbr/\u003e    // How to handle session\u0026#39;s state here?\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a524\"\u003eHow do we handle result when we return from the system’s confirmation Activity?\u003c/p\u003e\u003cp id=\"2c01\"\u003eThere’s a workaround. We can query session’s progress, and if it did change, that means the installation continues normally. Otherwise, if we didn’t get result in our \u003cem\u003eBroadcastReceiver\u003c/em\u003e, something went wrong.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"845a\"\u003eoverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\u003cbr/\u003e  val extras = intent.extras ?: return\u003cbr/\u003e  val sessionId = extras.getInt(PackageInstaller.EXTRA_SESSION_ID)\u003cbr/\u003e  val sessionInfo = packageManager.packageInstaller.getSessionInfo(sessionId)\u003cbr/\u003e  // Hacky workaround: progress not going higher after commit means session is dead.\u003cbr/\u003e  val isSessionAlive = sessionInfo != null \u0026amp;\u0026amp; sessionInfo.progress \u0026gt;= getProgressThresholdValue()\u003cbr/\u003e  if (!isSessionAlive) {\u003cbr/\u003e    handler.postDelayed(\u003cbr/\u003e      Runnable {\u003cbr/\u003e        // Here we notify that session failed (\u0026#34;Session {id} is dead\u0026#34;).\u003cbr/\u003e        // Why delay? We can’t be sure if BroadcastReceiver really\u003cbr/\u003e        // won’t promptly deliver some result.\u003cbr/\u003e      },\u003cbr/\u003e      1000\u003cbr/\u003e    )\u003cbr/\u003e  } else {\u003cbr/\u003e    // Everything went OK. Probably.\u003cbr/\u003e    finish()\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6e3f\"\u003eIt worked great. But this solution didn’t take into account some other edge cases, which are in fact bugs in different Android versions. And one of these cases got reported in that GitHub comment.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"3fad\"\u003eWorkarounds journey\u003c/h2\u003e\u003cp id=\"cf19\"\u003eLet me remind you what the initial issue was. We don’t get a confirmation window after user grants install permission. It’s not guaranteed that this issue presents itself only on Android TV, we should think of it as a general possibility. So let’s somehow check whether the confirmation was or wasn’t present.\u003c/p\u003e\u003cp id=\"54a1\"\u003eHow do we approach this? Well, if user didn’t confirm installation due to confirmation not appearing, that means install session’s progress didn’t change!\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"decd\"\u003eval isSessionStuck = sessionInfo != null \u0026amp;\u0026amp; sessionInfo.progress \u0026lt; getProgressThresholdValue()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6b6d\"\u003eIf our app doesn’t have install permission, we can just cancel the session here.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cfe2\"\u003eif (!canInstallPackages) abortSession(\u0026#34;Install permission denied\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f6b5\"\u003eWe also need to distinguish whether install permission request took place or not, because confirmation doesn’t appear only if user went to permission settings. We can check whether the install permission status changed after returning. If it changed, that means this request actually took place. It doesn’t matter if permission was denied, because we handled it earlier.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8ed3\"\u003e// canInstallPackages is a field in our Activity\u003cbr/\u003eval previousCanInstallPackagesValue = canInstallPackages\u003cbr/\u003ecanInstallPackages = checkCanInstallPackages()\u003cbr/\u003eval isInstallPermissionStatusChanged = previousCanInstallPackagesValue != canInstallPackages\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"63a9\"\u003eAnd with this, we can finally relaunch confirmation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0913\"\u003eif (isSessionStuck \u0026amp;\u0026amp; isInstallPermissionStatusChanged) {\u003cbr/\u003e  launchInstallActivity()\u003cbr/\u003e  return\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6db1\"\u003eNice, now it works correctly in this case!\u003c/p\u003e\u003cp id=\"5d9f\"\u003eHowever, while investigating the issue, I actually opened a whole can of worms. It turns out Android’s confirmation window is \u003cstrong\u003emore bugged\u003c/strong\u003e than I thought!\u003c/p\u003e\u003ch2 id=\"7ade\"\u003eCursed dialog\u003c/h2\u003e\u003cp id=\"1b47\"\u003eIf we dismiss the confirmation via clicking \u003cstrong\u003eoutside a dialog\u003c/strong\u003e instead of clicking Cancel, install session becomes stuck, and \u003cem\u003eBroadcastReceiver\u003c/em\u003e doesn’t receive failure status!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eIf confirmation is dismissed via clicking on area highlighted with red, session’s going to stay stuck\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c974\"\u003eThis bug got fixed only on Android 14, so we have to work around it as well.\u003c/p\u003e\u003cp id=\"d715\"\u003eThis is quite easy. If the previous check didn’t succeed (which is when we got install permission and showed confirmation window), we check if the session was not stuck. If it progressed, we just finish our Activity:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4799\"\u003eval isSessionAlive = sessionInfo != null\u003cbr/\u003eif (isSessionAlive \u0026amp;\u0026amp; !isSessionStuck) {\u003cbr/\u003e  finish()\u003cbr/\u003e  return\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"82a7\"\u003eBut if it got stuck, it means that confirmation was dismissed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8d8f\"\u003e// Though confirmation Activity usually always returns RESULT_CANCELED\u003cbr/\u003e// value, on some Android versions resultCode is not equal to RESULT_CANCELED\u003cbr/\u003e// if Activity was finished normally via Cancel or Install buttons.\u003cbr/\u003eval isActivityCancelled = resultCode == RESULT_CANCELED\u003cbr/\u003eif (isSessionAlive \u0026amp;\u0026amp; isActivityCancelled) {\u003cbr/\u003e  abortSession()\u003cbr/\u003e  return\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2f81\"\u003eThere are two other issues related to this.\u003c/p\u003e\u003cp id=\"3624\"\u003eThe first one is the most interesting. Remember that on some devices confirmation didn’t appear after we grant permission? Our fix for that issue turns into a problem on devices where it \u003cstrong\u003edoes\u003c/strong\u003e appear, because in this case we will show confirmation \u003cstrong\u003etwice\u003c/strong\u003e!\u003cstrong\u003e \u003c/strong\u003e(Again, only if we dismiss the dialog by clicking outside of it).\u003c/p\u003e\u003cp id=\"56f6\"\u003eThat happens because our initial fix doesn’t check if \u003cstrong\u003ethere is no\u003c/strong\u003e confirmation Activity actually showing, but only if we \u003cstrong\u003epossibly\u003c/strong\u003e need to launch it. Improving our solution is a bit tricky, because we also have to account for process death, as on Android 11 changing install permission state always kills the process.\u003c/p\u003e\u003cp id=\"0fa0\"\u003eLet’s remember Activity’s lifecycle. \u003cem\u003eonStart()\u003c/em\u003e is called when Activity becomes visible, and \u003cem\u003eonResume()\u003c/em\u003e is called when Activity gets focus to interact with user. Now we’ll see some logs with this in mind.\u003c/p\u003e\u003cp id=\"03d4\"\u003eFirst, let’s look at lifecycle callbacks order in cases when confirmation Activity \u003cstrong\u003edoes\u003c/strong\u003e reappear after permission request.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"f21d\"\u003eAfter each lifecycle method call you can see a class name of Activity which was on top at that time.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4476\"\u003eFirst, our Activity is created, started and resumed.\u003c/li\u003e\u003cli id=\"45e8\"\u003eThen it goes to background (indicated by \u003cem\u003eonStop\u003c/em\u003e) as \u003cem\u003eManageAppExternalSourcesActivity\u003c/em\u003e comes to top. \u003cem\u003eManageAppExternalSourcesActivity\u003c/em\u003e is the install permission settings screen.\u003c/li\u003e\u003cli id=\"ab65\"\u003eOn Android 11, as I’ve already mentioned, process gets killed when install permission status changes, and when we go back, \u003cem\u003ePackageInstallerActivity\u003c/em\u003e is displayed first. \u003cem\u003ePackageInstallerActivity\u003c/em\u003e contains install confirmation dialog.\u003c/li\u003e\u003cli id=\"d97a\"\u003eWhile our Activity becomes visible, i.e., is started (because \u003cem\u003ePackageInstallerActivity\u003c/em\u003e has transparent background), we see that \u003cem\u003ePackageInstallerActivity\u003c/em\u003e is actually on top of activity stack and is visible above ours.\u003c/li\u003e\u003cli id=\"b308\"\u003eThen we get result in \u003cem\u003eonActivityResult()\u003c/em\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2eb9\"\u003eLet’s compare this with other logs.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"6866\"\u003eOn Android 10 we don’t observe process death, otherwise the order is roughly the same as it was on Android 11. When we go back from permission settings, our Activity becomes visible, and \u003cem\u003ePackageInstallerActivity\u003c/em\u003e is visible on top.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"7a57\"\u003eOn Android 9 and earlier versions, install confirmation is full-screen, not a dialog, so our Activity is not restarted until we confirm installation and go back. But we don’t need to check if our Activity is on top when started (it will always be anyway), because install session is going to be cancelled correctly via clicking Cancel button or going back. Therefore, our initial check (\u003cem\u003eisSessionStuck \u0026amp;\u0026amp; isInstallPermissionStatusChanged\u003c/em\u003e) is \u003cstrong\u003estill necessary\u003c/strong\u003e to avoid relaunching confirmation on correctly working Android versions.\u003c/p\u003e\u003cp id=\"163f\"\u003eNow let’s see logs when confirmation Activity \u003cstrong\u003edoesn’t\u003c/strong\u003e reappear.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cul\u003e\u003cli id=\"926e\"\u003eOur Activity launches confirmation, and then \u003cem\u003ePackageInstallerActivity\u003c/em\u003e redirects to install permission settings.\u003c/li\u003e\u003cli id=\"82ca\"\u003eAfter granting permission and returning, we get a result in \u003cem\u003eonActivityResult()\u003c/em\u003e, and our Activity gets started and resumed again.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6e72\"\u003eAs we can see, when our Activity becomes visible again, i.e., started, there are no other activities above it. It’s the same as on generic Android 9, but this time the check for stuck session succeeds. Compare this with earlier logs (Android 10+), where \u003cem\u003ePackageInstallerActivity\u003c/em\u003e is displayed on top at this moment.\u003c/p\u003e\u003cp id=\"8768\"\u003eSo, we can conclude that in order to determine whether confirmation Activity needs to be relaunched, we also need to remember if our Activity was on top when it was started. If it was, then we check whether session is stuck and permission status has changed, and only then we start confirmation again from \u003cem\u003eonActivityResult()\u003c/em\u003e. Otherwise, if there was another Activity in foreground, we just handle our stuff in \u003cem\u003eonActivityResult()\u003c/em\u003e and we’re done!\u003c/p\u003e\u003cp id=\"fcff\"\u003eIn code, it may look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8ea8\"\u003eprivate var wasOnTopOnStart = false\u003cp\u003eoverride fun onStart() {\u003cbr/\u003e  super.onStart()\u003cbr/\u003e  wasOnTopOnStart = isOnTop()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eoverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\u003cbr/\u003e  // ...\u003cbr/\u003e  if (isSessionStuck \u0026amp;\u0026amp; isInstallPermissionStatusChanged \u0026amp;\u0026amp; wasOnTopOnStart) {\u003cbr/\u003e    launchInstallActivity()\u003cbr/\u003e    return\u003cbr/\u003e  }\u003cbr/\u003e  // ...\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f5db\"\u003eNow it’s time to fix the last issue.\u003c/p\u003e\u003cp id=\"61a1\"\u003eSince Android 12, a confirmation window appears \u003cstrong\u003eimmediately\u003c/strong\u003e after granting install permission, not when returning from the settings screen.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid 11 on the left, Android 12 on the right\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c6b1\"\u003eOn Android 12–13 our workarounds won’t do, because if we dismiss the dialog by clicking outside of it, we don’t receive result in \u003cem\u003eonActivityResult()\u003c/em\u003e, so the checks will not even execute. Another bug.\u003c/p\u003e\u003cp id=\"b70e\"\u003eHere is a log of our Activity’s lifecycle on Android 12:\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"feda\"\u003eAs with the previous bug, we can circumvent it by determining whether our Activity is \u003cstrong\u003eon top\u003c/strong\u003e of activity stack when it’s started. It would mean there’s no confirmation Activity with the dialog above ours because it was already dismissed. Note that \u003cem\u003eonActivityResult()\u003c/em\u003e is always called \u003cstrong\u003ebefore\u003c/strong\u003e \u003cem\u003eonResume(). \u003c/em\u003eSo if our Activity was on top when started and if \u003cem\u003eonActivityResult()\u003c/em\u003e \u003cstrong\u003ewas not called\u003c/strong\u003e when we enter \u003cem\u003eonResume()\u003c/em\u003e, we cancel the session:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d211\"\u003eprivate var isOnActivityResultCalled = false\u003cbr/\u003e// We shouldn\u0026#39;t do anything if our Activity is freshly created.\u003cbr/\u003eprivate var isFirstResume = true\u003cp\u003eoverride fun onResume() {\u003cbr/\u003e  super.onResume()\u003cbr/\u003e  if (isFirstResume) {\u003cbr/\u003e    isFirstResume = false\u003cbr/\u003e    return\u003cbr/\u003e  }\u003cbr/\u003e  if (!isOnActivityResultCalled \u0026amp;\u0026amp; wasOnTopOnStart) {\u003cbr/\u003e    abortSession()\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eoverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\u003cbr/\u003e  isOnActivityResultCalled = true\u003cbr/\u003e  // ...\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9a84\"\u003eI omit code related to state saving and restoring which is needed to handle configuration changes and process restoration correctly, but the idea is there.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c085\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"24dc\"\u003eAs we saw, there may be a lot of frustrating peculiarities caused by incorrect Android behavior. I showed some examples of how you can work around non-trivial edge cases and ensure that your app handles all situations reliably.\u003c/p\u003e\u003cp id=\"1aaf\"\u003eIf you need this exact functionality in your app (installing APKs), you don’t have to implement it all yourself, because I already did it in my open-source library Ackpine! I’ll be happy if you give it a try and come with feedback! You can read \u003ca href=\"https://medium.com/@solrudev/painless-building-of-an-android-package-installer-app-d5a09b5df432\" rel=\"noopener\"\u003emy article\u003c/a\u003e about it, or visit a website with documentation:\u003c/p\u003e\u003cp id=\"35b8\"\u003eThanks for reading and enjoy your coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-11-07T19:01:17.033Z",
  "modifiedTime": null
}
