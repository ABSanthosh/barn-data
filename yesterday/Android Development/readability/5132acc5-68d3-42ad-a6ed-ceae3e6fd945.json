{
  "id": "5132acc5-68d3-42ad-a6ed-ceae3e6fd945",
  "title": "Stop hopping threads!",
  "link": "https://proandroiddev.com/stop-hopping-threads-6a6241016529?source=rss----c72404660798---4",
  "description": "",
  "author": "Joost Klitsie",
  "published": "Thu, 02 Jan 2025 15:35:08 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "threading",
    "android-app-development",
    "android",
    "androiddev",
    "kotlin-coroutines"
  ],
  "byline": "Joost Klitsie",
  "length": 11389,
  "excerpt": "Learn to love the Main thread by utilizing the official Coroutine conventions and best practices for Android developers.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Learn to love the Main thread by utilizing the official Coroutine conventions and best practices for Android developers.Android Rabbit not hopping! by Copilot.MisconceptionsThe story begins, as all stories, through the things that we see. It can be during an interview for an Android position at the company where I work, or seen in an article on proandroiddev.com. The following statements are the ones that stood out in the recent months:-We should run business logic off the main thread, in a background thread!-Oh that looks like it makes a backend call, we should really switch to the IO dispatcher-Using a LaunchedEffect is async, therefore it will not block the main threadOr a classic example of doing work in a ViewModel as part of some example:class MyViewModel( private val myRepository: MyRepository,): ViewModel() { fun doWork() { viewModelScope.launch { val myData = withContext(Dispatchers.IO) { myRepository.getMyData() } // Do something with myData } }}Kotlin to the rescue!As always, Kotlin has your back. It is the year 2025 and if you aren’t using Coroutines yet, I seriously advice you to drop everything and start implementing them. The quotes are basically misconceptions, created when modern technology meets old standards. In the past, we needed to be mindful of not blocking the main thread. But now there is Kotlin.Coroutine Main thread conventionsWhen we understand Android coroutine threading conventions, we will directly understand why 3 out of 4 of these examples are bad in regards to when to switch threads (don’t worry, the 4th one about LaunchedEffect is briefly mentioned down below). The title of this article may already give the biggest clue. The trick is: if a library offers an API with Coroutines, you should assume that the library will internally handle any required threading! That is right, the convention is, and I quote:“Suspend functions should be safe to call from the main thread”Here is the link to the Coroutine Best Practices on the official Android site. This convention is extremely important to know, as it is very different from how it was before. In the past, it was mandatory to be mindful about threading while you were waiting for resources. You were not allowed to place network calls and you were not allowed to access a database.The “good” old daysLet us have a look at the following old-school Retrofit code:interface GitHubService { @GET(\"users/{user}/repos\") fun listRepos(@Path(\"user\") user: String): Call\u003cList\u003cRepo\u003e\u003e}class GithubNetworkSource( private val gitHubService: GitHubService = getGithubService(),) { fun fetchUserRepos(user: String) = gitHubService.listRepos(user).execute().body() ?: emptyList()}As you can see: there is no suspending going on here, just a simple call to retrieve a list of repositories for a certain user on Retrofit. Let us call this code in our ViewModel:class MainViewModel( private val githubNetworkSource: GithubNetworkSource = GithubNetworkSource(),): ViewModel() { init { println(githubNetworkSource.fetchUserRepos(\"joost-klitsie\")) }}If we run this, we are supposed to see the following exception:android.os.NetworkOnMainThreadExceptionTo fix this, we can do two things: We either switch threads, which we could do by creating a suspend function instead of a regular function and then switch context to Dispatchers.IO, OR we could simply use the Coroutines API that Retrofit supports out of the box! And yes, we are going with the second option, as you can see in the updated version:interface GitHubService { @GET(\"users/{user}/repos\") suspend fun listRepos(@Path(\"user\") user: String): Response\u003cList\u003cRepo\u003e\u003e}You can see there is a suspend modifier added, and we changed the return type from Call\u003c\u003e to Response\u003c\u003e. This means, that we no longer have to execute the call ourselves, and we can directly deal with the response. I strongly urge you to take in mind that this is example code and it doesn’t catch any errors or do proper error handling, as this code is only meant to show how to tackle threading and Corouting Scopes. Obviously, now we need to launch a Coroutine to run this code. To avoid any confusion, we can have a look at the same guidelines page as earlier to decide how to do that:“The ViewModel should create coroutines”So knowing that, we will now add some boilerplate code and after that we can change our ViewModel to launch the actual work:class GithubNetworkSource( private val gitHubService: GitHubService = getGithubService(),) { suspend fun fetchUserRepos(user: String) = gitHubService.listRepos(user).body() ?: emptyList()}class GithubRepository( private val githubNetworkSource: GithubNetworkSource = GithubNetworkSource(),) { suspend fun fetchUserRepos(user: String) = githubNetworkSource.fetchUserRepos(user)}class FetchRepositoriesForUserUseCase( private val githubRepository: GithubRepository = GithubRepository(),) { suspend fun run(user: String) = githubRepository.fetchUserRepos(user)}class MainViewModel( private val fetchRepositoriesForUserUseCase: FetchRepositoriesForUserUseCase = FetchRepositoriesForUserUseCase(),): ViewModel() { init { viewModelScope.launch { println(fetchRepositoriesForUserUseCase.run(\"joost-klitsie\")) } }}And we should get the following response:[ Repo(id=322302851, name=compose-progress-button), Repo(id=834030119, name=DataLoadingExample), Repo(id=315288699, name=kotlin-styled-material-ui), Repo(id=206812053, name=ScopedObserver), Repo(id=857373384, name=Translatable)]You can see that we launched the Coroutine from the ViewModel. The ViewModel uses a Dispatchers.Main.immediate under the hood, so the code definitely runs on the Main thread. After that, the journey took us through a use case, a repository and finally a network source which invoked our Retrofit service. Nowhere did we need to switch from the Main thread, because we didn’t violate anything in Android’s StrictMode. Retrofit did all of the heavy lifting for us, yay! :)Good libraries follow Main-thread safe suspend functionsAny proper library does and should follow the Main thread safe suspend function requirements! Luckily, the most used libraries like Room and Retrofit do this. So if you are an author of any library that uses Coroutines, you should definitely implement your API in this way. Also, this can help you to create conventions in any other project you work on.So, when do we switch threads?Never say never, but you should know the following:It is perfectly fine to run the vast majority of your work on the Main threadI am not making the argument that modern phones are fast enough: I am making the argument you are probably not doing heavy lifting to begin with. I’d say that for 99% of your business needs, your code will run fine on the Main thread! Imagine a case where you have a feature with 10 requirements: most likely you have a bunch of if/else or when statements, and a bunch of suspending calls to a network or database resource. Remember how you answered the question “what are Coroutines” on that job interview? It probably was something similar to “Coroutines are like light-weight threads or something”. The beauty is that when they are suspending, they hardly take any resources (especially compared to Threads). So having a suspending point, or literally 100,000 of them, on the Main thread while waiting for data to load is an operation with little overhead.Switching threads is expensiveIf you think about your work as being some serious heavy lifting, then of course you should go ahead and run it on a Dispatchers.Default . But this should be a conscious decision, for when you actually do heavy work like image or video processing. In all my current projects combined (note the plural), I can count on 1 hand when I felt like I had to actually switch threads to do work:SharedPreferencesIf you still use ye olde SharedPreferences, instead of the DataStore, know that this can be a disk-read and therefore block the main thread. This is (sadly) allowed by default, and it is good to be mindful of it by for example creating a Coroutine-friendly preferences wrapper that switches internally to the IO dispatcher. The particular issue we faced was that we wished to use (the now deprecated!) EncryptedSharedPreferences, which does not have any fancy coroutines API like the DataStore.LoggingDid you know that logging also can block the thread? If you have are logging large backend responses, this could be an issue. A solution would be to accept the slowness in your debug builds, and remove logging from your production apps altogether! We opted for adjusting our logger to launch a Coroutine using the Dispatchers.IO on every log message, and we never had this lag bothering us again!Combining legacy code with CoroutinesObviously, when you combine legacy network calls with Coroutines and you couldn’t be bothered to migrate it properly, you will need to wrap your calls inside Dispatchers.IO.Actually expensive calculationsOn one project we have to check which markers are visible on a rotatable map. We get a map polygon and on every map movement, we calculate whether a markers Lat/Long is inside this visible polygon. As we have thousands of markers, and it runs often, we decided to off-load this task to another thread.WWGD?Google actually knows pretty well how to thread. Lets see what tools and libraries they offer and how threading is done:Android ComponentsApplications, Activities, Fragments, Services and BroadcastReceivers will by default run their work on the Main thread. For a BroadcastReceiver it is perhaps good to know that you can start asynchronous work on a different thread which is allowed to run a tad longer than the usual 5 seconds.Jetpack ViewModelA ViewModel expects asynchronous code to be started from the viewModelScope. This uses the Dispatchers.Main.immediate under the hood.LifecycleThe lifecycle helper CoroutineScopes like the ProcessLifecycelOwner.lifecycleScope, Activity.lifecycleScope, Fragment.lifecycleScope, Fragment.viewLifecycleOwner.lifecycleScope , Compose’s LocalLifecycleOwner.current.lifecycleScope and even the lifecycle of a LifecycleService will run the code on the Main thread.Jetpack ComposeAny code inside a LaunchedEffect orSideEffect runs on the Main thread. Any code launched using the rememberLifecycleScope also runs on the Main thread. It is good to know that these disptachers are more special and may only run at designated times during compositions.WorkManagerIf you run work using the WorkManager and you use a CoroutineWorker, your code will run inside the Dispatchers.Default. If you feel it is necessary, you can still change the context to a Dispatchers.IO if you want to make backend calls. You can see that WorkManager is optimised to run your work in the background.ConclusionStick to the main thread for the bulk of your work and only switch threads as part of a very conscious decision, and not as part of a default way of working. Forget the past and embrace Coroutine friendly APIs! Coroutines makes it easier than ever to run your code, await data and propagate results. I hope this article helps to shed some light on modern day Android developing and threading, and shows how it changed during the last years.If you like what you saw, put those digital hands together, and as always: let me know what you think in the comments! Joost out.",
  "image": "https://miro.medium.com/v2/resize:fill:1024:539/g:fp:0.5:0.29/1*5d0pgbjyox5sjZrZRuRQbQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@joostklitsie?source=post_page---byline--6a6241016529--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Joost Klitsie\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*7_baj1bWcyhiAYMp.\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--6a6241016529--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"2aad\"\u003eLearn to love the Main thread by utilizing the official Coroutine conventions and best practices for Android developers.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid Rabbit not hopping! by \u003ca href=\"https://copilot.microsoft.com/chats\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCopilot\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"7309\"\u003eMisconceptions\u003c/h2\u003e\u003cp id=\"1875\"\u003eThe story begins, as all stories, through the things that we see. It can be during an interview for an Android position at the company where I work, or seen in an article on \u003ca href=\"https://proandroiddev.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eproandroiddev.com\u003c/a\u003e. The following statements are the ones that stood out in the recent months:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d2e5\"\u003e-We should run business logic off the main thread, in a background thread!\u003c/p\u003e\u003cp id=\"2b04\"\u003e-Oh that looks like it makes a backend call, we should really switch to the IO dispatcher\u003c/p\u003e\u003cp id=\"0648\"\u003e-Using a LaunchedEffect is async, therefore it will not block the main thread\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"c37a\"\u003eOr a classic example of doing work in a ViewModel as part of some example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1235\"\u003eclass MyViewModel(\u003cbr/\u003e  private val myRepository: MyRepository,\u003cbr/\u003e): ViewModel() {\u003cp\u003e  fun doWork() {\u003cbr/\u003e    viewModelScope.launch {\u003cbr/\u003e      val myData = withContext(Dispatchers.IO) {\u003cbr/\u003e        myRepository.getMyData()\u003cbr/\u003e      }\u003cbr/\u003e      // Do something with myData\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8633\"\u003eKotlin to the rescue!\u003c/h2\u003e\u003cp id=\"7ad8\"\u003eAs always, Kotlin has your back. It is the year 2025 and if you aren’t using Coroutines yet, I seriously advice you to drop everything and start implementing them. The quotes are basically misconceptions, created when modern technology meets old standards. In the past, we needed to be mindful of not blocking the main thread. But now there is Kotlin.\u003c/p\u003e\u003ch2 id=\"9d11\"\u003eCoroutine Main thread conventions\u003c/h2\u003e\u003cp id=\"9b1d\"\u003eWhen we understand Android coroutine threading conventions, we will directly understand why 3 out of 4 of these examples are bad in regards to when to switch threads (don’t worry, the 4th one about LaunchedEffect is briefly mentioned down below). The title of this article may already give the biggest clue. The trick is: if a library offers an API with Coroutines, you should assume that the library will internally handle any required threading! That is right, the convention is, and I quote:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"f740\"\u003e“Suspend functions should be safe to call from the main thread”\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e0cd\"\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/coroutines-best-practices#main-safe\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHere\u003c/a\u003e is the link to the Coroutine Best Practices on the official Android site. This convention is extremely important to know, as it is very different from how it was before. In the past, it was mandatory to be mindful about threading while you were waiting for resources. You were not allowed to place network calls and you were not allowed to access a database.\u003c/p\u003e\u003ch2 id=\"fd9e\"\u003eThe “good” old days\u003c/h2\u003e\u003cp id=\"3174\"\u003eLet us have a look at the following old-school Retrofit code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5926\"\u003einterface GitHubService {\u003cp\u003e  @GET(\u0026#34;users/{user}/repos\u0026#34;)\u003cbr/\u003e  fun listRepos(@Path(\u0026#34;user\u0026#34;) user: String): Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eclass GithubNetworkSource(\u003cbr/\u003e  private val gitHubService: GitHubService = getGithubService(),\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e  fun fetchUserRepos(user: String) =\u003cbr/\u003e    gitHubService.listRepos(user).execute().body() ?: emptyList()\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"218c\"\u003eAs you can see: there is no suspending going on here, just a simple call to retrieve a list of repositories for a certain user on Retrofit. Let us call this code in our ViewModel:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9cae\"\u003eclass MainViewModel(\u003cbr/\u003e  private val githubNetworkSource: GithubNetworkSource = GithubNetworkSource(),\u003cbr/\u003e): ViewModel() {\u003cp\u003e  init {\u003cbr/\u003e    println(githubNetworkSource.fetchUserRepos(\u0026#34;joost-klitsie\u0026#34;))\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"51ac\"\u003eIf we run this, we are supposed to see the following exception:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"ec23\"\u003eandroid.os.NetworkOnMainThreadException\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"df09\"\u003eTo fix this, we can do two things: We either switch threads, which we could do by creating a suspend function instead of a regular function and then switch context to Dispatchers.IO, OR we could simply use the Coroutines API that Retrofit supports out of the box! And yes, we are going with the second option, as you can see in the updated version:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d38\"\u003einterface GitHubService {\u003cp\u003e  @GET(\u0026#34;users/{user}/repos\u0026#34;)\u003cbr/\u003e  suspend fun listRepos(@Path(\u0026#34;user\u0026#34;) user: String): Response\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt;\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ccc4\"\u003eYou can see there is a suspend modifier added, and we changed the return type from \u003ccode\u003eCall\u0026lt;\u0026gt;\u003c/code\u003e to \u003ccode\u003eResponse\u0026lt;\u0026gt;\u003c/code\u003e. This means, that we no longer have to execute the call ourselves, and we can directly deal with the response. I strongly urge you to take in mind that this is example code and it doesn’t catch any errors or do proper error handling, as this code is only meant to show how to tackle threading and Corouting Scopes. Obviously, now we need to launch a Coroutine to run this code. To avoid any confusion, we can have a look at the \u003ca href=\"https://developer.android.com/kotlin/coroutines/coroutines-best-practices#viewmodel-coroutines\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esame guidelines page\u003c/a\u003e as earlier to decide how to do that:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"b274\"\u003e“The ViewModel should create coroutines”\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8eae\"\u003eSo knowing that, we will now add some boilerplate code and after that we can change our ViewModel to launch the actual work:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a29\"\u003eclass GithubNetworkSource(\u003cbr/\u003e  private val gitHubService: GitHubService = getGithubService(),\u003cbr/\u003e) {\u003cp\u003e  suspend fun fetchUserRepos(user: String) =\u003cbr/\u003e    gitHubService.listRepos(user).body() ?: emptyList()\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eclass GithubRepository(\u003cbr/\u003e  private val githubNetworkSource: GithubNetworkSource = GithubNetworkSource(),\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e  suspend fun fetchUserRepos(user: String) =\u003cbr/\u003e    githubNetworkSource.fetchUserRepos(user)\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eclass FetchRepositoriesForUserUseCase(\u003cbr/\u003e  private val githubRepository: GithubRepository = GithubRepository(),\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e  suspend fun run(user: String) = githubRepository.fetchUserRepos(user)\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003cp\u003eclass MainViewModel(\u003cbr/\u003e  private val fetchRepositoriesForUserUseCase: FetchRepositoriesForUserUseCase = FetchRepositoriesForUserUseCase(),\u003cbr/\u003e): ViewModel() {\u003c/p\u003e\u003cp\u003e  init {\u003cbr/\u003e    viewModelScope.launch {\u003cbr/\u003e      println(fetchRepositoriesForUserUseCase.run(\u0026#34;joost-klitsie\u0026#34;))\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2eb5\"\u003eAnd we should get the following response:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5902\"\u003e[\u003cbr/\u003e  Repo(id=322302851, name=compose-progress-button), \u003cbr/\u003e  Repo(id=834030119, name=DataLoadingExample), \u003cbr/\u003e  Repo(id=315288699, name=kotlin-styled-material-ui), \u003cbr/\u003e  Repo(id=206812053, name=ScopedObserver), \u003cbr/\u003e  Repo(id=857373384, name=Translatable)\u003cbr/\u003e]\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cac1\"\u003eYou can see that we launched the Coroutine from the ViewModel. The ViewModel uses a \u003ccode\u003eDispatchers.Main.immediate\u003c/code\u003e under the hood, so the code definitely runs on the Main thread. After that, the journey took us through a use case, a repository and finally a network source which invoked our Retrofit service. Nowhere did we need to switch from the Main thread, because we didn’t violate anything in Android’s \u003ca href=\"https://developer.android.com/reference/android/os/StrictMode\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStrictMode\u003c/a\u003e. Retrofit did all of the heavy lifting for us, yay! :)\u003c/p\u003e\u003ch2 id=\"5737\"\u003eGood libraries follow Main-thread safe suspend functions\u003c/h2\u003e\u003cp id=\"1990\"\u003eAny proper library does and should follow the Main thread safe suspend function requirements! Luckily, the most used libraries like Room and Retrofit do this. So if you are an author of any library that uses Coroutines, you should definitely implement your API in this way. Also, this can help you to create conventions in any other project you work on.\u003c/p\u003e\u003ch2 id=\"6798\"\u003eSo, when do we switch threads?\u003c/h2\u003e\u003cp id=\"a8c9\"\u003eNever say never, but you should know the following:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"9f44\"\u003eIt is perfectly fine to run the vast majority of your work on the Main thread\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"5295\"\u003eI am not making the argument that modern phones are fast enough: I am making the argument you are probably not doing heavy lifting to begin with. I’d say that for 99% of your business needs, your code will run fine on the Main thread! Imagine a case where you have a feature with 10 requirements: most likely you have a bunch of \u003ccode\u003eif/else\u003c/code\u003e or \u003ccode\u003ewhen\u003c/code\u003e statements, and a bunch of suspending calls to a network or database resource. Remember how you answered the question “what are Coroutines” on that job interview? It probably was something similar to “Coroutines are like light-weight threads or something”. The beauty is that when they are suspending, they hardly take any resources (especially compared to Threads). So having a suspending point, or literally 100,000 of them, on the Main thread while waiting for data to load is an operation with little overhead.\u003c/p\u003e\u003ch2 id=\"2005\"\u003eSwitching threads is expensive\u003c/h2\u003e\u003cp id=\"c970\"\u003eIf you think about your work as being some serious heavy lifting, then of course you should go ahead and run it on a \u003ccode\u003eDispatchers.Default\u003c/code\u003e . But this should be a conscious decision, for when you actually do heavy work like image or video processing. In all my current projects combined (note the plural), I can count on 1 hand when I felt like I had to actually switch threads to do work:\u003c/p\u003e\u003ch2 id=\"ac4e\"\u003eSharedPreferences\u003c/h2\u003e\u003cp id=\"6a02\"\u003eIf you still use ye olde SharedPreferences, instead of the DataStore, know that this can be a disk-read and therefore block the main thread. This is (sadly) allowed by default, and it is good to be mindful of it by for example creating a Coroutine-friendly preferences wrapper that switches internally to the IO dispatcher. The particular issue we faced was that we wished to use (the now deprecated!) EncryptedSharedPreferences, which does not have any fancy coroutines API like the DataStore.\u003c/p\u003e\u003ch2 id=\"990c\"\u003eLogging\u003c/h2\u003e\u003cp id=\"4458\"\u003eDid you know that logging also can block the thread? If you have are logging large backend responses, this could be an issue. A solution would be to accept the slowness in your debug builds, and remove logging from your production apps altogether! We opted for adjusting our logger to launch a Coroutine using the Dispatchers.IO on every log message, and we never had this lag bothering us again!\u003c/p\u003e\u003ch2 id=\"2e17\"\u003eCombining legacy code with Coroutines\u003c/h2\u003e\u003cp id=\"ff3d\"\u003eObviously, when you combine legacy network calls with Coroutines and you couldn’t be bothered to migrate it properly, you will need to wrap your calls inside Dispatchers.IO.\u003c/p\u003e\u003ch2 id=\"2c89\"\u003eActually expensive calculations\u003c/h2\u003e\u003cp id=\"63f8\"\u003eOn one project we have to check which markers are visible on a rotatable map. We get a map polygon and on every map movement, we calculate whether a markers Lat/Long is inside this visible polygon. As we have thousands of markers, and it runs often, we decided to off-load this task to another thread.\u003c/p\u003e\u003ch2 id=\"e40d\"\u003eWWGD?\u003c/h2\u003e\u003cp id=\"2390\"\u003eGoogle actually knows pretty well how to thread. Lets see what tools and libraries they offer and how threading is done:\u003c/p\u003e\u003ch2 id=\"4e4b\"\u003eAndroid Components\u003c/h2\u003e\u003cp id=\"dc1b\"\u003e\u003ccode\u003eApplications\u003c/code\u003e, \u003ccode\u003eActivities\u003c/code\u003e, \u003ccode\u003eFragments\u003c/code\u003e, \u003ccode\u003eServices\u003c/code\u003e and \u003ccode\u003eBroadcastReceivers\u003c/code\u003e will by default run their work on the Main thread. For a \u003ccode\u003eBroadcastReceiver\u003c/code\u003e it is perhaps good to know that you can start asynchronous work on a different thread which is allowed to run a tad longer than the usual 5 seconds.\u003c/p\u003e\u003ch2 id=\"37bc\"\u003eJetpack ViewModel\u003c/h2\u003e\u003cp id=\"f880\"\u003eA \u003ccode\u003eViewModel\u003c/code\u003e expects asynchronous code to be started from the \u003ccode\u003eviewModelScope\u003c/code\u003e. This uses the \u003ccode\u003eDispatchers.Main.immediate\u003c/code\u003e under the hood.\u003c/p\u003e\u003ch2 id=\"e7d3\"\u003eLifecycle\u003c/h2\u003e\u003cp id=\"b0dd\"\u003eThe lifecycle helper CoroutineScopes like the \u003ccode\u003eProcessLifecycelOwner.lifecycleScope\u003c/code\u003e, \u003ccode\u003eActivity.lifecycleScope\u003c/code\u003e, \u003ccode\u003eFragment.lifecycleScope\u003c/code\u003e, \u003ccode\u003eFragment.viewLifecycleOwner.lifecycleScope\u003c/code\u003e , Compose’s \u003ccode\u003eLocalLifecycleOwner.current.lifecycleScope\u003c/code\u003e and even the lifecycle of a \u003ccode\u003eLifecycleService\u003c/code\u003e will run the code on the Main thread.\u003c/p\u003e\u003ch2 id=\"75ec\"\u003eJetpack Compose\u003c/h2\u003e\u003cp id=\"9988\"\u003eAny code inside a \u003ccode\u003eLaunchedEffect\u003c/code\u003e or\u003ccode\u003eSideEffect\u003c/code\u003e runs on the Main thread. Any code launched using the \u003ccode\u003erememberLifecycleScope\u003c/code\u003e also runs on the Main thread. It is good to know that these disptachers are more special and may only run at designated times during compositions.\u003c/p\u003e\u003ch2 id=\"a7f6\"\u003e\u003ccode\u003eWorkManager\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"6e8d\"\u003eIf you run work using the \u003ccode\u003eWorkManager\u003c/code\u003e and you use a \u003ccode\u003eCoroutineWorker\u003c/code\u003e, your code will run inside the \u003ccode\u003eDispatchers.Default\u003c/code\u003e. If you feel it is necessary, you can still change the context to a \u003ccode\u003eDispatchers.IO\u003c/code\u003e if you want to make backend calls. You can see that \u003ccode\u003eWorkManager\u003c/code\u003e is optimised to run your work in the background.\u003c/p\u003e\u003ch2 id=\"bfe8\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"24ca\"\u003eStick to the main thread for the bulk of your work and only switch threads as part of a very conscious decision, and not as part of a default way of working. Forget the past and embrace Coroutine friendly APIs! Coroutines makes it easier than ever to run your code, await data and propagate results. I hope this article helps to shed some light on modern day Android developing and threading, and shows how it changed during the last years.\u003c/p\u003e\u003cp id=\"86f3\"\u003eIf you like what you saw, put those digital hands together, and as always: let me know what you think in the comments! Joost out.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-01-02T15:35:07.889Z",
  "modifiedTime": null
}
