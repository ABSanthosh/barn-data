{
  "id": "49489a2c-a18d-4f40-a176-09116c9a749a",
  "title": "Koin: My Favorite Dependency Injection Library for Android",
  "link": "https://proandroiddev.com/koin-my-favorite-dependency-injection-library-for-android-776db4d455c8?source=rss----c72404660798---4",
  "description": "",
  "author": "Stefano Natali",
  "published": "Sun, 27 Oct 2024 19:12:01 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "koin",
    "android",
    "androiddev",
    "android-app-development",
    "kotlin"
  ],
  "byline": "Stefano Natali",
  "length": 10935,
  "excerpt": "In Android development, Hilt is often the go-to library for dependency injection due to its official support from Google and deep integration with Android libraries. However, I prefer Koin for its…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Easy to set up, Lightweight and Kotlin-centricIn Android development, Hilt is often the go-to library for dependency injection due to its official support from Google and deep integration with Android libraries. However, I prefer Koin for its simplicity, fast adoption and Kotlin-first approach. In my experience, Koin’s lightweight design makes it easier to set up and maintain, while providing a powerful DI solution that doesn’t compromise on flexibility. Let’s explore why Koin is my favorite DI library and how you can use it effectively in your Android projects.Why Koin?There are a number of reasons why I love Koin. First, it’s easy to use. Koin has a simple and intuitive API that makes it easy to get started with dependency injection. Second, Koin is lightweight. It won’t add a lot of overhead to your application. Third, Koin is powerful. It provides a powerful set of features that can help you manage dependencies in complex applications. Finally, Koin offers direct integrations with Jetpack Compose.Getting Started with KoinGetting started with Koin is easy. You can add the Koin library to your project using the version catalog and the gradle file.//libs.versions.toml[versions]koin = \"4.0.0\"...[libraries]koin-android = { module = \"io.insert-koin:koin-android\", version.ref = \"koin\" }koin-androidx-compose = { module = \"io.insert-koin:koin-androidx-compose\", version.ref = \"koin\" }...//build.gradle.kts implementation(libs.koin.androidx.compose)implementation(libs.koin.android)...Once you’ve added the libraries, you can start defining your dependencies. Koin uses modules to define dependencies. A module is a collection of dependencies that can be used together. Here’s an example:val myModules = module { single { MyHttpClient().getClient() } factory { BookService(get()) as IBookService } factoryOf(::BookDownloader) single { BookDatabase.getInstance(get()) } factoryOf(::DatabaseRepository) factoryOf(::BookRepository) singleOf(::PrefsDataStore) viewModelOf(::NavigationViewModel) viewModelOf(::HomeViewModel) viewModelOf(::LibraryViewModel) viewModelOf(::ZoomBookViewModel) viewModelOf(::ReaderEpubViewModel) viewModelOf(::LanguagesSelectorViewModel) viewModelOf(::TopicViewModel) viewModelOf(::SettingsViewModel)}Within a module, you can declare various types of components:Single: Provides a single instance of a dependency throughout the application’s lifecycle.Factory: Creates a new instance of a dependency each time it’s requested.ViewModel: Specifically designed for Android ViewModel instances, ensuring proper lifecycle management.With the standard component definition you can also use the extensions functions (singleOf, factoryOf and viewModelOf ) to provide a more concise syntax for creating instances.Initializing Koin ApplicationOnce you’ve defined your modules, it’s time to integrate Koin with your application.class MyApplication : Application() { override fun onCreate() { super.onCreate() startKoin { androidLogger() androidContext(applicationContext) modules(myModules) } }}In your AndroidManifest.xml file, update the application tag to reference your custom application class:\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003capplication android:name=\".MyApplication\"...By following these steps, you’ve successfully initialized Koin and made it ready to manage your application’s dependencies.Injecting DependenciesKoin makes it straightforward to inject dependencies into your classes. By defining your modules and components, you can directly access them within your classes.Here’s an example of a HomeViewModel using dependencies provided by Koin:class HomeViewModel( private val bookRepository: BookRepository, prefsDataStore: PrefsDataStore, private val gutenbergRepository: GutenbergRepository,) : ViewModel() { // ViewModel logic here}For a Jetpack Compose environment, the setup is slightly different. In your Activity, it’s helpful to wrap all Compose code inside a KoinAndroidContext to define the Koin Context and then use the dependencies:class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyBooksTheme { KoinAndroidContext { val navigationViewModel = koinViewModel\u003cNavigationViewModel\u003e() // Additional UI code here } } } }}In your Composable functions, you can then easily inject your ViewModels with Koin:@Composablefun HomeInitScreen( navigationViewModel: NavigationViewModel = koinViewModel(viewModelStoreOwner = LocalContext.current as ComponentActivity), homeViewModel: HomeViewModel = koinViewModel(),) { // UI code here}In this example:NavigationViewModel will follow the lifecycle of the Activity, making it suitable for app-wide navigation.HomeViewModel will be scoped to the HomeInitScreen Composable function, fitting the more transient lifecycle of UI elements in Compose.This setup allows for precise lifecycle management with minimal boilerplate, making Koin an excellent choice for Compose-based projects.Testing with KoinKoin’s structure makes it highly testable and ideal for achieving high code coverage. Dependencies can be easily mocked or replaced, and you can even define custom Koin modules specifically for testing purposes.Kotlin class MyTest: KoinTest { @Before fun setup() { startkoin ( modules (testModule)) } @After fun tearDown() { stopKoin() } }This flexibility allows you to isolate and test individual components effectively.To ensure that your Koin modules are configured correctly, you can use the verify extension provided by Koin’s testing utilities:class MyModulesTest: KoinTest { @OptIn(KoinExperimentalAPI::class) @Test fun testMyModules() { myModules.verify( extraTypes = listOf( Application::class, Context::class, ) ) }}This test verifies the correctness of the myModules definition, ensuring that all dependencies are defined and can be resolved.By following these guidelines, you can effectively test your Koin-based applications, improving code quality and reducing potential issues.Koin Annotations: A Hilt-like ApproachIf you prefer Hilt’s annotation-based approach, Koin recently introduced annotations, allowing you to mark dependencies with simple annotations for a more declarative setup. This style lets you define dependencies similarly to Hilt.One key difference is that Koin traditionally resolves dependencies at runtime. This means that if a dependency is missing, the error only appears when the dependency is requested. With the new annotation-based approach, Koin now offers compile-time checking for dependencies, which catches these issues during the build process. This extra validation is especially valuable for large apps with complex dependency trees, adding a layer of robustness and reliability to your project.To update the implementation we already defined to Koin annotations, follow these steps:Include the Kotlin Symbol Processing (KSP) plugin://libs.versions.toml[versions]ksp = \"2.0.20-1.0.25\"koinAnnotations = \"2.0.0-Beta1\"...[plugins]googleDevtoolsKsp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }...//app build.gradle.ktsplugins { alias(libs.plugins.googleDevtoolsKsp) ...Include the extra Koin dependencies for annotations, and the KSP compiler://libs.versions.toml[versions]koinAnnotations = \"2.0.0-Beta1\"...[libraries]koin-annotations = { module = \"io.insert-koin:koin-annotations\", version.ref = \"koinAnnotations\" }koin-ksp-compiler = { module = \"io.insert-koin:koin-ksp-compiler\", version.ref = \"koinAnnotations\" }...//app build.gradle.ktsdependencies { ksp(libs.koin.ksp.compiler) implementation(libs.koin.annotations) ...Enable compile-time safety checks in your build.gradle.kts:ksp { arg(\"KOIN_CONFIG_CHECK\", \"true\")}With this configuration in place, you can remove your modules definition:import org.koin.ksp.generated.*class MyApplication : Application() { override fun onCreate() { super.onCreate() startKoin { androidLogger() androidContext(applicationContext) modules(defaultModule) } }}and start migrating your dependencies by using Koin’s annotations: @Single, @Factory, and @KoinViewModel. Simply add the relevant annotation on top of each class to define its lifecycle and scope.For example:@Singleclass PrefsDataStore(private val context: Context) { //logic here}@Factoryclass BookRepository( private val bookService: IBookService, private val prefsDataStore: PrefsDataStore) { //logic here}@KoinViewModelclass HomeViewModel( private val bookRepository: BookRepository, prefsDataStore: PrefsDataStore, private val gutenbergRepository: GutenbergRepository,) : ViewModel() { // ViewModel logic here}Once you’ve annotated your dependencies, Koin will verify them at compile time. If any dependencies are missing or misconfigured, you’ll receive an error during the build process, allowing you to catch issues early. This compile-time validation makes your app more robust, especially as it scales and new dependencies are added.Migrating from Hilt to KoinIf you’re convinced about Koin’s benefits and want to migrate your Hilt project, a helpful guide can be found here: https://blog.kotzilla.io/migrate-from-hilt-to-koinThis guide walks you through the process of translating Hilt annotations to their Koin counterparts.ConclusionNow you know why Koin is my favorite Dependency Injection library for Android. I really like its simplicity, flexibility, and Kotlin-centric approach. Its easy setup and clear lifecycle management make it ideal for both small and large applications.With Koin, you have the flexibility to define dependencies in a straightforward syntax, while also benefiting from recent advancements like annotation support and compile-time checks. These features allow you to ensure dependency correctness during the build process, enhancing the reliability of your app as it grows in complexity.Whether you’re building a new project or considering a DI solution for an existing one, Koin’s simplicity and power make it an excellent choice. By following the guidelines in this article, you can take advantage of Koin’s capabilities to create a clean, maintainable, and testable codebase for your Android apps.If you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I publish new articles almost every week. Don’t hesitate to share your comments or reach out to me on LinkedIn for further discussions.Have a great day!",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*vhOf2s2bGrVMycE24fzFPg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"2cdc\"\u003eEasy to set up, Lightweight and Kotlin-centric\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@stefanoq21?source=post_page-----776db4d455c8--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Stefano Natali\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*nJT9nmRwE28kmJAEiRyHMw.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----776db4d455c8--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"87de\"\u003eIn Android development, \u003cstrong\u003eHilt\u003c/strong\u003e is often the go-to library for dependency injection due to its official support from Google and deep integration with Android libraries. However, I prefer \u003cstrong\u003eKoin\u003c/strong\u003e for its simplicity, fast adoption and Kotlin-first approach. In my experience, Koin’s lightweight design makes it easier to set up and maintain, while providing a powerful DI solution that doesn’t compromise on flexibility. Let’s explore why Koin is my favorite DI library and how you can use it effectively in your Android projects.\u003c/p\u003e\u003ch2 id=\"9714\"\u003eWhy Koin?\u003c/h2\u003e\u003cp id=\"c7b3\"\u003eThere are a number of reasons why I love Koin. First, it’s easy to use. Koin has a simple and intuitive API that makes it easy to get started with dependency injection. Second, Koin is lightweight. It won’t add a lot of overhead to your application. Third, Koin is powerful. It provides a powerful set of features that can help you manage dependencies in complex applications. Finally, Koin offers direct integrations with \u003cstrong\u003eJetpack Compose.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"7f8e\"\u003e\u003cstrong\u003eGetting Started with Koin\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"5b34\"\u003eGetting started with Koin is easy. You can add the Koin library to your project using the version catalog and the gradle file.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a3ea\"\u003e//libs.versions.toml\u003cbr/\u003e[versions]\u003cbr/\u003ekoin = \u0026#34;4.0.0\u0026#34;\u003cbr/\u003e...\u003cbr/\u003e[libraries]\u003cbr/\u003ekoin-android = { module = \u0026#34;io.insert-koin:koin-android\u0026#34;, version.ref = \u0026#34;koin\u0026#34; }\u003cbr/\u003ekoin-androidx-compose = { module = \u0026#34;io.insert-koin:koin-androidx-compose\u0026#34;, version.ref = \u0026#34;koin\u0026#34; }\u003cbr/\u003e...\u003cp\u003e//build.gradle.kts    \u003cbr/\u003eimplementation(libs.koin.androidx.compose)\u003cbr/\u003eimplementation(libs.koin.android)\u003cbr/\u003e...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c7cc\"\u003eOnce you’ve added the libraries, you can start defining your dependencies. Koin uses modules to define dependencies. A module is a collection of dependencies that can be used together. Here’s an example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2953\"\u003eval myModules = module {\u003cbr/\u003e    single { MyHttpClient().getClient() }\u003cbr/\u003e    factory { BookService(get()) as IBookService }\u003cbr/\u003e    factoryOf(::BookDownloader)\u003cbr/\u003e    single { BookDatabase.getInstance(get()) }\u003cbr/\u003e    factoryOf(::DatabaseRepository)\u003cbr/\u003e    factoryOf(::BookRepository)\u003cbr/\u003e    singleOf(::PrefsDataStore)\u003cp\u003e    viewModelOf(::NavigationViewModel)\u003cbr/\u003e    viewModelOf(::HomeViewModel)\u003cbr/\u003e    viewModelOf(::LibraryViewModel)\u003cbr/\u003e    viewModelOf(::ZoomBookViewModel)\u003cbr/\u003e    viewModelOf(::ReaderEpubViewModel)\u003cbr/\u003e    viewModelOf(::LanguagesSelectorViewModel)\u003cbr/\u003e    viewModelOf(::TopicViewModel)\u003cbr/\u003e    viewModelOf(::SettingsViewModel)\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"37fa\"\u003eWithin a module, you can declare various types of components:\u003c/p\u003e\u003cul\u003e\u003cli id=\"38dc\"\u003e\u003cstrong\u003eSingle:\u003c/strong\u003e Provides a single instance of a dependency throughout the application’s lifecycle.\u003c/li\u003e\u003cli id=\"8e5a\"\u003e\u003cstrong\u003eFactory:\u003c/strong\u003e Creates a new instance of a dependency each time it’s requested.\u003c/li\u003e\u003cli id=\"dee4\"\u003e\u003cstrong\u003eViewModel: \u003c/strong\u003eSpecifically designed for Android ViewModel instances, ensuring proper lifecycle management.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9731\"\u003eWith the standard component definition you can also use the extensions functions (\u003cstrong\u003esingleOf, factoryOf and viewModelOf \u003c/strong\u003e) to provide a more concise syntax for creating instances.\u003c/p\u003e\u003ch2 id=\"7e50\"\u003eInitializing Koin Application\u003c/h2\u003e\u003cp id=\"a9f5\"\u003eOnce you’ve defined your modules, it’s time to integrate Koin with your application.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6b4f\"\u003eclass MyApplication : Application() {\u003cbr/\u003e    override fun onCreate() {\u003cbr/\u003e        super.onCreate()\u003cp\u003e        startKoin {\u003cbr/\u003e            androidLogger()\u003cbr/\u003e            androidContext(applicationContext)\u003cbr/\u003e            modules(myModules)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d12\"\u003eIn your \u003cstrong\u003eAndroidManifest.xml\u003c/strong\u003e file, update the \u003cstrong\u003eapplication \u003c/strong\u003etag to reference your custom application class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b2ed\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt;\u003cp\u003e    \u0026lt;application\u003cbr/\u003e        android:name=\u0026#34;.MyApplication\u0026#34;\u003cbr/\u003e...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4ee9\"\u003eBy following these steps, you’ve successfully initialized Koin and made it ready to manage your application’s dependencies.\u003c/p\u003e\u003ch2 id=\"7ea0\"\u003eInjecting Dependencies\u003c/h2\u003e\u003cp id=\"aff3\"\u003eKoin makes it straightforward to inject dependencies into your classes. By defining your modules and components, you can directly access them within your classes.\u003c/p\u003e\u003cp id=\"fd66\"\u003eHere’s an example of a \u003cstrong\u003eHomeViewModel\u003c/strong\u003e using dependencies provided by Koin:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4e3d\"\u003eclass HomeViewModel(\u003cbr/\u003e    private val bookRepository: BookRepository,\u003cbr/\u003e    prefsDataStore: PrefsDataStore,\u003cbr/\u003e    private val gutenbergRepository: GutenbergRepository,\u003cbr/\u003e) : ViewModel() {\u003cbr/\u003e    // ViewModel logic here\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b289\"\u003eFor a \u003cstrong\u003eJetpack Compose\u003c/strong\u003e environment, the setup is slightly different. In your \u003cstrong\u003eActivity\u003c/strong\u003e, it’s helpful to wrap all Compose code inside a \u003cstrong\u003eKoinAndroidContext \u003c/strong\u003eto define the Koin Context and then use the dependencies:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"69a1\"\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContent {\u003cbr/\u003e            MyBooksTheme {\u003cbr/\u003e                KoinAndroidContext {\u003cbr/\u003e                    val navigationViewModel = koinViewModel\u0026lt;NavigationViewModel\u0026gt;()\u003cbr/\u003e                    // Additional UI code here\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"167f\"\u003eIn your Composable functions, you can then easily inject your ViewModels with Koin:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4f71\"\u003e@Composable\u003cbr/\u003efun HomeInitScreen(\u003cbr/\u003e    navigationViewModel: NavigationViewModel = koinViewModel(viewModelStoreOwner = LocalContext.current as ComponentActivity),\u003cbr/\u003e    homeViewModel: HomeViewModel = koinViewModel(),\u003cbr/\u003e) {\u003cbr/\u003e    // UI code here\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a849\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0286\"\u003e\u003cstrong\u003eNavigationViewModel\u003c/strong\u003e will follow the lifecycle of the \u003cstrong\u003eActivity\u003c/strong\u003e, making it suitable for app-wide navigation.\u003c/li\u003e\u003cli id=\"b1e5\"\u003e\u003cstrong\u003eHomeViewModel \u003c/strong\u003ewill be scoped to the \u003cstrong\u003eHomeInitScreen\u003c/strong\u003e Composable function, fitting the more transient lifecycle of UI elements in Compose.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fc81\"\u003eThis setup allows for precise lifecycle management with minimal boilerplate, making Koin an excellent choice for \u003cstrong\u003eCompose-based projects\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"79f0\"\u003eTesting with Koin\u003c/h2\u003e\u003cp id=\"0b80\"\u003eKoin’s structure makes it highly testable and ideal for achieving high code coverage. Dependencies can be easily \u003cstrong\u003emocked or replaced\u003c/strong\u003e, and you can even define custom Koin modules specifically for testing purposes.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b1e9\"\u003eKotlin class MyTest: KoinTest { \u003cbr/\u003e  @Before \u003cbr/\u003e  fun setup() { \u003cbr/\u003e    startkoin ( modules (testModule)) \u003cbr/\u003e  } \u003cp\u003e  @After \u003cbr/\u003e  fun tearDown() { \u003cbr/\u003e    stopKoin() \u003cbr/\u003e  } \u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"83a6\"\u003eThis flexibility allows you to isolate and test individual components effectively.\u003c/p\u003e\u003cp id=\"93f5\"\u003eTo ensure that your Koin modules are configured correctly, you can use the \u003cstrong\u003everify \u003c/strong\u003eextension provided by Koin’s testing utilities:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c756\"\u003eclass MyModulesTest: KoinTest {\u003cp\u003e    @OptIn(KoinExperimentalAPI::class)\u003cbr/\u003e    @Test\u003cbr/\u003e    fun testMyModules() {\u003cbr/\u003e        myModules.verify(\u003cbr/\u003e            extraTypes = listOf(\u003cbr/\u003e                Application::class,\u003cbr/\u003e                Context::class,\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"da75\"\u003eThis test verifies the correctness of the \u003cstrong\u003emyModules \u003c/strong\u003edefinition, ensuring that all dependencies are defined and can be resolved.\u003c/p\u003e\u003cp id=\"1d62\"\u003eBy following these guidelines, you can effectively test your Koin-based applications, improving code quality and reducing potential issues.\u003c/p\u003e\u003ch2 id=\"c232\"\u003eKoin Annotations: A Hilt-like Approach\u003c/h2\u003e\u003cp id=\"51c8\"\u003eIf you prefer Hilt’s annotation-based approach, Koin recently introduced annotations, allowing you to mark dependencies with simple annotations for a more declarative setup. This style lets you define dependencies similarly to Hilt.\u003c/p\u003e\u003cp id=\"0b20\"\u003eOne key difference is that Koin traditionally resolves dependencies at runtime. This means that if a dependency is missing, the error only appears when the dependency is requested. With the new annotation-based approach, Koin now offers \u003cstrong\u003ecompile-time checking\u003c/strong\u003e for dependencies, which catches these issues during the build process. This extra validation is especially valuable for large apps with complex dependency trees, adding a layer of robustness and reliability to your project.\u003c/p\u003e\u003cp id=\"6da5\"\u003eTo update the implementation we already defined to Koin annotations, follow these steps:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0d44\"\u003eInclude the Kotlin Symbol Processing (KSP) plugin:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"a58d\"\u003e//libs.versions.toml\u003cbr/\u003e[versions]\u003cbr/\u003eksp = \u0026#34;2.0.20-1.0.25\u0026#34;\u003cbr/\u003ekoinAnnotations = \u0026#34;2.0.0-Beta1\u0026#34;\u003cbr/\u003e...\u003cbr/\u003e[plugins]\u003cbr/\u003egoogleDevtoolsKsp = { id = \u0026#34;com.google.devtools.ksp\u0026#34;, version.ref = \u0026#34;ksp\u0026#34; }\u003cbr/\u003e...\u003cp\u003e//app build.gradle.kts\u003cbr/\u003eplugins {\u003cbr/\u003e    alias(libs.plugins.googleDevtoolsKsp)\u003cbr/\u003e  ...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"77b4\"\u003eInclude the extra Koin dependencies for annotations, and the KSP compiler:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"6ef5\"\u003e//libs.versions.toml\u003cbr/\u003e[versions]\u003cbr/\u003ekoinAnnotations = \u0026#34;2.0.0-Beta1\u0026#34;\u003cbr/\u003e...\u003cbr/\u003e[libraries]\u003cbr/\u003ekoin-annotations = { module = \u0026#34;io.insert-koin:koin-annotations\u0026#34;, version.ref = \u0026#34;koinAnnotations\u0026#34; }\u003cbr/\u003ekoin-ksp-compiler = { module = \u0026#34;io.insert-koin:koin-ksp-compiler\u0026#34;, version.ref = \u0026#34;koinAnnotations\u0026#34; }\u003cbr/\u003e...\u003cp\u003e//app build.gradle.kts\u003cbr/\u003edependencies {\u003cbr/\u003e    ksp(libs.koin.ksp.compiler)\u003cbr/\u003e    implementation(libs.koin.annotations)\u003cbr/\u003e  ...\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"ea15\"\u003eEnable compile-time safety checks in your \u003cstrong\u003ebuild.gradle.kts\u003c/strong\u003e:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"67b0\"\u003eksp {\u003cbr/\u003e    arg(\u0026#34;KOIN_CONFIG_CHECK\u0026#34;, \u0026#34;true\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2c38\"\u003eWith this configuration in place, you can remove your modules definition:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2b04\"\u003eimport org.koin.ksp.generated.*\u003cp\u003eclass MyApplication : Application() {\u003cbr/\u003e    override fun onCreate() {\u003cbr/\u003e        super.onCreate()\u003c/p\u003e\u003cp\u003e        startKoin {\u003cbr/\u003e            androidLogger()\u003cbr/\u003e            androidContext(applicationContext)\u003cbr/\u003e            modules(defaultModule)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f74a\"\u003eand start migrating your dependencies by using Koin’s annotations: \u003cstrong\u003e@Single\u003c/strong\u003e, \u003cstrong\u003e@Factory\u003c/strong\u003e, and \u003cstrong\u003e@KoinViewModel\u003c/strong\u003e. Simply add the relevant annotation on top of each class to define its lifecycle and scope.\u003c/p\u003e\u003cp id=\"174c\"\u003eFor example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fb01\"\u003e\u003cbr/\u003e@Single\u003cbr/\u003eclass PrefsDataStore(private val context: Context) {\u003cbr/\u003e    //logic here\u003cbr/\u003e}\u003cbr/\u003e@Factory\u003cbr/\u003eclass BookRepository(\u003cbr/\u003e    private val bookService: IBookService, private val prefsDataStore: PrefsDataStore\u003cbr/\u003e) {\u003cbr/\u003e    //logic here\u003cbr/\u003e}\u003cp\u003e@KoinViewModel\u003cbr/\u003eclass HomeViewModel(\u003cbr/\u003e    private val bookRepository: BookRepository,\u003cbr/\u003e    prefsDataStore: PrefsDataStore,\u003cbr/\u003e    private val gutenbergRepository: GutenbergRepository,\u003cbr/\u003e) : ViewModel() {\u003cbr/\u003e    // ViewModel logic here\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4e74\"\u003eOnce you’ve annotated your dependencies, Koin will verify them at compile time. If any dependencies are missing or misconfigured, you’ll receive an error during the build process, allowing you to catch issues early. This \u003cstrong\u003ecompile-time validation\u003c/strong\u003e makes your app more robust, especially as it scales and new dependencies are added.\u003c/p\u003e\u003ch2 id=\"dc42\"\u003eMigrating from Hilt to Koin\u003c/h2\u003e\u003cp id=\"8e84\"\u003eIf you’re convinced about Koin’s benefits and want to migrate your Hilt project, a helpful guide can be found here: \u003cbr/\u003e\u003ca href=\"https://blog.kotzilla.io/migrate-from-hilt-to-koin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003ehttps://blog.kotzilla.io/migrate-from-hilt-to-koin\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"5dcf\"\u003eThis guide walks you through the process of translating Hilt annotations to their Koin counterparts.\u003c/p\u003e\u003ch2 id=\"f6ac\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"9ba8\"\u003eNow you know why \u003cstrong\u003eKoin \u003c/strong\u003eis my favorite \u003cstrong\u003eDependency Injection library for Android\u003c/strong\u003e. I really like its simplicity, flexibility, and Kotlin-centric approach. Its easy setup and clear lifecycle management make it ideal for both small and large applications.\u003c/p\u003e\u003cp id=\"eb23\"\u003eWith Koin, you have the flexibility to define dependencies in a straightforward syntax, while also benefiting from recent advancements like annotation support and compile-time checks. These features allow you to ensure dependency correctness during the build process, enhancing the reliability of your app as it grows in complexity.\u003c/p\u003e\u003cp id=\"55e4\"\u003eWhether you’re building a new project or considering a DI solution for an existing one, Koin’s simplicity and power make it an excellent choice. By following the guidelines in this article, you can take advantage of Koin’s capabilities to create a clean, maintainable, and testable codebase for your Android apps.\u003c/p\u003e\u003cp id=\"bdd8\"\u003eIf you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I publish new articles almost every week. Don’t hesitate to share your comments or reach out to me on \u003ca href=\"http://www.linkedin.com/in/stefano-natali-q21\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003efor further discussions.\u003c/p\u003e\u003cp id=\"bd06\"\u003eHave a great day!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-10-27T14:25:20.363Z",
  "modifiedTime": null
}
