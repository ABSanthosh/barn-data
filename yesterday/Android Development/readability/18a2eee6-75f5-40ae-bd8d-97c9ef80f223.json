{
  "id": "18a2eee6-75f5-40ae-bd8d-97c9ef80f223",
  "title": "How easy is drag-and-drop in Compose?",
  "link": "https://proandroiddev.com/how-easy-is-drag-and-drop-in-compose-e66d47ae8e5f?source=rss----c72404660798---4",
  "description": "",
  "author": "Mustafa Khaled",
  "published": "Sat, 07 Dec 2024 00:01:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "jetpack-compose",
    "drag-and-drop"
  ],
  "byline": "Mustafa Khaled",
  "length": 27956,
  "excerpt": "In Android, whenever you have a drag-and-drop feature, we usually expect that it will be a complex task. To be honest, I agree. However, the drag-and-drop feature is now easier in Compose. To make it…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In Android, whenever you have a drag-and-drop feature, we usually expect that it will be a complex task. To be honest, I agree. However, the drag-and-drop feature is now easier in Compose.To make it clear and easy to understand, we will build a Scrum/Kanban board that contains tickets. These tickets should be dragged and dropped into different columns.In this example, the user can:create a ticket which should be placed on the TODO column by defaultUsing a bottom sheet, the user can add the ticket description, ticket estimation, and tagsWhen the ticket moves to the Done column, a delete option becomes available, allowing the user to remove it from the board.The user can move the ticket from any column to another.For technical understanding, we are going to have 3 different parts to this article. We are going to talk about each in detail.Build the Jetpack Compose UIEnable drag feature for TicketCardEnable the Drop feature for the ColumnDrag and Drop logic in details(ViewModel)UI Customization for Drag and DropClarify the drag-drop processBuild the Jetpack Compose UIStarting with the Board UI, as per the screenshot below, we have 3 titled equal columns, where each column can accept a list of tickets.With the help of the floating button on the bottom right, we can add a new ticket to the board. these new tickets should be added by default to the TODO column(we will discuss it in the Add/Delete ticket section).When the ticket moves to the Done column, a delete IconButton is available to delete the ticket, otherwise we would have an infinite number of tickets in the Done column.Adding and deleting option opens a BottomSheet, where its content depends on the feature(we will discuss it in the Add/Delete ticket section).Overview of the Board UI@Composablefun DragAndDropCompose( modifier: Modifier, uiState: UiState, onNewTicketSubmitted: (BoardTicket) -\u003e Unit, onDeleteConfirmed: (BoardTicket) -\u003e Unit, onTicketDropped: (BoardTicket, Column) -\u003e Unit) { var showAddTicketDialog by remember { mutableStateOf(false) }// A Box contains 3 equal weight DragAndDropBox() separated by a VerticalDivider() Box(modifier = modifier.fillMaxSize()) { Row( modifier = Modifier .fillMaxSize() .padding(8.dp) ) { DragAndDropBox( modifier = Modifier.weight(1f), list = uiState.list.listOne, column = Column.TODO, onTicketDropped = onTicketDropped, ) VerticalDivider() DragAndDropBox( modifier = Modifier.weight(1f), list = uiState.list.listTwo, column = Column.IN_PROGRESS, onTicketDropped = onTicketDropped, ) VerticalDivider() DragAndDropBox( modifier = Modifier .weight(1f), list = uiState.list.listThree, column = Column.DONE, onTicketDropped = onTicketDropped, onDeleteConfirmed = onDeleteConfirmed ) } FloatingActionButton( modifier = Modifier .padding(8.dp) .align(Alignment.BottomEnd), onClick = { showAddTicketDialog = true } ) { Icon(Icons.Filled.Add, contentDescription = null) } } InputDialog( showDialog = showAddTicketDialog, estimationsList = uiState.list.estimations, tagsList = uiState.list.tags, onNewTicketSubmitted = { onNewTicketSubmitted(it) }, onDismiss = { showAddTicketDialog = false } )}DragAndDropCompose() is the parent content of the composable function. it contains the following:A modifier to customize the UIA uiState holds the state of the UI, it contains the data that should be displayed.onNewTicketSubmitted: (BoardTicket) -\u003e Unit is a callback when a new ticket is added to the board. it accepts BoardTicket as a param. BoardTicket is a data class that contains information about each ticket on the board, which we will discuss later.onDeleteConfirmed: (BoardTicket) -\u003e Unit is a callback when a ticket deleted from the boardonTicketDropped(BoardTicket, Column) -\u003e Unit is a callback when a ticket is dropped to a column. It accepts BoardTicket and Column parameters. Where Column is a data class that describes which column is affected.Another essential component is DragAndDropBox()DragAndDropBox() accepts 4 required and 1 optional params.Using state hoisting, we are passing all callbacks to the parent composable function DragAndDropCompose(). DragAndDropBox() contains a list param, where it contains a list of List\u003cBoardTicket\u003e.Enable drag feature for TicketCardAs you may expect, enabling the drag feature should be applied to the ticket. Inside DragAndDropBox() we have a title on the top and a list of tickets on each column.LazyColumn contains a sticky header that holds the column name. items(list) contains a list of BoardTicket List\u003cBoardTicket\u003e which is a data class that describes the ticket.From each BoardTicket, we have TicketCard, which is a composable function that draws the ticket on each column.LazyColumn( modifier = Modifier .fillMaxSize() ) { stickyHeader { Text( text = column.name, modifier = Modifier .fillMaxWidth() .graphicsLayer { scaleX = scale scaleY = scale transformOrigin = TransformOrigin.Center }, textAlign = TextAlign.Center, fontWeight = titleStyle.value, ) } items(list) { boardTicket -\u003e if (list.isNotEmpty()) { TicketCard( ticket = boardTicket, onDeleteConfirmed = onDeleteConfirmed, ) } } }To enable the drag feature for TicketCard() we need to add a modifier extension function dragAndDropSource. we can enable the drag by enabling a long-press using onLongPress()The main concept behind the drag and drop is to transfer data from the drag part to the target drop part. startTransfer() is a method that accepts DragAndDropTransferData that accepts ClipData.ClipData could have 5 different types, PlainText, HtmlText, Intent, Uri, and RawUri.Since we want the whole object to be transferred from one column to another, we will ClipData.newIntent type with the help of the Gson library. The newIntent() accepts 2 arguments, a label which is a String that usually describes the data to be transferred, and usually, it’s needed for accessibility. the second argument, is the Intent(), where it contains the data.Modifier.dragAndDropSource(block = { detectTapGestures( onLongPress = { startTransfer( DragAndDropTransferData( clipData = ClipData.newIntent(\"ticket\", Intent().apply { putExtra(ARG_TICKET, gson.toJson(ticket)) }) ) ) } })Enable the Drop feature for the ColumnAfter successfully adding the Drag feature, by filling an Intent with the data, now it’s time to receive/accept that data when the drop happened.The core part behind receiving the data is a DragAndDropTarget. It’s an interface where it contains some methodsfun onDrop(event: DragAndDropEvent): Booleanfun onStarted(event: DragAndDropEvent) = Unitfun onEntered(event: DragAndDropEvent) = Unitfun onMoved(event: DragAndDropEvent) = Unitfun onExited(event: DragAndDropEvent) = Unitfun onChanged(event: DragAndDropEvent) = Unitfun onEnded(event: DragAndDropEvent) = UnitWe would focus on three of these methods, onDrop(), onEntered(), onExited(), onEnded().onDrop() is called whenever the item dragged has been dropped on the target.onEntered() is called whenever the dragged item has entered the target boundsonExited() is called whenever the dragged item has exited the bounds where the item was placed.Inside DragAndBox() function, we added the implementation of the DragAndroidDropTarget interface.@Composablefun DragAndDropBox( modifier: Modifier, list: List\u003cBoardTicket\u003e, column: Column, onTicketDropped: (BoardTicket, Column) -\u003e Unit, onDeleteConfirmed: (BoardTicket) -\u003e Unit = {},) { ...... ...... val dragAndDropTarget = remember { object : DragAndDropTarget { override fun onDrop(event: DragAndDropEvent): Boolean { val data = event.toAndroidDragEvent().clipData.getItemAt(0).intent val ticket = gson.fromJson(data.getStringExtra(ARG_TICKET), BoardTicket::class.java) onTicketDropped( ticket, column ) return true } override fun onEntered(event: DragAndDropEvent) { super.onEntered(event) ..... ..... } override fun onExited(event: DragAndDropEvent) { super.onExited(event) ..... ..... } } } Box( modifier = modifier .fillMaxWidth() .padding(8.dp) .background(color = backgroundColor) .dragAndDropTarget( shouldStartDragAndDrop = { event -\u003e event .mimeTypes() .contains(ClipDescription.MIMETYPE_TEXT_INTENT) }, target = dragAndDropTarget ) ) { ..... ..... }Let’s break down onDrop() implementation, to receive the clipData sent, we use toAndroidDragEvent() extension function that returns DragEvent where we can extract all the clipData sent. Since we have a single clipData we would use getItemAt(0).intent.val data = event.toAndroidDragEvent().clipData.getItemAt(0).intentAfter that we would retrieve the intent, we would need the extra sent which contains a serialized JSONval ticket = gson.fromJson(data.getStringExtra(ARG_TICKET), BoardTicket::class.java)After implementing the interface, we would use another Modifier extension function to make the DragAndDropBox() composable function configured for drag and drop using Modifier.dragAndDropTarget().Let’s break it down, dragAndDropTarget has 2 arguments. First, shouldStartDragAndDrop where it describes the type of the event, in this case, we need to make sure that the dragAndDropTarget accepts Intent. Second, the target is the interface implementation we did earlier.Box( modifier = modifier .fillMaxWidth() .padding(8.dp) .background(color = backgroundColor) .dragAndDropTarget( shouldStartDragAndDrop = { event -\u003e event .mimeTypes() .contains(ClipDescription.MIMETYPE_TEXT_INTENT) }, target = dragAndDropTarget )) {..........}Drag and Drop logic in details(ViewModel)After the discussion about enabling the drag and drop feature for the Composable functions, we need to make it clear how can we handle the business logic to make sure the board acts as a Kanban/Agile board.We have a viewModel that contains 3 StateFlow for the 3 lists that match 3 columns we have todos, inProgress, and done list. These 3 lists are wrapped in a uiState.class MainViewModel : ViewModel() { private val todos = MutableStateFlow\u003cList\u003cBoardTicket\u003e\u003e(emptyList()) private val inProgress = MutableStateFlow\u003cList\u003cBoardTicket\u003e\u003e(emptyList()) private val done = MutableStateFlow\u003cList\u003cBoardTicket\u003e\u003e(emptyList()) private val _uiState = MutableStateFlow\u003cUiState\u003e( UiState.Success( SuccessState( todos.value, inProgress.value, done.value ) ) ) val uiState = _uiState.asStateFlow()..........}There are 3 actions on the board, Add, Delete, and Move. Each action has a method inside the ViewModel. we used State Hoisting when the ticket, was added, deleted, or moved.// Main Composable function@Composablefun DragAndDropCompose( modifier: Modifier, uiState: UiState, onNewTicketSubmitted: (BoardTicket) -\u003e Unit, onDeleteConfirmed: (BoardTicket) -\u003e Unit, onTicketDropped: (BoardTicket, Column) -\u003e Unit) {..........}// Activityclass MainActivity : ComponentActivity() { private val viewModel: MainViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { DDBoardTheme { val uiState = viewModel.uiState.collectAsState(MainViewModel.UiState.Loading) Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -\u003e DragAndDropCompose( modifier = Modifier.padding(paddingValues = innerPadding), uiState = uiState.value, onTicketDropped = { boardTicket, type -\u003e viewModel.move(boardTicket = boardTicket, to = type) }, onNewTicketSubmitted = { viewModel.add(it) }, onDeleteConfirmed = { viewModel.delete(it) } ) } } } }}As you can see, we are passing the callbacks using state hoisting from the Composable function the Activity to call the proper method on the ViewModel. For example, if we are looking for adding a new ticket, onNewTicketSubmitted = { viewModel.add(it) } should be invoked.We have a data class that contains the business logic of each ticket.data class BoardTicket( val text: String, val estimation: String? = null, val tag: String? = null, val column: Column)The data class contains text that corresponds to the title of the ticket, an estimation that corresponds to the estimation of the ticket, a tag that categorizes the ticket, and a column which is an enum that describes the column typeenum class Column(val columnName: String) { TODO(\"TODO\"), IN_PROGRESS(\"In Progress\"), DONE(\"Done\")}Let’s break down the add method. when we add a ticket onNewTicketSubmitted: (BoardTicket) -\u003e Unit callback passed to the MainActivity where we call { viewModel.add(it) }.Since when we add a ticket it by default is added to the TODO column, that makes it a very straightforward method. We used += operator to add the ticket to the todos List.fun add(boardTicket: BoardTicket) { todos.value += BoardTicket(text = boardTicket.text, estimation = boardTicket.estimation, tag = boardTicket.tag, column = Column.TODO) updateUiState()}Let’s break down the delete method. when we delete a ticket. we enable ticket deletion only on the done column. that makes it straightforward as well. using -= operator, we delete the ticket from the done List.fun delete(boardTicket: BoardTicket) { done.value -= boardTicket updateUiState()}Let’s break down the move method. As we mentioned earlier, any ticket can move from any column to another without restrictions, that is why the signature of the move method contains a BoardTicket instance and a target column. The move method is also straightforward, we want to know what is the source and destination columns. Because we would delete the ticket from the source list and add it to the destination list. For example, if we move a ticket from inProgress column to the done column, we will remove it from the inProgress list and it to the done List.fun move(boardTicket: BoardTicket, target: Column) { when (boardTicket.column) { Column.DONE -\u003e done.value -= boardTicket Column.IN_PROGRESS -\u003e inProgress.value -= boardTicket Column.TODO -\u003e todos.value -= boardTicket } when (target) { Column.DONE -\u003e done.value += boardTicket.copy(column = target) Column.IN_PROGRESS -\u003e inProgress.value += boardTicket.copy(column = target) Column.TODO -\u003e todos.value += boardTicket.copy(column = target) } updateUiState() }Note: we have a method updateUiState() that updates the _uiState to update the UI state and reflect the updates happen.private fun updateUiState() { _uiState.value = UiState.Success(SuccessState(todos.value, inProgress.value, done.value))}UI Customization for Drag and DropWe need to polish the UI to make look great. we are going to polish the following:TicketCard UI CustomizationColumn UI CustomizationBottomSheet for ticket addition and deletionTicketCard UI Customizationsas per the screen below, we have made some UI customization on the TicketCard, the background color and add a delete icon to any ticket on the Done column.For the background, it’s straightforward, we decide the containerColor of the card using a when statement with column type.@Composablefun TicketCard( ticket: BoardTicket, onDeleteConfirmed: (BoardTicket) -\u003e Unit) { val showDeleteTicketDialog = remember { mutableStateOf(false) } Card( ..... ..... shape = CardDefaults.outlinedShape, colors = CardDefaults.cardColors( containerColor = when (ticket.column) { Column.IN_PROGRESS -\u003e MaterialTheme.colorScheme.onSecondary Column.DONE -\u003e MaterialTheme.colorScheme.onTertiary Column.TODO -\u003e MaterialTheme.colorScheme.onPrimary } ) ) { ..... .....}For the delete icon on the Done TicketCard columns, we also check the type of the ticket, if it’s done we add a delete icon on the top right.@Composablefun TicketCard( ticket: BoardTicket, onDeleteConfirmed: (BoardTicket) -\u003e Unit) { ..... ..... Column( modifier = Modifier .padding(8.dp) .fillMaxWidth() ) { Row { Text( text = ticket.text, modifier = Modifier.weight(1f), fontWeight = FontWeight.Bold ) if (ticket.column == Column.DONE) { Icon( Icons.Filled.Delete, contentDescription = null, modifier = Modifier .clickable { showDeleteTicketDialog.value = true }) } } ..... .....}Column UI CustomizationWe will do some customization for the Column, in the title and the background of the column. Our mission is to make the title scale increase when a ticket enters the column and returns to its original scale when the ticket leaves the columnAlso, to change the background color of the column whenever a ticket moves in/out of a specific columnsTo achieve that we would need onEntered() and onExited() callbacks.For the title scale, we use animateFloatAsState() that switches between font-weight and scale based on a titleStyle mutableState.For the background, we use a backgroundColor mutableState to switch between 2 colors.in the onEntered(), onExited() callback, we will change the color and also change the FontWeight, also change the column background.@Composablefun DragAndDropBox( modifier: Modifier, list: List\u003cBoardTicket\u003e, column: Column, onTicketDropped: (BoardTicket, Column) -\u003e Unit, onDeleteConfirmed: (BoardTicket) -\u003e Unit = {},) { var backgroundColor by remember { mutableStateOf(Color(0xffE5E4E2)) } val titleStyle = remember { mutableStateOf(FontWeight.Normal) } val scale by animateFloatAsState( if (titleStyle.value == FontWeight.Bold) 1.4f else 1f, label = \"scale\" ) val dragAndDropTarget = remember { object : DragAndDropTarget { override fun onDrop(event: DragAndDropEvent): Boolean { ..... ..... } override fun onEntered(event: DragAndDropEvent) { super.onEntered(event) backgroundColor = Color(0xffD3D3D3) titleStyle.value = FontWeight.Bold } override fun onExited(event: DragAndDropEvent) { super.onExited(event) backgroundColor = Color(0xffE5E4E2) titleStyle.value = FontWeight.Normal } } } ..... .....}BottomSheet for ticket addition and deletionWe will use the bottom sheet twice, for the addition and deletion of a ticket.For deletion, it’s straightforward, it’s just a bottom sheet with a message and 2 buttons, one responsible for propagating the onDelete() to the MainActivity by state hoisting to perform the viewModel.delete() method. The second is just to hide the bottom sheet.For adding a ticket, it’s a detailed bottom sheet, that contains a TextField with a maximum of 100 characters.the second and third is a single selection component, where the user can select a tag and an estimation for the ticket and two buttons for adding a ticket by propagating onNewTicketsubmitted() to call viewModel.add() by state hoisting. We are using a FlowRow to achieve the single selection.private fun SingleSelectionSection( title: String, list: List\u003cString\u003e, selectedIndex: Int, badgeType: BadgeType, onItemSelected: (Int) -\u003e Unit = {}, hasError: Boolean = false) { Row(verticalAlignment = Alignment.CenterVertically) { Text(text = title, modifier = Modifier.padding(end = 8.dp)) FlowRow(horizontalArrangement = Arrangement.spacedBy(4.dp)) { list.forEachIndexed { index, text -\u003e CardContainer( text = text, isSelected = selectedIndex == index, badgeType = badgeType, onClick = { onItemSelected(index) }, hasError = hasError ) } } }}we have also multiple mutableStateFlow to remember the selection of the tags, estimation, and color of the single selection component, because we have a validation on the single selection and TextField, if the user click on save button without filling all required fields.You may notice that the mutableStateFlow that saves the value of the chosen value takes sheetState.isVisible as a param, for example, the reason behind that is to reset the state each time we open the bottom sheet. so old value disappears.var text by remember(sheetState.isVisible) { mutableStateOf(\"\") }@Composablefun InputDialog( showDialog: Boolean, estimationsList: List\u003cString\u003e, tagsList: List\u003cString\u003e, onNewTicketSubmitted: (BoardTicket) -\u003e Unit, onDismiss: () -\u003e Unit) { val colorScheme = MaterialTheme.colorScheme val sheetState = rememberModalBottomSheetState() val scope = rememberCoroutineScope() var text by remember(sheetState.isVisible) { mutableStateOf(\"\") } val selectedEstimationIndex = remember(sheetState.isVisible) { mutableIntStateOf(-1) } val textError = remember(sheetState.isVisible) { mutableStateOf(false) } val selectedTagIndex = remember(sheetState.isVisible) { mutableIntStateOf(-1) } var supportTextColor by remember { mutableStateOf(colorScheme.onSurface) } var estimationError by remember(sheetState.isVisible) { mutableStateOf(false) } var tagError by remember(sheetState.isVisible) { mutableStateOf(false) } if (showDialog) { ModalBottomSheet( onDismissRequest = { onDismiss() }, sheetState = sheetState ) { Column(modifier = Modifier.padding(horizontal = 24.dp, vertical = 8.dp)) { Text(text = \"Add a new Ticket\", fontWeight = FontWeight.Bold) Spacer(modifier = Modifier.height(8.dp)) TextField( value = text, placeholder = { Text(text = \"Write your ticket title/details\") }, onValueChange = { text = it supportTextColor = if (text.length \u003e 100) { Color.Red } else { colorScheme.onSurface } if (textError.value \u0026\u0026 it.isNotEmpty()) { textError.value = false } }, modifier = Modifier.fillMaxWidth(), supportingText = { Text( text = \"${text.length} / 100\", textAlign = TextAlign.End, modifier = Modifier.fillMaxWidth(), color = supportTextColor ) }, colors = TextFieldDefaults.colors( focusedIndicatorColor = Color.Transparent, unfocusedIndicatorColor = Color.Transparent ), isError = textError.value ) Spacer(modifier = Modifier.height(8.dp)) SingleSelectionSection( title = \"Estimation\", list = estimationsList, badgeType = BadgeType.ESTIMATION, selectedIndex = selectedEstimationIndex.intValue, onItemSelected = { selectedEstimationIndex.intValue = it estimationError = false }, hasError = estimationError ) Spacer(modifier = Modifier.height(8.dp)) SingleSelectionSection( title = \"Tags\", list = tagsList, badgeType = BadgeType.TAG, selectedIndex = selectedTagIndex.intValue, onItemSelected = { selectedTagIndex.intValue = it tagError = false }, hasError = tagError ) Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { val hasError = text.isEmpty() || selectedTagIndex.intValue == -1 || selectedEstimationIndex.intValue == -1 if (hasError) { textError.value = text.isEmpty() estimationError = selectedEstimationIndex.intValue == -1 tagError = selectedTagIndex.intValue == -1 return@Button } scope.launch { sheetState.hide() }.invokeOnCompletion { if (!sheetState.isVisible) { onDismiss() } } onNewTicketSubmitted( BoardTicket( text = text, estimation = estimationsList[selectedEstimationIndex.intValue], tag = tagsList[selectedTagIndex.intValue], column = Column.TODO ) ) }, modifier = Modifier.fillMaxWidth()) { Text(text = \"Create\") } Spacer(modifier = Modifier.height(8.dp)) } } }}So, that’s it. with a real-life example, we were able to:Understand how drag-and-drop API works in composeAdapt some UI customization to make it similar to the Agile/Kanban boardhandle the business logic using ViewModel.You can find the full repository on GitHub.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*yf2X-s5vw-dscMoc6Ox_iw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@mustafa_khaled?source=post_page---byline--e66d47ae8e5f--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Mustafa Khaled\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*jDrb0xGDTtNp2uqw7uT1MQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e66d47ae8e5f--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"99ea\"\u003eIn Android, whenever you have a drag-and-drop feature, we usually expect that it will be a complex task. To be honest, I agree. However, the drag-and-drop feature is now easier in Compose.\u003c/p\u003e\u003cp id=\"20d4\"\u003eTo make it clear and easy to understand, we will build a Scrum/Kanban board that contains tickets. These tickets should be dragged and dropped into different columns.\u003c/p\u003e\u003cp id=\"9ae3\"\u003eIn this example, the user can:\u003c/p\u003e\u003col\u003e\u003cli id=\"d632\"\u003ecreate a ticket which should be placed on the TODO column by default\u003c/li\u003e\u003cli id=\"342b\"\u003eUsing a bottom sheet, the user can add the ticket description, ticket estimation, and tags\u003c/li\u003e\u003cli id=\"43a2\"\u003eWhen the ticket moves to the Done column, a delete option becomes available, allowing the user to remove it from the board.\u003c/li\u003e\u003cli id=\"38c0\"\u003eThe user can move the ticket from any column to another.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b3a3\"\u003eFor technical understanding, we are going to have 3 different parts to this article. We are going to talk about each in detail.\u003c/p\u003e\u003cul\u003e\u003cli id=\"46c3\"\u003e\u003cstrong\u003eBuild the Jetpack Compose UI\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"d006\"\u003e\u003cstrong\u003eEnable drag feature for TicketCard\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"79f3\"\u003e\u003cstrong\u003eEnable the Drop feature for the Column\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"8f85\"\u003e\u003cstrong\u003eDrag and Drop logic in details(ViewModel)\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"d77d\"\u003e\u003cstrong\u003eUI Customization for Drag and Drop\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"f2ae\"\u003e\u003cstrong\u003eClarify the drag-drop process\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6800\"\u003eBuild the Jetpack Compose UI\u003c/h2\u003e\u003cp id=\"5404\"\u003eStarting with the Board UI, as per the screenshot below, we have 3 titled equal columns, where each column can accept a list of tickets.\u003c/p\u003e\u003cp id=\"ca30\"\u003eWith the help of the floating button on the bottom right, we can add a new ticket to the board. these new tickets should be added by default to the TODO column(we will discuss it in the \u003cstrong\u003eAdd/Delete ticket\u003c/strong\u003e section).\u003c/p\u003e\u003cp id=\"8820\"\u003eWhen the ticket moves to the Done column, a delete IconButton is available to delete the ticket, otherwise we would have an infinite number of tickets in the Done column.\u003c/p\u003e\u003cp id=\"ddc3\"\u003eAdding and deleting option opens a BottomSheet, where its content depends on the feature(we will discuss it in the \u003cstrong\u003eAdd/Delete ticket\u003c/strong\u003e section).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eOverview of the Board UI\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"6902\"\u003e@Composable\u003cbr/\u003efun DragAndDropCompose(\u003cbr/\u003e        modifier: Modifier,\u003cbr/\u003e        uiState: UiState,\u003cbr/\u003e        onNewTicketSubmitted: (BoardTicket) -\u0026gt; Unit,\u003cbr/\u003e        onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit,\u003cbr/\u003e        onTicketDropped: (BoardTicket, Column) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    var showAddTicketDialog by remember { mutableStateOf(false) }\u003cbr/\u003e// A Box contains 3 equal weight DragAndDropBox() separated by a VerticalDivider()\u003cbr/\u003e    Box(modifier = modifier.fillMaxSize()) {\u003cbr/\u003e        Row(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                        .fillMaxSize()\u003cbr/\u003e                        .padding(8.dp)\u003cp\u003e        ) {\u003cbr/\u003e            DragAndDropBox(\u003cbr/\u003e                    modifier = Modifier.weight(1f),\u003cbr/\u003e                    list = uiState.list.listOne,\u003cbr/\u003e                    column = Column.TODO,\u003cbr/\u003e                    onTicketDropped = onTicketDropped,\u003cbr/\u003e            )\u003cbr/\u003e            VerticalDivider()\u003cbr/\u003e            DragAndDropBox(\u003cbr/\u003e                    modifier = Modifier.weight(1f),\u003cbr/\u003e                    list = uiState.list.listTwo,\u003cbr/\u003e                    column = Column.IN_PROGRESS,\u003cbr/\u003e                    onTicketDropped = onTicketDropped,\u003cbr/\u003e            )\u003cbr/\u003e            VerticalDivider()\u003cbr/\u003e            DragAndDropBox(\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                            .weight(1f),\u003cbr/\u003e                    list = uiState.list.listThree,\u003cbr/\u003e                    column = Column.DONE,\u003cbr/\u003e                    onTicketDropped = onTicketDropped,\u003cbr/\u003e                    onDeleteConfirmed = onDeleteConfirmed\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        FloatingActionButton(\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                        .padding(8.dp)\u003cbr/\u003e                        .align(Alignment.BottomEnd),\u003cbr/\u003e                onClick = {\u003cbr/\u003e                    showAddTicketDialog = true\u003cbr/\u003e                }\u003cbr/\u003e        ) {\u003cbr/\u003e            Icon(Icons.Filled.Add, contentDescription = null)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    InputDialog(\u003cbr/\u003e            showDialog = showAddTicketDialog,\u003cbr/\u003e            estimationsList = uiState.list.estimations,\u003cbr/\u003e            tagsList = uiState.list.tags,\u003cbr/\u003e            onNewTicketSubmitted = {\u003cbr/\u003e                onNewTicketSubmitted(it)\u003cbr/\u003e            },\u003cbr/\u003e            onDismiss = { showAddTicketDialog = false }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"981a\"\u003eDragAndDropCompose() is the parent content of the composable function. it contains the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"203e\"\u003eA \u003cstrong\u003e\u003cem\u003emodifier\u003c/em\u003e\u003c/strong\u003e to customize the UI\u003c/li\u003e\u003cli id=\"3d69\"\u003eA \u003cstrong\u003e\u003cem\u003euiState\u003c/em\u003e\u003c/strong\u003e holds the state of the UI, it contains the data that should be displayed.\u003c/li\u003e\u003cli id=\"2c96\"\u003e\u003cstrong\u003e\u003cem\u003eonNewTicketSubmitted: (BoardTicket) -\u0026gt;\u003c/em\u003e\u003c/strong\u003e Unit is a callback when a new ticket is added to the board. it accepts BoardTicket as a param. BoardTicket is a data class that contains information about each ticket on the board, which we will discuss later.\u003c/li\u003e\u003cli id=\"7d97\"\u003e\u003cstrong\u003e\u003cem\u003eonDeleteConfirmed: (BoardTicket) -\u0026gt; Unit\u003c/em\u003e\u003c/strong\u003e is a callback when a ticket deleted from the board\u003c/li\u003e\u003cli id=\"16e8\"\u003e\u003cstrong\u003e\u003cem\u003eonTicketDropped(BoardTicket, Column) -\u0026gt; Unit \u003c/em\u003e\u003c/strong\u003eis a callback when a ticket is dropped to a column. It accepts BoardTicket and Column parameters. Where Column is a data class that describes which column is affected.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4729\"\u003eAnother essential component is \u003cstrong\u003e\u003cem\u003eDragAndDropBox()\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"1e23\"\u003eDragAndDropBox() accepts 4 required and 1 optional params.\u003c/p\u003e\u003cp id=\"9d37\"\u003eUsing state hoisting, we are passing all callbacks to the parent composable function DragAndDropCompose(). DragAndDropBox() contains a list param, where it contains a list of List\u0026lt;BoardTicket\u0026gt;.\u003c/p\u003e\u003ch2 id=\"acaf\"\u003e\u003cstrong\u003eEnable drag feature for TicketCard\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"be08\"\u003eAs you may expect, enabling the drag feature should be applied to the ticket. Inside \u003cstrong\u003e\u003cem\u003eDragAndDropBox() \u003c/em\u003e\u003c/strong\u003ewe have a title on the top and a list of tickets on each column.\u003c/p\u003e\u003cp id=\"1fb4\"\u003e\u003cstrong\u003e\u003cem\u003eLazyColumn\u003c/em\u003e\u003c/strong\u003e contains a sticky header that holds the column name. \u003cstrong\u003e\u003cem\u003eitems(list)\u003c/em\u003e\u003c/strong\u003e contains a list of \u003cstrong\u003e\u003cem\u003eBoardTicket\u003c/em\u003e\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003eList\u0026lt;BoardTicket\u0026gt;\u003c/em\u003e\u003c/strong\u003e which is a data class that describes the ticket.\u003c/p\u003e\u003cp id=\"1f48\"\u003eFrom each \u003cstrong\u003e\u003cem\u003eBoardTicket\u003c/em\u003e\u003c/strong\u003e, we have \u003cstrong\u003e\u003cem\u003eTicketCard\u003c/em\u003e\u003c/strong\u003e, which is a composable function that draws the ticket on each column.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e327\"\u003eLazyColumn(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e    ) {\u003cp\u003e        stickyHeader {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = column.name,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .graphicsLayer {\u003cbr/\u003e                        scaleX = scale\u003cbr/\u003e                        scaleY = scale\u003cbr/\u003e                        transformOrigin = TransformOrigin.Center\u003cbr/\u003e                    },\u003cbr/\u003e                textAlign = TextAlign.Center,\u003cbr/\u003e                fontWeight = titleStyle.value,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        items(list) { boardTicket -\u0026gt;\u003cbr/\u003e            if (list.isNotEmpty()) {\u003cbr/\u003e                TicketCard(\u003cbr/\u003e                    ticket = boardTicket,\u003cbr/\u003e                    onDeleteConfirmed = onDeleteConfirmed,\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e9ab\"\u003eTo enable the drag feature for \u003cstrong\u003e\u003cem\u003eTicketCard()\u003c/em\u003e\u003c/strong\u003e we need to add a modifier extension function \u003cstrong\u003e\u003cem\u003edragAndDropSource\u003c/em\u003e\u003c/strong\u003e. we can enable the drag by enabling a long-press using\u003cstrong\u003e\u003cem\u003e onLongPress()\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"76b0\"\u003eThe main concept behind the drag and drop is to transfer data from the drag part to the target drop part. \u003cstrong\u003e\u003cem\u003estartTransfer()\u003c/em\u003e\u003c/strong\u003e is a method that accepts \u003cstrong\u003e\u003cem\u003eDragAndDropTransferData\u003c/em\u003e\u003c/strong\u003e that accepts \u003cstrong\u003e\u003cem\u003eClipData.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"eb79\"\u003eClipData could have 5 different types, PlainText, HtmlText, Intent, Uri, and RawUri.\u003c/p\u003e\u003cp id=\"deca\"\u003eSince we want the whole object to be transferred from one column to another, we will ClipData.newIntent type with the help of the \u003cstrong\u003e\u003cem\u003eGson\u003c/em\u003e\u003c/strong\u003e library. The\u003cstrong\u003e\u003cem\u003e newIntent()\u003c/em\u003e\u003c/strong\u003e accepts 2 arguments, a \u003cstrong\u003e\u003cem\u003elabel\u003c/em\u003e\u003c/strong\u003e which is a String that usually describes the data to be transferred, and usually, it’s needed for accessibility. the second argument, is the \u003cstrong\u003e\u003cem\u003eIntent()\u003c/em\u003e\u003c/strong\u003e, where it contains the data.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"adc6\"\u003eModifier\u003cbr/\u003e.dragAndDropSource(block = {\u003cbr/\u003e                detectTapGestures(\u003cbr/\u003e                    onLongPress = {\u003cbr/\u003e                        startTransfer(\u003cbr/\u003e                            DragAndDropTransferData(\u003cbr/\u003e                                clipData = ClipData.newIntent(\u0026#34;ticket\u0026#34;, Intent().apply {\u003cbr/\u003e                                    putExtra(ARG_TICKET, gson.toJson(ticket))\u003cbr/\u003e                                })\u003cbr/\u003e                            )\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e            })\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"f835\"\u003e\u003cstrong\u003eEnable the Drop feature for the Column\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"c165\"\u003eAfter successfully adding the Drag feature, by filling an Intent with the data, now it’s time to receive/accept that data when the drop happened.\u003c/p\u003e\u003cp id=\"35fb\"\u003eThe core part behind receiving the data is a \u003cstrong\u003e\u003cem\u003eDragAndDropTarget\u003c/em\u003e\u003c/strong\u003e. It’s an interface where it contains some methods\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b833\"\u003efun onDrop(event: DragAndDropEvent): Boolean\u003cbr/\u003efun onStarted(event: DragAndDropEvent) = Unit\u003cbr/\u003efun onEntered(event: DragAndDropEvent) = Unit\u003cbr/\u003efun onMoved(event: DragAndDropEvent) = Unit\u003cbr/\u003efun onExited(event: DragAndDropEvent) = Unit\u003cbr/\u003efun onChanged(event: DragAndDropEvent) = Unit\u003cbr/\u003efun onEnded(event: DragAndDropEvent) = Unit\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c01e\"\u003eWe would focus on three of these methods, \u003cstrong\u003e\u003cem\u003eonDrop()\u003c/em\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003cem\u003eonEntered()\u003c/em\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003cem\u003eonExited()\u003c/em\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003cem\u003eonEnded()\u003c/em\u003e\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"32f2\"\u003e\u003cstrong\u003e\u003cem\u003eonDrop()\u003c/em\u003e\u003c/strong\u003e is called whenever the item dragged has been dropped on the target.\u003c/p\u003e\u003cp id=\"641b\"\u003e\u003cstrong\u003e\u003cem\u003eonEntered()\u003c/em\u003e\u003c/strong\u003e is called whenever the dragged item has entered the target bounds\u003c/p\u003e\u003cp id=\"72d9\"\u003e\u003cstrong\u003e\u003cem\u003eonExited()\u003c/em\u003e\u003c/strong\u003e is called whenever the dragged item has exited the bounds where the item was placed.\u003c/p\u003e\u003cp id=\"51de\"\u003eInside \u003cstrong\u003e\u003cem\u003eDragAndBox()\u003c/em\u003e\u003c/strong\u003e function, we added the implementation of the DragAndroidDropTarget interface.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1694\"\u003e@Composable\u003cbr/\u003efun DragAndDropBox(\u003cbr/\u003e    modifier: Modifier,\u003cbr/\u003e    list: List\u0026lt;BoardTicket\u0026gt;,\u003cbr/\u003e    column: Column,\u003cbr/\u003e    onTicketDropped: (BoardTicket, Column) -\u0026gt; Unit,\u003cbr/\u003e    onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit = {},\u003cbr/\u003e) {\u003cbr/\u003e    ......\u003cbr/\u003e    ......\u003cp\u003e    val dragAndDropTarget = remember {\u003cbr/\u003e        object : DragAndDropTarget {\u003cbr/\u003e            override fun onDrop(event: DragAndDropEvent): Boolean {\u003cbr/\u003e                val data = event.toAndroidDragEvent().clipData.getItemAt(0).intent\u003cbr/\u003e                val ticket = gson.fromJson(data.getStringExtra(ARG_TICKET), BoardTicket::class.java)\u003cbr/\u003e                onTicketDropped(\u003cbr/\u003e                    ticket, column\u003cbr/\u003e                )\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            override fun onEntered(event: DragAndDropEvent) {\u003cbr/\u003e                super.onEntered(event)\u003cbr/\u003e                .....\u003cbr/\u003e  .....\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            override fun onExited(event: DragAndDropEvent) {\u003cbr/\u003e                super.onExited(event)\u003cbr/\u003e  .....\u003cbr/\u003e  .....\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Box(\u003cbr/\u003e        modifier = modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .padding(8.dp)\u003cbr/\u003e            .background(color = backgroundColor)\u003cbr/\u003e            .dragAndDropTarget(\u003cbr/\u003e                shouldStartDragAndDrop = { event -\u0026gt;\u003cbr/\u003e                    event\u003cbr/\u003e                        .mimeTypes()\u003cbr/\u003e                        .contains(ClipDescription.MIMETYPE_TEXT_INTENT)\u003cbr/\u003e                },\u003cbr/\u003e                target = dragAndDropTarget\u003cbr/\u003e            )\u003cbr/\u003e    ) {\u003cbr/\u003e    .....\u003cbr/\u003e    .....\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"10bd\"\u003eLet’s break down \u003cstrong\u003e\u003cem\u003eonDrop()\u003c/em\u003e\u003c/strong\u003e implementation, to receive the clipData sent, we use \u003cstrong\u003e\u003cem\u003etoAndroidDragEvent()\u003c/em\u003e\u003c/strong\u003e extension function that returns DragEvent where we can extract all the clipData sent. Since we have a single clipData we would use\u003cstrong\u003e\u003cem\u003e getItemAt(0).intent\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a4af\"\u003eval data = event.toAndroidDragEvent().clipData.getItemAt(0).intent\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f452\"\u003eAfter that we would retrieve the intent, we would need the extra sent which contains a serialized JSON\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f64b\"\u003eval ticket = gson.fromJson(data.getStringExtra(ARG_TICKET), BoardTicket::class.java)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"aa79\"\u003eAfter implementing the interface, we would use another Modifier extension function to make the DragAndDropBox() composable function configured for drag and drop using \u003cstrong\u003e\u003cem\u003eModifier.dragAndDropTarget().\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"e76b\"\u003eLet’s break it down, \u003cstrong\u003e\u003cem\u003edragAndDropTarget\u003c/em\u003e\u003c/strong\u003e has 2 arguments. First, \u003cstrong\u003e\u003cem\u003eshouldStartDragAndDrop\u003c/em\u003e\u003c/strong\u003e where it describes the type of the event, in this case, we need to make sure that the \u003cstrong\u003e\u003cem\u003edragAndDropTarget\u003c/em\u003e\u003c/strong\u003e accepts Intent. Second, the \u003cstrong\u003e\u003cem\u003etarget\u003c/em\u003e\u003c/strong\u003e is the interface implementation we did earlier.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f116\"\u003eBox(\u003cbr/\u003e    modifier = modifier\u003cbr/\u003e        .fillMaxWidth()\u003cbr/\u003e        .padding(8.dp)\u003cbr/\u003e        .background(color = backgroundColor)\u003cbr/\u003e        .dragAndDropTarget(\u003cbr/\u003e            shouldStartDragAndDrop = { event -\u0026gt;\u003cbr/\u003e                event\u003cbr/\u003e                    .mimeTypes()\u003cbr/\u003e                    .contains(ClipDescription.MIMETYPE_TEXT_INTENT)\u003cbr/\u003e            },\u003cbr/\u003e            target = dragAndDropTarget\u003cbr/\u003e        )\u003cbr/\u003e) {\u003cbr/\u003e.....\u003cbr/\u003e.....\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bb75\"\u003e\u003cstrong\u003eDrag and Drop logic in details(ViewModel)\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"a1a1\"\u003eAfter the discussion about enabling the drag and drop feature for the Composable functions, we need to make it clear how can we handle the business logic to make sure the board acts as a Kanban/Agile board.\u003c/p\u003e\u003cp id=\"9440\"\u003eWe have a viewModel that contains 3 StateFlow for the 3 lists that match 3 columns we have todos, inProgress, and done list. These 3 lists are wrapped in a uiState.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"13fa\"\u003eclass MainViewModel : ViewModel() {\u003cp\u003e    private val todos = MutableStateFlow\u0026lt;List\u0026lt;BoardTicket\u0026gt;\u0026gt;(emptyList())\u003cbr/\u003e    private val inProgress = MutableStateFlow\u0026lt;List\u0026lt;BoardTicket\u0026gt;\u0026gt;(emptyList())\u003cbr/\u003e    private val done = MutableStateFlow\u0026lt;List\u0026lt;BoardTicket\u0026gt;\u0026gt;(emptyList())\u003c/p\u003e\u003cp\u003e    private val _uiState = MutableStateFlow\u0026lt;UiState\u0026gt;(\u003cbr/\u003e        UiState.Success(\u003cbr/\u003e            SuccessState(\u003cbr/\u003e                todos.value,\u003cbr/\u003e                inProgress.value,\u003cbr/\u003e                done.value\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e    val uiState = _uiState.asStateFlow()\u003c/p\u003e\u003cp\u003e.....\u003cbr/\u003e.....\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3f9a\"\u003eThere are 3 actions on the board, Add, Delete, and Move. Each action has a method inside the ViewModel. we used State Hoisting when the ticket, was added, deleted, or moved.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2c3c\"\u003e// Main Composable function\u003cbr/\u003e@Composable\u003cbr/\u003efun DragAndDropCompose(\u003cbr/\u003e        modifier: Modifier,\u003cbr/\u003e        uiState: UiState,\u003cbr/\u003e        onNewTicketSubmitted: (BoardTicket) -\u0026gt; Unit,\u003cbr/\u003e        onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit,\u003cbr/\u003e        onTicketDropped: (BoardTicket, Column) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e.....\u003cbr/\u003e.....\u003cbr/\u003e}\u003cp\u003e// Activity\u003cbr/\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e    private val viewModel: MainViewModel by viewModels()\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContent {\u003cbr/\u003e            DDBoardTheme {\u003cbr/\u003e                val uiState = viewModel.uiState.collectAsState(MainViewModel.UiState.Loading)\u003cbr/\u003e                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -\u0026gt;\u003cbr/\u003e                    DragAndDropCompose(\u003cbr/\u003e                        modifier = Modifier.padding(paddingValues = innerPadding),\u003cbr/\u003e                        uiState = uiState.value,\u003cbr/\u003e                        onTicketDropped = { boardTicket, type -\u0026gt;\u003cbr/\u003e                            viewModel.move(boardTicket = boardTicket, to = type)\u003cbr/\u003e                        },\u003cbr/\u003e                        onNewTicketSubmitted = { viewModel.add(it) },\u003cbr/\u003e                        onDeleteConfirmed = { viewModel.delete(it) }\u003cbr/\u003e                        )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e625\"\u003eAs you can see, we are passing the callbacks using state hoisting from the Composable function the Activity to call the proper method on the ViewModel. For example, if we are looking for adding a new ticket, onNewTicketSubmitted = { viewModel.add(it) } should be invoked.\u003c/p\u003e\u003cp id=\"6fcc\"\u003eWe have a data class that contains the business logic of each ticket.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b980\"\u003edata class BoardTicket(\u003cbr/\u003e    val text: String,\u003cbr/\u003e    val estimation: String? = null,\u003cbr/\u003e    val tag: String? = null,\u003cbr/\u003e    val column: Column\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"95b4\"\u003eThe data class contains \u003cstrong\u003e\u003cem\u003etext\u003c/em\u003e\u003c/strong\u003e that corresponds to the title of the ticket, an \u003cstrong\u003e\u003cem\u003eestimation\u003c/em\u003e\u003c/strong\u003e that corresponds to the estimation of the ticket, a \u003cstrong\u003e\u003cem\u003etag\u003c/em\u003e\u003c/strong\u003e that categorizes the ticket, and a column which is an enum that describes the column type\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c78a\"\u003eenum class Column(val columnName: String) {\u003cbr/\u003e    TODO(\u0026#34;TODO\u0026#34;),\u003cbr/\u003e    IN_PROGRESS(\u0026#34;In Progress\u0026#34;),\u003cbr/\u003e    DONE(\u0026#34;Done\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"95bb\"\u003eLet’s break down the add method. when we add a ticket \u003cstrong\u003e\u003cem\u003eonNewTicketSubmitted: (BoardTicket) -\u0026gt; \u003c/em\u003e\u003c/strong\u003eUnit callback passed to the MainActivity where we call \u003cstrong\u003e\u003cem\u003e{ viewModel.add(it) }.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"e1bd\"\u003eSince when we add a ticket it by default is added to the TODO column, that makes it a very straightforward method. We used \u003cstrong\u003e\u003cem\u003e+=\u003c/em\u003e\u003c/strong\u003e operator to add the ticket to the todos List.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0fd2\"\u003efun add(boardTicket: BoardTicket) {\u003cbr/\u003e    todos.value += BoardTicket(text = boardTicket.text, estimation = boardTicket.estimation, tag = boardTicket.tag, column =  Column.TODO)\u003cbr/\u003e    updateUiState()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5283\"\u003eLet’s break down the delete method. when we delete a ticket. we enable ticket deletion only on the done column. that makes it straightforward as well. using \u003cstrong\u003e\u003cem\u003e-=\u003c/em\u003e\u003c/strong\u003e operator, we delete the ticket from the done List.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"39c0\"\u003efun delete(boardTicket: BoardTicket) {\u003cbr/\u003e    done.value -= boardTicket\u003cbr/\u003e    updateUiState()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"39e0\"\u003eLet’s break down the move method. As we mentioned earlier, any ticket can move from any column to another without restrictions, that is why the signature of the move method contains a BoardTicket instance and a \u003cstrong\u003e\u003cem\u003etarget\u003c/em\u003e\u003c/strong\u003e column. The move method is also straightforward, we want to know what is the source and destination columns. Because we would delete the ticket from the source list and add it to the destination list. For example, if we move a ticket from inProgress column to the done column, we will remove it from the inProgress list and it to the done List.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7208\"\u003efun move(boardTicket: BoardTicket, target: Column) {\u003cbr/\u003e        when (boardTicket.column) {\u003cbr/\u003e            Column.DONE -\u0026gt; done.value -= boardTicket\u003cbr/\u003e            Column.IN_PROGRESS -\u0026gt; inProgress.value -= boardTicket\u003cbr/\u003e            Column.TODO -\u0026gt; todos.value -= boardTicket\u003cbr/\u003e        }\u003cbr/\u003e        when (target) {\u003cbr/\u003e            Column.DONE -\u0026gt; done.value += boardTicket.copy(column = target)\u003cbr/\u003e            Column.IN_PROGRESS -\u0026gt; inProgress.value += boardTicket.copy(column = target)\u003cbr/\u003e            Column.TODO -\u0026gt; todos.value += boardTicket.copy(column = target)\u003cbr/\u003e        }\u003cbr/\u003e        updateUiState()\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2387\"\u003eNote: we have a method \u003cstrong\u003e\u003cem\u003eupdateUiState() \u003c/em\u003e\u003c/strong\u003ethat updates the _uiState to update the UI state and reflect the updates happen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"03a8\"\u003eprivate fun updateUiState() {\u003cbr/\u003e    _uiState.value =\u003cbr/\u003e        UiState.Success(SuccessState(todos.value, inProgress.value, done.value))\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"005c\"\u003e\u003cstrong\u003eUI Customization for Drag and Drop\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"16ae\"\u003eWe need to polish the UI to make look great. we are going to polish the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"331d\"\u003eTicketCard UI Customization\u003c/li\u003e\u003cli id=\"2393\"\u003eColumn UI Customization\u003c/li\u003e\u003cli id=\"b5b6\"\u003eBottomSheet for ticket addition and deletion\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"7165\"\u003eTicketCard UI Customizations\u003c/h2\u003e\u003cp id=\"bb26\"\u003eas per the screen below, we have made some UI customization on the TicketCard, the background color and add a delete icon to any ticket on the Done column.\u003c/p\u003e\u003cp id=\"90f2\"\u003eFor the background, it’s straightforward, we decide the containerColor of the card using a when statement with column type.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f0d6\"\u003e@Composable\u003cbr/\u003efun TicketCard(\u003cbr/\u003e    ticket: BoardTicket,\u003cbr/\u003e    onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val showDeleteTicketDialog = remember { mutableStateOf(false) }\u003cbr/\u003e    Card(\u003cbr/\u003e        .....\u003cbr/\u003e        .....\u003cbr/\u003e        shape = CardDefaults.outlinedShape,\u003cbr/\u003e        colors = CardDefaults.cardColors(\u003cbr/\u003e            containerColor = when (ticket.column) {\u003cbr/\u003e                Column.IN_PROGRESS -\u0026gt; MaterialTheme.colorScheme.onSecondary\u003cbr/\u003e                Column.DONE -\u0026gt; MaterialTheme.colorScheme.onTertiary\u003cbr/\u003e                Column.TODO -\u0026gt; MaterialTheme.colorScheme.onPrimary\u003cbr/\u003e            }\u003cbr/\u003e        )\u003cbr/\u003e    ) {\u003cbr/\u003e      .....\u003cbr/\u003e      .....\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d06\"\u003eFor the delete icon on the Done TicketCard columns, we also check the type of the ticket, if it’s done we add a delete icon on the top right.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c10\"\u003e@Composable\u003cbr/\u003efun TicketCard(\u003cbr/\u003e    ticket: BoardTicket,\u003cbr/\u003e    onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e        .....\u003cbr/\u003e        .....\u003cp\u003e        Column(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .padding(8.dp)\u003cbr/\u003e                .fillMaxWidth()\u003cbr/\u003e        ) {\u003c/p\u003e\u003cp\u003e            Row {\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = ticket.text,\u003cbr/\u003e                    modifier = Modifier.weight(1f),\u003cbr/\u003e                    fontWeight = FontWeight.Bold\u003cbr/\u003e                )\u003cbr/\u003e                if (ticket.column == Column.DONE) {\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        Icons.Filled.Delete,\u003cbr/\u003e                        contentDescription = null,\u003cbr/\u003e                        modifier = Modifier\u003cbr/\u003e                            .clickable {\u003cbr/\u003e                                showDeleteTicketDialog.value = true\u003cbr/\u003e                            })\u003cbr/\u003e                }\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e        .....\u003cbr/\u003e        .....\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9724\"\u003e\u003cstrong\u003eColumn UI Customization\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d08e\"\u003eWe will do some customization for the Column, in the title and the background of the column. \u003cbr/\u003eOur mission is to make the title scale increase when a ticket enters the column and returns to its original scale when the ticket leaves the column\u003c/p\u003e\u003cp id=\"09a3\"\u003eAlso, to change the background color of the column whenever a ticket moves in/out of a specific columns\u003c/p\u003e\u003cp id=\"66bd\"\u003eTo achieve that we would need onEntered() and onExited() callbacks.\u003c/p\u003e\u003cp id=\"45e6\"\u003eFor the title scale, we use \u003cstrong\u003e\u003cem\u003eanimateFloatAsState() \u003c/em\u003e\u003c/strong\u003ethat switches between font-weight and scale based on a \u003cstrong\u003e\u003cem\u003etitleStyle\u003c/em\u003e\u003c/strong\u003e mutableState.\u003c/p\u003e\u003cp id=\"5ebd\"\u003eFor the background, we use a backgroundColor mutableState to switch between 2 colors.\u003c/p\u003e\u003cp id=\"ecb8\"\u003ein the onEntered(), onExited() callback, we will change the color and also change the FontWeight, also change the column background.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"5ea2\"\u003e@Composable\u003cbr/\u003efun DragAndDropBox(\u003cbr/\u003e    modifier: Modifier,\u003cbr/\u003e    list: List\u0026lt;BoardTicket\u0026gt;,\u003cbr/\u003e    column: Column,\u003cbr/\u003e    onTicketDropped: (BoardTicket, Column) -\u0026gt; Unit,\u003cbr/\u003e    onDeleteConfirmed: (BoardTicket) -\u0026gt; Unit = {},\u003cbr/\u003e) {\u003cbr/\u003e    var backgroundColor by remember { mutableStateOf(Color(0xffE5E4E2)) }\u003cbr/\u003e    val titleStyle = remember { mutableStateOf(FontWeight.Normal) }\u003cbr/\u003e    val scale by animateFloatAsState(\u003cbr/\u003e        if (titleStyle.value == FontWeight.Bold) 1.4f else 1f,\u003cbr/\u003e        label = \u0026#34;scale\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e    val dragAndDropTarget = remember {\u003cbr/\u003e        object : DragAndDropTarget {\u003cbr/\u003e            override fun onDrop(event: DragAndDropEvent): Boolean {\u003cbr/\u003e                .....\u003cbr/\u003e                .....\u003cbr/\u003e            }\u003cp\u003e            override fun onEntered(event: DragAndDropEvent) {\u003cbr/\u003e                super.onEntered(event)\u003cbr/\u003e                backgroundColor = Color(0xffD3D3D3)\u003cbr/\u003e                titleStyle.value = FontWeight.Bold\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            override fun onExited(event: DragAndDropEvent) {\u003cbr/\u003e                super.onExited(event)\u003cbr/\u003e                backgroundColor = Color(0xffE5E4E2)\u003cbr/\u003e                titleStyle.value = FontWeight.Normal\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        .....\u003cbr/\u003e    .....\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1d5a\"\u003e\u003cstrong\u003eBottomSheet for ticket addition and deletion\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"bb3a\"\u003eWe will use the bottom sheet twice, for the addition and deletion of a ticket.\u003c/p\u003e\u003cp id=\"a67f\"\u003eFor deletion, it’s straightforward, it’s just a bottom sheet with a message and 2 buttons, one responsible for propagating the onDelete() to the MainActivity by state hoisting to perform the viewModel.delete() method. The second is just to hide the bottom sheet.\u003c/p\u003e\u003cp id=\"7930\"\u003eFor adding a ticket, it’s a detailed bottom sheet, that contains a TextField with a maximum of 100 characters.\u003c/p\u003e\u003cp id=\"6bfc\"\u003ethe second and third is a single selection component, where the user can select a tag and an estimation for the ticket and two buttons for adding a ticket by propagating \u003cstrong\u003e\u003cem\u003eonNewTicketsubmitted()\u003c/em\u003e\u003c/strong\u003e to call \u003cstrong\u003e\u003cem\u003eviewModel.add()\u003c/em\u003e\u003c/strong\u003e by state hoisting. We are using a \u003cstrong\u003e\u003cem\u003eFlowRow\u003c/em\u003e\u003c/strong\u003e to achieve the single selection.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"761a\"\u003eprivate fun SingleSelectionSection(\u003cbr/\u003e    title: String,\u003cbr/\u003e    list: List\u0026lt;String\u0026gt;,\u003cbr/\u003e    selectedIndex: Int,\u003cbr/\u003e    badgeType: BadgeType,\u003cbr/\u003e    onItemSelected: (Int) -\u0026gt; Unit = {},\u003cbr/\u003e    hasError: Boolean = false\u003cbr/\u003e) {\u003cbr/\u003e    Row(verticalAlignment = Alignment.CenterVertically) {\u003cbr/\u003e        Text(text = title, modifier = Modifier.padding(end = 8.dp))\u003cbr/\u003e        FlowRow(horizontalArrangement = Arrangement.spacedBy(4.dp)) {\u003cbr/\u003e            list.forEachIndexed { index, text -\u0026gt;\u003cbr/\u003e                CardContainer(\u003cbr/\u003e                    text = text,\u003cbr/\u003e                    isSelected = selectedIndex == index,\u003cbr/\u003e                    badgeType = badgeType,\u003cbr/\u003e                    onClick = {\u003cbr/\u003e                        onItemSelected(index)\u003cbr/\u003e                    },\u003cbr/\u003e                    hasError = hasError\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a67a\"\u003ewe have also multiple mutableStateFlow to remember the selection of the tags, estimation, and color of the single selection component, because we have a validation on the single selection and TextField, if the user click on save button without filling all required fields.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c11d\"\u003eYou may notice that the mutableStateFlow that saves the value of the chosen value takes sheetState.isVisible as a param, for example, the reason behind that is to reset the state each time we open the bottom sheet. so old value disappears.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"481e\"\u003evar text by remember(sheetState.isVisible) { mutableStateOf(\u0026#34;\u0026#34;) }\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"74a3\"\u003e@Composable\u003cbr/\u003efun InputDialog(\u003cbr/\u003e    showDialog: Boolean,\u003cbr/\u003e    estimationsList: List\u0026lt;String\u0026gt;,\u003cbr/\u003e    tagsList: List\u0026lt;String\u0026gt;,\u003cbr/\u003e    onNewTicketSubmitted: (BoardTicket) -\u0026gt; Unit,\u003cbr/\u003e    onDismiss: () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val colorScheme = MaterialTheme.colorScheme\u003cbr/\u003e    val sheetState = rememberModalBottomSheetState()\u003cbr/\u003e    val scope = rememberCoroutineScope()\u003cbr/\u003e    var text by remember(sheetState.isVisible) { mutableStateOf(\u0026#34;\u0026#34;) }\u003cbr/\u003e    val selectedEstimationIndex = remember(sheetState.isVisible) { mutableIntStateOf(-1) }\u003cbr/\u003e    val textError = remember(sheetState.isVisible)  { mutableStateOf(false) }\u003cbr/\u003e    val selectedTagIndex = remember(sheetState.isVisible) { mutableIntStateOf(-1) }\u003cbr/\u003e    var supportTextColor by remember { mutableStateOf(colorScheme.onSurface) }\u003cbr/\u003e    var estimationError by remember(sheetState.isVisible)  { mutableStateOf(false) }\u003cbr/\u003e    var tagError by remember(sheetState.isVisible)  { mutableStateOf(false) }\u003cbr/\u003e    if (showDialog) {\u003cp\u003e        ModalBottomSheet(\u003cbr/\u003e            onDismissRequest = {\u003cbr/\u003e                onDismiss()\u003cbr/\u003e            },\u003cbr/\u003e            sheetState = sheetState\u003cbr/\u003e        ) {\u003cbr/\u003e            Column(modifier = Modifier.padding(horizontal = 24.dp, vertical = 8.dp)) {\u003cbr/\u003e                Text(text = \u0026#34;Add a new Ticket\u0026#34;, fontWeight = FontWeight.Bold)\u003cbr/\u003e                Spacer(modifier = Modifier.height(8.dp))\u003cbr/\u003e                TextField(\u003cbr/\u003e                    value = text,\u003cbr/\u003e                    placeholder = {\u003cbr/\u003e                        Text(text = \u0026#34;Write your ticket title/details\u0026#34;)\u003cbr/\u003e                    },\u003cbr/\u003e                    onValueChange = {\u003cbr/\u003e                        text = it\u003cbr/\u003e                        supportTextColor = if (text.length \u0026gt; 100) {\u003cbr/\u003e                            Color.Red\u003cbr/\u003e                        } else {\u003cbr/\u003e                            colorScheme.onSurface\u003cbr/\u003e                        }\u003cbr/\u003e                        if (textError.value \u0026amp;\u0026amp; it.isNotEmpty()) {\u003cbr/\u003e                            textError.value = false\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                    modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e                    supportingText = {\u003cbr/\u003e                        Text(\u003cbr/\u003e                            text = \u0026#34;${text.length} / 100\u0026#34;,\u003cbr/\u003e                            textAlign = TextAlign.End,\u003cbr/\u003e                            modifier = Modifier.fillMaxWidth(),\u003cbr/\u003e                            color = supportTextColor\u003cbr/\u003e                        )\u003cbr/\u003e                    },\u003cbr/\u003e                    colors = TextFieldDefaults.colors(\u003cbr/\u003e                        focusedIndicatorColor = Color.Transparent,\u003cbr/\u003e                        unfocusedIndicatorColor = Color.Transparent\u003cbr/\u003e                    ),\u003cbr/\u003e                    isError = textError.value\u003cbr/\u003e                )\u003cbr/\u003e                Spacer(modifier = Modifier.height(8.dp))\u003cbr/\u003e                SingleSelectionSection(\u003cbr/\u003e                    title = \u0026#34;Estimation\u0026#34;,\u003cbr/\u003e                    list = estimationsList,\u003cbr/\u003e                    badgeType = BadgeType.ESTIMATION,\u003cbr/\u003e                    selectedIndex = selectedEstimationIndex.intValue,\u003cbr/\u003e                    onItemSelected = {\u003cbr/\u003e                        selectedEstimationIndex.intValue = it\u003cbr/\u003e                        estimationError = false\u003cbr/\u003e                    },\u003cbr/\u003e                    hasError = estimationError\u003cbr/\u003e                )\u003cbr/\u003e                Spacer(modifier = Modifier.height(8.dp))\u003cbr/\u003e                SingleSelectionSection(\u003cbr/\u003e                    title = \u0026#34;Tags\u0026#34;,\u003cbr/\u003e                    list = tagsList,\u003cbr/\u003e                    badgeType = BadgeType.TAG,\u003cbr/\u003e                    selectedIndex = selectedTagIndex.intValue,\u003cbr/\u003e                    onItemSelected = {\u003cbr/\u003e                        selectedTagIndex.intValue = it\u003cbr/\u003e                        tagError = false\u003cbr/\u003e                    },\u003cbr/\u003e                    hasError = tagError\u003cbr/\u003e                )\u003c/p\u003e\u003cp\u003e                Spacer(modifier = Modifier.height(16.dp))\u003cbr/\u003e                Button(onClick = {\u003cbr/\u003e                    val hasError =\u003cbr/\u003e                        text.isEmpty() || selectedTagIndex.intValue == -1 || selectedEstimationIndex.intValue == -1\u003cbr/\u003e                    if (hasError) {\u003cbr/\u003e                        textError.value = text.isEmpty()\u003cbr/\u003e                        estimationError = selectedEstimationIndex.intValue == -1\u003cbr/\u003e                        tagError = selectedTagIndex.intValue == -1\u003cbr/\u003e                        return@Button\u003cbr/\u003e                    }\u003cbr/\u003e                    scope.launch {\u003cbr/\u003e                        sheetState.hide()\u003c/p\u003e\u003cp\u003e                    }.invokeOnCompletion {\u003cbr/\u003e                        if (!sheetState.isVisible) {\u003cbr/\u003e                            onDismiss()\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                    onNewTicketSubmitted(\u003cbr/\u003e                        BoardTicket(\u003cbr/\u003e                            text = text,\u003cbr/\u003e                            estimation = estimationsList[selectedEstimationIndex.intValue],\u003cbr/\u003e                            tag = tagsList[selectedTagIndex.intValue],\u003cbr/\u003e                            column = Column.TODO\u003cbr/\u003e                        )\u003cbr/\u003e                    )\u003c/p\u003e\u003cp\u003e                }, modifier = Modifier.fillMaxWidth()) {\u003cbr/\u003e                    Text(text = \u0026#34;Create\u0026#34;)\u003cbr/\u003e                }\u003cbr/\u003e                Spacer(modifier = Modifier.height(8.dp))\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"76fe\"\u003eSo, that’s it. with a real-life example, we were able to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0345\"\u003eUnderstand how drag-and-drop API works in compose\u003c/li\u003e\u003cli id=\"db0a\"\u003eAdapt some UI customization to make it similar to the Agile/Kanban board\u003c/li\u003e\u003cli id=\"5306\"\u003ehandle the business logic using ViewModel.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1ec2\"\u003eYou can find the full repository on \u003ca href=\"https://github.com/MustafaKhaled/DragAndDropBoard\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "30 min read",
  "publishedTime": "2024-12-07T00:01:10.444Z",
  "modifiedTime": null
}
