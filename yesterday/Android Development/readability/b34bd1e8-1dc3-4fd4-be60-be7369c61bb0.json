{
  "id": "b34bd1e8-1dc3-4fd4-be60-be7369c61bb0",
  "title": "Integrating Native Swift Code in a Kotlin Compose Multiplatform App",
  "link": "https://proandroiddev.com/integrating-native-swift-code-in-a-kotlin-compose-multiplatform-app-0abea9269bb2?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Mon, 17 Mar 2025 07:59:48 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "mobile-app-development",
    "android-app-development",
    "kotlin-multiplatform",
    "androiddev"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 4548,
  "excerpt": "In Compose Multiplatform, we typically develop our user interface with Jetpack Compose while placing the majority of our code in the commonMain module. Whenever we need platform-specific…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Our ScenarioWe will define a very simple example using the expect/actual mechanism, where our shared code passes a number to a platform-specific function. On Android, this function will return the input plus 10, while on iOS, it will return the input plus 100.Starter Code:commonMain: Here we just define our interface to implement for Android and iOS.// commonMain/NativeResponse.ktexpect fun getNativeResponse(input: Int): IntandroidMain: On Android implementation we just return input+10// androidMain/NativeResponse.android.ktactual fun getNativeResponse(input: Int): Int { return input + 10}iosMain: On iOS implementation we just return input+100// iosMain/NativeResponse.ios.ktactual fun getNativeResponse(input: Int): Int { return input + 100}Our UI will be as simple as that:@Composable@Previewfun App() { MaterialTheme { Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center ) { val input by remember { mutableStateOf(1) } Text( text = \"Input: $input\\nOutput: ${getNativeResponse(input)}\", fontSize = 24.sp, textAlign = TextAlign.Center, lineHeight = 1.3.em ) } }}Moving Code to Swift — Direct SolutionWe’ll migrate the actual iOS functionality from Kotlin to Swift and then call that Swift code from Kotlin to fetch the result (input + 10) from Swift.1. Modify the iosMain sideLet’s start by modifying our iosMain code firstBefore// iosMain/NativeResponse.ios.ktactual fun getNativeResponse(input: Int): Int { return input + 100}AfterWe declare an interface NatifeResponseFactory which will be utilized at the iOS side.Then we use the setNativeResponseFactoryfor Swift to be able to talk back to Kotlin.Finally, our altered actual implementation, will utilize the factory to communicate with Swift.// iosMain/NativeResponse.ios.ktinterface NativeResponseFactory { fun getNativeResponse(input: Int): Int}// Add this variable to store the Swift implementationprivate var nativeFactory: NativeResponseFactory? = null// Add this function to be called from Swiftfun setNativeResponseFactory(factory: NativeResponseFactory) { nativeFactory = factory}actual fun getNativeResponse(input: Int): Int {// Get the Swift implementation and call it return nativeFactory?.getNativeResponse(input) ?: throw IllegalStateException(\"NativeResponseFactory not set\")}Now at Xcode press [command]+[B] to build the app, so this interface can become available at Swift, as Swift can communicate with compiled code only.2. Create the Swift “actual” code in XcodeOpen Xcode and go to your iOS project hosted at the iosApp folder and select the iosApp.xcodeproj to open the iOS project.There, create a new empty Swift file (for example NativeResponse.swift) and add the following code:import ComposeAppclass IOSNativeResponseFactory: NativeResponseFactory { func getNativeResponse(input: Int32) -\u003e Int32 { // Native Swift logic; for example, add 100 to the input return input + 100 }}Pay attention not to forget to add the import ComposeApp, otherwise Swift won’t be able to retrieve the NativeResponseFactory interface which was declared on iosMain.3. Modify the “iosApp.swift” file in XcodeNow it is time to modify our “entry point” of the iOS App so that it is bridged with ourBeforeimport SwiftUI@mainstruct iOSApp: App { var body: some Scene { WindowGroup { ContentView() } }}Afterimport SwiftUIimport ComposeApp@mainstruct iOSApp: App { init() { let nativeResponseFactory = IOSNativeResponseFactory() NativeResponse_iosKt.setNativeResponseFactory(factory: nativeResponseFactory) } var body: some Scene { WindowGroup { ContentView() } }}Note here that because the setNativeResponseFactory was declared inside NativeResponse.ios.kt file in iosMain, we can reference it as NativeResponse_iosKt.Again, don’t forget to import ComposeApp in order for Swift to be able to utilize Kotlin code and get access to NativeResponse_iosKtBut now due to our init statement, Kotlin can now utilize Swift!ConclusionBy creating a native Swift implementation and bridging it to Kotlin via the setNativeResponseFactory mechanism, you can easily call platform-specific code that isn’t automatically bridged by Kotlin Multiplatform.This approach empowers you to mix platform-native features with your shared Kotlin business logic, giving you full flexibility across both Android and iOS.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*3z0biwj_7QXQF6QEUI_XUw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"63ab\"\u003eOur Scenario\u003c/h2\u003e\u003cp id=\"16d2\"\u003eWe will define a \u003cstrong\u003every simple example\u003c/strong\u003e using the \u003ccode\u003e\u003cstrong\u003eexpect/actual\u003c/strong\u003e\u003c/code\u003e mechanism, where our shared code passes a number to a \u003cstrong\u003eplatform-specific\u003c/strong\u003e function. On \u003cstrong\u003eAndroid\u003c/strong\u003e, this function will \u003cstrong\u003ereturn\u003c/strong\u003e the \u003cstrong\u003einput plus 10\u003c/strong\u003e, while on \u003cstrong\u003eiOS\u003c/strong\u003e, it will \u003cstrong\u003ereturn\u003c/strong\u003e the \u003cstrong\u003einput plus 100\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"ee31\"\u003eStarter Code:\u003c/h2\u003e\u003cp id=\"f93b\"\u003e\u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e Here we just define our \u003cem\u003einterface\u003c/em\u003e to implement for Android and iOS.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"330d\"\u003e// commonMain/NativeResponse.kt\u003cbr/\u003eexpect fun getNativeResponse(input: Int): Int\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"592d\"\u003e\u003ccode\u003e\u003cstrong\u003eandroidMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e On Android \u003cem\u003eimplementation\u003c/em\u003e we just return \u003ccode\u003einput+10\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3c4f\"\u003e// androidMain/NativeResponse.android.kt\u003cbr/\u003eactual fun getNativeResponse(input: Int): Int {\u003cbr/\u003e    return input + 10\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b6ee\"\u003e\u003ccode\u003e\u003cstrong\u003eiosMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e On iOS \u003cem\u003eimplementation\u003c/em\u003e we just return \u003ccode\u003einput+100\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1774\"\u003e// iosMain/NativeResponse.ios.kt\u003cbr/\u003eactual fun getNativeResponse(input: Int): Int {\u003cbr/\u003e    return input + 100\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8bdb\"\u003eOur UI will be as simple as that:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7e8f\"\u003e@Composable\u003cbr/\u003e@Preview\u003cbr/\u003efun App() {\u003cbr/\u003e    MaterialTheme {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier.fillMaxSize(),\u003cbr/\u003e            contentAlignment = Alignment.Center\u003cbr/\u003e        ) {\u003cbr/\u003e            val input by remember { mutableStateOf(1) }\u003cp\u003e            Text(\u003cbr/\u003e                text = \u0026#34;Input: $input\\nOutput: ${getNativeResponse(input)}\u0026#34;,\u003cbr/\u003e                fontSize = 24.sp,\u003cbr/\u003e                textAlign = TextAlign.Center,\u003cbr/\u003e                lineHeight = 1.3.em\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3fc0\"\u003eMoving Code to Swift — Direct Solution\u003c/h2\u003e\u003cp id=\"6485\"\u003eWe’ll migrate the actual iOS functionality from Kotlin to Swift and then call that Swift code from Kotlin to fetch the result (\u003ccode\u003einput + 10\u003c/code\u003e) from Swift.\u003c/p\u003e\u003ch2 id=\"99bf\"\u003e1. Modify the \u003ccode\u003eiosMain\u003c/code\u003e side\u003c/h2\u003e\u003cp id=\"1247\"\u003eLet’s start by modifying our \u003ccode\u003eiosMain\u003c/code\u003e code first\u003c/p\u003e\u003cp id=\"4c44\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dbce\"\u003e// iosMain/NativeResponse.ios.kt\u003cbr/\u003eactual fun getNativeResponse(input: Int): Int {\u003cbr/\u003e    return input + 100\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"35e8\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3bb6\"\u003eWe declare an interface \u003ccode\u003eNatifeResponseFactory\u003c/code\u003e which will be utilized at the iOS side.\u003c/p\u003e\u003cp id=\"7fc2\"\u003eThen we use the \u003ccode\u003esetNativeResponseFactory\u003c/code\u003efor Swift to be able to talk back to Kotlin.\u003c/p\u003e\u003cp id=\"df74\"\u003eFinally, our altered \u003ccode\u003eactual\u003c/code\u003e \u003cem\u003eimplementation\u003c/em\u003e, will utilize the factory to communicate with Swift.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a93\"\u003e// iosMain/NativeResponse.ios.kt\u003cbr/\u003einterface NativeResponseFactory {\u003cbr/\u003e    fun getNativeResponse(input: Int): Int\u003cbr/\u003e}\u003cp\u003e// Add this variable to store the Swift implementation\u003cbr/\u003eprivate var nativeFactory: NativeResponseFactory? = null\u003c/p\u003e\u003cp\u003e// Add this function to be called from Swift\u003cbr/\u003efun setNativeResponseFactory(factory: NativeResponseFactory) {\u003cbr/\u003e    nativeFactory = factory\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eactual fun getNativeResponse(input: Int): Int {\u003cbr/\u003e// Get the Swift implementation and call it\u003cbr/\u003e    return nativeFactory?.getNativeResponse(input)\u003cbr/\u003e        ?: throw IllegalStateException(\u0026#34;NativeResponseFactory not set\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a937\"\u003eNow at Xcode press \u003ccode\u003e[command]+[B]\u003c/code\u003e to build the app, so this \u003cem\u003einterface\u003c/em\u003e can become available at Swift, as Swift can communicate with compiled code only.\u003c/p\u003e\u003ch2 id=\"ba2f\"\u003e2. Create the Swift “actual” code in Xcode\u003c/h2\u003e\u003cp id=\"112f\"\u003eOpen Xcode and go to your iOS project hosted at the \u003ccode\u003eiosApp\u003c/code\u003e folder and select the \u003ccode\u003eiosApp.xcodeproj\u003c/code\u003e to open the iOS project.\u003c/p\u003e\u003cp id=\"0835\"\u003eThere, create a new empty Swift file (for example \u003ccode\u003eNativeResponse.swift\u003c/code\u003e) and add the following code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5124\"\u003eimport ComposeApp\u003cp\u003eclass IOSNativeResponseFactory: NativeResponseFactory {\u003cbr/\u003e    func getNativeResponse(input: Int32) -\u0026gt; Int32 {\u003cbr/\u003e        // Native Swift logic; for example, add 100 to the input\u003cbr/\u003e        return input + 100\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"e72f\"\u003e\u003cem\u003ePay attention \u003c/em\u003e\u003cstrong\u003e\u003cem\u003enot to forget to add the\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e\u003ccode\u003e\u003cstrong\u003e\u003cem\u003eimport ComposeApp\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e\u003cem\u003e, otherwise Swift won’t be able to retrieve the \u003c/em\u003e\u003ccode\u003e\u003cem\u003eNativeResponseFactory\u003c/em\u003e\u003c/code\u003e\u003cem\u003e interface which was declared on iosMain.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"6d6f\"\u003e3. Modify the “iosApp.swift” file in Xcode\u003c/h2\u003e\u003cp id=\"fb04\"\u003eNow it is time to modify our “\u003cstrong\u003eentry point\u003c/strong\u003e” of the iOS App so that it is bridged with our\u003c/p\u003e\u003cp id=\"a770\"\u003e\u003cstrong\u003eBefore\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8043\"\u003eimport SwiftUI\u003cp\u003e@main\u003cbr/\u003estruct iOSApp: App {\u003cbr/\u003e    var body: some Scene {\u003cbr/\u003e        WindowGroup {\u003cbr/\u003e            ContentView()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"16aa\"\u003e\u003cstrong\u003eAfter\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"391f\"\u003eimport SwiftUI\u003cbr/\u003eimport ComposeApp\u003cp\u003e@main\u003cbr/\u003estruct iOSApp: App {\u003cbr/\u003e    init() {\u003cbr/\u003e        let nativeResponseFactory = IOSNativeResponseFactory()\u003cbr/\u003e        NativeResponse_iosKt.setNativeResponseFactory(factory: nativeResponseFactory)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        var body: some Scene {\u003cbr/\u003e        WindowGroup {\u003cbr/\u003e            ContentView()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"fe1b\"\u003e\u003cstrong\u003e\u003cem\u003eNote\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e here that because the \u003c/em\u003e\u003ccode\u003e\u003cem\u003esetNativeResponseFactory\u003c/em\u003e\u003c/code\u003e\u003cem\u003e was declared inside \u003c/em\u003e\u003ccode\u003e\u003cem\u003eNativeResponse.ios.kt\u003c/em\u003e\u003c/code\u003e\u003cem\u003e file in iosMain, we can reference it as \u003c/em\u003e\u003ccode\u003e\u003cem\u003eNativeResponse_iosKt\u003c/em\u003e\u003c/code\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"48ad\"\u003e\u003cem\u003eAgain, \u003c/em\u003e\u003cstrong\u003e\u003cem\u003edon’t forget to \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e\u003cem\u003eimport ComposeApp\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e\u003cem\u003e in order for Swift to be able to utilize Kotlin code and get access to \u003c/em\u003e\u003ccode\u003e\u003cem\u003eNativeResponse_iosKt\u003c/em\u003e\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cblockquote\u003e\u003cp id=\"da43\"\u003eBut now due to our \u003ccode\u003einit\u003c/code\u003e statement, Kotlin can now utilize Swift!\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"de17\"\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0026\"\u003eBy creating a \u003cstrong\u003enative Swift implementation\u003c/strong\u003e and bridging it to Kotlin via the \u003ccode\u003esetNativeResponseFactory\u003c/code\u003e mechanism, you can easily call platform-specific code that isn’t automatically bridged by Kotlin Multiplatform.\u003c/p\u003e\u003cp id=\"960b\"\u003eThis approach empowers you to mix platform-native features with your shared Kotlin business logic, giving you full flexibility across both Android and iOS.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-03-17T07:59:48.699Z",
  "modifiedTime": null
}
