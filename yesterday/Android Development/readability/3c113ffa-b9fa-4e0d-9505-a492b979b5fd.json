{
  "id": "3c113ffa-b9fa-4e0d-9505-a492b979b5fd",
  "title": "Get your app for larger screens using window-size classes",
  "link": "https://proandroiddev.com/get-your-android-app-ready-for-larger-screen-sizes-using-window-size-classes-on-android-1663d1a77423?source=rss----c72404660798---4",
  "description": "",
  "author": "Mubarak Native",
  "published": "Thu, 27 Feb 2025 15:12:37 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "android-development",
    "large-screen",
    "kotlin"
  ],
  "byline": "Mubarak Native",
  "length": 7233,
  "excerpt": "Prepare your Android app for larger screens by utilizing window-size classes, enabling responsive layouts that adapt to various display sizes.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In this article, we are going to learn how to optimize our app to look better on every screen-sizes. It includes a phone, tablet and even a desktop (Chrome OS) and also learn why we need to consider optimizing our app for larger screens and more. Let’s begin.Why do we need to support larger screen-sizes?Android not only runs on smartphones, it also runs on Tablet, Desktop (Chrome OS), Foldables, Automotive and also on Smart TV’s with over three billion active devices. We are developers we ensure to provide a seamless experience on every platform, foldables are now the current hot topic is that every smartphone brand releases their own version of foldables. They dynamically change their screen sizes from a phone to a tablet-sized display.How to support large screen-sizes?To support every screen-size, we need to make our layout adaptive, so they adapt its size based on screen size. We achieve this by using window-size-classes on android. They provide high level abstraction of screen size by providing these simple types: compact, medium, and expanded, so we can easily make UI design decisions based on screen sizes. Ex: in compact we show a navigation bar or model navigation drawer, there are 2 types of window-size-classesHeightWidthWe usually consider width size class because most of the content in our app scrolls vertically.Window-Size-ClassesTo get the current window-size let’s add one dependency to our libs.versions.toml[versions]material3AdaptiveNavigationSuite = \"1.3.0-beta04\"[libraries]androidx-material3-adaptive-navigation-suite = { module = \"androidx.compose.material3:material3-adaptive-navigation-suite\", version.ref = \"material3AdaptiveNavigationSuite\" }And define it on build.gradle.kts(module:app)dependencies { // NavigationSuiteScaffoldimplementation(libs.androidx.material3.adaptive.navigation.suite)}Note: The material adaptive library is currently in beta. Check out the latest releases hereWe have the two following benefits for adding this dependencyOne is obvious, we can access the window-size class for both height and width by using the currentWindowAdaptiveInfo() function.val windowSizeClass = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClassSo we can make UI design decisions about something like that.@OptIn(ExperimentalMaterial3AdaptiveApi::class)@Composablefun App( widthSizeClass: WindowWidthSizeClass) { // Perform logic on the size class to decide whether to show navigation rail or not. val isExpanded = windowSizeClass == WindowWidthSizeClass.EXPANDED Row { if (isExpanded) { NavigationRail { NavigationRailItem( /* ... */ ) } } DefaultNavGraph(/* ... */) }}2. The second one is that we have access to NavigationSuiteScaffold which simplifies the navigation UI decision logic for us, based on window-size.It shows the bottom navigation bar if the windowsize is in a compact or in a table-top (horizontal) position, and it shows navigation rail for everything else.For what screen-size, which navigation layout is best ?As per Material Design guidelines, window size classCompact (Width \u003c 600 dp): Use Navigation bar, modal navigation drawerMedium (600 dp≤ width \u003c 840 dp): Use Navigation rail, modal navigation drawerExpanded (840 ≤ width \u003c 1200*): Use Navigation rail, modal or standard navigation drawer (for expanded use 2 pane layout if you use list-detail screen by using ListDetailPaneScaffold)Note: ListDetailPaneScaffold is from a material-adaptive library which is currently in alpha, and it also is not supporting Navigation compose yet, for view-based app use SlidingPaneLayout.Let’s see a real world demoAs I already mentioned, by using NavigationSuiteScaffold, it really simplifies our work. We don’t need to write a logic based on window-size-class ourselves. It does for us out of the box. Let’s get into a demo. Next, we also learn how to manually show navigation layout based on window-size-classes.What do we build??NavigationSuiteScaffold app demoIn this app we don’t focus on the content of the screen, instead just showing the text that displays, our current destination. Our goal is just displaying a navigation layout based on window-size.Let’s implement it:As we already added the required dependency, which is navigation-suite from material 3, so let’s focus on code.For our top level destinations, I added an enum class. For that, here is that code.enum class AppDestinations( @StringRes val label: Int, val icon: ImageVector, @StringRes val contentDescription: Int) { HOME(R.string.home, Icons.Default.Home, R.string.home), DRAWING(R.string.draw, Icons.Default.Draw, R.string.draw), EDIT(R.string.edit, Icons.Default.Edit, R.string.edit), SETTINGS(R.string.profile, Icons.Default.Person, R.string.settings),}And let’s call the NavigationSuiteScaffold and pass the necessary argumentsAs you can see the code how easy it is to implement the navigation layout based on window-size class when we use NavigationSuiteScaffold, we don’t need to write. Single conditional statement for the window-size classIf you want, we can further customize it. If you want to show other navigation layout based on window-size, you can do so by passing another parameter in NavigationSuiteScaffold named layoutType.val adaptiveInfo = currentWindowAdaptiveInfo() /* Optional */ val customNavSuiteType = with(adaptiveInfo) { if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) { NavigationSuiteType.NavigationRail } else { NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo) } }Here we customize the navigation layout based on the window class. If we are currently on the EXPANDED screen, we show the navigation rail instead of the default navigation bar, our layout screen is considered as an EXPANDED if the below criteria meet:Phone in landscapeTablet in landscapeFoldable in landscape (unfolded state)Desktop (Chrome OS)Now we have learned how to work with NavigationSuiteScaffold. Now let’s move on to more customized option.Handling navigation layout decisions ourselves by using Window-Size-ClassesNow let’s explore how to handle navigation layout based on Window-Size-Class ourselves.As you can see in the code, we conditionally show Navigation Rail based on screen-size by usingval isExpanded = widthSizeClass == WindowWidthSizeClass.EXPANDEDLet’s call this function in MainActivity.ktYourAppTheme{ val windowWidthSizeClass = currentWindowAdaptiveInfo().windowSizeClass OsbApp(windowWidthSizeClass.windowWidthSizeClass) // here we using Width Size class.}When you run the app it shows an appropriate navigation layout based on widow-sizeConditionally show a navigation layout based on window-size.The source code of the NavigationSuiteScaffold demo is available on this repository:In this article, we learned how to provide the best user-experience on larger screen sizes and also learned its use cases. I hope you will like this article. If so, please applause this story and share it with your friends and family. And i will see you in the next upcoming article with an interesting topic.Signing off, Mubarak.M Basha",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*6KATZ_l6y6Mg7CxgWVqP3w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://mubaraknative.medium.com/?source=post_page---byline--1663d1a77423---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Mubarak Native\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*UDMb5Rfs_Vvpb92Kmd76vw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--1663d1a77423---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp id=\"def6\"\u003eIn this article, we are going to learn how to optimize our app to look better on every screen-sizes. It includes a phone, tablet and even a desktop (Chrome OS) and also learn why we need to consider optimizing our app for larger screens and more. Let’s begin.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"9bdc\"\u003eWhy do we need to support larger screen-sizes?\u003c/h2\u003e\u003cp id=\"e9a3\"\u003eAndroid not only runs on smartphones, it also runs on Tablet, Desktop (Chrome OS), Foldables, Automotive and also on Smart TV’s with over \u003cstrong\u003ethree billion active devices\u003c/strong\u003e. We are developers we ensure to provide a seamless experience on every platform, foldables are now the current hot topic is that every smartphone brand releases their own version of foldables. They dynamically change their screen sizes from a phone to a tablet-sized display.\u003c/p\u003e\u003ch2 id=\"a82e\"\u003eHow to support large screen-sizes?\u003c/h2\u003e\u003cp id=\"0f0e\"\u003eTo support every screen-size, \u003cstrong\u003ewe need to make our layout adaptive\u003c/strong\u003e, so they adapt its size based on screen size. We achieve this by using \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive/window-size-classes\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003ewindow-size-classes on android\u003c/strong\u003e\u003c/a\u003e. They provide high level abstraction of screen size by providing these simple types: \u003cstrong\u003e\u003cem\u003ecompact\u003c/em\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003cem\u003emedium\u003c/em\u003e\u003c/strong\u003e, and \u003cstrong\u003eexpanded\u003c/strong\u003e, so we can easily make UI design decisions based on screen sizes. \u003cstrong\u003eEx: in compact we show a navigation bar or model navigation drawer, there are 2 types of window-size-classes\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"d5e8\"\u003eHeight\u003c/li\u003e\u003cli id=\"3297\"\u003eWidth\u003c/li\u003e\u003c/ol\u003e\u003cblockquote\u003e\u003cp id=\"24f1\"\u003e\u003cstrong\u003eWe usually consider width size class because most of the content in our app scrolls vertically.\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003cfigcaption\u003eWindow-Size-Classes\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ff00\"\u003eTo get the current window-size let’s add one dependency to our \u003cstrong\u003e\u003cem\u003elibs.versions.toml\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"57f4\"\u003e[versions]\u003cbr/\u003ematerial3AdaptiveNavigationSuite = \u0026#34;1.3.0-beta04\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-material3-adaptive-navigation-suite = { module = \u0026#34;androidx.compose.material3:material3-adaptive-navigation-suite\u0026#34;, version.ref = \u0026#34;material3AdaptiveNavigationSuite\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b881\"\u003eAnd define it on \u003cstrong\u003ebuild.gradle.kts(module:app)\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"960e\"\u003edependencies {\u003cp\u003e // NavigationSuiteScaffold\u003cbr/\u003eimplementation(libs.androidx.material3.adaptive.navigation.suite)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"ba9e\"\u003eNote: The material adaptive library is currently in beta. Check out the latest releases \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/compose-material3-adaptive\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3ec8\"\u003e\u003cstrong\u003eWe have the two following benefits for adding this dependency\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"8a41\"\u003eOne is obvious, we can access the window-size class for both height and width by using the \u003cstrong\u003ecurrentWindowAdaptiveInfo\u003c/strong\u003e() function.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"cbec\"\u003eval windowSizeClass = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6edb\"\u003eSo we can make UI design decisions about something like that.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8a38\"\u003e@OptIn(ExperimentalMaterial3AdaptiveApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun App(\u003cbr/\u003e    widthSizeClass: WindowWidthSizeClass\u003cbr/\u003e) {\u003cbr/\u003e    // Perform logic on the size class to decide whether to show navigation rail or not.\u003cbr/\u003e    val isExpanded = windowSizeClass == WindowWidthSizeClass.EXPANDED\u003cp\u003e    Row {\u003cbr/\u003e        if (isExpanded) {\u003cbr/\u003e            NavigationRail {\u003cbr/\u003e                NavigationRailItem(\u003cbr/\u003e                    /* ... */\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        DefaultNavGraph(/* ... */)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dd50\"\u003e2. The second one is that we have access to \u003cstrong\u003eNavigationSuiteScaffold \u003cem\u003ewhich simplifies the navigation UI decision logic for us, based on window-size.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"1c6f\"\u003eIt shows the \u003cstrong\u003ebottom navigation bar\u003c/strong\u003e \u003cstrong\u003eif the windowsize is in a compact or in a table-top (horizontal) position\u003c/strong\u003e, \u003cstrong\u003eand it shows navigation rail for everything else.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"92a3\"\u003eFor what screen-size, which navigation layout is best ?\u003c/h2\u003e\u003cp id=\"d963\"\u003eAs per Material Design guidelines, window size class\u003c/p\u003e\u003cul\u003e\u003cli id=\"1657\"\u003e\u003cstrong\u003eCompact (Width \u0026lt; 600 dp): Use Navigation bar, modal navigation drawer\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"f5da\"\u003e\u003cstrong\u003eMedium (600 dp≤ width \u0026lt; 840 dp): Use Navigation rail, modal navigation drawer\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"10db\"\u003e\u003cstrong\u003eExpanded (840 ≤ width \u0026lt; 1200*): Use Navigation rail, modal or standard navigation drawer (for expanded use 2 pane layout if you use list-detail screen by using \u003c/strong\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive/list-detail#implement_ui_pattern_with_listdetailpanescaffold\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eListDetailPaneScaffold\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"b1a2\"\u003eNote: ListDetailPaneScaffold is from a material-adaptive library which is currently in alpha, and it also is not supporting Navigation compose yet, for view-based app use \u003ca href=\"https://developer.android.com/develop/ui/views/layout/twopane\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eSlidingPaneLayout\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"0d75\"\u003eLet’s see a real world demo\u003c/h2\u003e\u003cp id=\"e4bc\"\u003eAs I already mentioned, by using \u003cstrong\u003eNavigationSuiteScaffold\u003c/strong\u003e, it really simplifies our work. \u003cstrong\u003eWe don’t need to write a logic based on window-size-class ourselves.\u003c/strong\u003e It does for us out of the box. Let’s get into a demo. Next, \u003cstrong\u003ewe also learn how to manually show navigation layout based on window-size-classes.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"aaf0\"\u003eWhat do we build??\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eNavigationSuiteScaffold app demo\u003c/strong\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ba58\"\u003eIn this app we don’t focus on the content of the screen, instead just showing the text that displays, our current destination. Our goal is just displaying a navigation layout based on window-size.\u003c/p\u003e\u003cp id=\"8432\"\u003eLet’s implement it:\u003c/p\u003e\u003cp id=\"527a\"\u003eAs we already added the required dependency, which is navigation-suite from material 3, so let’s focus on code.\u003c/p\u003e\u003cp id=\"bde2\"\u003e\u003cem\u003eFor our top level destinations, I added an enum class. For that, here is that code.\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1c4c\"\u003eenum class AppDestinations(\u003cbr/\u003e    @StringRes val label: Int,\u003cbr/\u003e    val icon: ImageVector,\u003cbr/\u003e    @StringRes val contentDescription: Int\u003cbr/\u003e) {\u003cbr/\u003e    HOME(R.string.home, Icons.Default.Home, R.string.home),\u003cbr/\u003e    DRAWING(R.string.draw, Icons.Default.Draw, R.string.draw),\u003cbr/\u003e    EDIT(R.string.edit, Icons.Default.Edit, R.string.edit),\u003cbr/\u003e    SETTINGS(R.string.profile, Icons.Default.Person, R.string.settings),\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d44b\"\u003eAnd let’s call the \u003cstrong\u003eNavigationSuiteScaffold \u003c/strong\u003eand pass the \u003cem\u003enecessary arguments\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"16d5\"\u003eAs you can see the code how easy it is to implement the navigation layout based on window-size class \u003cstrong\u003ewhen we use NavigationSuiteScaffold, we don’t need to write. Single conditional statement for the window-size class\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7103\"\u003eIf you want, we can further customize it. If you want to show other navigation layout based on window-size, you can do so by passing another parameter in NavigationSuiteScaffold named \u003cstrong\u003elayoutType\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1ff9\"\u003eval adaptiveInfo = currentWindowAdaptiveInfo()\u003cp\u003e\t\t\t/* Optional */\u003cbr/\u003e    val customNavSuiteType = with(adaptiveInfo) {\u003cbr/\u003e        if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) {\u003cbr/\u003e            NavigationSuiteType.NavigationRail\u003cbr/\u003e        } else {\u003cbr/\u003e            NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b5ab\"\u003eHere we customize the navigation layout based on the window class. \u003cstrong\u003eIf we are currently on the EXPANDED screen, we show the navigation rail instead of the default navigation bar\u003c/strong\u003e, our layout screen is considered as an EXPANDED if the below criteria meet:\u003c/p\u003e\u003cul\u003e\u003cli id=\"051d\"\u003ePhone in landscape\u003c/li\u003e\u003cli id=\"4d7f\"\u003eTablet in landscape\u003c/li\u003e\u003cli id=\"cb33\"\u003eFoldable in landscape (unfolded state)\u003c/li\u003e\u003cli id=\"2240\"\u003eDesktop (Chrome OS)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4ccc\"\u003eNow we have learned how to work with NavigationSuiteScaffold. Now let’s move on to more customized option.\u003c/p\u003e\u003ch2 id=\"f75c\"\u003eHandling navigation layout decisions ourselves by using Window-Size-Classes\u003c/h2\u003e\u003cp id=\"3866\"\u003eNow let’s explore how to handle navigation layout based on Window-Size-Class ourselves.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ffc1\"\u003eAs you can see in the code, \u003cstrong\u003ewe conditionally show Navigation Rail based on screen-size\u003c/strong\u003e by using\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ed33\"\u003eval isExpanded = widthSizeClass == WindowWidthSizeClass.EXPANDED\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4d60\"\u003eLet’s call this function in \u003cstrong\u003eMainActivity.kt\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b221\"\u003eYourAppTheme{\u003cbr/\u003e    val windowWidthSizeClass = currentWindowAdaptiveInfo().windowSizeClass\u003cbr/\u003e    OsbApp(windowWidthSizeClass.windowWidthSizeClass) // here we using Width Size class.\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a328\"\u003eWhen you run the app it shows an appropriate navigation layout based on widow-size\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eConditionally show a navigation layout based on window-size.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"969b\"\u003eThe source code of the \u003cstrong\u003eNavigationSuiteScaffold \u003c/strong\u003edemo is available on this repository:\u003c/p\u003e\u003cp id=\"4a34\"\u003eIn this article, we learned \u003cem\u003ehow to provide the best user-experience on larger screen sizes and also learned its use cases.\u003c/em\u003e I hope you will like this article. If so, please applause this story and share it with your friends and family. And i will see you in the next upcoming article with an interesting topic.\u003c/p\u003e\u003cp id=\"2a46\"\u003eSigning off, \u003ca href=\"https://nativemb.github.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMubarak.M Basha\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-06-29T16:10:48.355Z",
  "modifiedTime": null
}
