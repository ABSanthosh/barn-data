{
  "id": "4e2766e3-3f95-4be0-b7e9-c88c80fe20c6",
  "title": "Public secrets exposure leads to supply chain attack on GitHub CodeQL",
  "link": "https://www.praetorian.com/blog/codeqleaked-public-secrets-exposure-leads-to-supply-chain-attack-on-github-codeql/",
  "description": "Comments",
  "author": "",
  "published": "Sun, 30 Mar 2025 19:54:46 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Harry Hayward",
  "length": 21435,
  "excerpt": "An exposed GitHub token could have been used to launch a supply chain attack on GitHub CodeQL, resulting in source code exposure and repository tampering of CodeQL users.",
  "siteName": "Praetorian",
  "favicon": "https://www.praetorian.com/wp-content/uploads/2024/06/cropped-cropped-Praetorian-Favicon-192x192.png",
  "text": "A potential supply chain attack on GitHub CodeQL started simply: a publicly exposed secret, valid for 1.022 seconds at a time. In that second, an attacker could take a series of steps that would allow them to execute code within a GitHub Actions workflow in most repositories using CodeQL, GitHub’s code analysis engine trusted by hundreds of thousands of repositories. The impact would reach both public GitHub (GitHub Cloud) and GitHub Enterprise. If backdooring GitHub Actions sounds familiar, that’s because it’s exactly what threat actors did in the recent tj-actions/changed-files supply chain attack. Imagine that very same supply chain attack, but instead of backdooring actions in tj-actions, they backdoored actions in GitHub CodeQL. An attacker could use this to: Compromise intellectual property by exfiltrating the source code of private repositories using CodeQL. Steal credentials within GitHub Actions secrets of workflow jobs using CodeQL and leverage those secrets to execute further supply chain attacks. Execute code on internal infrastructure running CodeQL workflows. Compromise GitHub Actions secrets of workflows using the GitHub Actions Cache within a repo that uses CodeQL. This is the story of how we uncovered an exposed secret leading to a race condition, a potential supply chain attack, and CVE-2025-24362. Note: Per GitHub’s advisory, they have found no evidence of compromise to its platform or systems. How Did We Get Here? In January 2025, I took a break from Praetorian’s Red Team and began three months of research. I aimed to push the limits of public GitHub Actions exploitation, building on presentations we’ve given at Black Hat, DEF CON, Schmoocon, and Black Hat Arsenal. Tools and takeaways from this research will be implemented in our CI/CD Professional Services Engagements, and into Chariot, our Continuous Threat Exposure Management platform. I began my research rotation by scanning GitHub Actions workflow artifacts for secrets. Secret Scanning In August 2024, Palo Alto researcher Yaron Avital published an article about identifying secrets in workflow artifacts. I had a hunch that there were still secrets to be found, especially since there hadn’t been much public follow-up work since the article. I built a simple Actions Artifacts Secret Scanner to get started. It downloads artifacts from GitHub Actions workflows, recursively extracts their contents, and scans their contents for secrets with Nosey Parker, Praetorian’s open-sourced secrets scanning tool. The Actions Artifacts Secret Scanner has been integrated into Chariot and open-sourced as a Gato capability. After running this scanner for one day, it found a secret that could lead to a supply chain attack on GitHub CodeQL. But first, I needed to see if the key was usable. Background CI/CD vulnerabilities sound complicated until you understand the terminology. Let’s catch you up. GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows the execution of code specified within workflows as part of the CI/CD process. When you push code to a GitHub repository or create a pull request, GitHub Actions can automatically build, test, and deploy your code using workflows defined in YAML files. For example, let’s say you are building a web application that is hosted in AWS. You can configure a GitHub Actions workflow so that whenever you push code to your repository, it is automatically tested and then deployed to AWS. If you are new to GitHub Actions, we’d recommend reading through some examples. Every workflow run generates a GITHUB_TOKEN — a special, automatically generated GitHub App installation token that allows the workflow to interact with the repository. This token’s permissions can be configured in the workflow file, at the repository level, or at the org level, determining what actions it can perform within the repository. Put simply: GitHub workflows execute on GitHub runners (typically a VM or Docker containers). GitHub runners need a way to authenticate to GitHub to do stuff the workflows tell them to do. For that purpose, they use the GITHUB_TOKEN. If the token has high privileges, then token compromise == bad. What are Workflow Artifacts? We found the publicly exposed secret in a GitHub Actions workflow artifact. GitHub Actions workflows can upload workflow “artifacts” to GitHub Actions. Workflow artifacts can be any file and are saved by that workflow for later use. By default, artifacts are publicly accessible to anyone with read access to the repository and are stored for up to 90 days. And Finally, What is CodeQL? CodeQL is GitHub’s Code Analysis Engine. The CodeQL actions perform static code analysis on GitHub repositories to try and identify vulnerabilities. They have found several hundred CVEs over it’s lifetime, protecting organizations from breaches. Security tools, like CodeQL, often need access to sensitive systems and data, making them an attractive target to an attacker. If CodeQL was compromised, one of the most widely used security tools now becomes a backdoor. Finding the Token After running the Actions Artifact Secrets Scanner for a day, it picked up a token in a github/codeql-action repository artifact published by this run. The Actions Artifact Secrets Scanner downloaded the “my-debug-artifacts” zip uploaded by the “PR Check – Debug artifacts after failure” workflow, recursively extracted the “my-db-java-partial.zip” file stored inside, and ran Nosey Parker. Within seconds, Nosey Parker flagged a GitHub Token starting with “ghs_” in a crash report. Investigating manually, I confirmed this was a GitHub App token installation token stored in a file containing the environment variables of the GitHub Runner executing the workflow. Investigating Impact Secrets compromise is cool, but what can we do with this token? The impact of a compromisedGITHUB_TOKEN is minimal if it only has read permissions. The easiest way to determine the privileges of a GITHUB_TOKEN is to look at workflow logs. To investigate this, I navigated to the “Setup Job” step of the workflow that uploaded the token. The GitHub token had full write privileges. We could spend a lot of time talking about each privilege, but let’s focus on the ones that are particularly interesting. Contents: write – Allows the token to create branches, create tags, and upload release artifacts.Actions: write – Allows you to work with Actions, including trigger workflow_dispatch events.Packages: write – Allows the token to upload packages. With these privileges, an attacker has a lot of potential for repository tampering, but there is still one issue. These tokens are only valid for the duration of their specific workflow job. That means that once the job is over, the token is useless. Three things needed to happen for an attacker to be able to abuse this token: The token needs to have some sort of write privileges (already confirmed). The token needs to use V4 of the upload artifact API, as that is the only version that allows you to retrieve an artifact before the job is complete (and after the job is complete, the token is invalid.) The time between uploading the artifact and completing the job needs to be great enough for us to download, extract, and use the token. If all of these conditions are met, this publicly exposed token could be used to launch a full scale supply chain attack on CodeQL. This was like finding out that the security guard was accidentally leaving their master key in plain sight for a brief moment, over and over again. We had to determine if the guard left us enough time to steal the key and use it before they returned to their post. Let’s investigate further. Tick, tock. Determining the Artifact Upload Version Identifying the artifact upload version is typically straightforward. If a workflow usesactions/upload-artifact@v4***, we can retrieve the artifact before job completion. If it uses an earlier version, we cannot do so. In this case, CodeQL wasn’t using the actions/upload-artifact action; they were manually using the upload artifact client in the source code. Code comments indicated it used version 4. That was enough for me to continue. Now we needed to determine if the job lasted long enough for us to retrieve and use the token. Calculating our Execution Time Looking at the raw GitHub logs for this workflow, we can see two key timestamps: “Finalizing artifact upload” occurred at 17:22:09:888. The final step in the job, “Cleaning up orphan processes”, happened at 17:22:10:911. That means we had approximately 1.022 seconds to download the artifact, extract the GitHub token, and use it. I noticed the token stayed valid for about a second after the “Cleaning up orphan processes” step, so we’ll call it two seconds. The guard was giving us two seconds to steal the key and use it before they returned.Is that enough time for an attacker to use this token? Or is this another theoretical vulnerability? Start Your Engines To test this, I made a Python script artifact_racer.py. Artifact racer performs the following actions. Continuously queries the github/codeql-action GitHub repository until it sees a “PR Check – Debug artifacts after failure” workflow begin. Monitors the running workflow for artifacts. Once it sees a “PR Check – Debug artifacts after failure” workflow run, it downloads the artifact and extracts the GITHUB_TOKEN. Shelling out for file operations and downloads was key to increasing the speed, although there are probably ways to make it even faster. Uses the GITHUB_TOKEN to make a new branch. Use the GITHUB_TOKEN to push an empty file named poc.txt to that branch. Makes a new tag for that commit. If I could make a new branch, add a file, and create a tag for that commit, that would prove an attacker could use the token for nefarious purposes before it expired. Given that the workflow artifact was only ~21MBs, I thought we had a chance. After successfully executing against a test repository, I moved on to the github/codeql-action repository. Executing the Proof of Concept I ran the racer. And then I waited. About two hours later, a “PR Check – Debug artifacts after failure” workflow executed. The racer successfully retrieved the GITHUB_TOKEN, created the branch, pushed the file, and added the tag. Branch URL: https://github.com/github/codeql-action/tree/testpocCommit URL: https://github.com/github/codeql-action/commit/26fcd8e2368067be04a705a229590749a426fefeTag URL: https://github.com/github/codeql-action/releases/tag/testpoctag The ability to create a tag becomes very important in this attack. Keep that in mind as we go. After confirming the GITHUB_TOKEN could be used within the short time window, we responsibly disclosed this vulnerability to GitHub. What if You’re Still Not Impressed? Using the GITHUB_TOKEN, an attacker could add malicious code to any unprotected branch. A covert tactic would be to target feature branches pre-merge, smuggle in a small malicious code change, and wait for it to get merged. This would be especially effective due to how frequently the GitHub Actions bot commits to the CodeQL Actions repository. They could also add tags that point to specific commits. For example, if they had malicious code on a branch and then added a v3 tag, anyone who manually used codeql-action…@v3 would execute the malicious code. More on this later. Through code execution, you’d be able to compromise any GitHub Actions secret used within that job, as well as exfiltrate the source code of that repository. If their actions were executing on internal infrastructure, which is common with self-hosted GitHub runners, you’d also have code execution on their internal network or cloud environment. The impact from this attack would have been very similar to the recent tj-actions/changed-files supply chain attack. This impact is impressive, but it doesn’t quite live up to the claims I made in the beginning. Yes, through these paths, they could launch a supply chain attack against repos manually using the CodeQL actions. However, most organizations don’t include these actions manually. They just go into their repository settings, click “Enable CodeQL”, and go from there. At first, I assumed that enabling CodeQL in your repository didn’t interact with the github/codeql-action repository at all. I was wrong. Exponential Impact After discussing this issue with some colleagues, I decided to investigate further. What actually happens when you enable CodeQL? This section is key to understanding the full impact of this vulnerability. Stick with me. To investigate, I created my own public repository, “John’s Top Secret Repo”, and enabled CodeQL. After you enable CodeQL with the default settings, a special GitHub Actions workflow runs in your repository. This CodeQL action won’t show up in your repository workflows, but you can navigate to the workflow logs to see what it is doing. Enabling CodeQL in your repository settings. Observing the CodeQL workflow. Based on my observations, CodeQL: Checks out your repository to the filesystem Initializes CodeQL Runs CodeQL scans Uploads the scan results Let’s take a closer look at step 3. If this doesn’t shock you, look again. Remember that we have the ability to push tags to the github/codeql-action repository. CodeQL, under the hood, is executing the actions in the github/codeql-action repository, using the commit referenced by the v3 tag. This tag was not immutable, and they were not using workflow pinning (which GitHub recommends), which meant that an attacker could overwrite the v3 tag using the compromised GITHUB_TOKEN. Now, if an attacker removed and then added a v3 tag to their malicious commit, every single repository using the default CodeQL workflow would execute their malicious code. The Action created when selecting “Advanced CodeQL” also used the reusable github/codeql-action with the v3 tag. The CodeQL actions check out the source code of every repository they run on, which means that a malicious CodeQL action could exfiltrate the source code of any repository using default CodeQL configurations. This would result in significant disclosure of intellectual property. And if you’ve ever operated on a Red Team, you know how many hardcoded secrets are lying around in private source code repositories. But Wait, There’s More We’re almost done. But remember, I promised one more thing: 4. Compromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL When assessing the impact of CI/CD attack paths, I look for ways to compromise GitHub Actions secrets. Usually, those secrets are where the crown jewels live. If the CodeQL action is executing with write privileges or alongside GitHub Actions secrets, then it’s trivial to use the code execution to exfiltrate those secrets. But the default CodeQL action uses a GITHUB_TOKEN that only has read privileges, so you can’t perform repository write operations, backdoor releases, or use fancy workflow dispatch events to steal secrets, like what happened with PyTorch. What the default CodeQL action does do is execute in the main branch of the repository. The main branch of any GitHub repository can write cache entries that will be used by the entire repo. This opens up an opportunity to conduct GitHub Actions cache poisoning. GitHub Actions Cache Poisoning is thoroughly explained in this article by Adnan Khan, which documents the discovery and exploitation of cache poisoning. The easiest way to conduct GitHub Actions cache poisoning is by deploying Cacheract, malware that persists in a build pipeline through cache poisoning. If an attacker deployed Cacheract in the CodeQL workflow, it would: Predict cache entries Overwrite these entries with a malicious action Gain code execution within any workflow that uses action-cache (the Actions Cache is used by most repositories) Leverage code execution to compromise GitHub Actions secrets used by those workflows, capture privileged GITHUB_TOKENs, and more Even if someone noticed the malicious CodeQL action and remediated the vulnerability, Cacheract would continue poisoning caches. I spent ten minutes looking for prominent repos that use CodeQL \u0026 actions/cache and identifiedHomebrew, Angular, and Grafana. Cache poisoning would allow an attacker to leverage this CodeQL supply chain attack to gain write access to repositories and repository secrets. Congratulations, You Made It We’ve now hit all the impact highlights I mentioned at the beginning: Compromise intellectual property by exfiltrating the source code of all private repositories using CodeQL. Steal credentials within GitHub Actions secrets of any workflow job using CodeQL, and leverage those secrets to execute further supply chain attacks. Execute code on internal infrastructure running CodeQL workflows. Compromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL. Supply chain attacks like these are scary, especially when they start with something as simple as a publicly exposed credential. If this is your first time hearing about abusing GitHub Actions to launch supply chain attacks, I’ll let you in on a secret: these vulnerabilities occur all the time. GitHub Actions abuse has been around for several years, but it is still one of the highest-impact, least-understood vulnerability classes. That is slowly starting to change (emphasis on ~slowly~). The DevOps and security communities need to commit to learning about these vulnerabilities to protect their organizations from risk. Vulnerabilities like this, and the recent tj-actions/changed-files supply chain attack, are starting to bring these issues to the public spotlight. That is why we invest in research to uncover these vulnerabilities and design solutions to prevent them. CVE-2025-24362 A side-effect of this disclosure was CVE-2025-24362. The publicly exposed GITHUB_TOKEN was within a debug artifact uploaded by the CodeQL Action after a failed code scanning workflow. The CodeQL Actions repository was intentionally triggering this failure, but other users of CodeQL Actions could have exposed their own secrets as environment variables to the workflow, had their workflows experienced a similar failure. This issue was fixed in CodeQL Action version 3.28.3. Even though this disclosure resulted in a CVE, the highest potential impact still lies in exploiting that vulnerability against the CodeQL Actions repository and launching a supply chain attack against CodeQL users. Remediation GitHub had one of the most rapid and impressive remediation responses we have ever seen. Jan 22, 2025, 3:13 PM UTC: Report Submitted to GitHubJan 22, 2025, 5:48 PM UTC: GitHub acknowledged receipt of the submissionJan 22, 2025, 6:28 PM UTC: GitHub confirmed the vulnerability, temporarily disabled the “PR Check – Debug artifacts after failure” workflow, and submitted this PR to disable debug artifacts upload. This occurred just three hours after submitting the report, which is a very rapid resolution time.Jan 24, 2025: GitHub assigned CVE-2025-24362 and published this security advisory, which notes they found no evidence of compromise to its platform or systems. If you are concerned about you’re own GitHub Actions workflow artifacts, you can take the following steps to limit the risk of secrets exposure: ideally, only upload specific files or directories as workflow artifacts avoid uploading artifacts containing environment variables, the .git/config file, or any files in the runner’s \u003cpath_to_runner_dir\u003e/_work/_temp/ directory limit GITHUB_TOKEN permissions to read-only scan artifacts for secrets prior to uploading To learn more about this vulnerability, how I discovered it, and how you can detect similar vulnerabilities in your own environment, please join me for a webinar on April 10 at 1pm ET. How Can Praetorian Help Praetorian has been leading the charge in offensive CI/CD security for several years, inventing novel tooling and giving presentations at Black Hat, DEF CON, Schmoocon, and Black Hat Arsenal. Our Continuous Threat Exposure Management (CTEM) platform, Chariot, can identify vulnerabilities like this in your attack surface before the attackers do. Our CI/CD Security Assessments can take an in-depth look at your internal CI/CD security posture, enumerating attack paths that an attacker would exploit to go from low-privileged access to complete organization compromise. The next major supply chain attack could start with something as simple as a publicly exposed secret. Help make sure that doesn’t happen by learning about CI/CD vulnerabilities and implementing continuous controls to protect your organization from compromise. You can create a free Chariot account anytime. Alternatively, if you’re interested in our managed Chariot offering, reach out to speak with our team.",
  "image": "https://www.praetorian.com/wp-content/uploads/2025/03/codeQL-social-web.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-id=\"887d2a1\" data-element_type=\"container\" data-widget_type=\"theme-post-content.default\"\u003e\n\t\t\t\t\t\n\u003cp\u003eA potential supply chain attack on GitHub CodeQL started simply: a publicly exposed secret, valid for 1.022 seconds at a time.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn that second, an attacker could take a series of steps that would allow them to execute code within a GitHub Actions workflow in most repositories using CodeQL, GitHub’s code analysis engine trusted by hundreds of thousands of repositories. The impact would reach both public GitHub (GitHub Cloud) and GitHub Enterprise.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf backdooring GitHub Actions sounds familiar, that’s because it’s exactly what threat actors did in the recent tj-actions/changed-files supply chain attack. Imagine that very same supply chain attack, but instead of backdooring actions in tj-actions, they backdoored actions in GitHub CodeQL.\u003c/p\u003e\n\n\n\n\u003cp\u003eAn attacker could use this to:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eCompromise intellectual property\u003c/strong\u003e by exfiltrating the source code of private repositories using CodeQL.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSteal credentials within GitHub Actions secrets\u003c/strong\u003e of workflow jobs using CodeQL and leverage those secrets to execute further supply chain attacks.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eExecute code on internal infrastructure\u003c/strong\u003e running CodeQL workflows.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eCompromise GitHub Actions secrets\u003c/strong\u003e of workflows using the GitHub Actions Cache within a repo that uses CodeQL.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThis is the story of how we uncovered an exposed secret leading to a race condition, a potential supply chain attack, and CVE-2025-24362.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eNote: Per \u003ca href=\"https://github.com/advisories/GHSA-vqf5-2xx6-9wfm\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eGitHub’s advisory\u003c/a\u003e, they have found no evidence of compromise to its platform or systems.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow Did We Get Here?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn January 2025, I took a break from Praetorian’s \u003ca href=\"https://www.praetorian.com/services/red-team/\"\u003eRed Team\u003c/a\u003e and began three months of research. I aimed to push the limits of public GitHub Actions exploitation, building on presentations we’ve given at \u003ca href=\"https://johnstawinski.com/wp-content/uploads/2024/08/us24-khan-stawinski-self-hosted-github-cicd-runners-continuous-integration-continuous-destruction.pdf\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eBlack Hat\u003c/a\u003e, \u003ca href=\"https://www.youtube.com/watch?v=5P7KatZBr_I\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eDEF CON\u003c/a\u003e, \u003ca href=\"https://www.praetorian.com/blog/introducing-gato-for-ci-cd-exploitation/\"\u003eSchmoocon\u003c/a\u003e, and Black Hat Arsenal. Tools and takeaways from this research will be implemented in our \u003ca href=\"https://www.praetorian.com/services/ci-cd-security-engagement/\"\u003eCI/CD Professional Services Engagements\u003c/a\u003e, and into \u003ca href=\"https://www.praetorian.com/chariot/\"\u003eChariot\u003c/a\u003e, our Continuous Threat Exposure Management platform.\u003c/p\u003e\n\n\n\n\u003cp\u003eI began my research rotation by scanning GitHub Actions workflow artifacts for secrets.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSecret Scanning\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn August 2024, Palo Alto researcher Yaron Avital \u003ca href=\"https://unit42.paloaltonetworks.com/github-repo-artifacts-leak-tokens/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003epublished an article\u003c/a\u003e about identifying secrets in workflow artifacts. I had a hunch that there were still secrets to be found, especially since there hadn’t been much public follow-up work since the article.\u003c/p\u003e\n\n\n\n\u003cp\u003eI built a simple Actions Artifacts Secret Scanner to get started. It downloads artifacts from GitHub Actions workflows, recursively extracts their contents, and scans their contents for secrets with \u003ca href=\"https://github.com/praetorian-inc/noseyparker\"\u003eNosey Parker\u003c/a\u003e, Praetorian’s open-sourced secrets scanning tool.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Actions Artifacts Secret Scanner has been integrated into Chariot and open-sourced as a \u003ca href=\"https://github.com/praetorian-inc/gato\"\u003eGato\u003c/a\u003e capability.\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter running this scanner for one day, it found a secret that could lead to a supply chain attack on GitHub CodeQL.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut first, I needed to see if the key was usable.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBackground\u003c/h2\u003e\n\n\n\n\u003cp\u003eCI/CD vulnerabilities sound complicated until you understand the terminology. Let’s catch you up.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows the execution of code specified within workflows as part of the CI/CD process. When you push code to a GitHub repository or create a pull request, GitHub Actions can automatically build, test, and deploy your code using workflows defined in YAML files.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, let’s say you are building a web application that is hosted in AWS. You can configure a GitHub Actions workflow so that whenever you push code to your repository, it is automatically tested and then deployed to AWS.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eIf you are new to GitHub Actions, we’d recommend reading through \u003ca href=\"https://docs.github.com/en/actions/writing-workflows/quickstart\" target=\"_blank\" rel=\"noreferrer noopener\"\u003esome examples\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eEvery workflow run generates a GITHUB_TOKEN\u003c/em\u003e\u003c/strong\u003e — a special, automatically generated GitHub App installation token that allows the workflow to interact with the repository. This token’s permissions can be configured in the workflow file, at the repository level, or at the org level, determining what actions it can perform within the repository.\u003c/p\u003e\n\n\n\n\u003cp\u003ePut simply:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eGitHub workflows execute on GitHub runners (typically a VM or Docker containers).\u003c/li\u003e\n\n\n\n\u003cli\u003eGitHub runners need a way to authenticate to GitHub to do stuff the workflows tell them to do.\u003c/li\u003e\n\n\n\n\u003cli\u003eFor that purpose, they use the GITHUB_TOKEN.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cbr/\u003e\u003cstrong\u003eIf the token has high privileges, then token compromise == bad.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhat are Workflow Artifacts?\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe found the publicly exposed secret in a \u003ca href=\"https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eGitHub Actions workflow artifact\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub Actions workflows can upload workflow “artifacts” to GitHub Actions. Workflow artifacts can be any file and are saved by that workflow for later use. By default, artifacts are publicly accessible to anyone with read access to the repository and are stored for up to 90 days.\u003c/p\u003e\n\n\n\n\u003ch3\u003eAnd Finally, What is CodeQL?\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://codeql.github.com/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCodeQL\u003c/a\u003e is GitHub’s Code Analysis Engine. The CodeQL actions perform static code analysis on GitHub repositories to try and identify vulnerabilities. They have found \u003ca href=\"https://securitylab.github.com/codeql-wall-of-fame/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eseveral hundred CVEs\u003c/a\u003e over it’s lifetime, protecting organizations from breaches.\u003c/p\u003e\n\n\n\n\u003cp\u003eSecurity tools, like CodeQL, often need access to sensitive systems and data, making them an attractive target to an attacker.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf CodeQL was compromised, one of the most widely used security tools now becomes a backdoor.\u003c/p\u003e\n\n\n\n\u003ch2\u003eFinding the Token\u003c/h2\u003e\n\n\n\n\u003cp\u003eAfter running the Actions Artifact Secrets Scanner for a day, it picked up a token in a \u003ca href=\"https://github.com/github/codeql-action\"\u003egithub/\u003c/a\u003e\u003ca href=\"https://github.com/github/codeql-action\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ecodeql-action\u003c/a\u003e repository artifact published by \u003ca href=\"https://github.com/github/codeql-action/actions/runs/12901573957\"\u003ethis \u003c/a\u003e\u003ca href=\"https://github.com/github/codeql-action/actions/runs/12901573957\" target=\"_blank\" rel=\"noreferrer noopener\"\u003erun\u003c/a\u003e. The Actions Artifact Secrets Scanner downloaded the “my-debug-artifacts” zip uploaded by the “\u003ca href=\"https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml\"\u003ePR Check – Debug \u003c/a\u003e\u003ca href=\"https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eartifacts\u003c/a\u003e\u003ca href=\"https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml\"\u003e after failure\u003c/a\u003e” workflow, recursively extracted the “my-db-java-partial.zip” file stored inside, and ran Nosey Parker. Within seconds, Nosey Parker flagged a GitHub Token starting with “ghs_” in a crash report.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture fetchpriority=\"high\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-300x130.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-768x332.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56.png.webp 1072w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg fetchpriority=\"high\" decoding=\"async\" width=\"1024\" height=\"443\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png\" alt=\"Finding the Token\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-300x130.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-768x332.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56.png 1072w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20443\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-300x130.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-768x332.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56.png 1072w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eInvestigating manually, I confirmed this was a GitHub App token installation token stored in a file containing the environment variables of the GitHub Runner executing the workflow.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eInvestigating Impact\u003c/h2\u003e\n\n\n\n\u003cp\u003eSecrets compromise is cool, but what can we do with this token? The impact of a compromised\u003cbr/\u003e\u003cem\u003eGITHUB_TOKEN\u003c/em\u003e is minimal if it only has read permissions.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe easiest way to determine the privileges of a \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e is to look at workflow logs. To investigate this, I navigated to the “Setup Job” step of the workflow that uploaded the token.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-300x251.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-768x643.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13.png.webp 1364w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg decoding=\"async\" width=\"1024\" height=\"857\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png\" alt=\"Investigating Impact\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-300x251.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-768x643.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13.png 1364w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20857\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-300x251.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-768x643.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13.png 1364w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eThe GitHub token had full write privileges.\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eWe could spend a lot of time talking about \u003ca href=\"https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token\"\u003eeach privilege\u003c/a\u003e, but let’s focus on the ones that are particularly interesting.\u003c/p\u003e\n\n\n\n\u003cp\u003eContents: write – Allows the token to create branches, create tags, and upload release artifacts.\u003cbr/\u003eActions: write – Allows you to work with Actions, including trigger workflow_dispatch events.\u003cbr/\u003ePackages: write – Allows the token to upload packages.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith these privileges, an attacker has a lot of potential for repository tampering, but there is still one issue. These tokens are only valid for the duration of their specific workflow job. That means that once the job is over, the token is useless. Three things needed to happen for an attacker to be able to abuse this token:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eThe token needs to have some sort of write privileges (already confirmed).\u003c/li\u003e\n\n\n\n\u003cli\u003eThe token needs to use V4 of the upload artifact API, as that is the only version that allows you to retrieve an artifact before the job is complete (and after the job is complete, the token is invalid.)\u003c/li\u003e\n\n\n\n\u003cli\u003eThe time between uploading the artifact and completing the job needs to be great enough for us to download, extract, and use the token.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eIf all of these conditions are met, this publicly exposed token could be used to launch a full scale supply chain attack on CodeQL. This was like finding out that the security guard was accidentally leaving their master key in plain sight for a brief moment, over and over again.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe had to determine if the guard left us enough time to steal the key and use it before they returned to their post.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s investigate further. Tick, tock.\u003c/p\u003e\n\n\n\n\u003ch3\u003eDetermining the Artifact Upload Version\u003c/h3\u003e\n\n\n\n\u003cp\u003eIdentifying the artifact upload version is typically straightforward. If a workflow uses\u003cbr/\u003eactions/upload-artifact@v4***, we can retrieve the artifact before job completion. If it uses an earlier version, we cannot do so.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this case, CodeQL wasn’t using the \u003ca href=\"https://github.com/actions/upload-artifact\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eactions/upload-artifact\u003c/a\u003e action; they were manually using the upload artifact client in the source code. Code comments indicated it used version 4. That was enough for me to continue.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow we needed to determine if the job lasted long enough for us to retrieve and use the token.\u003c/p\u003e\n\n\n\n\u003ch3\u003eCalculating our Execution Time\u003c/h3\u003e\n\n\n\n\u003cp\u003eLooking at the raw GitHub logs for this workflow, we can see two key timestamps:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-300x65.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-768x166.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08.png.webp 1350w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg decoding=\"async\" width=\"1024\" height=\"221\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png\" alt=\"Calculating our Execution Time\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-300x65.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-768x166.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08.png 1350w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20221\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-300x65.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-768x166.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08.png 1350w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e“Finalizing artifact upload” occurred at 17:22:09:888.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe final step in the job, “Cleaning up orphan processes”, happened at 17:22:10:911.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat means we had approximately 1.022 seconds to download the artifact, extract the GitHub token, and use it. I noticed the token stayed valid for about a second after the “Cleaning up orphan processes” step, so we’ll call it two seconds.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe guard was giving us two seconds to steal the key and use it before they returned.\u003cbr/\u003eIs that enough time for an attacker to use this token? Or is this another theoretical vulnerability?\u003c/p\u003e\n\n\n\n\u003ch2\u003eStart Your Engines\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo test this, I made a Python script \u003cem\u003eartifact_racer.py\u003c/em\u003e. Artifact racer performs the following actions.\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eContinuously queries the \u003cem\u003egithub/codeql-action\u003c/em\u003e GitHub repository until it sees a “PR Check – Debug artifacts after failure” workflow begin.\u003c/li\u003e\n\n\n\n\u003cli\u003eMonitors the running workflow for artifacts.\u003c/li\u003e\n\n\n\n\u003cli\u003eOnce it sees a “PR Check – Debug artifacts after failure” workflow run, it downloads the artifact and extracts the \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e.\n\u003cul\u003e\n\u003cli\u003eShelling out for file operations and downloads was key to increasing the speed, although there are probably ways to make it even faster.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eUses the \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e to make a new branch.\u003c/li\u003e\n\n\n\n\u003cli\u003eUse the \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e to push an empty file named \u003ccode\u003epoc.txt\u003c/code\u003e to that branch.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eMakes a new tag\u003c/strong\u003e for that commit.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eIf I could make a new branch, add a file, and create a tag for that commit, that would prove an attacker could use the token for nefarious purposes before it expired.\u003c/p\u003e\n\n\n\n\u003cp\u003eGiven that the workflow artifact was only ~21MBs, I thought we had a chance. After successfully executing against a test repository, I moved on to the \u003ca href=\"https://github.com/github/codeql-action\"\u003egithub/codeql-action\u003c/a\u003e repository.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg loading=\"lazy\" loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"429\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png\" alt=\"\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-300x126.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-768x322.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1536x644.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11.png 1728w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20429\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-300x126.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-768x322.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1536x644.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11.png 1728w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png\"/\u003e\u003c/figure\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eExecuting the Proof of Concept\u003c/h2\u003e\n\n\n\n\u003cp\u003eI ran the racer.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd then I waited.\u003c/p\u003e\n\n\n\n\u003cp\u003eAbout two hours later, a “PR Check – Debug artifacts after failure” workflow executed. The racer successfully retrieved the \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e, created the branch, pushed the file, and added the tag.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-300x172.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-768x440.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00.png.webp 1300w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"586\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png\" alt=\"Executing the Proof of Concept\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-300x172.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-768x440.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00.png 1300w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20586\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-300x172.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-768x440.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00.png 1300w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eBranch URL: \u003ca href=\"https://github.com/github/codeql-action/tree/testpoc\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehttps://github.com/github/codeql-action/tree/testpoc\u003c/a\u003e\u003cbr/\u003eCommit URL: \u003ca href=\"https://github.com/github/codeql-action/commit/26fcd8e2368067be04a705a229590749a426fefe\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehttps://github.com/github/codeql-action/commit/26fcd8e2368067be04a705a229590749a426fefe\u003c/a\u003e\u003cbr/\u003eTag URL: \u003ca href=\"https://github.com/github/codeql-action/releases/tag/testpoctag\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehttps://github.com/github/codeql-action/releases/tag/testpoctag\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-300x151.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-768x387.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20.png.webp 1414w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"516\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png\" alt=\"New tag created\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-300x151.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-768x387.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20.png 1414w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20516\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-300x151.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-768x387.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20.png 1414w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eThe ability to create a tag becomes very important in this attack. Keep that in mind as we go.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter confirming the \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e could be used within the short time window, we responsibly disclosed this vulnerability to GitHub.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat if You’re Still Not Impressed?\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eUsing the GITHUB_TOKEN, an attacker could add malicious code to any unprotected branch\u003c/strong\u003e. A covert tactic would be to target feature branches pre-merge, smuggle in a small malicious code change, and wait for it to get merged. This would be especially effective due to how frequently the GitHub Actions bot commits to the CodeQL Actions repository.\u003c/p\u003e\n\n\n\n\u003cp\u003eThey could also add tags that point to specific commits. For example, if they had malicious code on a branch and then added a v3 tag, anyone who manually used codeql-action…@v3 would execute the malicious code. \u003cstrong\u003eMore on this later\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThrough code execution, you’d be able to compromise any GitHub Actions secret used within that job, as well as exfiltrate the source code of that repository. If their actions were executing on internal infrastructure, which is common with \u003ca href=\"https://www.praetorian.com/blog/self-hosted-github-runners-are-backdoors/\"\u003eself-hosted GitHub runners\u003c/a\u003e, you’d also have code execution on their internal network or cloud environment.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eThe impact from this attack would have been very similar to the recent tj-actions/changed-files supply chain attack.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eT\u003c/strong\u003ehis impact is impressive, but it doesn’t quite live up to the claims I made in the beginning. Yes, through these paths, they could launch a supply chain attack against repos manually using the CodeQL actions. However, most organizations don’t include these actions manually. They just go into their repository settings, click “Enable CodeQL”, and go from there.\u003c/p\u003e\n\n\n\n\u003cp\u003eAt first, I assumed that enabling CodeQL in your repository didn’t interact with the github/codeql-action repository at all.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eI was wrong.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eExponential Impact\u003c/h2\u003e\n\n\n\n\u003cp\u003eAfter discussing this issue with some colleagues, I decided to investigate further. What actually happens when you enable CodeQL?\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eThis section is key to understanding the full impact of this vulnerability.\u003c/strong\u003e Stick with me.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo investigate, I created my own public repository, “John’s Top Secret Repo”, and enabled CodeQL.\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter you enable CodeQL with the default settings, a special GitHub Actions workflow runs in your repository. This CodeQL action won’t show up in your repository workflows, but you can navigate to the workflow logs to see what it is doing.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-300x124.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-768x317.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57.png.webp 1174w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"422\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png\" alt=\"\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-300x124.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-768x317.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57.png 1174w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20422\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-300x124.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-768x317.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57.png 1174w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eEnabling CodeQL in your repository settings.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-300x153.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-768x391.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12.png.webp 1378w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"522\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png\" alt=\"CodeQL Setup\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-300x153.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-768x391.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12.png 1378w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20522\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-300x153.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-768x391.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12.png 1378w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eObserving the CodeQL workflow.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eBased on my observations, CodeQL:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eChecks out your repository to the filesystem\u003c/li\u003e\n\n\n\n\u003cli\u003eInitializes CodeQL\u003c/li\u003e\n\n\n\n\u003cli\u003eRuns CodeQL scans\u003c/li\u003e\n\n\n\n\u003cli\u003eUploads the scan results\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-300x287.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-768x735.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31.png.webp 1240w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"979\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png\" alt=\"CodeQL\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-300x287.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-768x735.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31.png 1240w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20979\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-300x287.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-768x735.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31.png 1240w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s take a closer look at step 3.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-300x67.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-768x173.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39.png.webp 1210w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"230\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png\" alt=\"step 3.\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-300x67.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-768x173.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39.png 1210w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20230\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-300x67.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-768x173.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39.png 1210w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf this doesn’t shock you, look again. Remember that we have the ability to push tags to the \u003cem\u003egithub/codeql-action\u003c/em\u003e repository.\u003c/p\u003e\n\n\n\n\u003cp\u003eCodeQL, under the hood, is executing the actions in the \u003cem\u003egithub/codeql-action\u003c/em\u003e repository, using the commit referenced by the \u003cem\u003ev3\u003c/em\u003e tag. This tag was not immutable, and they were not using \u003ca href=\"https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions\"\u003eworkflow pinning\u003c/a\u003e (which GitHub recommends), which meant that an attacker could overwrite the v3 tag using the compromised \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e. Now, if an attacker removed and then added a v3 tag to their malicious commit, every single repository using the default CodeQL workflow would execute their malicious code.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-300x69.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-768x178.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37.png.webp 1194w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"237\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png\" alt=\"CodeQL\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-300x69.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-768x178.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37.png 1194w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20237\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-300x69.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-768x178.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37.png 1194w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eThe Action created when selecting “Advanced CodeQL” also used the reusable github/codeql-action with the v3 tag.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThe CodeQL actions check out the source code of every repository they run on, which means that a malicious CodeQL action could exfiltrate the source code of any repository using default CodeQL configurations.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis would result in significant disclosure of intellectual property. And if you’ve ever operated on a Red Team, you know how many hardcoded secrets are lying around in private source code repositories.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBut Wait, There’s More\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe’re almost done. But remember, I promised one more thing:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003e4. Compromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen assessing the impact of CI/CD attack paths, I look for ways to compromise GitHub Actions secrets. Usually, those secrets are where the crown jewels live.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf the CodeQL action is executing with write privileges or alongside GitHub Actions secrets, then it’s trivial to use the code execution to exfiltrate those secrets. But the default CodeQL action uses a \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e that only has read privileges, so you can’t perform repository write operations, backdoor releases, or use fancy workflow dispatch events to steal secrets, \u003ca href=\"https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/\"\u003elike what happened with\u003c/a\u003e\u003ca href=\"https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e \u003c/a\u003e\u003ca href=\"https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/\"\u003ePyTorch\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat the default CodeQL action \u003cem\u003edoes\u003c/em\u003e do is execute in the main branch of the repository. The main branch of any GitHub repository can write cache entries that will be used by the entire repo. This opens up an opportunity to conduct \u003cstrong\u003eGitHub Actions cache poisoning\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub Actions Cache Poisoning is thoroughly explained \u003ca href=\"https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/\"\u003ein this \u003c/a\u003e\u003ca href=\"https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003earticle\u003c/a\u003e by Adnan Khan, which documents the discovery and exploitation of cache poisoning. The easiest way to conduct GitHub Actions cache poisoning is by deploying \u003ca href=\"https://github.com/AdnaneKhan/Cacheract\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCacheract\u003c/a\u003e, malware that persists in a build pipeline through cache poisoning.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf an attacker deployed Cacheract in the CodeQL workflow, it would:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003ePredict cache entries\u003c/li\u003e\n\n\n\n\u003cli\u003eOverwrite these entries with a malicious action\u003c/li\u003e\n\n\n\n\u003cli\u003eGain code execution within any workflow that uses \u003ccode\u003eaction-cache\u003c/code\u003e (the Actions Cache is used by most repositories)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eLeverage code execution to compromise GitHub Actions secrets used by those workflows, capture privileged GITHUB_TOKENs, and more\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eEven if someone noticed the malicious CodeQL action and remediated the vulnerability, Cacheract would continue poisoning caches.\u003c/p\u003e\n\n\n\n\u003cp\u003eI spent ten minutes looking for prominent repos that use CodeQL \u0026amp; actions/cache and identified\u003cbr/\u003e\u003ca href=\"https://github.com/Homebrew/brew\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eHomebrew\u003c/a\u003e, \u003ca href=\"https://github.com/angular/angular\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eAngular\u003c/a\u003e, and \u003ca href=\"https://github.com/grafana/grafana\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eGrafana\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eCache poisoning would allow an attacker to leverage this CodeQL supply chain attack to gain write access to repositories and repository secrets.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCongratulations, You Made It\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe’ve now hit all the impact highlights I mentioned at the beginning:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eCompromise intellectual property by exfiltrating the source code of all private repositories using CodeQL.\u003c/li\u003e\n\n\n\n\u003cli\u003eSteal credentials within GitHub Actions secrets of any workflow job using CodeQL, and leverage those secrets to execute further supply chain attacks.\u003c/li\u003e\n\n\n\n\u003cli\u003eExecute code on internal infrastructure running CodeQL workflows.\u003c/li\u003e\n\n\n\n\u003cli\u003eCompromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cpicture loading=\"lazy\" decoding=\"async\"\u003e\n\u003csource type=\"image/webp\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-300x103.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-768x263.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1536x526.png.webp 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-2048x701.png.webp 2048w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\n\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"351\" src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png\" alt=\"Congratulations, You Made It\" srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-300x103.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-768x263.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1536x526.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-2048x701.png 2048w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" data-old-src=\"data:image/svg+xml,%3Csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20viewBox=\u0026#39;0%200%201024%20351\u0026#39;%3E%3C/svg%3E\" data-lazy-srcset=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-300x103.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-768x263.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1536x526.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-2048x701.png 2048w\" data-lazy-src=\"https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png\"/\u003e\n\u003c/picture\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eSupply chain attacks like these are scary, especially when they start with something as simple as a publicly exposed credential. If this is your first time hearing about abusing GitHub Actions to launch supply chain attacks, I’ll let you in on a secret: \u003ca href=\"https://www.praetorian.com/blog/tensorflow-supply-chain-compromise-via-self-hosted-runner-attack/\"\u003ethese vulnerabilities\u003c/a\u003e \u003ca href=\"https://www.praetorian.com/blog/compromising-bytedances-rspack-github-actions-vulnerabilities/\"\u003eoccur\u003c/a\u003e \u003ca href=\"https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/\"\u003eall \u003c/a\u003e\u003ca href=\"https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ethe\u003c/a\u003e\u003ca href=\"https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/\"\u003e time\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub Actions abuse has been around for several years, but it is still one of the highest-impact, least-understood vulnerability classes. That is slowly starting to change (emphasis on ~slowly~). The DevOps and security communities need to commit to learning about these vulnerabilities to protect their organizations from risk. Vulnerabilities like this, and the recent tj-actions/changed-files supply chain attack, are starting to bring these issues to the public spotlight. That is why we invest in research to uncover these vulnerabilities and design solutions to prevent them.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCVE-2025-24362\u003c/h2\u003e\n\n\n\n\u003cp\u003eA side-effect of this disclosure was \u003ca href=\"https://github.com/advisories/GHSA-vqf5-2xx6-9wfm\"\u003eCVE-2025-24362\u003c/a\u003e. The publicly exposed \u003cem\u003eGITHUB_TOKEN\u003c/em\u003e was within a debug artifact uploaded by the CodeQL Action after a failed code scanning workflow. The CodeQL Actions repository was intentionally triggering this failure, but other users of CodeQL Actions could have exposed their own secrets as environment variables to the workflow, had their workflows experienced a similar failure.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eThis issue was fixed in CodeQL Action version 3.28.3.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eEven though this disclosure resulted in a CVE, the highest potential impact still lies in exploiting that vulnerability against the CodeQL Actions repository and launching a supply chain attack against CodeQL users.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRemediation\u003c/h2\u003e\n\n\n\n\u003cp\u003eGitHub had one of the most rapid and impressive remediation responses we have ever seen.\u003c/p\u003e\n\n\n\n\u003cp\u003eJan 22, 2025, 3:13 PM UTC: Report Submitted to GitHub\u003cbr/\u003eJan 22, 2025, 5:48 PM UTC: GitHub acknowledged receipt of the submission\u003cbr/\u003eJan 22, 2025, 6:28 PM UTC: GitHub confirmed the vulnerability, temporarily disabled the “PR Check – Debug artifacts after failure” workflow, and submitted \u003ca href=\"https://github.com/github/codeql-action/pull/2712\"\u003ethis PR\u003c/a\u003e to disable debug artifacts upload. This occurred just three hours after submitting the report, which is a very rapid resolution time.\u003cbr/\u003eJan 24, 2025: GitHub assigned \u003ca href=\"https://hackerone.com/hacktivity/cve_discovery?id=CVE-2025-24362\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCVE-2025-24362\u003c/a\u003e and published this \u003ca href=\"https://github.com/advisories/GHSA-vqf5-2xx6-9wfm\" target=\"_blank\" rel=\"noreferrer noopener\"\u003esecurity advisory\u003c/a\u003e, which notes they found no evidence of compromise to its platform or systems.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you are concerned about you’re own GitHub Actions workflow artifacts, you can take the following steps to limit the risk of secrets exposure:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eideally, only upload specific files or directories as workflow artifacts\u003c/li\u003e\n\n\n\n\u003cli\u003eavoid uploading artifacts containing environment variables, the \u003ccode\u003e.git/config\u003c/code\u003e file, or any files in the runner’s \u003ccode\u003e\u0026lt;path_to_runner_dir\u0026gt;/_work/_temp/\u003c/code\u003e directory\u003c/li\u003e\n\n\n\n\u003cli\u003elimit GITHUB_TOKEN permissions to read-only\u003c/li\u003e\n\n\n\n\u003cli\u003escan artifacts for secrets prior to uploading\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eTo learn more about this vulnerability, how I discovered it, and how you can detect similar vulnerabilities in your own environment, \u003ca href=\"https://www.praetorian.com/resources/unpacking-codeqleaked-a-potential-supply-chain-attack-on-github-codeql/\"\u003eplease join me for a webinar\u003c/a\u003e on April 10 at 1pm ET.\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow Can Praetorian Help\u003c/h2\u003e\n\n\n\n\u003cp\u003ePraetorian has been leading the charge in offensive CI/CD security for several years, inventing novel \u003ca href=\"https://github.com/praetorian-inc/gato\" target=\"_blank\" rel=\"noreferrer noopener\"\u003etooling\u003c/a\u003e and giving presentations at Black Hat, DEF CON, Schmoocon, and Black Hat Arsenal.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur \u003cstrong\u003e\u003ca href=\"https://www.praetorian.com/continuous-threat-exposure-management/\"\u003eContinuous Threat Exposure Management (CTEM)\u003c/a\u003e\u003c/strong\u003e platform, Chariot, can identify vulnerabilities like this in your attack surface before the attackers do.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur CI/CD Security Assessments can take an in-depth look at your internal CI/CD security posture, enumerating attack paths that an attacker would exploit to go from low-privileged access to complete organization compromise.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe next major supply chain attack could start with something as simple as a publicly exposed secret. Help make sure that doesn’t happen by learning about CI/CD vulnerabilities and implementing continuous controls to protect your organization from compromise.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eYou can \u003ca href=\"http://future.chariot.praetorian.com/\"\u003ecreate a free\u003c/a\u003e Chariot account anytime. Alternatively, if you’re interested in our managed Chariot offering, \u003ca href=\"https://www.praetorian.com/contact-us/\"\u003ereach out to speak with our team\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\n\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2025-03-26T12:24:28Z",
  "modifiedTime": "2025-03-26T12:29:51Z"
}
