{
  "id": "50fbbc15-1706-4f38-97a9-00ff36a07df3",
  "title": "Bad Apple but it's 6,500 regexes that I search for in Vim",
  "link": "https://eieio.games/blog/bad-apple-with-regex-in-vim/",
  "description": "Comments",
  "author": "",
  "published": "Sun, 12 Jan 2025 15:13:14 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 17180,
  "excerpt": "There's no reason I should exit vim just to watch a video",
  "siteName": "eieio.games",
  "favicon": "https://eieio.games/favicon.png",
  "text": "Why should I leave vim to watch a video?Jan 10, 2025 Well the title of this post promised you Bad Apple in vim only using search queries. So here’s Bad Apple in vim, but the only thing that’s changing is the search query: Loading...Unfortunately this is only 120x90; my screen isn't big enough to size up more Let’s talk about how this works! Wait, sorry, what is Bad Apple Bad Apple is a visually compelling music video that folks enjoy embedding in surprising places. It’s a meme in the same way that running DOOM on a smartfridge is a meme. I’ve wanted to run Bad Apple somewhere since I saw this video purporting to run it on One Million Checkboxes. Getting the frames The first step here was pretty simple. I needed data for each frame of Bad Apple. Felixoofed had already done some of the work for me; I cloned their repo which gave me the video along with a suggestion of an ffmpeg command to turn the video into ~6,500 PNGs representing each frame. Then I wrote a little bit of Python code to turn each of those PNGs into a 2D array of 0s and 1s (where 1 represented a black pixel). The video was originally 480x360 - I shrunk it down to 120x90 after taking some measurements of my terminal and concluding that I couldn’t really go any bigger. from PIL import Image import numpy as np def process_image(path, target_width=120, target_height=90): img = Image.open(path) img = img.resize((target_width, target_height), Image.Resampling.LANCZOS) if img.mode != \"L\": img = img.convert(\"L\") pixels = np.array(img) binary_pixels = (pixels \u003c 10).astype(int) # 1 for dark, 0 for light return binary_pixels def text_preview(binary_pixels): chars = {0: \".\", 1: \"#\"} return \"\\n\".join(\"\".join(chars[px] for px in row) for row in binary_pixels) I ran this against a couple of frames and printed out their text_previews to confirm that they looked ok. They did! Drawing in vim So how do we draw something in vim? Well, to start I made a grid of text with a drawing embedded inside it. Here’s a grid that mostly has As, but if you search for B you see a little stick figure: hey little guy So that kinda lets us create a drawing! But there are some problems. One is that the blue highlighting here (which I think is the default thing vim does?) isn’t super clear. But vim highlighting is very configurable! We can tell it to highlight the foreground and background of each matched character with the same color. The invocation I use is hi Search cterm=NONE ctermfg=grey ctermbg=grey which gives us nice blocks instead: much nicer But there’s one more problem - we want square pixels! But right now each of our characters is more of a rectangle, because most fonts are taller than they are wide! I searched around and found Square, a font that is…square! It’s designed for roguelike games played in the terminal, and using it here gives us a very nice grid: all squared away So that lets us create pictures by highlighting text. But how do we highlight the right text for each frame of Bad Apple? Drawing arbitrary rectangles I kicked around a bunch of vague ideas about file structure - maybe there was a way to analyze my frames, figure out which pixels were “hot,” and then generate a file that was optimized for regexs selecting those pixels? But before going too far down this path I decided to read through vim’s docs on searching. I knew that vim’s search had all sorts of crazy features 1 and I wanted to know what tools I had available. And it turns out that vim already had exactly what I needed! 1My favorites are \\zs and \\ze, which let you declare when a match starts or ends. It’s basically a way to say “treat everything behind/ahead of me as a lookahead/lookbehind” - it’s very ergonomic! /\\%l /\\%\u003el /\\%\u003cl E951 E1204 E1273 \\%23l Matches in a specific line. \\%\u003c23l Matches above a specific line (lower line number). \\%\u003e23l Matches below a specific line (higher line number). \\%.l Matches at the cursor line. \\%\u003c.l Matches above the cursor line. \\%\u003e.l Matches below the cursor line. vim searches can match on specific line numbers (and column numbers). And you can combine several of these searches together - for example \\%\u003e5c\\%\u003c15c\\%\u003e4l\\%\u003c9l matches the rectangle between columns 5 and 15 and between lines 4 and 9. And better yet, you can OR those patterns together just like any other vim search - \\%\u003e5c\\%\u003c15c\\%\u003e4l\\%\u003c9l\\|\\%\u003e12c\\%\u003c25c\\%\u003e10l\\%\u003c15l finds both our previous rectangle and the one between cols 12 and 25 and lines 10 and 15. So it’s easy to draw many rectangles to the screen with a single search. two squares from one search string! This transformed the problem - now the goal was to decompose each frame into a series of rectangles that we could search for! Frames into rectangles Our grid was 90x120 so we had ~10,000 pixels. This meant that a super naive approach would potentially look for thousands of different rectangles and generate a search string tens of thousands of characters long. Some basic testing showed me that while vim’s search was fast, search strings that long would kill my framerate. “Decompose this grid into the minimum number of rectangles required to fill it” seemed like the type of thing that would have a de-facto solution, so I looked for existing solutions. But I didn’t find much! There’s a 14 year old stack overflow question where the accepted answer is “it’s hard.” So I wrote something naive. The approach I took was: Detect all runs of “1s” in the first row Look at the next row, and find runs that overlap with the runs from the previous row “Merge” those runs into a rectangle if the area of the merged rectangle is greater than the area of either row alone (remember, the runs may not overlap fully) Keep going, making sure to merge new runs into old rectangles whenever possible The actual code is pretty long and I’m not sure it’s worth reading, but here it is if you’re curious: The code, which I'm not sure you really need to see class Rect: def __init__(self, col_start, col_end, row_start, row_end): self.row_start = row_start self.row_end = row_end self.col_start = col_start self.col_end = col_end def height(self): return self.row_end - self.row_start def width(self): return self.col_end - self.col_start def area(self): return self.height() * self.width() def to_vim_pattern(self): # vim is 1-indexed and exclusive in both directions row_start = self.row_start row_end = self.row_end + 1 col_start = self.col_start col_end = self.col_end + 1 return fr\"\\%\u003e{col_start}c\\%\u003c{col_end}c\\%\u003e{row_start}l\\%\u003c{row_end}l\" def __repr__(self): width = self.width() height = self.height() return f\"R: ({width}x{height}) {self.row_start}:{self.row_end}, {self.col_start}:{self.col_end}\" def test_merge_horizontal(self, run_start, run_end, run_row): if run_end \u003c= self.col_start: return [False, None, None, None] if run_start \u003e= self.col_end: return [False, None, None, None] overlap_start = max(run_start, self.col_start) overlap_end = min(run_end, self.col_end) overlap_rect = Rect(overlap_start, overlap_end, self.row_start, run_row+1) # rects that are no longer eligible for merging top_rects = [] if overlap_start \u003e self.col_start: top_rects.append(Rect(self.col_start, overlap_start, self.row_start, self.row_end)) if overlap_end \u003c self.col_end: top_rects.append(Rect(overlap_end, self.col_end, self.row_start, self.row_end)) # rects that are split from the current run but eligible for merging # with stuff below bot_rects = [] if overlap_start \u003e run_start: bot_rects.append(Rect(run_start, overlap_start, run_row, run_row+1)) if overlap_end \u003c run_end: bot_rects.append(Rect(overlap_end, run_end, run_row, run_row+1)) return [True, overlap_rect, top_rects, bot_rects] def find_runs(row): runs = [] start = None for i, val in enumerate(row): if val == 1 and start is None: start = i elif val == 0 and start is not None: runs.append((start, i)) start = None if start is not None: runs.append((start, len(row))) return runs def try_merge_with_prev_row(mergeable_rects, run_start, run_end, run_row): candidate_merges = [] for i, rect in enumerate(mergeable_rects): merge_result = rect.test_merge_horizontal(run_start, run_end, run_row) if merge_result[0]: candidate_merges.append((merge_result, i)) best = None best_idx = None best_merge_result = None run_length = run_end - run_start for (candidate, candidate_idx) in candidate_merges: _, overlap_rect, top_rects, bot_rects = candidate overlap_area = overlap_rect.area() if best is None or overlap_area \u003e best: best = overlap_area best_idx = candidate_idx best_merge_result = (overlap_rect, top_rects, bot_rects) if best is None: return (None, None) elif best \u003e run_length: return (best_idx, best_merge_result) else: return (None, None) def to_horizontal_merge_rect_representation(binary_pixels): completed_rects = [] mergeable_rects = [] for row_idx, row in enumerate(binary_pixels): next_mergeable_rects = [] runs = find_runs(row) for (run_start, run_end) in runs: best_merge_idx, best_merge_result = try_merge_with_prev_row(mergeable_rects, run_start, run_end, row_idx) if best_merge_idx is None: r = Rect(run_start, run_end, row_idx, row_idx+1) next_mergeable_rects.append(r) else: mergeable_rects.pop(best_merge_idx) overlap_rect, top_rects, bot_rects = best_merge_result mergeable_rects.extend(top_rects) next_mergeable_rects.append(overlap_rect) next_mergeable_rects.extend(bot_rects) completed_rects.extend(mergeable_rects) mergeable_rects = next_mergeable_rects completed_rects.extend(mergeable_rects) return r\"\\|\".join(rect.to_vim_pattern() for rect in completed_rects) So probably don’t read that. But the point is that it’s far from optimal 2. For example, the code never looks more than one row ahead, so it discards merges that are a bad idea now but would work out well based on following rows. 2it was really fun to write though But I knew the code was naive when I wrote it - I just wanted to get something vaguely reasonable down to see how it’d perform. I generated search queries for each frame and wrote them to a file. And then I set up a simple vim animation test harness 3, and found that the performance was fine! Well, in some cases. 3we’ll talk about how this works in a second Pathological cases My naive algorithm worked really well in some cases and totally fell over in others. Many of the search strings were 500 - 2000 characters long, but the search string that it generates for this image is over 10,000 characters 4! 4Length of a search string is not a perfect proxy for performance, but I think it’s pretty good. Our search strings are just a bunch of patterns (of similar length) OR’d together. The longer a search string, the more patterns. And search time should scale with the number of patterns, since vim has to check each one before deciding that a search doesn’t match. That said I did no principled profiling here and may be totally wrong in some way! cool image tbh These long search strings dramatically reduced frames per second - we went from around ~40 FPS to the single digits. I hunted for optimizations 5. I came up with a bunch of ideas for tweaks, but wasn’t confident that any of them would help much with the bad cases. And I didn’t have the time to find a good general-purpose algorithm: I was working on this the night before weekly presentations at the Recurse Center and I wanted to present it the next day! 5My favorite rabbit hole was trying to improve vim’s search performance instead of my regexs. My setup for playing the video had multiple buffers open and the searches were ran over each buffer. I thought if I could prevent that (or prevent highlighting in other buffers) that might help. But I couldn’t get that to work. So I pulled out one of my favorite tricks 6 - instead of trying to write one great algorithm, write several mediocre ones and use them all! I wrote two more naive solutions: A version of my “build rects top to bottom” algorithm that went left to right instead A simple RLE that only looked at individual rows And then I updated my code to run each frame through all three algorithms and pick the shortest search pattern generated! This worked great. While each of these algorithms had pathological cases, they had very different pathological cases. So in (almost) all cases, at least one of them generated a search pattern that was good enough. RLE ended up most often generating the “best” solution - although when it’s bad it’s really bad (which is why I avoided using it to start). And my original approach was used the least often! oops. # Number of times each approach was picked original approach (top to bottom merging) - 1110 left to right merging - 2239 single-row RLE - 3300 Wait, so how do you actually run this inside vim Yes, right, that’s a good question. Here’s an image of the vim setup: it's all clear now right? The center window on the top is where we play the video. It’s a file that contains 90 lines of 120 spaces (remember that our images are 120x90); since we’re matching on rows and columns it doesn’t need to have any content. To its left and right are some empty buffers that are sized to center the image. The bottom window is our list of search patterns! All ~6,500 of them. To play the video we use a vim macro. If you haven’t seen vim macros, they’re a way to record a series of arbitrary keystrokes to be replayed later. They’re extremely powerful - since you do ~everything in vim via the keyboard, you can trivially record and replay any action. And if you set up your macro right (so that it ends with the cursor in the right spot for the next iteration) you can tell vim to run the macro many times in a row! The macro The macro is \"ay$:let @/=@a^M+. That is: \"a Operate over register a y$ Yank until the end of the line Vim has “named” registers that can hold text - ‘a’ now contains the current line : Enter command mode let @/=@a set the contents of register / to the contents of register a ^M execute the command (^M represents the enter key) To reference a register in command mode you use @ followed by the register name. Vim has special registers - the / register represents the current search. At this point vim is searching for the query that is on the current line + move to the start of the next line This is what I meant by “if you set up your macro right you can make it replayable” - we’re prepared to execute our macro again because the cursor is now on the start of the next line! This might look like nonsense to you - I’m pretty comfortable with macros because of the years that I’ve spent vim golfing. But it works! The most interesting optimization is let @/=@a - an alternative is to do something like /^Ra^M (begin a search, pastes the output of register a, enter), but this is a problem because it requires directly pasting a query that is potentially thousands of characters long. This causes the search window to expand to fit the query, which creates a flickering effect and reduces framerate. But now we can run 1500@q (assuming we recorded the macro into register q) to play the macro 1500 times - meaning that we’ll run through 1500 frames as quickly as we can. And that gives us this! Wrapping up This was really fun! I built this in a single day, but if I wanted to spend more time on it I might make a few tweaks: I think it’d be more magical if I had gone the “create a well-structured file that I can craft traditional regexs over” route instead of using vim’s line/col search feature. You might (reasonably) quibble that these aren’t real regexs! I make no effort to keep a stable framerate, and the framerate definitely fluctuates a bit over the course of the video. But this was good enough for my purposes. And I think it’s neat that I’ve built most of a general-purpose solution for playing a video inside of vim using search queries. Someone suggested that I record a video of me running Bad Apple in vim and play that video in vim. So I guess I’ll get on that. Beyond that, I made this in my first week of a new batch at The Recurse Center, a place that offers something like a writers retreat but for programming. I presented it to folks there and got a lovely response. I really love Recurse, and if you love nonsense like this I bet you’d like it too. Consider applying!. Finally, the code is super messy but if you want to poke around you can see it here. And that’s all I’ve got. As always, I’ll be back with more nonsense soon.",
  "image": "https://eieio.games/images/bad-apple-with-regex-in-vim/title-image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003ca href=\"https://eieio.games/blog/bad-apple-with-regex-in-vim/\"\u003e\u003c/a\u003e\u003cdiv\u003e\u003cp\u003eWhy should I leave vim to watch a video?\u003c/p\u003e\u003cp\u003eJan 10, 2025\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cp\u003eWell the title of this post promised you Bad Apple in vim only using search queries. So here’s Bad Apple in vim, but the only thing that’s changing is the search query:\u003c/p\u003e\n\u003cdiv\u003e\u003cvideo controls=\"\" playsinline=\"\" poster=\"https://eieio.games/images/bad-apple-with-regex-in-vim/badapple-optimized-1500-small-firstframe.png\" width=\"1510\" height=\"932\" preload=\"metadata\" alt=\"The first several seconds of \u0026#39;bad apple.\u0026#39; The video is playing inside of vim at a low resolution. On the bottom of the screen search queries scroll by as the video plays\"\u003e\u003cp\u003eLoading...\u003c/p\u003e\u003c/video\u003e\u003cp\u003eUnfortunately this is only 120x90; my screen isn\u0026#39;t big enough to size up more\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eLet’s talk about how this works!\u003c/p\u003e\n\n\u003ch2 id=\"toc:wait-sorry-what-is-bad-apple\"\u003eWait, sorry, what is Bad Apple\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://knowyourmeme.com/memes/bad-apple\"\u003eBad Apple\u003c/a\u003e is a visually compelling music video that folks enjoy embedding in surprising places. It’s a meme in the same way that running DOOM on a smartfridge is a meme.\u003c/p\u003e\n\u003cp\u003eI’ve wanted to run Bad Apple somewhere since I saw \u003ca href=\"https://x.com/delatoid/status/1806130369269580081\"\u003ethis video\u003c/a\u003e purporting to run it on One Million Checkboxes.\u003c/p\u003e\n\u003ch2 id=\"toc:getting-the-frames\"\u003eGetting the frames\u003c/h2\u003e\n\u003cp\u003eThe first step here was pretty simple. I needed data for each frame of Bad Apple. \u003ca href=\"https://github.com/Felixoofed\"\u003eFelixoofed\u003c/a\u003e had already done some of the work for me; I cloned \u003ca href=\"https://github.com/Felixoofed/badapple-frames\"\u003etheir repo\u003c/a\u003e which gave me the video along with a suggestion of an \u003ccode\u003effmpeg\u003c/code\u003e command to turn the video into ~6,500 PNGs representing each frame.\u003c/p\u003e\n\u003cp\u003eThen I wrote a little bit of Python code to turn each of those PNGs into a 2D array of 0s and 1s (where 1 represented a black pixel). The video was originally 480x360 - I shrunk it down to 120x90 after taking some measurements of my terminal and concluding that I couldn’t really go any bigger.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efrom\u003c/span\u003e PIL \u003cspan\u003eimport\u003c/span\u003e Image\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e numpy \u003cspan\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eprocess_image\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003epath\u003cspan\u003e,\u003c/span\u003e target_width\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e120\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e target_height\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e90\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    img \u003cspan\u003e=\u003c/span\u003e Image\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003epath\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    img \u003cspan\u003e=\u003c/span\u003e img\u003cspan\u003e.\u003c/span\u003eresize\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003etarget_width\u003cspan\u003e,\u003c/span\u003e target_height\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e Image\u003cspan\u003e.\u003c/span\u003eResampling\u003cspan\u003e.\u003c/span\u003eLANCZOS\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e img\u003cspan\u003e.\u003c/span\u003emode \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e\u0026#34;L\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e img \u003cspan\u003e=\u003c/span\u003e img\u003cspan\u003e.\u003c/span\u003econvert\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;L\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    pixels \u003cspan\u003e=\u003c/span\u003e np\u003cspan\u003e.\u003c/span\u003earray\u003cspan\u003e(\u003c/span\u003eimg\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    binary_pixels \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003epixels \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003eastype\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e# 1 for dark, 0 for light\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e binary_pixels\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003etext_preview\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ebinary_pixels\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    chars \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;.\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;#\u0026#34;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;\\n\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003ejoin\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003ejoin\u003cspan\u003e(\u003c/span\u003echars\u003cspan\u003e[\u003c/span\u003epx\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e px \u003cspan\u003ein\u003c/span\u003e row\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e row \u003cspan\u003ein\u003c/span\u003e binary_pixels\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI ran this against a couple of frames and printed out their \u003ccode\u003etext_preview\u003c/code\u003es to confirm that they looked ok. They did!\u003c/p\u003e\n\u003ch2 id=\"toc:drawing-in-vim\"\u003eDrawing in vim\u003c/h2\u003e\n\u003cp\u003eSo how do we draw something in vim? Well, to start I made a grid of text with a drawing embedded inside it. Here’s a grid that mostly has As, but if you search for B you see a little stick figure:\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"a vim window with a bunch of text. most of the text is the letter A, but there are some Bs. The Bs form a stick figure. The user has searched for \u0026#39;B\u0026#39; so the Bs are highlighted blue.\" loading=\"lazy\" width=\"1370\" height=\"920\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/grid-blue.png\"/\u003e\u003c/p\u003e\u003cp\u003ehey little guy\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eSo that kinda lets us create a drawing! But there are some problems. One is that the blue highlighting here (which I think is the default thing vim does?) isn’t super clear.\u003c/p\u003e\n\u003cp\u003eBut vim highlighting is very configurable! We can tell it to highlight the foreground and background of each matched character with the same color. The invocation I use is \u003ccode\u003ehi Search cterm=NONE ctermfg=grey ctermbg=grey\u003c/code\u003e which gives us nice blocks instead:\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"a vim window with a bunch of text. most of the text is the letter A, but there is a stick figure that is drawn using monocolor rectangles\" loading=\"lazy\" width=\"1370\" height=\"920\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/grid-blocks.png\"/\u003e\u003c/p\u003e\u003cp\u003emuch nicer\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eBut there’s one more problem - we want square pixels! But right now each of our characters is more of a rectangle, because most fonts are taller than they are wide! I searched around and found \u003ca href=\"https://strlen.com/square/\"\u003eSquare\u003c/a\u003e, a font that is…square! It’s designed for roguelike games played in the terminal, and using it here gives us a very nice grid:\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"a vim window with a bunch of text. most of the text is the letter A, but there is a stick figure that is drawn using monocolor rectangles. The font is square\" loading=\"lazy\" width=\"2630\" height=\"834\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/grid-square.png\"/\u003e\u003c/p\u003e\u003cp\u003eall squared away\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eSo that lets us create pictures by highlighting text. But how do we highlight the \u003cem\u003eright\u003c/em\u003e text for each frame of Bad Apple?\u003c/p\u003e\n\u003ch3 id=\"toc:drawing-arbitrary-rectangles\"\u003eDrawing arbitrary rectangles\u003c/h3\u003e\n\u003cp\u003eI kicked around a bunch of vague ideas about file structure - maybe there was a way to analyze my frames, figure out which pixels were “hot,” and then generate a file that was optimized for regexs selecting those pixels?\u003c/p\u003e\n\u003cp\u003eBut before going too far down this path I decided to read through vim’s docs on searching. I knew that vim’s search had all sorts of crazy features \u003ca\u003e1\u003c/a\u003e and I wanted to know what tools I had available. And it turns out that vim already had exactly what I needed!\u003c/p\u003e\n\u003cdiv data-is-footnote=\"true\"\u003e\u003cp\u003e\u003cspan\u003e1\u003c/span\u003e\u003c/p\u003e\u003cp\u003eMy favorites are \u003ccode\u003e\\zs\u003c/code\u003e and \u003ccode\u003e\\ze\u003c/code\u003e, which let you declare when a match starts or\nends. It’s basically a way to say “treat everything behind/ahead of me as a\nlookahead/lookbehind” - it’s very ergonomic!\u003c/p\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\t\t\t\t\u003cspan\u003e/\u003c/span\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e E951 E1204 E1273\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e23l\tMatches \u003cspan\u003ein\u003c/span\u003e a specific line\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e23l\tMatches above a specific line \u003cspan\u003e(\u003c/span\u003elower line \u003cspan\u003enumber\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e23l\tMatches below a specific line \u003cspan\u003e(\u003c/span\u003ehigher line \u003cspan\u003enumber\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e\tMatches at the cursor line\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e\tMatches above the cursor line\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\\\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003el\u003c/span\u003e\tMatches below the cursor line\u003cspan\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evim searches can match on specific line numbers (and column numbers). And you can combine several of these searches together - for example \u003ccode\u003e\\%\u0026gt;5c\\%\u0026lt;15c\\%\u0026gt;4l\\%\u0026lt;9l\u003c/code\u003e matches the rectangle between columns 5 and 15 and between lines 4 and 9.\u003c/p\u003e\n\u003cp\u003eAnd better yet, you can OR \u003cem\u003ethose\u003c/em\u003e patterns together just like any other vim search - \u003ccode\u003e\\%\u0026gt;5c\\%\u0026lt;15c\\%\u0026gt;4l\\%\u0026lt;9l\\|\\%\u0026gt;12c\\%\u0026lt;25c\\%\u0026gt;10l\\%\u0026lt;15l\u003c/code\u003e finds both our previous rectangle and the one between cols 12 and 25 and lines 10 and 15. So it’s easy to draw many rectangles to the screen with a single search.\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"A vim window with two highlighted squares. A vim search string is visible (the squares are selected by the search string). The search string is \\%\u0026gt;5c\\%\u0026lt;15c\\%\u0026gt;4l\\%\u0026lt;9l\\|\\%\u0026gt;12c\\%\u0026lt;25c\\%\u0026gt;10l\\%\u0026lt;15l\" loading=\"lazy\" width=\"2630\" height=\"770\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/square-drawing.png\"/\u003e\u003c/p\u003e\u003cp\u003etwo squares from one search string!\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eThis transformed the problem - now the goal was to decompose each frame into a series of rectangles that we could search for!\u003c/p\u003e\n\u003ch2 id=\"toc:frames-into-rectangles\"\u003eFrames into rectangles\u003c/h2\u003e\n\u003cp\u003eOur grid was 90x120 so we had ~10,000 pixels. This meant that a super naive approach would potentially look for thousands of different rectangles and generate a search string tens of thousands of characters long. Some basic testing showed me that while vim’s search was fast, search strings that long would kill my framerate.\u003c/p\u003e\n\u003cp\u003e“Decompose this grid into the minimum number of rectangles required to fill it” seemed like the type of thing that would have a de-facto solution, so I looked for existing solutions. But I didn’t find much! There’s \u003ca href=\"https://stackoverflow.com/questions/4304750/how-can-i-reduce-a-grid-of-equal-sized-squares-to-a-minimum-set-of-rectangles\"\u003ea 14 year old stack overflow question\u003c/a\u003e where the accepted answer is “it’s hard.”\u003c/p\u003e\n\u003cp\u003eSo I wrote something naive. The approach I took was:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDetect all runs of “1s” in the first row\u003c/li\u003e\n\u003cli\u003eLook at the next row, and find runs that overlap with the runs from the previous row\u003c/li\u003e\n\u003cli\u003e“Merge” those runs into a rectangle if the area of the merged rectangle is greater than the area of either row alone (remember, the runs may not overlap fully)\u003c/li\u003e\n\u003cli\u003eKeep going, making sure to merge new runs into old rectangles whenever possible\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe actual code is pretty long and I’m not sure it’s worth reading, but here it is if you’re curious:\u003c/p\u003e\n\u003cdetails\u003e\u003csummary\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e\u003cpath d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\"\u003e\u003c/path\u003e\u003ccircle cx=\"12\" cy=\"12\" r=\"3\"\u003e\u003c/circle\u003e\u003c/svg\u003e The code, which I\u0026#39;m not sure you really need to see\u003c/summary\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eRect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e,\u003c/span\u003e col_start\u003cspan\u003e,\u003c/span\u003e col_end\u003cspan\u003e,\u003c/span\u003e row_start\u003cspan\u003e,\u003c/span\u003e row_end\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        self\u003cspan\u003e.\u003c/span\u003erow_start \u003cspan\u003e=\u003c/span\u003e row_start\n\u003c/span\u003e\u003cspan\u003e        self\u003cspan\u003e.\u003c/span\u003erow_end \u003cspan\u003e=\u003c/span\u003e row_end\n\u003c/span\u003e\u003cspan\u003e        self\u003cspan\u003e.\u003c/span\u003ecol_start \u003cspan\u003e=\u003c/span\u003e col_start\n\u003c/span\u003e\u003cspan\u003e        self\u003cspan\u003e.\u003c/span\u003ecol_end \u003cspan\u003e=\u003c/span\u003e col_end\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_end \u003cspan\u003e-\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_start\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end \u003cspan\u003e-\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_start\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003earea\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003eheight\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ewidth\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eto_vim_pattern\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# vim is 1-indexed and exclusive in both directions\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        row_start \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_start\n\u003c/span\u003e\u003cspan\u003e        row_end \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_end \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        col_start \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_start\n\u003c/span\u003e\u003cspan\u003e        col_end \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003efr\u0026#34;\\%\u0026gt;\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003ecol_start\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003ec\\%\u0026lt;\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003ecol_end\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003ec\\%\u0026gt;\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003erow_start\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003el\\%\u0026lt;\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003erow_end\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003el\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__repr__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        width \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ewidth\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        height \u003cspan\u003e=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003eheight\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ef\u0026#34;R: (\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003ewidth\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003eheight\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003eself\u003cspan\u003e.\u003c/span\u003erow_start\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003eself\u003cspan\u003e.\u003c/span\u003erow_end\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003eself\u003cspan\u003e.\u003c/span\u003ecol_start\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003eself\u003cspan\u003e.\u003c/span\u003ecol_end\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003etest_merge_horizontal\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e,\u003c/span\u003e run_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e run_end \u003cspan\u003e\u0026lt;=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_start\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e run_start \u003cspan\u003e\u0026gt;=\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        overlap_start \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emax\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003erun_start\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_start\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        overlap_end \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003erun_end\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        overlap_rect \u003cspan\u003e=\u003c/span\u003e Rect\u003cspan\u003e(\u003c/span\u003eoverlap_start\u003cspan\u003e,\u003c/span\u003e overlap_end\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_start\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# rects that are no longer eligible for merging\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        top_rects \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e overlap_start \u003cspan\u003e\u0026gt;\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_start\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            top_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003eRect\u003cspan\u003e(\u003c/span\u003eself\u003cspan\u003e.\u003c/span\u003ecol_start\u003cspan\u003e,\u003c/span\u003e overlap_start\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_start\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_end\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e overlap_end \u003cspan\u003e\u0026lt;\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            top_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003eRect\u003cspan\u003e(\u003c/span\u003eoverlap_end\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003ecol_end\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_start\u003cspan\u003e,\u003c/span\u003e self\u003cspan\u003e.\u003c/span\u003erow_end\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# rects that are split from the current run but eligible for merging\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003e# with stuff below\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        bot_rects \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e overlap_start \u003cspan\u003e\u0026gt;\u003c/span\u003e run_start\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            bot_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003eRect\u003cspan\u003e(\u003c/span\u003erun_start\u003cspan\u003e,\u003c/span\u003e overlap_start\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e overlap_end \u003cspan\u003e\u0026lt;\u003c/span\u003e run_end\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            bot_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003eRect\u003cspan\u003e(\u003c/span\u003eoverlap_end\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eTrue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e overlap_rect\u003cspan\u003e,\u003c/span\u003e top_rects\u003cspan\u003e,\u003c/span\u003e bot_rects\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003efind_runs\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003erow\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    runs \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    start \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e i\u003cspan\u003e,\u003c/span\u003e val \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eenumerate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003erow\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e val \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e start \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            start \u003cspan\u003e=\u003c/span\u003e i\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eelif\u003c/span\u003e val \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e start \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            runs\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003estart\u003cspan\u003e,\u003c/span\u003e i\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            start \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e start \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        runs\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003estart\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003erow\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e runs\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003etry_merge_with_prev_row\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emergeable_rects\u003cspan\u003e,\u003c/span\u003e run_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    candidate_merges \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e i\u003cspan\u003e,\u003c/span\u003e rect \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eenumerate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emergeable_rects\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        merge_result \u003cspan\u003e=\u003c/span\u003e rect\u003cspan\u003e.\u003c/span\u003etest_merge_horizontal\u003cspan\u003e(\u003c/span\u003erun_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e run_row\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e merge_result\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e candidate_merges\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emerge_result\u003cspan\u003e,\u003c/span\u003e i\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    best \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    best_idx \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    best_merge_result \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    run_length \u003cspan\u003e=\u003c/span\u003e run_end \u003cspan\u003e-\u003c/span\u003e run_start\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ecandidate\u003cspan\u003e,\u003c/span\u003e candidate_idx\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e candidate_merges\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        _\u003cspan\u003e,\u003c/span\u003e overlap_rect\u003cspan\u003e,\u003c/span\u003e top_rects\u003cspan\u003e,\u003c/span\u003e bot_rects \u003cspan\u003e=\u003c/span\u003e candidate\n\u003c/span\u003e\u003cspan\u003e        overlap_area \u003cspan\u003e=\u003c/span\u003e overlap_rect\u003cspan\u003e.\u003c/span\u003earea\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003eif\u003c/span\u003e best \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003eor\u003c/span\u003e overlap_area \u003cspan\u003e\u0026gt;\u003c/span\u003e best\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            best \u003cspan\u003e=\u003c/span\u003e overlap_area\n\u003c/span\u003e\u003cspan\u003e            best_idx \u003cspan\u003e=\u003c/span\u003e candidate_idx\n\u003c/span\u003e\u003cspan\u003e            best_merge_result \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eoverlap_rect\u003cspan\u003e,\u003c/span\u003e top_rects\u003cspan\u003e,\u003c/span\u003e bot_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e best \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eelif\u003c/span\u003e best \u003cspan\u003e\u0026gt;\u003c/span\u003e run_length\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ebest_idx\u003cspan\u003e,\u003c/span\u003e best_merge_result\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eto_horizontal_merge_rect_representation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ebinary_pixels\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    completed_rects \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    mergeable_rects \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003efor\u003c/span\u003e row_idx\u003cspan\u003e,\u003c/span\u003e row \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eenumerate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ebinary_pixels\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        next_mergeable_rects \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        runs \u003cspan\u003e=\u003c/span\u003e find_runs\u003cspan\u003e(\u003c/span\u003erow\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003erun_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e runs\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            best_merge_idx\u003cspan\u003e,\u003c/span\u003e best_merge_result \u003cspan\u003e=\u003c/span\u003e try_merge_with_prev_row\u003cspan\u003e(\u003c/span\u003emergeable_rects\u003cspan\u003e,\u003c/span\u003e run_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e row_idx\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003eif\u003c/span\u003e best_merge_idx \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                r \u003cspan\u003e=\u003c/span\u003e Rect\u003cspan\u003e(\u003c/span\u003erun_start\u003cspan\u003e,\u003c/span\u003e run_end\u003cspan\u003e,\u003c/span\u003e row_idx\u003cspan\u003e,\u003c/span\u003e row_idx\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                next_mergeable_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003er\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                mergeable_rects\u003cspan\u003e.\u003c/span\u003epop\u003cspan\u003e(\u003c/span\u003ebest_merge_idx\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                overlap_rect\u003cspan\u003e,\u003c/span\u003e top_rects\u003cspan\u003e,\u003c/span\u003e bot_rects \u003cspan\u003e=\u003c/span\u003e best_merge_result\n\u003c/span\u003e\u003cspan\u003e                mergeable_rects\u003cspan\u003e.\u003c/span\u003eextend\u003cspan\u003e(\u003c/span\u003etop_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                next_mergeable_rects\u003cspan\u003e.\u003c/span\u003eappend\u003cspan\u003e(\u003c/span\u003eoverlap_rect\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e                next_mergeable_rects\u003cspan\u003e.\u003c/span\u003eextend\u003cspan\u003e(\u003c/span\u003ebot_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        completed_rects\u003cspan\u003e.\u003c/span\u003eextend\u003cspan\u003e(\u003c/span\u003emergeable_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e        mergeable_rects \u003cspan\u003e=\u003c/span\u003e next_mergeable_rects\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    completed_rects\u003cspan\u003e.\u003c/span\u003eextend\u003cspan\u003e(\u003c/span\u003emergeable_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003er\u0026#34;\\|\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003ejoin\u003cspan\u003e(\u003c/span\u003erect\u003cspan\u003e.\u003c/span\u003eto_vim_pattern\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e rect \u003cspan\u003ein\u003c/span\u003e completed_rects\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/details\u003e\n\u003cp\u003eSo probably don’t read that. But the point is that it’s far from optimal \u003ca\u003e2\u003c/a\u003e. For example, the code never looks more than one row ahead, so it discards merges that are a bad idea \u003cem\u003enow\u003c/em\u003e but would work out well based on following rows.\u003c/p\u003e\n\u003cdiv data-is-footnote=\"true\"\u003e\u003cp\u003e\u003cspan\u003e2\u003c/span\u003e\u003c/p\u003e\u003cp\u003eit \u003cem\u003ewas\u003c/em\u003e really fun to write though\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eBut I knew the code was naive when I wrote it - I just wanted to get something vaguely reasonable down to see how it’d perform. I generated search queries for each frame and wrote them to a file. And then I set up a simple vim animation test harness \u003ca\u003e3\u003c/a\u003e, and found that the performance was fine! Well, in some cases.\u003c/p\u003e\n\u003cdiv data-is-footnote=\"true\"\u003e\u003cp\u003e\u003cspan\u003e3\u003c/span\u003e\u003c/p\u003e\u003cp\u003ewe’ll talk about how this works in a second\u003c/p\u003e\u003c/div\u003e\n\u003ch3 id=\"toc:pathological-cases\"\u003ePathological cases\u003c/h3\u003e\n\u003cp\u003eMy naive algorithm worked really well in some cases and totally fell over in others. Many of the search strings were 500 - 2000 characters long, but the search string that it generates for this image is over 10,000 characters \u003ca\u003e4\u003c/a\u003e!\u003c/p\u003e\n\u003cdiv data-is-footnote=\"true\"\u003e\u003cp\u003e\u003cspan\u003e4\u003c/span\u003e\u003c/p\u003e\u003cdiv\u003e\u003cp\u003eLength of a search string is not a perfect proxy for performance, but I think it’s pretty good. Our search strings are just a bunch of patterns (of similar length) OR’d together. The longer a search string, the more patterns. And search time should scale with the number of patterns, since vim has to check each one before deciding that a search doesn’t match. \u003c/p\u003e\u003cp\u003e    That said I did no principled profiling here and may be totally wrong in some way!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"A vim window. A frame from bad apple is visible. A woman stands on a boat holding a scythe, visible from the side.\" loading=\"lazy\" width=\"1942\" height=\"1462\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/pathological.png\"/\u003e\u003c/p\u003e\u003cp\u003ecool image tbh\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eThese long search strings dramatically reduced frames per second - we went from around ~40 FPS to the single digits.\u003c/p\u003e\n\u003cp\u003eI hunted for optimizations \u003ca\u003e5\u003c/a\u003e. I came up with a bunch of ideas for tweaks, but wasn’t confident that any of them would help much with the bad cases. And I didn’t have the time to find a good general-purpose algorithm: I was working on this the night before weekly presentations at the \u003ca href=\"https://www.recurse.com/\"\u003eRecurse Center\u003c/a\u003e and I wanted to present it the next day!\u003c/p\u003e\n\u003cdiv data-is-footnote=\"true\"\u003e\u003cp\u003e\u003cspan\u003e5\u003c/span\u003e\u003c/p\u003e\u003cp\u003eMy favorite rabbit hole was trying to improve \u003cem\u003evim’s\u003c/em\u003e search performance instead of my regexs. My setup for playing the video had multiple buffers open and the searches were ran over each buffer. I thought if I could prevent that (or prevent \u003cem\u003ehighlighting\u003c/em\u003e in other buffers) that might help. But I couldn’t get that to work.\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eSo I pulled out one of my favorite tricks \u003ca\u003e6\u003c/a\u003e - instead of trying to write one great algorithm, write several mediocre ones and use them all!\u003c/p\u003e\n\n\u003cp\u003eI wrote two more naive solutions:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA version of my “build rects top to bottom” algorithm that went left to right instead\u003c/li\u003e\n\u003cli\u003eA simple \u003ca href=\"https://en.wikipedia.org/wiki/Run-length_encoding\"\u003eRLE\u003c/a\u003e that only looked at individual rows\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd then I updated my code to run each frame through all three algorithms and pick the shortest search pattern generated!\u003c/p\u003e\n\u003cp\u003eThis worked great. While each of these algorithms had pathological cases, they had \u003cem\u003every different\u003c/em\u003e pathological cases. So in (almost) all cases, at least one of them generated a search pattern that was good enough.\u003c/p\u003e\n\u003cp\u003eRLE ended up most often generating the “best” solution - although when it’s bad it’s really bad (which is why I avoided using it to start). And my original approach was used the least often! oops.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e# Number of times each approach was picked\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003eoriginal approach \u003cspan\u003e(\u003c/span\u003etop to bottom merging\u003cspan\u003e)\u003c/span\u003e - \u003cspan\u003e1110\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003eleft to right merging                     - \u003cspan\u003e2239\u003c/span\u003e\n\u003c/span\u003e\u003cspan\u003esingle-row RLE                            - \u003cspan\u003e3300\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"toc:wait-so-how-do-you-actually-run-this-inside-vim\"\u003eWait, so how do you actually run this inside vim\u003c/h2\u003e\n\u003cp\u003eYes, right, that’s a good question.\u003c/p\u003e\n\u003cp\u003eHere’s an image of the vim setup:\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"vim. There are 2 rows of windows - the first row contains a large window with an image from Bad Apple, flanked by two smaller empty buffers. The bottom row contains a single wide window with a lot of unreadable small text.\" loading=\"lazy\" width=\"3020\" height=\"1720\" decoding=\"async\" data-nimg=\"1\" src=\"https://eieio.games/images/bad-apple-with-regex-in-vim/vimsetup.png\"/\u003e\u003c/p\u003e\u003cp\u003eit\u0026#39;s all clear now right?\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eThe center window on the top is where we play the video. It’s a file that contains 90 lines of 120 spaces (remember that our images are 120x90); since we’re matching on rows and columns it doesn’t need to have any content. To its left and right are some empty buffers that are sized to center the image.\u003c/p\u003e\n\u003cp\u003eThe bottom window is our list of search patterns! All ~6,500 of them.\u003c/p\u003e\n\u003cp\u003eTo play the video we use a vim macro. If you haven’t seen vim macros, they’re a way to record a series of arbitrary keystrokes to be replayed later. They’re extremely powerful - since you do ~everything in vim via the keyboard, you can trivially record and replay \u003cem\u003eany\u003c/em\u003e action. And if you set up your macro right (so that it ends with the cursor in the right spot for the next iteration) you can tell vim to run the macro many times in a row!\u003c/p\u003e\n\u003ch3 id=\"toc:the-macro\"\u003eThe macro\u003c/h3\u003e\n\u003cp\u003eThe macro is \u003ccode\u003e\u0026#34;ay$:let @/=@a^M+\u003c/code\u003e. That is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#34;a\u003c/code\u003e Operate over register a\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ey$\u003c/code\u003e Yank until the end of the line\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eVim has “named” registers that can hold text - ‘a’ now contains the current line\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e:\u003c/code\u003e Enter command mode\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elet @/=@a\u003c/code\u003e set the contents of register \u003ccode\u003e/\u003c/code\u003e to the contents of register \u003ccode\u003ea\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e^M\u003c/code\u003e execute the command (\u003ccode\u003e^M\u003c/code\u003e represents the enter key)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eTo reference a register in command mode you use \u003ccode\u003e@\u003c/code\u003e followed by the register name. Vim has special registers - the \u003ccode\u003e/\u003c/code\u003e register represents the current search. At this point vim is searching for the query that is on the current line\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e move to the start of the next line\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eThis is what I meant by “if you set up your macro right you can make it replayable” - we’re prepared to execute our macro again because the cursor is now on the start of the next line!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThis might look like nonsense to you - I’m pretty comfortable with macros because of the years that I’ve spent \u003ca href=\"https://www.vimgolf.com/\"\u003evim golfing\u003c/a\u003e. But it works!\u003c/p\u003e\n\u003cp\u003eThe most interesting optimization is \u003ccode\u003elet @/=@a\u003c/code\u003e - an alternative is to do something like \u003ccode\u003e/^Ra^M\u003c/code\u003e (begin a search, pastes the output of register \u003ccode\u003ea\u003c/code\u003e, enter), but this is a problem because it requires directly pasting a query that is potentially thousands of characters long. This causes the search window to expand to fit the query, which creates a flickering effect and reduces framerate.\u003c/p\u003e\n\u003cp\u003eBut now we can run \u003ccode\u003e1500@q\u003c/code\u003e (assuming we recorded the macro into register \u003ccode\u003eq\u003c/code\u003e) to play the macro 1500 times - meaning that we’ll run through 1500 frames as quickly as we can.\u003c/p\u003e\n\u003cp\u003eAnd that gives us this!\u003c/p\u003e\n\n\u003ch2 id=\"toc:wrapping-up\"\u003eWrapping up\u003c/h2\u003e\n\u003cp\u003eThis was really fun! I built this in a single day, but if I wanted to spend more time on it I might make a few tweaks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI think it’d be more magical if I had gone the “create a well-structured file that I can craft traditional regexs over” route instead of using vim’s line/col search feature. You might (reasonably) quibble that these aren’t real regexs!\u003c/li\u003e\n\u003cli\u003eI make no effort to keep a \u003cem\u003estable\u003c/em\u003e framerate, and the framerate definitely fluctuates a bit over the course of the video.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut this was good enough for my purposes. And I think it’s neat that I’ve built most of a general-purpose solution for playing a video inside of vim using search queries. Someone suggested that I record a video of me running Bad Apple in vim and play \u003cem\u003ethat\u003c/em\u003e video in vim. So I guess I’ll get on that.\u003c/p\u003e\n\u003cp\u003eBeyond that, I made this in my first week of a new batch at \u003ca href=\"https://recurse.com\"\u003eThe Recurse Center\u003c/a\u003e, a place that offers something like a writers retreat but for programming. I presented it to folks there and got a lovely response. I really love Recurse, and if you love nonsense like this I bet you’d like it too. Consider \u003ca href=\"https://recurse.com/apply\"\u003eapplying!\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFinally, the code is super messy but if you want to poke around \u003ca href=\"https://github.com/nolenroyalty/vim-badapple\"\u003eyou can see it here\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAnd that’s all I’ve got. As always, I’ll be back with more nonsense soon.\u003c/p\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2025-01-10T00:00:00Z",
  "modifiedTime": null
}
