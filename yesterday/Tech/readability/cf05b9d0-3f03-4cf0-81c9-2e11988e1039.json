{
  "id": "cf05b9d0-3f03-4cf0-81c9-2e11988e1039",
  "title": "Fun with C++26 reflection: Keyword Arguments",
  "link": "https://pydong.org/posts/KwArgs/",
  "description": "Comments",
  "author": "",
  "published": "Mon, 10 Feb 2025 23:16:33 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Che",
  "length": 29262,
  "excerpt": "In this blog post, we’ll explore implementing order-independent keyword arguments for C++ through use of C++26’s proposed reflection features. I stumbled upon this technique while experimenting with reflection a few days ago and thought it might be worthwhile to share, as it nicely showcases just how powerful the proposed reflection features are.",
  "siteName": "Pydong",
  "favicon": "https://pydong.org/assets/img/favicons/apple-touch-icon.png",
  "text": "In this blog post, we’ll explore implementing order-independent keyword arguments for C++ through use of C++26’s proposed reflection features. I stumbled upon this technique while experimenting with reflection a few days ago and thought it might be worthwhile to share, as it nicely showcases just how powerful the proposed reflection features are.An example implementation of the technique presented in this blog post can be found on GitHub. It can be used with Bloomberg’s experimental P2996 clang fork. If you enjoy these shenanigans, feel free to leave a star. :)Prior artNamed, labeled or keyword arguments have been proposed many times over the years, but as EWG issue 150 notes: all of these attempts have failed. Here is several past proposals on the topic:n4172 Named argumentsp1229 Labelled Parametersp0671 Self-explanatory Function ArgumentsSince none of these proposals were accepted, we have to be somewhat creative to get similar functionality in C++. Naturally, there are various approaches to this problem. Below is a short overview of what you can already do without reflection.Designated initializersLet’s start with the simplest way to achieve keyword argument-like syntax. C++20 introduced designated initializers for aggregate types, which gives us the initialization syntax Point{.x=42, .y=7}.In a function call’s argument list the type can potentially be deduced, so we could write foo({.x=2, .y=2}). While this requires extra curly braces and .-prefixes for every member name, syntactically this is almost what we want.Usage example (Run on Compiler Explorer):1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct FooArgs { int x; int y; }; void foo(FooArgs args) { std::println(\"x: {} y: {}\", args.x, args.y); } struct BarArgs { int x; }; void bar(int x, BarArgs args) { std::println(\"x: {} y: {}\", x, args.x); } int main() { // optional keyword arguments foo({.x = 2, .y = 42}); foo({.x = 2}); // positional arguments and keyword arguments bar(12, {.x = 10}); } Unfortunately this has various drawbacks:Extra Type Definitions - we need to define a type for every set of keyword arguments out-of-line.Optional Arguments - While std::optional can be used to express optionality of arguments, additional keyword arguments cannot be passed.Order Sensitivity - Arguments must appear in the exact order their corresponding members were declared in the aggregate, although skipping members is still fine.Helper objectsAs it turns out, making the desired syntax bar(12, x = 10) valid C++ is not actually that difficult. To do this, let x be an object of some type with an operator= overload that wraps the value in some way that later lets us retrieve it by name.You might be able to see the problem here already - this needs to be done for every named argument.Essentially, all you need to do at the library side of things is define a wrapper, like so:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u003ctypename T, util::fixed_string Name\u003e struct TypedArg { T value; decltype(auto) operator*(this auto\u0026\u0026 self) { return std::forward\u003cdecltype(self)\u003e(self).value; } }; template \u003cutil::fixed_string Name\u003e struct Arg { template \u003ctypename T\u003e TypedArg\u003cT, Name\u003e operator=(T\u0026\u0026 value) const{ return {std::forward\u003cT\u003e(value)}; } }; Now we can introduce helpers like this:1 constexpr inline Arg\u003c\"name\"\u003e name; This could potentially be hidden behind a macro to reduce the possibility of messing up the repetition of the argument’s name, but you still need to carefully do this wherever keyword arguments shall be used.To accept keyword arguments, functions must wrap their parameters as well.1 2 3 void foo(int x, int y); // becomes void foo(TypedArg\u003cint, \"x\"\u003e x, TypedArg\u003cint, \"y\"\u003e y); Once again, a macro could help here.To access the wrapped value, we can use the unary * operator:1 2 3 4 5 6 7 8 void bar(int a, TypedArg\u003cint, \"x\"\u003e x) { std::println(\"a: {} x: {}\", a, *x); } constexpr inline Arg\u003c\"x\"\u003e x; int main() { bar(10, x = 4); } Run on Compiler ExplorerOrder-independent argumentsTo support order-independent arguments, functions can receive the keyword arguments as a pack. We can then pick out the desired keyword arguments by re-using std::get’s ability to retrieve a tuple’s element by type.1 2 3 4 template \u003ctypename Needle, typename... Ts\u003e constexpr decltype(auto) pick(Ts\u0026\u0026... args) { return *std::get\u003cNeedle\u003e(std::make_tuple(std::forward\u003cTs\u003e(args)...)); } Now, keyword arguments can be passed in any order (Run on Compiler Explorer):1 2 3 4 5 6 7 8 9 10 11 12 13 void oof(auto... kwargs) { auto x = pick\u003cTypedArg\u003cint, \"x\"\u003e\u003e(kwargs...); auto y = pick\u003cTypedArg\u003cint, \"y\"\u003e\u003e(kwargs...); std::println(\"x: {}, y: {}\", x, y); } constexpr inline Arg\u003c\"x\"\u003e x; constexpr inline Arg\u003c\"y\"\u003e y; int main() { oof(y=42, x=2); oof(x=2, y=42); } The same technique can be used to implement optional arguments. To do this, simply let pick return a default if none of the argument pack’s elements was of the desired type.args variable templateTo further improve upon this, we want to eliminate the error-prone and somewhat unpleasant need to define helpers out-of-line first. Since they are all of the same type, we can instead use a single variable template arg:1 2 template \u003cutil::fixed_string Name\u003e constexpr inline Arg\u003cName\u003e arg{}; This allows us to write code like this (Run on Compiler Explorer):1 2 foo(arg\u003c\"x\"\u003e = 2, arg\u003c\"y\"\u003e = 42); bar(12, arg\u003c\"x\"\u003e = 10); However, that approach is still somewhat verbose. Also note that the space between \u003e and = is required to avoid parsing issues.User-defined literal operator templateA user-defined literal operator template can be used to further streamline the syntax:1 2 3 4 template\u003cutil::fixed_string Name\u003e constexpr Arg\u003cName\u003e operator \"\"_arg() { return {}; } Now, we can write:1 2 3 4 5 6 // optional keyword arguments foo(\"x\"_arg = 2, \"y\"_arg = 42); foo(\"x\"_arg = 2); // positional arguments and keyword arguments bar(12, \"x\"_arg = 10); Run on Compiler ExplorerThis might be a little prettier than the previous example, but it’s still rather verbose. However, if we want the desired syntax back we could still write:1 2 3 4 constexpr inline auto x = \"x\"_arg; constexpr inline auto y = \"y\"_arg; foo(x=2, y=3); A reflective approachSo.. can we do any better with reflection?While we might not be able to provide the desired syntax foo(3, x=5) directly, reflection allows us to inject new class types with named non-static data members. For all intents and purposes the keyword arguments are therefore collected into a named tuple.This means we can constrain the receiving function to express non-optionality of keyword arguments:1 2 3 4 5 6 7 8 template \u003ctypename T\u003e requires requires(T kwargs) { { kwargs.x } -\u003e std::convertible_to\u003cint\u003e; { kwargs.y } -\u003e std::convertible_to\u003cint\u003e; } void foo(erl::kwargs_t\u003cT\u003e const\u0026 kwargs) { std::println(\"x: {} y: {}\", kwargs.x, erl::get\u003c\"y\"\u003e(kwargs)); } Run on compiler explorerAll keyword arguments that we require to exist can safely be accessed using member access syntax or erl::get.Optional keyword arguments can be accessed with erl::get_or or a combination of erl::get with erl::has_arg or an inline requires expression:1 2 3 4 5 6 7 8 9 10 11 12 template \u003ctypename T\u003e void foo(erl::kwargs_t\u003cT\u003e const\u0026 kwargs) { if constexpr (erl::has_arg\u003cT\u003e(\"x\")) { std::println(\"x: {}\", get\u003c\"x\"\u003e(kwargs)); } if constexpr (requires { kwargs.y; }) { std::println(\"y: {}\", kwargs.y); } std::println(\"z: {}\", get_or\u003c\"z\"\u003e(kwargs, \"\u003cunmatched\u003e\")); } Run on Compiler ExplorerTo create the keyword argument tuple at the call site, we need to wrap all keyword arguments somehow - for this we will later introduce the macro make_args. This is how it can be used:1 2 3 4 5 6 7 8 9 10 11 12 13 14 // optional keyword arguments foo(make_args(y = 42, x = 2)); foo(make_args(x = 2)); // positional arguments and keyword arguments bar(12, make_args(x = 10)); // references int const baz = 24; bar(12, make_args(\u0026x = baz)); // shorthand int x = 2; foo(make_args(x, y=23)); Run on Compiler ExplorerThe order in which keyword arguments appear does not matter and we can use shorthands. If this reminds you of lambdas, you’re spot on.Reflecting lambda closure typesLambda captures are almost a perfect fit - their order does not matter, their type is deduced and lambdas introduce a class type with every capture corresponding to a non-static data member for us.Unfortunately though lambda closures are neither decomposable through a structured binding (unless you use GCC) nor are lambda captures directly accessible outside of the lambda’s body.Nevertheless, C++26 reflection allows us to reflect private members.ExpansionSince this blog post is mostly about P2996, expansion statements (as proposed in P1306) are not used. In lieu of expansion statements, we will instead use the expand helper. The syntax might look a little weird at first, but you’ll get used to it.1 2 3 4 5 6 7 8 9 10 //p1306 expansion statement template for (constexpr auto member : nonstatic_data_members_of(^^Type)) { // ... } // roughly equivalent to [:expand(nonstatic_data_members_of(^^Type)):] \u003e\u003e []\u003cstd::meta::info... Member\u003e { // ... } The implementation of expand looks roughly like this:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace impl { template \u003cauto... Vs\u003e struct Replicator { template \u003ctypename F\u003e constexpr decltype(auto) operator\u003e\u003e(F fnc) const { return fnc.template operator()\u003cVs...\u003e(); } }; template \u003cauto... Vs\u003e constexpr static Replicator\u003cVs...\u003e replicator{}; } // namespace impl template \u003cstd::ranges::range R\u003e consteval auto expand(R const\u0026 range) { std::vector\u003cstd::meta::info\u003e args; for (auto item : range) { args.push_back(reflect_value(item)); } return substitute(^^impl::replicator, args); } This has the added benefit of giving us the items as a pack.With expand we can now print some information about a lambda closure type, so let’s do that.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { int baz = 42; auto closure = [x=420, \u0026bar = baz]{}; using closure_type = decltype(closure); [:expand(nonstatic_data_members_of(^^closure_type)):] \u003e\u003e [\u0026]\u003cauto... members\u003e { (std::println(\"has identifier: {} - type: {:\u003c5} - value: {}\", has_identifier(members), display_string_of(type_of(members)), closure.[:members:]), ...); }; } // Output: // has identifier: false - type: int - value: 420 // has identifier: false - type: int \u0026 - value: 42 Run on Compiler ExplorerGood news, we can reuse Java memes we can get types of lambda captures and references are properly handled. Even better, we can splice in the respective member to access captures outside of the lambda (for now.. see P3587). Bad news though, the members are all unnamed.Order of capturesNote that [expr.prim.lambda.capture]/10 makes the declaration order of the lambda closure’s members unspecified. While the following hackery with lambdas might work, it is not guaranteed.Parsing the capture listTo work around the lack of member names, we can stringify the capture list and parse it to recover the member names from it. To do this, we introduce the macro make_args.1 2 3 4 5 6 7 8 namespace kwargs { template \u003cfixed_string str, typename T\u003e auto from_lambda(T\u0026\u0026 captures) { // ... } } #define make_args(...) ::kwargs::from_lambda\u003c#__VA_ARGS__\u003e([__VA_ARGS__] {}) Let’s address the elephant in the room - parsing even a subset of C++ correctly is difficult. Lambda capture lists can be highly complex, but the vast majority of “odd” ones aren’t really meaningful in the context of named arguments. This allows us to limit the scope of our parser.We obviously want to support captures of the form arg1 = 123, arg2 = ident, but it would also be nice to allow for shorthands such as x,y - which would be equivalent to x=x,y=y in a lambda’s capture list.Additionally, capturing arguments by reference is sometimes necessary. Our parser must therefore handle cases like \u0026foo = bar or \u0026foo without failing. This leaves us with two grammar rules:1 2 capture-list ::= capture (\",\" capture)* ; capture ::= [\"\u0026\"] identifier [ \"=\" expression ] ; UtilitiesUnfortunately, parsing expressions is still unavoidable since they can contain commas, as in foo(1, 2), Foo{1, 2} or foo[1, 2]. However, since we do not actually need to understand the expressions, it’s sufficient to ensure we do not prematurely stop on a , inside unbalanced curly braces, parentheses or square brackets when skipping forward to the next capture.Let’s start by defining a Parser base class:1 2 3 4 5 6 7 struct Parser { std::string_view data; std::size_t cursor{0}; [[nodiscard]] constexpr char current() const { return data[cursor]; } [[nodiscard]] constexpr bool is_valid() const { return cursor \u003c data.length(); } }; The desired utility can now be implemented. Since it does not matter if the code we parse is syntactically valid, counting (] the same way as () is fine.1 2 3 4 5 6 7 8 9 10 11 12 13 constexpr void skip_to(std::same_as\u003cchar\u003e auto... needles) { int brace_count = 0; while (is_valid()) { if (char c = current(); brace_count == 0 \u0026\u0026 ((c == needles) || ...)) { break; } else if (c == '[' || c == '{' || c == '(') { ++brace_count; } else if (c == ']' || c == '}' || c == ')') { --brace_count; } ++cursor; } } Since whitespace is also often not significant, another utility function to skip whitespace - let’s call it skip_whitespace - is also very useful. Since its implementation is trivial, it is omitted here.Implementing the parserAt this point, it’s also advisable to reject various captures that would not make sense for our use case. These include:Capture KindReasoningCapturing thisA member cannot be named this, so injecting the container would fail.Default captures = and \u0026Since the lambda’s body is empty, these would not capture anything.Packs ...fooEvery argument must have a name for keyword argument handling.With the aforementioned utilities, the actual capture list parser can now be implemented as follows:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 struct NameParser : Parser { std::vector\u003cstd::string_view\u003e names; constexpr bool parse() { while (is_valid()) { skip_whitespace(); if (current() == '\u0026') { // might be captured by reference ++cursor; skip_whitespace(); } if (current() == '.') { // pack captured, reject return false; } auto start = cursor; // find `=`, `,` or whitespace skip_to('=', ',', ' ', '\\r', '\\n', '\\t'); // retrieve the name if (cursor - start == 0) { // default capture or invalid name return false; } auto name = data.substr(start, cursor - start); if (name == \"this\" || name == \"*this\") { // this captured, reject return false; } names.push_back(name); // skip ahead to next capture // this won't move the cursor if the current character is already `,` skip_to(','); ++cursor; } return true; } }; Constexpr ExceptionsP3068 proposes support for exceptions during constant evaluation. If accepted, we could make names a local variable and have parse return it. Invalid captures could then be rejected by throwing an exception.Injecting the kwargs container typeSince we now know the names for the lambda’s unnamed members, we can inject an aggregate class type with named members of appropriate type for every capture of the lambda.First, we need to parse the stringified capture list and create data member specifications that associate each non-static data member of the lambda closure with its corresponding name. This can then be used to inject the keyword argument container type.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template \u003ctypename Impl\u003e struct [[nodiscard]] kwargs_t : Impl { using type = Impl; }; template \u003cutil::fixed_string Names, typename... Ts\u003e constexpr auto make(Ts\u0026\u0026... values) { struct kwargs_impl; consteval { std::vector\u003cstd::meta::info\u003e types{^^Ts...}; std::vector\u003cstd::meta::info\u003e args; auto parser = NameParser{Names.to_sv()}; if(!parser.parse()) { // name list rejected or parsing error, abort return; } // associate every argument with the corresponding name // retrieved by parsing the capture list for (auto [member, name] : std::views::zip(types, parser.names)) { args.push_back(data_member_spec(member, {.name = name})); } define_aggregate(^^kwargs_impl, args); }; // ensure injecting the class worked static_assert(is_type(^^kwargs_impl), \"Could not inject named argument class\"); return kwargs_t\u003ckwargs_impl\u003e; } At this point make\u003c\"x,y\"\u003e(123, \"foo\") can already be used to make named arguments x=123 and y=\"foo\" without the use of lambdas.For the lambda hackery to work, we need to reflect the lambda’s private non-static data members to produce an appropriate keyword argument container. Finally we need to extract these members from the lambda produced by the make_args macro.1 2 3 4 5 6 7 8 9 template \u003cutil::fixed_string Names, typename T\u003e auto from_lambda(T\u0026\u0026 lambda) { using fnc_t = std::remove_cvref_t\u003cT\u003e; return [:meta::expand(nonstatic_data_members_of(^^fnc_t)):] \u003e\u003e [\u0026]\u003cauto... member\u003e() { return make\u003cNames\u003e(std::forward\u003cT\u003e(lambda).[:member:]...); }; } As mentioned before, to simplify usage on the receiving side, kwargs_t\u003cT\u003e should also implement the tuple protocol. This means we need to provide specializations for std::tuple_size and std::tuple_element. Also we’ll need to implement get for kwargs_t\u003cT\u003e.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u003ctypename T\u003e struct std::tuple_size\u003ckwargs_t\u003cT\u003e\u003e : public integral_constant\u003csize_t, nonstatic_data_members_of(^^std::remove_cvref_t\u003cT\u003e).size()\u003e{}; template \u003cstd::size_t I, typename T\u003e struct std::tuple_element\u003cI, kwargs_t\u003cT\u003e\u003e { using type = [:get_nth_field(^^T, I):]; }; template \u003cstd::size_t I, typename T\u003e constexpr auto get(kwargs_t\u003cT\u003e const\u0026 t) noexcept { return t.[:get_nth_field(^^T, I):]; } Additionally, we want to be able to retrieve keyword arguments by name. Since this might fail, it can be useful to return a default value when no member with the requested name is found. For this, we introduce get_or.1 2 3 4 5 6 7 8 9 10 11 12 13 template \u003cfixed_string name, typename T\u003e constexpr auto get_or(kwargs_t\u003cT\u003e const\u0026 t) { return t.[:get_nth_field(^^T, get_member_index(name.to_sv())):]; } template \u003cfixed_string name, typename T, typename R\u003e constexpr auto get_or(kwargs_t\u003cT\u003e const\u0026 t, R default_) { if constexpr (get_member_index\u003cT\u003e(name.to_sv()) == -1UZ) { return default_; } else { return t.[:get_nth_field(^^T, get_member_index\u003cT\u003e(name.to_sv())):]; } } Function parameter reflectionWhat if we could wrap any function and convert keyword arguments to positional arguments in calls to it as needed? Thanks to P3096 function parameter reflection, this would also be possible.Essentially, we want to be able to write the following:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void foo_impl(int x, char c, double d) { printf(\"x: %d c: %c d: %f\\n\", x, c, d); } constexpr inline erl::kwargs::Wrap\u003c^^foo_impl\u003e foo; int main() { foo(3, 'c', 2.2); foo(3, 'c', make_args(d = 2.2)); foo(3, make_args(c = 'c', d = 2.2)); foo(make_args(c = 'c', x = 3, d = 2.2)); // error: Argument `d` missing. // foo(3, make_args(c = 'c')); // error: Positional argument `x` repeated as keyword argument. // foo(3, make_args(x = 4)); } Run on Compiler ExplorerNote that this only works with free functions and static member functions. Function templates and function objects are not supported.ImplementationUnfortunately non-trailing packs are not deduced. If our keyword argument tuple were the first parameter this would be trivial, but realistically that does not look very nice and would also be inconsistent with our previous mixed usage.Consider the following example (Run on Compiler Explorer):1 2 3 4 5 6 7 8 9 10 template \u003ctypename... Args, typename T\u003e void foo(Args... args, T kwargs); int main() { foo\u003cint\u003e(1, 0); // OK // Args... = \u003c\u003e, T = int // error: no matching function for call to 'foo' foo(1, 0); } P2347 solves this issue, for more information please refer to cor3ntin’s amazing blog post about it.Pack indexingTo circumvent this limitation, we can leverage P2662 pack indexing to extract the last argument, which allows us to check if it is a keyword argument container.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u003cstd::meta::info F\u003e requires (is_function(F)) struct Wrap { template \u003ctypename... Args\u003e requires (sizeof...(Args) \u003e 0) static constexpr decltype(auto) operator()(Args\u0026\u0026... args) { using T = std::remove_cvref_t\u003cArgs...[pos_only]\u003e; if constexpr (erl::is_kwargs\u003cT\u003e) { // handle keyword arguments // ... } else { // no keyword arguments return [:F:](std::forward\u003cArgs\u003e(args)...); } } }; Combining positional and keyword argumentsTo properly merge the received positional arguments with the given keyword arguments, we need to:Expand args except for the last elementExtract the remaining parameters of F from the last element of args (the keyword argument container)ExpansionFor the following to work, one adjustment to the aforementioned expand helper must be made.Replicator’s operator\u003e\u003e expands all elements of the range into the template argument list of a single call to the given lambda. Similarly we want operator\u003e\u003e= to call the lambda once per element, passing one template argument at a time.1 2 3 4 5 6 7 8 9 10 11 12 template \u003cauto... Vs\u003e struct Replicator { template \u003ctypename F\u003e constexpr decltype(auto) operator\u003e\u003e(F fnc) const { return fnc.template operator()\u003cVs...\u003e(); } template \u003ctypename F\u003e constexpr void operator\u003e\u003e=(F fnc) const { (fnc.template operator()\u003cVs\u003e(), ...); } }; Additionally, we introduce a shorthand sequence(N), which is equivalent to expand(std::ranges::iota_view{0U, N}).To do this, we need two nested expansions. The first expansion must expand the reflected parameters of F, except for the first sizeof...(Args) - 1 parameters. The second expansion shall expand an integer sequence from 0 to sizeof...(Args) - 1.1 2 3 4 5 6 7 8 9 10 11 12 13 static constexpr std::size_t pos_only = sizeof...(Args) - 1; return [:meta::expand(parameters_of(F) | std::views::drop(pos_only)):] \u003e\u003e [\u0026]\u003cauto... Params\u003e { return [:meta::sequence(pos_only):] \u003e\u003e [\u0026]\u003cstd::size_t... Idx\u003e { return [:F:]( /* positional arguments */ std::forward\u003cArgs...[Idx]\u003e(args...[Idx])..., /* keyword arguments */ get\u003cmeta::get_member_index\u003cT\u003e(identifier_of(Params))\u003e(args...[pos_only])...); }; }; Adding diagnosticsWe also want to detect and report errors when:A positional argument is repeated as keyword argumentA required argument was missing altogetherFor this we can use expand in combination with the \u003e\u003e= operator to look at F’s parameters one at a time. Also p2741 can be used at this point to provide very nice diagnostics.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u003ctypename T, std::size_t PosOnly = 0\u003e static constexpr void check_args() { [:erl::meta::expand(parameters_of(F) | std::views::take(PosOnly)):] \u003e\u003e= [\u0026]\u003cauto Param\u003e { static_assert(!erl::meta::has_member\u003cT\u003e(identifier_of(Param)), std::string{} + \"In call to `\" + identifier_of(F) + \"`: \" \"Positional argument `\" + identifier_of(Param) + \"` \" \"repeated as keyword argument.\" ); }; [:erl::meta::expand(parameters_of(F) | std::views::drop(PosOnly)):] \u003e\u003e= [\u0026]\u003cauto Param\u003e { static_assert(erl::meta::has_member\u003cT\u003e(identifier_of(Param)), \"In call to `\" + std::string(identifier_of(F)) + \"`: \" \"Argument `\" + identifier_of(Param) + \"` missing.\" ); }; } Bonus: Format strings with named argumentsAside from positional arguments, the awesome fmt library also allows for named arguments. You might be able to recognize the approach used in fmt, here’s what the code would look like:1 2 3 4 5 6 7 fmt::print(\"Hello, {name}! The answer is {number}. Goodbye, {name}.\", fmt::arg(\"name\", \"World\"), fmt::arg(\"number\", 42)); // alternatively using namespace fmt::literals; fmt::print(\"Hello, {name}! The answer is {number}. Goodbye, {name}.\", \"name\"_a=\"World\", \"number\"_a=42); Let’s implement similar functionality using erl::kwargs_t.Transforming the format stringSince std::format does not yet support named arguments like fmt, we need to transform the format string into a format that std::format understands.std::format allows referring to arguments by position (e.g. std::format(\"{1}{0}\", 0, 42)). We can therefore expand all keyword arguments into the std::format call’s argument list and transform the format string so it refers to them by position rather than by name.The parser utilities we defined earlier can be re-used to transform the format string. Here’s an example implementation:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct FmtParser : Parser { constexpr std::string transform(std::ranges::forward_range auto\u0026\u0026 names) { std::string out; int brace_count = 0; while (is_valid()) { out += current(); if (current() == '{') { ++cursor; if (current() == '{') { // double curly braces means escaped curly braces // =\u003e treat the content as text auto start = cursor; // skip to first unbalanced } // this will match the outer { skip_to('}'); out += data.substr(start, cursor - start); continue; } // find name auto start = cursor; skip_to('}', ':'); auto name = data.substr(start, cursor - start); // replace name auto it = std::find(names.begin(), names.end(), name); auto idx = std::distance(names.begin(), it); out += itoa(idx); out += current(); } ++cursor; } return out; } }; Wrapping std::format_stringAt some point we will have to produce a std::format_string. To avoid having to resort to runtime format checking, we can instead instantiate a template function that handles formatting for us. This function shall receive the format string as constant template argument.So let’s first provide a replacement for the std::format_string argument of format - note that the constructor must be consteval.1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u003ctypename Args\u003e struct NamedFormatString { using format_type = std::string (*)(Args const\u0026); format_type format; template \u003ctypename Tp\u003e requires std::convertible_to\u003cTp const\u0026, std::string_view\u003e consteval explicit(false) NamedFormatString(Tp const\u0026 str) { auto parser = FmtParser{str}; auto fmt = parser.transform(meta::get_member_names\u003ctypename Args::type\u003e()); format = extract\u003cformat_type\u003e( substitute(^^format_impl, {meta::intern(fmt),^^Args})); } }; This will instantiate format_impl with the transformed format string as constant template argument for us. In format_impl we can retrieve the keyword arguments and simply delegate to std::format.1 2 3 4 5 6 7 template \u003cutil::fixed_string fmt, typename Args\u003e std::string format_impl(Args const\u0026 kwargs) { return [:meta::sequence(std::tuple_size_v\u003cArgs\u003e):] \u003e\u003e [\u0026]\u003cstd::size_t... Idx\u003e() { return std::format(fmt, get\u003cIdx\u003e(kwargs)...); }; } We can now define two versions of format - one for named arguments and one to wrap the existing functionality of std::format.1 2 3 4 5 6 7 8 9 10 11 template \u003ctypename T\u003e requires(is_kwargs\u003cT\u003e) void print(NamedFormatString\u003cT\u003e fmt, T const\u0026 kwargs) { fmt.print(kwargs); } template \u003ctypename... Args\u003e requires(sizeof...(Args) != 1 || (!is_kwargs\u003cstd::remove_cvref_t\u003cArgs\u003e\u003e \u0026\u0026 ...)) void print(std::format_string\u003cArgs...\u003e fmt, Args\u0026\u0026... args) { std::print(fmt, std::forward\u003cArgs\u003e(args)...); } Similarly, std::print and std::println can be wrapped using the same approach.UsageWith this, we can now write:1 2 3 erl::format(\"{bar}{foo}\", make_args(bar=0, foo=42)); // instead of std::format(\"{1}{0}\", 0, 42) Notice how the order in which arguments appear in make_args does not matter.Here’s a full example (Run on compiler explorer):1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u003cvector\u003e #include \u003ciostream\u003e #define KWARGS_FORMATTING 1 #include \u003ckwargs.h\u003e int main() { int x = 3; std::vector\u003cint\u003e list = {1, 2, 3, 4}; erl::print(\"{} {}\\n\", 42, x); erl::print(\"{1} {0}\\n\", x, 42); erl::print(\"{x} {y}\\n\", make_args(x=42, y=x)); erl::print(\"x: {} list: {} : {}\", x, list, \"foo\"); erl::print(\"x: {0} list: {2} : {1}\", x, \"foo\", list); erl::println(\"x: {x} list: {list} : {str}\", make_args(x=x, str=\"foo\", list=list)); erl::println(\"x: {x} list: {list} : {str}\", make_args(x, str=\"foo\", list)); std::cout \u003c\u003c erl::format(\"{x} {y}\", make_args(x, y=3)) \u003c\u003c '\\n'; }",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eIn this blog post, we’ll explore implementing order-independent keyword arguments for C++ through use of C++26’s \u003ca href=\"https://wg21.link/p2996\"\u003eproposed reflection\u003c/a\u003e features. I stumbled upon this technique while experimenting with reflection a few days ago and thought it might be worthwhile to share, as it nicely showcases just how powerful the proposed reflection features are.\u003c/p\u003e\u003cp\u003eAn example implementation of the technique presented in this blog post can be found on \u003ca href=\"https://github.com/tsche/kwargs\"\u003eGitHub\u003c/a\u003e. It can be used with Bloomberg’s experimental \u003ca href=\"https://github.com/bloomberg/clang-p2996\"\u003eP2996 clang fork\u003c/a\u003e. If you enjoy these shenanigans, feel free to leave a star. :)\u003c/p\u003e\u003ch2 id=\"prior-art\"\u003e\u003cspan\u003ePrior art\u003c/span\u003e\u003ca href=\"#prior-art\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eNamed, labeled or keyword arguments have been proposed many times over the years, but as \u003ca href=\"https://cplusplus.github.io/EWG/ewg-closed.html#150\"\u003eEWG issue 150\u003c/a\u003e notes: all of these attempts have failed. Here is several past proposals on the topic:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://wg21.link/n4172\"\u003en4172\u003c/a\u003e Named arguments\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://wg21.link/p1229\"\u003ep1229\u003c/a\u003e Labelled Parameters\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://wg21.link/p0671\"\u003ep0671\u003c/a\u003e Self-explanatory Function Arguments\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSince none of these proposals were accepted, we have to be somewhat creative to get similar functionality in C++. Naturally, there are various approaches to this problem. Below is a short overview of what you can already do without reflection.\u003c/p\u003e\u003ch3 id=\"designated-initializers\"\u003e\u003cspan\u003eDesignated initializers\u003c/span\u003e\u003ca href=\"#designated-initializers\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eLet’s start with the simplest way to achieve keyword argument-like syntax. C++20 introduced designated initializers for aggregate types, which gives us the initialization syntax \u003ccode\u003ePoint{.x=42, .y=7}\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eIn a function call’s argument list the type can potentially be deduced, so we could write \u003ccode\u003efoo({.x=2, .y=2})\u003c/code\u003e. While this requires extra curly braces and \u003ccode\u003e.\u003c/code\u003e-prefixes for every member name, syntactically this is almost what we want.\u003c/p\u003e\u003cp\u003eUsage example (\u003ca href=\"https://godbolt.org/z/ja5oha875\"\u003eRun on Compiler Explorer\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eFooArgs\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eFooArgs\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {} y: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eBarArgs\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eBarArgs\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {} y: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// optional keyword arguments\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e({.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e});\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e({.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e});\u003c/span\u003e\n\n  \u003cspan\u003e// positional arguments and keyword arguments\u003c/span\u003e\n  \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e{.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eUnfortunately this has various drawbacks:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eExtra Type Definitions\u003c/strong\u003e - we need to define a type for every set of keyword arguments out-of-line.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eOptional Arguments\u003c/strong\u003e - While \u003ccode\u003estd::optional\u003c/code\u003e can be used to express optionality of arguments, additional keyword arguments cannot be passed.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eOrder Sensitivity\u003c/strong\u003e - Arguments must appear in the exact order their corresponding members were declared in the aggregate, although skipping members is still fine.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"helper-objects\"\u003e\u003cspan\u003eHelper objects\u003c/span\u003e\u003ca href=\"#helper-objects\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAs it turns out, making the desired syntax \u003ccode\u003ebar(12, x = 10)\u003c/code\u003e valid C++ is not actually that difficult. To do this, let \u003ccode\u003ex\u003c/code\u003e be an object of some type with an \u003ccode\u003eoperator=\u003c/code\u003e overload that wraps the value in some way that later lets us retrieve it by name.\u003c/p\u003e\u003cp\u003eYou might be able to see the problem here already - this needs to be done for \u003cem\u003eevery\u003c/em\u003e named argument.\u003c/p\u003e\u003cp\u003eEssentially, all you need to do at the library side of things is define a wrapper, like so:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eTypedArg\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eT\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)};\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNow we can introduce helpers like this:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis could potentially be hidden behind a macro to reduce the possibility of messing up the repetition of the argument’s name, but you still need to carefully do this wherever keyword arguments shall be used.\u003c/p\u003e\u003cp\u003eTo accept keyword arguments, functions must wrap their parameters as well.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e// becomes\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eOnce again, a macro could help here.\u003c/p\u003e\u003cp\u003eTo access the wrapped value, we can use the unary \u003ccode\u003e*\u003c/code\u003e operator:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;a: {} x: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://godbolt.org/z/h7a3vMaqY\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003ch4 id=\"order-independent-arguments\"\u003e\u003cspan\u003eOrder-independent arguments\u003c/span\u003e\u003ca href=\"#order-independent-arguments\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTo support order-independent arguments, functions can receive the keyword arguments as a pack. We can then pick out the desired keyword arguments by re-using \u003ccode\u003estd::get\u003c/code\u003e’s ability to retrieve a tuple’s element by type.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eNeedle\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003epick\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eNeedle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emake_tuple\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)...));\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNow, keyword arguments can be passed in any order (\u003ca href=\"https://godbolt.org/z/4ePfobjG5\"\u003eRun on Compiler Explorer\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eoof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003epick\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e...);\u003c/span\u003e\n  \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003epick\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTypedArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e...);\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {}, y: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eoof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003eoof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e  \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe same technique can be used to implement optional arguments. To do this, simply let \u003ccode\u003epick\u003c/code\u003e return a default if none of the argument pack’s elements was of the desired type.\u003c/p\u003e\u003ch4 id=\"args-variable-template\"\u003e\u003cspan\u003e\u003ccode\u003eargs\u003c/code\u003e variable template\u003c/span\u003e\u003ca href=\"#args-variable-template\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTo further improve upon this, we want to eliminate the error-prone and somewhat unpleasant need to define helpers out-of-line first. Since they are all of the same type, we can instead use a single variable template \u003ccode\u003earg\u003c/code\u003e:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e{};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis allows us to write code like this (\u003ca href=\"https://godbolt.org/z/GP8GE3n8z\"\u003eRun on Compiler Explorer\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHowever, that approach is still somewhat verbose. Also note that the space between \u003ccode\u003e\u0026gt;\u003c/code\u003e and \u003ccode\u003e=\u003c/code\u003e is required to avoid parsing issues.\u003c/p\u003e\u003ch4 id=\"user-defined-literal-operator-template\"\u003e\u003cspan\u003eUser-defined literal operator template\u003c/span\u003e\u003ca href=\"#user-defined-literal-operator-template\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eA user-defined \u003ca href=\"https://en.cppreference.com/w/cpp/language/user_literal#Literal_operators\"\u003eliteral operator template\u003c/a\u003e can be used to further streamline the syntax:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eArg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eName\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e{};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNow, we can write:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003e// optional keyword arguments\u003c/span\u003e\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003e// positional arguments and keyword arguments\u003c/span\u003e\n\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://godbolt.org/z/5oPTdsKbz\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThis might be a little prettier than the previous example, but it’s still rather verbose. However, if we want the desired syntax back we could still write:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e_arg\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"a-reflective-approach\"\u003e\u003cspan\u003eA reflective approach\u003c/span\u003e\u003ca href=\"#a-reflective-approach\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSo.. can we do any better with reflection?\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://pydong.org/assets/img/reflection-reflection-everywhere.jpg\"\u003e\u003cimg src=\"https://pydong.org/assets/img/reflection-reflection-everywhere.jpg\" alt=\"Reflection, reflection everywhere!\" loading=\"lazy\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eWhile we might not be able to provide the desired syntax \u003ccode\u003efoo(3, x=5)\u003c/code\u003e directly, reflection allows us to inject new class types with named non-static data members. For all intents and purposes the keyword arguments are therefore collected into a named tuple.\u003c/p\u003e\u003cp\u003eThis means we can constrain the receiving function to express non-optionality of keyword arguments:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003erequires\u003c/span\u003e \u003cspan\u003erequires\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003econvertible_to\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003econvertible_to\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {} y: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://cpp26.godbolt.org/z/nT751eM9n\"\u003eRun on compiler explorer\u003c/a\u003e\u003c/p\u003e\u003cp\u003eAll keyword arguments that we require to exist can safely be accessed using member access syntax or \u003ccode\u003eerl::get\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eOptional keyword arguments can be accessed with \u003ccode\u003eerl::get_or\u003c/code\u003e or a combination of \u003ccode\u003eerl::get\u003c/code\u003e with \u003ccode\u003eerl::has_arg\u003c/code\u003e or an inline requires expression:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ehas_arg\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erequires\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e})\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;y: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;z: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eget_or\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#34;z\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026lt;unmatched\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://cpp26.godbolt.org/z/9h3hnT5nx\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTo create the keyword argument tuple at the call site, we need to wrap all keyword arguments somehow - for this we will later introduce the macro \u003ccode\u003emake_args\u003c/code\u003e. This is how it can be used:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003e// optional keyword arguments\u003c/span\u003e\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n\u003cspan\u003e// positional arguments and keyword arguments\u003c/span\u003e\n\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n\u003cspan\u003e// references\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ebaz\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e24\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e12\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebaz\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n\u003cspan\u003e// shorthand\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e23\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://cpp26.godbolt.org/z/36s4jnbdv\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe order in which keyword arguments appear does not matter \u003cem\u003eand\u003c/em\u003e we can use shorthands. If this reminds you of lambdas, you’re spot on.\u003c/p\u003e\u003ch2 id=\"reflecting-lambda-closure-types\"\u003e\u003cspan\u003eReflecting lambda closure types\u003c/span\u003e\u003ca href=\"#reflecting-lambda-closure-types\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLambda captures are almost a perfect fit - their order does not matter, their type is deduced and lambdas introduce a class type with every capture corresponding to a non-static data member for us.\u003c/p\u003e\u003cp\u003eUnfortunately though lambda closures are neither decomposable through a structured binding (\u003ca href=\"https://godbolt.org/z/Wrjq37Y61\"\u003eunless you use GCC\u003c/a\u003e) nor are lambda captures directly accessible outside of the lambda’s body.\u003c/p\u003e\u003cp\u003eNevertheless, C++26 reflection allows us to reflect private members.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eExpansion\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSince this blog post is mostly about \u003ca href=\"https://wg21.link/p2996\"\u003eP2996\u003c/a\u003e, expansion statements (as proposed in \u003ca href=\"https://wg21.link/p1306\"\u003eP1306\u003c/a\u003e) are not used. In lieu of expansion statements, we will instead use the \u003ccode\u003eexpand\u003c/code\u003e helper. The syntax might look a little weird at first, but you’ll get used to it.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003e//p1306 expansion statement\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003emember\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003enonstatic_data_members_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n \u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// roughly equivalent to\u003c/span\u003e\n\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enonstatic_data_members_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eType\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eMember\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e// ...\u003c/span\u003e\n \u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe implementation of \u003ccode\u003eexpand\u003c/code\u003e looks roughly like this:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003enamespace\u003c/span\u003e \u003cspan\u003eimpl\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eReplicator\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e \u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e...\u0026gt;();\u003c/span\u003e\n \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eReplicator\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003ereplicator\u003c/span\u003e\u003cspan\u003e{};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e  \u003cspan\u003e// namespace impl\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eranges\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003erange\u003c/span\u003e \u003cspan\u003eR\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econsteval\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eR\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush_back\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ereflect_value\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n \u003cspan\u003e}\u003c/span\u003e\n \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003esubstitute\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eimpl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ereplicator\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis has the added benefit of giving us the items as a pack.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eWith \u003ccode\u003eexpand\u003c/code\u003e we can now print some information about a lambda closure type, so let’s do that.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ebaz\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eclosure\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e420\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003ebar\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebaz\u003c/span\u003e\u003cspan\u003e]{};\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003eclosure_type\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eclosure\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n  \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enonstatic_data_members_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eclosure_type\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003emembers\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;has identifier: {} - type: {:\u0026lt;5} - value: {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n                  \u003cspan\u003ehas_identifier\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emembers\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n                  \u003cspan\u003edisplay_string_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etype_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emembers\u003c/span\u003e\u003cspan\u003e)),\u003c/span\u003e\n                  \u003cspan\u003eclosure\u003c/span\u003e\u003cspan\u003e.[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emembers\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]),\u003c/span\u003e \u003cspan\u003e...);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// Output:\u003c/span\u003e\n\u003cspan\u003e// has identifier: false - type: int   - value: 420\u003c/span\u003e\n\u003cspan\u003e// has identifier: false - type: int \u0026amp; - value: 42\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://cpp26.godbolt.org/z/W67WhrETq\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://pydong.org/assets/img/private_properties.jpg\"\u003e\u003cimg src=\"https://pydong.org/assets/img/private_properties.jpg\" alt=\"private properties\" loading=\"lazy\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eGood news, \u003cdel\u003ewe can reuse Java memes\u003c/del\u003e we can get types of lambda captures and references are properly handled. Even better, we can splice in the respective member to access captures outside of the lambda (for now.. see \u003ca href=\"https://wg21.link/p3473\"\u003eP3587\u003c/a\u003e). Bad news though, the members are all unnamed.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eOrder of captures\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eNote that \u003ca href=\"https://standards.pydong.org/c++/expr.prim.lambda.capture#10\"\u003e[expr.prim.lambda.capture]/10\u003c/a\u003e makes the declaration order of the lambda closure’s members \u003cstrong\u003eunspecified\u003c/strong\u003e. While the following hackery with lambdas might work, it is not guaranteed.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"parsing-the-capture-list\"\u003e\u003cspan\u003eParsing the capture list\u003c/span\u003e\u003ca href=\"#parsing-the-capture-list\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo work around the lack of member names, we can stringify the capture list and parse it to recover the member names from it. To do this, we introduce the macro \u003ccode\u003emake_args\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003enamespace\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003efrom_lambda\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003ecaptures\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e#define make_args(...) ::kwargs::from_lambda\u0026lt;#__VA_ARGS__\u0026gt;([__VA_ARGS__] {})\n\u003c/span\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eLet’s address the elephant in the room - parsing even a subset of C++ correctly is difficult. Lambda capture lists can be highly complex, but the vast majority of “odd” ones aren’t really meaningful in the context of named arguments. This allows us to limit the scope of our parser.\u003c/p\u003e\u003cp\u003eWe obviously want to support captures of the form \u003ccode\u003earg1 = 123, arg2 = ident\u003c/code\u003e, but it would also be nice to allow for shorthands such as \u003ccode\u003ex,y\u003c/code\u003e - which would be equivalent to \u003ccode\u003ex=x,y=y\u003c/code\u003e in a lambda’s capture list.\u003c/p\u003e\u003cp\u003eAdditionally, capturing arguments by reference is sometimes necessary. Our parser must therefore handle cases like \u003ccode\u003e\u0026amp;foo = bar\u003c/code\u003e or \u003ccode\u003e\u0026amp;foo\u003c/code\u003e without failing. This leaves us with two grammar rules:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003ecapture-list  ::= capture (\u0026#34;,\u0026#34; capture)* ;\ncapture       ::= [\u0026#34;\u0026amp;\u0026#34;] identifier [ \u0026#34;=\u0026#34; expression ] ;\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch3 id=\"utilities\"\u003e\u003cspan\u003eUtilities\u003c/span\u003e\u003ca href=\"#utilities\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eUnfortunately, parsing expressions is still unavoidable since they can contain commas, as in \u003ccode\u003efoo(1, 2)\u003c/code\u003e, \u003ccode\u003eFoo{1, 2}\u003c/code\u003e or \u003ccode\u003efoo[1, 2]\u003c/code\u003e. However, since we do not actually need to understand the expressions, it’s sufficient to ensure we do not prematurely stop on a \u003ccode\u003e,\u003c/code\u003e inside unbalanced curly braces, parentheses or square brackets when skipping forward to the next capture.\u003c/p\u003e\u003cp\u003eLet’s start by defining a \u003ccode\u003eParser\u003c/code\u003e base class:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring_view\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n\n  \u003cspan\u003e[[\u003c/span\u003e\u003cspan\u003enodiscard\u003c/span\u003e\u003cspan\u003e]]\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e \u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e[[\u003c/span\u003e\u003cspan\u003enodiscard\u003c/span\u003e\u003cspan\u003e]]\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eis_valid\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elength\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe desired utility can now be implemented. Since it does not matter if the code we parse is syntactically valid, counting \u003ccode\u003e(]\u003c/code\u003e the same way as \u003ccode\u003e()\u003c/code\u003e is fine.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eskip_to\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esame_as\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eneedles\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ebrace_count\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_valid\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echar\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e \u003cspan\u003ebrace_count\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eneedles\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003e...))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;[\u0026#39;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;{\u0026#39;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;(\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ebrace_count\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;]\u0026#39;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;}\u0026#39;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;)\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e--\u003c/span\u003e\u003cspan\u003ebrace_count\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSince whitespace is also often not significant, another utility function to skip whitespace - let’s call it \u003ccode\u003eskip_whitespace\u003c/code\u003e - is also very useful. Since its implementation is trivial, it is omitted here.\u003c/p\u003e\u003ch3 id=\"implementing-the-parser\"\u003e\u003cspan\u003eImplementing the parser\u003c/span\u003e\u003ca href=\"#implementing-the-parser\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAt this point, it’s also advisable to reject various captures that would not make sense for our use case. These include:\u003c/p\u003e\u003cdiv\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eCapture Kind\u003c/th\u003e\u003cth\u003eReasoning\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eCapturing \u003ccode\u003ethis\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eA member cannot be named \u003ccode\u003ethis\u003c/code\u003e, so injecting the container would fail.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eDefault captures \u003ccode\u003e=\u003c/code\u003e and \u003ccode\u003e\u0026amp;\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eSince the lambda’s body is empty, these would not capture anything.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePacks \u003ccode\u003e...foo\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eEvery argument must have a name for keyword argument handling.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\u003cp\u003eWith the aforementioned utilities, the actual capture list parser can now be implemented as follows:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eNameParser\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring_view\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eparse\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_valid\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003eskip_whitespace\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;\u0026amp;\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// might be captured by reference\u003c/span\u003e\n        \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003eskip_whitespace\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;.\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// pack captured, reject\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n\n      \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n      \u003cspan\u003e// find `=`, `,` or whitespace\u003c/span\u003e\n      \u003cspan\u003eskip_to\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;=\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39; \u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;\\r\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;\\t\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n      \u003cspan\u003e// retrieve the name\u003c/span\u003e\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// default capture or invalid name\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n\n      \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubstr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;this\u0026#34;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;*this\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// this captured, reject\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush_back\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n      \n      \u003cspan\u003e// skip ahead to next capture\u003c/span\u003e\n      \u003cspan\u003e// this won\u0026#39;t move the cursor if the current character is already `,`\u003c/span\u003e\n      \u003cspan\u003eskip_to\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n      \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eConstexpr Exceptions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://wg21.link/p3068\"\u003eP3068\u003c/a\u003e proposes support for exceptions during constant evaluation. If accepted, we could make \u003ccode\u003enames\u003c/code\u003e a local variable and have \u003ccode\u003eparse\u003c/code\u003e return it. Invalid captures could then be rejected by throwing an exception.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"injecting-the-kwargs-container-type\"\u003e\u003cspan\u003eInjecting the kwargs container type\u003c/span\u003e\u003ca href=\"#injecting-the-kwargs-container-type\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSince we now know the names for the lambda’s unnamed members, we can inject an aggregate class type with \u003cstrong\u003enamed\u003c/strong\u003e members of appropriate type for every capture of the lambda.\u003c/p\u003e\u003cp\u003eFirst, we need to parse the stringified capture list and create data member specifications that associate each non-static data member of the lambda closure with its corresponding name. This can then be used to inject the keyword argument container type.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eImpl\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003e[[\u003c/span\u003e\u003cspan\u003enodiscard\u003c/span\u003e\u003cspan\u003e]]\u003c/span\u003e \u003cspan\u003ekwargs_t\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eImpl\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eImpl\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eNames\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003ekwargs_impl\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003econsteval\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003etypes\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eTs\u003c/span\u003e\u003cspan\u003e...};\u003c/span\u003e\n    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n    \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eparser\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNameParser\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eNames\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eto_sv\u003c/span\u003e\u003cspan\u003e()};\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eparser\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eparse\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// name list rejected or parsing error, abort\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003e// associate every argument with the corresponding name\u003c/span\u003e\n    \u003cspan\u003e// retrieved by parsing the capture list\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003emember\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eviews\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ezip\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etypes\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eparser\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush_back\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edata_member_spec\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emember\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e{.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e}));\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003edefine_aggregate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003ekwargs_impl\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\n  \u003cspan\u003e// ensure injecting the class worked\u003c/span\u003e\n  \u003cspan\u003estatic_assert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_type\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003ekwargs_impl\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;Could not inject named argument class\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003ekwargs_impl\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAt this point \u003ccode\u003emake\u0026lt;\u0026#34;x,y\u0026#34;\u0026gt;(123, \u0026#34;foo\u0026#34;)\u003c/code\u003e can already be used to make named arguments \u003ccode\u003ex=123\u003c/code\u003e and \u003ccode\u003ey=\u0026#34;foo\u0026#34;\u003c/code\u003e without the use of lambdas.\u003c/p\u003e\u003cp\u003eFor the lambda hackery to work, we need to reflect the lambda’s private non-static data members to produce an appropriate keyword argument container. Finally we need to extract these members from the lambda produced by the \u003ccode\u003emake_args\u003c/code\u003e macro.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003eNames\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003efrom_lambda\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003elambda\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003efnc_t\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove_cvref_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enonstatic_data_members_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003efnc_t\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003emember\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eNames\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elambda\u003c/span\u003e\u003cspan\u003e).[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emember\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]...);\u003c/span\u003e\n    \u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAs mentioned before, to simplify usage on the receiving side, \u003ccode\u003ekwargs_t\u0026lt;T\u0026gt;\u003c/code\u003e should also implement the \u003ca href=\"https://en.cppreference.com/w/cpp/utility/tuple/tuple-like\"\u003etuple protocol\u003c/a\u003e. This means we need to provide specializations for \u003ccode\u003estd::tuple_size\u003c/code\u003e and \u003ccode\u003estd::tuple_element\u003c/code\u003e. Also we’ll need to implement \u003ccode\u003eget\u003c/code\u003e for \u003ccode\u003ekwargs_t\u0026lt;T\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etuple_size\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eintegral_constant\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n      \u003cspan\u003enonstatic_data_members_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove_cvref_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e{};\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003eI\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etuple_element\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eI\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eget_nth_field\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eI\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003eI\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003enoexcept\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e.[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eget_nth_field\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eI\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAdditionally, we want to be able to retrieve keyword arguments by name. Since this might fail, it can be useful to return a default value when no member with the requested name is found. For this, we introduce \u003ccode\u003eget_or\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eget_or\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e.[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eget_nth_field\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eget_member_index\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eto_sv\u003c/span\u003e\u003cspan\u003e()))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eR\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eget_or\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eR\u003c/span\u003e \u003cspan\u003edefault_\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eget_member_index\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eto_sv\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1U\u003c/span\u003e\u003cspan\u003eZ\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003edefault_\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e.[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eget_nth_field\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eget_member_index\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eto_sv\u003c/span\u003e\u003cspan\u003e()))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"function-parameter-reflection\"\u003e\u003cspan\u003eFunction parameter reflection\u003c/span\u003e\u003ca href=\"#function-parameter-reflection\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWhat if we could wrap any function and convert keyword arguments to positional arguments in calls to it as needed? Thanks to \u003ca href=\"https://wg21.link/p3096\"\u003eP3096\u003c/a\u003e function parameter reflection, this would also be possible.\u003c/p\u003e\u003cp\u003eEssentially, we want to be able to write the following:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo_impl\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edouble\u003c/span\u003e \u003cspan\u003ed\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eprintf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: %d c: %c d: %f\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ed\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eWrap\u003c/span\u003e\u003cspan\u003e\u0026lt;^^\u003c/span\u003e\u003cspan\u003efoo_impl\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;c\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e2.2\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;c\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ed\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2.2\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;c\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ed\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2.2\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;c\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ed\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2.2\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n  \u003cspan\u003e// error: Argument `d` missing.\u003c/span\u003e\n  \u003cspan\u003e// foo(3, make_args(c = \u0026#39;c\u0026#39;));\u003c/span\u003e\n\n  \u003cspan\u003e// error: Positional argument `x` repeated as keyword argument.\u003c/span\u003e\n  \u003cspan\u003e// foo(3, make_args(x = 4));\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://cpp26.godbolt.org/z/qoaPYd8Te\"\u003eRun on Compiler Explorer\u003c/a\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eNote that this only works with free functions and static member functions. Function templates and function objects are \u003cstrong\u003enot supported\u003c/strong\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003ch3 id=\"implementation\"\u003e\u003cspan\u003eImplementation\u003c/span\u003e\u003ca href=\"#implementation\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eUnfortunately non-trailing packs are not deduced. If our keyword argument tuple were the first parameter this would be trivial, but realistically that does not look very nice and would also be inconsistent with our previous mixed usage.\u003c/p\u003e\u003cp\u003eConsider the following example (\u003ca href=\"https://godbolt.org/z/4fYq8aPzc\"\u003eRun on Compiler Explorer\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e \u003cspan\u003e// OK\u003c/span\u003e\n\n  \u003cspan\u003e// Args... = \u0026lt;\u0026gt;, T = int\u003c/span\u003e\n  \u003cspan\u003e// error: no matching function for call to \u0026#39;foo\u0026#39;\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://wg21.link/p2347\"\u003eP2347\u003c/a\u003e solves this issue, for more information please refer to cor3ntin’s amazing \u003ca href=\"https://cor3ntin.github.io/posts/variadic/\"\u003eblog post about it\u003c/a\u003e.\u003c/p\u003e\u003ch4 id=\"pack-indexing\"\u003e\u003cspan\u003ePack indexing\u003c/span\u003e\u003ca href=\"#pack-indexing\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTo circumvent this limitation, we can leverage \u003ca href=\"https://wg21.link/p2662\"\u003eP2662\u003c/a\u003e pack indexing to extract the last argument, which allows us to check if it is a keyword argument container.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e \u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003erequires\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_function\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eWrap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003erequires\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e...(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e()(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove_cvref_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e...[\u003c/span\u003e\u003cspan\u003epos_only\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eis_kwargs\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e// handle keyword arguments\u003c/span\u003e\n      \u003cspan\u003e// ...\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e// no keyword arguments\u003c/span\u003e\n      \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e](\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)...);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch4 id=\"combining-positional-and-keyword-arguments\"\u003e\u003cspan\u003eCombining positional and keyword arguments\u003c/span\u003e\u003ca href=\"#combining-positional-and-keyword-arguments\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eTo properly merge the received positional arguments with the given keyword arguments, we need to:\u003c/p\u003e\u003cul\u003e\u003cli\u003eExpand \u003ccode\u003eargs\u003c/code\u003e \u003cstrong\u003eexcept for the last element\u003c/strong\u003e\u003c/li\u003e\u003cli\u003eExtract the remaining parameters of \u003ccode\u003eF\u003c/code\u003e from the last element of \u003ccode\u003eargs\u003c/code\u003e (the keyword argument container)\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eExpansion\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eFor the following to work, one adjustment to the aforementioned \u003ccode\u003eexpand\u003c/code\u003e helper must be made.\u003c/p\u003e\u003cp\u003e\u003ccode\u003eReplicator\u003c/code\u003e’s \u003ccode\u003eoperator\u0026gt;\u0026gt;\u003c/code\u003e expands all elements of the range into the template argument list of a single call to the given lambda. Similarly we want \u003ccode\u003eoperator\u0026gt;\u0026gt;=\u003c/code\u003e to call the lambda once per element, passing one template argument at a time.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eReplicator\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003edecltype\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e \u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e...\u0026gt;();\u003c/span\u003e\n \u003cspan\u003e}\u003c/span\u003e\n\n \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;=\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e \u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efnc\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eVs\u003c/span\u003e\u003cspan\u003e\u0026gt;(),\u003c/span\u003e \u003cspan\u003e...);\u003c/span\u003e\n \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAdditionally, we introduce a shorthand \u003ccode\u003esequence(N)\u003c/code\u003e, which is equivalent to \u003ccode\u003eexpand(std::ranges::iota_view{0U, N})\u003c/code\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eTo do this, we need two nested expansions. The first expansion must expand the reflected parameters of \u003ccode\u003eF\u003c/code\u003e, except for the first \u003ccode\u003esizeof...(Args) - 1\u003c/code\u003e parameters. The second expansion shall expand an integer sequence from \u003ccode\u003e0\u003c/code\u003e to \u003ccode\u003esizeof...(Args) - 1\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003epos_only\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e...(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparameters_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eviews\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003edrop\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epos_only\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \n\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eParams\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esequence\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epos_only\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n  \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eIdx\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e](\u003c/span\u003e\n      \u003cspan\u003e/* positional arguments */\u003c/span\u003e\n      \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e...[\u003c/span\u003e\u003cspan\u003eIdx\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e...[\u003c/span\u003e\u003cspan\u003eIdx\u003c/span\u003e\u003cspan\u003e])...,\u003c/span\u003e \n      \u003cspan\u003e/* keyword arguments */\u003c/span\u003e\n      \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eget_member_index\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eParams\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e...[\u003c/span\u003e\u003cspan\u003epos_only\u003c/span\u003e\u003cspan\u003e])...);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch4 id=\"adding-diagnostics\"\u003e\u003cspan\u003eAdding diagnostics\u003c/span\u003e\u003ca href=\"#adding-diagnostics\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003eWe also want to detect and report errors when:\u003c/p\u003e\u003cul\u003e\u003cli\u003eA positional argument is repeated as keyword argument\u003c/li\u003e\u003cli\u003eA required argument was missing altogether\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor this we can use \u003ccode\u003eexpand\u003c/code\u003e in combination with the \u003ccode\u003e\u0026gt;\u0026gt;=\u003c/code\u003e operator to look at \u003ccode\u003eF\u003c/code\u003e’s parameters one at a time. Also \u003ca href=\"https://wg21.link/p2741\"\u003ep2741\u003c/a\u003e can be used at this point to provide very nice diagnostics.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e \u003cspan\u003ePosOnly\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003echeck_args\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparameters_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eviews\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etake\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ePosOnly\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \n  \u003cspan\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic_assert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ehas_member\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e)),\u003c/span\u003e\n      \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e\u003cspan\u003e{}\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;In call to `\u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;`: \u0026#34;\u003c/span\u003e\n      \u003cspan\u003e\u0026#34;Positional argument `\u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;` \u0026#34;\u003c/span\u003e\n      \u003cspan\u003e\u0026#34;repeated as keyword argument.\u0026#34;\u003c/span\u003e\n    \u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\n  \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eexpand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparameters_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eviews\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003edrop\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ePosOnly\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \n  \u003cspan\u003e\u0026gt;\u0026gt;=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estatic_assert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ehas_member\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e)),\u003c/span\u003e\n      \u003cspan\u003e\u0026#34;In call to `\u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eF\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;`: \u0026#34;\u003c/span\u003e\n      \u003cspan\u003e\u0026#34;Argument `\u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003eidentifier_of\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eParam\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;` missing.\u0026#34;\u003c/span\u003e\n    \u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"bonus-format-strings-with-named-arguments\"\u003e\u003cspan\u003eBonus: Format strings with named arguments\u003c/span\u003e\u003ca href=\"#bonus-format-strings-with-named-arguments\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAside from positional arguments, the awesome \u003ccode\u003efmt\u003c/code\u003e library also allows for named arguments. You might be able to recognize the approach used in \u003ccode\u003efmt\u003c/code\u003e, here’s what the code would look like:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello, {name}! The answer is {number}. Goodbye, {name}.\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n           \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;number\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n\u003cspan\u003e// alternatively\u003c/span\u003e\n\u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003enamespace\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eliterals\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello, {name}! The answer is {number}. Goodbye, {name}.\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n           \u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan\u003e_a\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;number\u0026#34;\u003c/span\u003e\u003cspan\u003e_a\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eLet’s implement similar functionality using \u003ccode\u003eerl::kwargs_t\u003c/code\u003e.\u003c/p\u003e\u003ch3 id=\"transforming-the-format-string\"\u003e\u003cspan\u003eTransforming the format string\u003c/span\u003e\u003ca href=\"#transforming-the-format-string\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eSince \u003ccode\u003estd::format\u003c/code\u003e does not yet support named arguments like \u003ccode\u003efmt\u003c/code\u003e, we need to transform the format string into a format that \u003ccode\u003estd::format\u003c/code\u003e understands.\u003c/p\u003e\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e allows referring to arguments by position (e.g. \u003ccode\u003estd::format(\u0026#34;{1}{0}\u0026#34;, 0, 42)\u003c/code\u003e). We can therefore expand all keyword arguments into the \u003ccode\u003estd::format\u003c/code\u003e call’s argument list and transform the format string so it refers to them by position rather than by name.\u003c/p\u003e\u003cp\u003eThe parser utilities we defined earlier can be re-used to transform the format string. Here’s an example implementation:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eFmtParser\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003econstexpr\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e \u003cspan\u003etransform\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eranges\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward_range\u003c/span\u003e \u003cspan\u003eauto\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e \u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ebrace_count\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_valid\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003eout\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;{\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;{\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n          \u003cspan\u003e// double curly braces means escaped curly braces\u003c/span\u003e\n          \u003cspan\u003e// =\u0026gt; treat the content as text\u003c/span\u003e\n          \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n          \u003cspan\u003e// skip to first unbalanced }\u003c/span\u003e\n          \u003cspan\u003e// this will match the outer {\u003c/span\u003e\n          \u003cspan\u003eskip_to\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;}\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n          \u003cspan\u003eout\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubstr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n          \u003cspan\u003econtinue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n\n        \u003cspan\u003e// find name\u003c/span\u003e\n        \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003eskip_to\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;}\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;:\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubstr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecursor\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n        \u003cspan\u003e// replace name\u003c/span\u003e\n        \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efind\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebegin\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eend\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eidx\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enames\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebegin\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003eout\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003eitoa\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eidx\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n        \u003cspan\u003eout\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003ecurrent\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e++\u003c/span\u003e\u003cspan\u003ecursor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003ch3 id=\"wrapping-stdformat_string\"\u003e\u003cspan\u003eWrapping \u003ccode\u003estd::format_string\u003c/code\u003e\u003c/span\u003e\u003ca href=\"#wrapping-stdformat_string\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eAt some point we will have to produce a \u003ccode\u003estd::format_string\u003c/code\u003e. To avoid having to resort to runtime format checking, we can instead instantiate a template function that handles formatting for us. This function shall receive the format string as constant template argument.\u003c/p\u003e\u003cp\u003eSo let’s first provide a replacement for the \u003ccode\u003estd::format_string\u003c/code\u003e argument of \u003ccode\u003eformat\u003c/code\u003e - note that the constructor must be \u003ccode\u003econsteval\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eNamedFormatString\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003eformat_type\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003eformat_type\u003c/span\u003e \u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eTp\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003erequires\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003econvertible_to\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eTp\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring_view\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003econsteval\u003c/span\u003e \u003cspan\u003eexplicit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eNamedFormatString\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTp\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003eparser\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eFmtParser\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n    \u003cspan\u003eauto\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e    \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eparser\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etransform\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eget_member_names\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n    \u003cspan\u003eformat\u003c/span\u003e      \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eextract\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eformat_type\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n                    \u003cspan\u003esubstitute\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eformat_impl\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eintern\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\u003cspan\u003e^^\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e}));\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis will instantiate \u003ccode\u003eformat_impl\u003c/code\u003e with the transformed format string as constant template argument for us. In \u003ccode\u003eformat_impl\u003c/code\u003e we can retrieve the keyword arguments and simply delegate to \u003ccode\u003estd::format\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eutil\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efixed_string\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e \u003cspan\u003eformat_impl\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003emeta\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esequence\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etuple_size_v\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n  \u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eIdx\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eIdx\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)...);\u003c/span\u003e\n  \u003cspan\u003e};\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe can now define two versions of \u003ccode\u003eformat\u003c/code\u003e - one for named arguments and one to wrap the existing functionality of \u003ccode\u003estd::format\u003c/code\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003erequires\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eis_kwargs\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNamedFormatString\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan\u003erequires\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e...(\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eis_kwargs\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove_cvref_t\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e...))\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eformat_string\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eforward\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eArgs\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)...);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSimilarly, \u003ccode\u003estd::print\u003c/code\u003e and \u003ccode\u003estd::println\u003c/code\u003e can be wrapped using the same approach.\u003c/p\u003e\u003ch3 id=\"usage\"\u003e\u003cspan\u003eUsage\u003c/span\u003e\u003ca href=\"#usage\"\u003e\u003ci\u003e\u003c/i\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eWith this, we can now write:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{bar}{foo}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\u003cspan\u003e// instead of\u003c/span\u003e\n\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{1}{0}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNotice how the order in which arguments appear in \u003ccode\u003emake_args\u003c/code\u003e does not matter.\u003c/p\u003e\u003cp\u003eHere’s a full example (\u003ca href=\"https://cpp26.godbolt.org/z/1fda3or8v\"\u003eRun on compiler explorer\u003c/a\u003e):\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003ccode\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cpre\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\u003c/pre\u003e\u003c/td\u003e\u003ctd\u003e\u003cpre\u003e\u003cspan\u003e#include\u003c/span\u003e \u003cspan\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003cspan\u003e\n#include\u003c/span\u003e \u003cspan\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003e#define KWARGS_FORMATTING 1\n#include\u003c/span\u003e \u003cspan\u003e\u0026lt;kwargs.h\u0026gt;\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\n\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{} {}\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{1} {0}\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{x} {y}\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {} list: {} : {}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {0} list: {2} : {1}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {x} list: {list} : {str}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n               \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n  \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;x: {x} list: {list} : {str}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n               \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n\n  \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecout\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003eerl\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;{x} {y}\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emake_args\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/code\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "31 min read",
  "publishedTime": "2025-02-09T04:20:29+01:00",
  "modifiedTime": null
}
