{
  "id": "2ef0d045-635a-4f06-b7c3-31e80f16eb4a",
  "title": "Cognitive load is what matters",
  "link": "https://minds.md/zakirullin/cognitive",
  "description": "Comments",
  "author": "",
  "published": "Sun, 22 Dec 2024 22:18:12 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Artem Zakirullin",
  "length": 25325,
  "excerpt": "There are so many buzzwords and best practices out there, but let's focus on something more fundamental. What matters is the amount of confusion developers feel when going through the code.",
  "siteName": "",
  "favicon": "",
  "text": "The logo image was taken from Reddit. It is a living document, last update: November 2024. Your contributions are welcome! Introduction There are so many buzzwords and best practices out there, but let's focus on something more fundamental. What matters is the amount of confusion developers feel when going through the code. Confusion costs time and money. Confusion is caused by high cognitive load. It's not some fancy abstract concept, but rather a fundamental human constraint. Since we spend far more time reading and understanding code than writing it, we should constantly ask ourselves whether we are embedding excessive cognitive load into our code. Cognitive load Cognitive load is how much a developer needs to think in order to complete a task. When reading code, you put things like values of variables, control flow logic and call sequences into your head. The average person can hold roughly four such chunks in working memory. Once the cognitive load reaches this threshold, it becomes much harder to understand things. Let's say we have been asked to make some fixes to a completely unfamiliar project. We were told that a really smart developer had contributed to it. Lots of cool architectures, fancy libraries and trendy technologies were used. In other words, the author had created a high cognitive load for us. We should reduce the cognitive load in our projects as much as possible. Types of cognitive load Intrinsic - caused by the inherent difficulty of a task. It can't be reduced, it's at the very heart of software development. Extraneous - created by the way the information is presented. Caused by factors not directly relevant to the task, such as smart author's quirks. Can be greatly reduced. We will focus on this type of cognitive load. Let's jump straight to the concrete practical examples of extraneous cognitive load. We will refer to the level cognitive load as follows:üß†: fresh working memory, zero cognitive loadüß†++: two facts in our working memory, cognitive load increasedü§Ø: cognitive overload, more than 4 facts Our brain is much more complex and unexplored, but we can go with this simplistic model. Complex conditionals if val \u003e someConstant // üß†+ \u0026\u0026 (condition2 || condition3) // üß†+++, prev cond should be true, one of c2 or c3 has be true \u0026\u0026 (condition4 \u0026\u0026 !condition5) { // ü§Ø, we are messed up by this point ... } Introduce intermediate variables with meaningful names: isValid = val \u003e someConstant isAllowed = condition2 || condition3 isSecure = condition4 \u0026\u0026 !condition5 // üß†, we don't need to remember the conditions, there are descriptive variables if isValid \u0026\u0026 isAllowed \u0026\u0026 isSecure { ... } Nested ifs if isValid { // üß†+, okay nested code applies to valid input only if isSecure { // üß†++, we do stuff for valid and secure input only stuff // üß†+++ } } Compare it with the early returns: if !isValid return if !isSecure return // üß†, we don't really care about earlier returns, if we are here then all good stuff // üß†+ We can focus on the happy path only, thus freeing our working memory from all sorts of preconditions. Inheritance nightmare We are asked to change a few things for our admin users: üß† AdminController extends UserController extends GuestController extends BaseController Ohh, part of the functionality is in BaseController, let's have a look: üß†+Basic role mechanics got introduced in GuestController: üß†++Things got partially altered in UserController: üß†+++Finally we are here, AdminController, let's code stuff! üß†++++ Oh, wait, there's SuperuserController which extends AdminController. By modifying AdminController we can break things in the inherited class, so let's dive in SuperuserController first: ü§Ø Prefer composition over inheritance. We won't go into detail - there's plenty of material out there. Too many small methods, classes or modules Method, class and module are interchangeable in this context Mantras like \"methods should be shorter than 15 lines of code\" or \"classes should be small\" turned out to be somewhat wrong. Deep module - simple interface, complex functionalityShallow module - interface is relatively complex to the small functionality it provides Having too many shallow modules can make it difficult to understand the project. Not only do we have to keep in mind each module responsibilities, but also all their interactions. To understand the purpose of a shallow module, we first need to look at the functionality of all the related modules. ü§Ø Information hiding is paramount, and we don't hide as much complexity in shallow modules. I have two pet projects, both of them are somewhat 5K lines of code. The first one has 80 shallow classes, whereas the second one has only 7 deep classes. I haven't been maintaining any of these projects for one year and a half. Once I came back, I realised that it was extremely difficult to untangle all the interactions between those 80 classes in the first project. I would have to rebuild an enormous amount of cognitive load before I could start coding. On the other hand, I was able to grasp the second project quickly, because it had only a few deep classes with a simple interface. The best components are those that provide powerful functionality yet have simple interface.John K. Ousterhout The interface of the UNIX I/O is very simple. It has only five basic calls: open(path, flags, permissions) read(fd, buffer, count) write(fd, buffer, count) lseek(fd, offset, referencePosition) close(fd) A modern implementation of this interface has hundreds of thousands of lines of code. Lots of complexity is hidden under the hood. Yet it is easy to use due to its simple interface. This deep module example is taken from the book A Philosophy of Software Design by John K. Ousterhout. Not only does this book cover the very essence of complexity in software development, but it also has the greatest interpretation of Parnas' influential paper On the Criteria To Be Used in Decomposing Systems into Modules. Both are essential reads. Other related readings: It's probably time to stop recommending Clean Code, Small Functions considered Harmful. P.S. If you think we are rooting for bloated God objects with too many responsibilities, you got it wrong. Shallow modules and SRP All too often, we end up creating lots of shallow modules, following some vague \"a module should be responsible for one, and only one, thing\" principle. What is this blurry one thing? Instantiating an object is one thing, right? So MetricsProviderFactoryFactory seems to be just fine. The names and interfaces of such classes tend to be more mentally taxing than their entire implementations, what kind of abstraction is that? Something went wrong. Jumping between such shallow components is mentally exhausting, linear thinking is more natural to us humans. We make changes to our systems to satisfy our users and stakeholders. We are responsible to them. A module should be responsible to one, and only one, user or stakeholder. This is what this Single Responsibility Principle is all about. Simply put, if we introduce a bug in one place, and then two different business people come to complain, we've violated the principle. It has nothing to do with the number of things we do in our module. But even now, this interpretation can do more harm than good. This rule can be understood in as many different ways as there are individuals. A better approach would be to look at how much cognitive load it all creates. It's mentally demanding to remember that change in one module can trigger a chain of reactions across different business streams. And that's about it. Too many shallow microservices This shallow-deep module principle is scale-agnostic, and we can apply it to microservices architecture. Too many shallow microservices won't do any good - the industry is heading towards somewhat \"macroservices\", i.e., services that are not so shallow (=deep). One of the worst and hardest to fix phenomena is so-called distributed monolith, which is often the result of this overly granular shallow separation. I once consulted a startup where a team of five developers introduced 17(!) microservices. They were 10 months behind schedule and appeared nowhere close to the public release. Every new requirement led to changes in 4+ microservices. Diagnostic difficulty in integration space skyrocketed. Both time to market and cognitive load were unacceptably high. ü§Ø Is this the right way to approach the uncertainty of a new system? It's enormously difficult to elicit the right logical boundaries in the beginning. The key is to make decisions as late as you can responsibly wait, because that is when you have the most information on which to base the decision. By introducing a network layer up front, we make our design decisions hard to revert right from the start. The team's only justification was: \"The FAANG companies proved microservices architecture to be effective\". Hello, you got to stop dreaming big. The Tanenbaum-Torvalds debate argued that Linux's monolithic design was flawed and obsolete, and that a microkernel architecture should be used instead. Indeed, the microkernel design seemed to be superior \"from a theoretical and aesthetical\" point of view. On the practical side of things - three decades on, microkernel-based GNU Hurd is still in development, and monolithic Linux is everywhere. This page is powered by Linux, your smart teapot is powered by Linux. By monolithic Linux. A well-crafted monolith with truly isolated modules is often much more flexible than a bunch of microservices. It also requires far less cognitive effort to maintain. It's only when the need for separate deployments becomes crucial, such as scaling the development team, that you should consider adding a network layer between the modules, future microservices. Feature-rich languages We feel excited when new features got released in our favourite language. We spend some time learning these features, we build code upon them. If there are lots of features, we may spend half an hour playing with a few lines of code, to use one or another feature. And it's kind of a waste of time. But what's worse, when you come back later, you would have to recreate that thought process! You not only have to understand this complicated program, you have to understand why a programmer decided this was the way to approach a problem from the features that are available. ü§Ø These statements are made by none other than Rob Pike. Reduce cognitive load by limiting the number of choices. Language features are OK, as long as they are orthogonal to each other. Thoughts from an engineer with 20 years of C++ experience ‚≠êÔ∏è I was looking at my RSS reader the other day and noticed that I have somewhat three hundred unread articles under the \"C++\" tag. I haven't read a single article about the language since last summer, and I feel great! I've been using C++ for 20 years for now, that's almost two-thirds of my life. Most of my experience lies in dealing with the darkest corners of the language (such as undefined behaviours of all sorts). It's not a reusable experience, and it's kind of creepy to throw it all away now. Like, can you imagine, the token || has a different meaning in requires ((!P\u003cT\u003e || !Q\u003cT\u003e)) and in requires (!(P\u003cT\u003e || Q\u003cT\u003e)). The first is the constraint disjunction, the second is the good-old logical or operator, and they behave differently. You can't allocate space for a trivial type and just memcpy a set of bytes there without extra effort - that won't start the lifetime of an object. This was the case before C++20. It was fixed in C++20, but the cognitive load of the language has only increased. Cognitive load is constantly growing, even though things got fixed. I should know what was fixed, when it was fixed, and what it was like before. I am a professional after all. Sure, C++ is good at legacy support, which also means that you will face that legacy. For example, last month a colleague of mine asked me about some behaviour in C++03. ü§Ø There were 20 ways of initialization. Uniform initialization syntax has been added. Now we have 21 ways of initialization. By the way, does anyone remember the rules for selecting constructors from the initializer list? Something about implicit conversion with the least loss of information, but if the value is known statically, then... ü§Ø This increased cognitive load is not caused by a business task at hand. It is not an intrinsic complexity of the domain. It is just there due to historical reasons (extraneous cognitive load). I had to come up with some rules. Like, if that line of code is not as obvious and I have to remember the standard, I better not write it that way. The standard is somewhat 1500 pages long, by the way. By no means I am trying to blame C++. I love the language. It's just that I am tired now. Business logic and HTTP status codes On the backend we return: 401 for expired jwt token 403 for not enough access 418 for banned users The guys on the frontend use backend API to implement login functionality. They would have to temporarily create the following cognitive load in their brains: 401 is for expired jwt token // üß†+, ok just temporary remember it 403 is for not enough access // üß†++ 418 is for banned users // üß†+++ Frontend developers would (hopefully) introduce some kind numeric status -\u003e meaning dictionary on their side, so that subsequent generations of contributors wouldn't have to recreate this mapping in their brains. Then QA people come into play: \"Hey, I got 403 status, is that expired token or not enough access?\" QA people can't jump straight to testing, because first they have to recreate the cognitive load that the guys on the backend once created. Why hold this custom mapping in our working memory? It's better to abstract away your business details from the HTTP transfer protocol, and return self-descriptive codes directly in the response body: { \"code\": \"jwt_has_expired\" } Cognitive load on the frontend side: üß† (fresh, no facts are held in mind)Cognitive load on the QA side: üß† The same rule applies to all sorts of numeric statuses (in the database or wherever) - prefer self-describing strings. We are not in the era of 640K computers to optimise for memory. People spend time arguing between 401 and 403, making decisions based on their own mental models. New developers are coming in, and they need to recreate that thought process. You may have documented the \"whys\" (ADRs) for your code, helping newcomers to understand the decisions made. But in the end it just doesn't make any sense. We can separate errors into either user-related or server-related, but apart from that, things are kind of blurry. P.S. It's often mentally taxing to distinguish between \"authentication\" and \"authorization\". We can use simpler terms like \"login\" and \"permissions\" to reduce the cognitive load. Abusing DRY principle Do not repeat yourself - that is one of the first principles you are taught as a software engineer. It is so deeply embedded in ourselves that we can not stand the fact of a few extra lines of code. Although in general a good and fundamental rule, when overused it leads to the cognitive load we can not handle. Nowadays, everyone builds software based on logically separated components. Often those are distributed among multiple codebases representing separate services. When you strive to eliminate any repetition, you might end up creating tight coupling between unrelated components. As a result changes in one part may have unintended consequences in other seemingly unrelated areas. It can also hinder the ability to replace or modify individual components without impacting the entire system. ü§Ø In fact, the same problem arises even within a single module. You might extract common functionality too early, based on perceived similarities that might not actually exist in the long run. This can result in unnecessary abstractions that are difficult to modify or extend. Rob Pike once said: A little copying is better than a little dependency. We are tempted to not reinvent the wheel so strong that we are ready to import large, heavy libraries to use a small function that we could easily write by ourselves. All your dependencies are your code. Going through 10+ levels of stack trace of some imported library and figuring out what went wrong (because things go wrong) is painful. Tight coupling with a framework There's a lot of \"magic\" in frameworks. By relying too heavily on a framework, we force all upcoming developers to learn that \"magic\" first. It can take months. Even though frameworks enable us to launch MVPs in a matter of days, in the long run they tend to add unnecessary complexity and cognitive load. Worse yet, at some point frameworks can become a significant constraint when faced with a new requirement that just doesn't fit the architecture. From here onwards people end up forking a framework and maintaining their own custom version. Imagine the amount of cognitive load a newcomer would have to build (i.e. learn this custom framework) in order to deliver any value. ü§Ø By no means do we advocate to invent everything from scratch! We can write code in a somewhat framework-agnostic way. The business logic should not reside within a framework; rather, it should use the framework's components. Put a framework outside of your core logic. Use the framework in a library-like fashion. This would allow new contributors to add value from day one, without the need of going through debris of framework-related complexity first. Why I Hate Frameworks Layered architecture There is a certain engineering excitement about all this stuff. I myself was a passionate advocate of Hexagonal/Onion Architecture for years. I used it here and there and encouraged other teams to do so. The complexity of our projects went up, the sheer number of files alone had doubled. It felt like we were writing a lot of glue code. On ever changing requirements we had to make changes across multiple layers of abstractions, it all became tedious. ü§Ø Abstraction is supposed to hide complexity, here it just adds indirection. Jumping from call to call to read along and figure out what goes wrong and what is missing is a vital requirement to quickly solve a problem. With this architecture‚Äôs layer uncoupling it requires an exponential factor of extra, often disjointed, traces to get to the point where the failure occurs. Every such trace takes space in our limited working memory. ü§Ø This architecture was something that made intuitive sense at first, but every time we tried applying it to projects it made a lot more harm than good. In the end, we gave it all up in favour of the good old dependency inversion principle. No port/adapter terms to learn, no unnecessary layers of horizontal abstractions, no extraneous cognitive load. If you think that such layering will allow you to quickly replace a database or other dependencies, you're mistaken. Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries. At best, abstractions can save somewhat 10% of your migration time (if any), the real pain is in data model incompatibilities, communication protocols, distributed systems challenges, and implicit interfaces. With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody. The law of implicit interfaces We did a storage migration, and that took us about 10 months. The old system was single-threaded, so the exposed events were sequential. All our systems depended on that observed behaviour. This behavior was not part of the API contract, it was not reflected in the code. A new distributed storage didn't have that guarantee - the events came out-of-order. We spent only a few hours coding a new storage adapter. We spent the next 10 months on dealing with out-of-order events and other challenges. It's now funny to say that layering helps us replace components quickly. So, why pay the price of high cognitive load for such a layered architecture, if it doesn't pay off in the future? Plus, in most cases, that future of replacing some core component never happens. These architectures are not fundamental, they are just subjective, biased consequences of more fundamental principles. Why rely on those subjective interpretations? Follow the fundamental rules instead: dependency inversion principle, cognitive load and information hiding. Discuss. Do not add layers of abstractions for the sake of an architecture. Add them whenever you need an extension point that is justified for practical reasons. Layers of abstraction aren't free of charge, they are to be held in our working memory. DDD Domain-driven design has some great points, although it is often misinterpreted. People say \"We write code in DDD\", which is a bit strange, because DDD is about problem space, not about solution space. Ubiquitous language, domain, bounded context, aggregate, event storming are all about problem space. They are meant to help us learn the insights about the domain and extract the boundaries. DDD enables developers, domain experts and business people to communicate effectively using a single, unified language. Rather than focusing on these problem space aspects of DDD, we tend to emphasise particular folder structures, services, repositories, and other solution space techniques. Chances are that the way we interpret DDD is likely to be unique and subjective. And if we build code upon this understanding, i.e., if we create a lot of extraneous cognitive load - future developers are doomed. ü§Ø Examples Our architecture is a standard CRUD app architecture, a Python monolith on top of Postgres How Instagram scaled to 14 million users with only 3 engineers The companies where we were like ‚Äùwoah, these folks are smart as hell‚Äù for the most part failed One function that wires up the entire system. If you want to know how the system works - go read it These architectures are quite boring and easy to understand. Anyone can grasp them without much mental effort. Involve junior developers in architecture reviews. They will help you to identify the mentally demanding areas. Cognitive load in familiar projects The problem is that familiarity is not the same as simplicity. They feel the same ‚Äî that same ease of moving through a space without much mental effort ‚Äî but for very different reasons. Every ‚Äúclever‚Äù (read: ‚Äúself-indulgent‚Äù) and non-idiomatic trick you use incurs a learning penalty for everyone else. Once they have done that learning, then they will find working with the code less difficult. So it is hard to recognise how to simplify code that you are already familiar with. This is why I try to get ‚Äúthe new kid‚Äù to critique the code before they get too institutionalised! It is likely that the previous author(s) created this huge mess one tiny increment at a time, not all at once. So you are the first person who has ever had to try to make sense of it all at once. In my class I describe a sprawling SQL stored procedure we were looking at one day, with hundreds of lines of conditionals in a huge WHERE clause. Someone asked how anyone could have let it get this bad. I told them: ‚ÄúWhen there are only 2 or 3 conditionals, adding another one doesn‚Äôt make any difference. By the time there are 20 or 30 conditionals, adding another one doesn‚Äôt make any difference!‚Äù There is no ‚Äúsimplifying force‚Äù acting on the code base other than deliberate choices that you make. Simplifying takes effort, and people are too often in a hurry. Thanks to Dan North for his comment. If you've internalized the mental models of the project into your long-term memory, you won't experience a high cognitive load. The more mental models there are to learn, the longer it takes for a new developer to deliver value. Once you onboard new people on your project, try to measure the amount of confusion they have (pair programming may help). If they're confused for more than ~40 minutes in a row - you've got things to improve in your code. If you keep the cognitive load low, people can contribute to your codebase within the first few hours of joining your company. Conclusion Imagine for a moment that what we inferred in the second chapter isn‚Äôt actually true. If that‚Äôs the case, then the conclusion we just negated, along with the conclusions in the previous chapter that we had accepted as valid, might not be correct either. ü§Ø Do you feel it? Not only do you have to jump all over the article to get the meaning (shallow modules!), but the paragraph in general is difficult to understand. We have just created an unnecessary cognitive load in your head. Do not do this to your colleagues. We should reduce any cognitive load above and beyond what is intrinsic to the work we do.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n            \u003cp\u003e\u003cimg src=\"https://minds.md/cat.webp\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe logo image was taken from Reddit.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003ca target=\"_blank\" href=\"https://github.com/zakirullin/cognitive-load\"\u003eIt is a living document\u003c/a\u003e, last update: \u003cstrong\u003eNovember 2024\u003c/strong\u003e. Your contributions are welcome!\u003c/em\u003e \u003c/p\u003e\n\u003ch2 id=\"intro\"\u003e\n    \u003ca href=\"#intro\"\u003eIntroduction\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThere are so many buzzwords and best practices out there, but let\u0026#39;s focus on something more fundamental. What matters is the amount of confusion developers feel when going through the code.\u003c/p\u003e\n\u003cp\u003eConfusion costs time and money. Confusion is caused by high \u003cem\u003ecognitive load\u003c/em\u003e. It\u0026#39;s not some fancy abstract concept, but rather \u003cstrong\u003ea fundamental human constraint\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eSince we spend far more time reading and understanding code than writing it, we should constantly ask ourselves whether we are embedding excessive cognitive load into our code. \u003c/p\u003e\n\u003ch2 id=\"cognitive-load\"\u003e\n    \u003ca href=\"#cognitive-load\"\u003eCognitive load\u003c/a\u003e\n\u003c/h2\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eCognitive load is how much a developer needs to think in order to complete a task.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWhen reading code, you put things like values of variables, control flow logic and call sequences into your head. The average person can hold roughly \u003ca target=\"_blank\" href=\"https://github.com/zakirullin/cognitive-load/issues/16\"\u003efour such chunks\u003c/a\u003e in working memory. Once the cognitive load reaches this threshold, it becomes much harder to understand things.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLet\u0026#39;s say we have been asked to make some fixes to a completely unfamiliar project. We were told that a really smart developer had contributed to it. Lots of cool architectures, fancy libraries and trendy technologies were used. In other words, \u003cstrong\u003ethe author had created a high cognitive load for us.\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/zakirullin/cognitive-load/blob/main/img/cognitiveloadv5paper.png?raw=true\" alt=\"Cognitive Load\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe should reduce the cognitive load in our projects as much as possible.\u003c/p\u003e\n\u003ch2 id=\"types\"\u003e\n    \u003ca href=\"#types\"\u003eTypes of cognitive load\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eIntrinsic\u003c/strong\u003e - caused by the inherent difficulty of a task. It can\u0026#39;t be reduced, it\u0026#39;s at the very heart of software development.  \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExtraneous\u003c/strong\u003e - created by the way the information is presented. Caused by factors not directly relevant to the task, such as smart author\u0026#39;s quirks. Can be greatly reduced. We will focus on this type of cognitive load. \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/zakirullin/cognitive-load/blob/main/img/smartauthorv14paperthanksmari.png?raw=true\" alt=\"Intrinsic vs Extraneous\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eLet\u0026#39;s jump straight to the concrete practical examples of extraneous cognitive load.\u003c/p\u003e\n\u003cp\u003eWe will refer to the level cognitive load as follows:\u003cbr/\u003e\u003ccode\u003eüß†\u003c/code\u003e: fresh working memory, zero cognitive load\u003cbr/\u003e\u003ccode\u003eüß†++\u003c/code\u003e: two facts in our working memory, cognitive load increased\u003cbr/\u003e\u003ccode\u003eü§Ø\u003c/code\u003e: cognitive overload, more than 4 facts  \u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eOur brain is much more complex and unexplored, but we can go with this simplistic model.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"complex-conditionals\"\u003e\n    \u003ca href=\"#complex-conditionals\"\u003eComplex conditionals\u003c/a\u003e\n\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eif\u003c/span\u003e val \u003cspan\u003e\u0026gt;\u003c/span\u003e someConstant \u003cspan\u003e// üß†+\u003c/span\u003e\n    \u0026amp;\u0026amp; (condition2 \u003cspan\u003e||\u003c/span\u003e condition3) \u003cspan\u003e// üß†+++, prev cond should be true, one of c2 or c3 has be true\u003c/span\u003e\n    \u0026amp;\u0026amp; (condition4 \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003econdition5) { \u003cspan\u003e// ü§Ø, we are messed up by this point\u003c/span\u003e\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIntroduce intermediate variables with meaningful names:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eisValid\u003c/span\u003e = val \u003cspan\u003e\u0026gt;\u003c/span\u003e someConstant\nisAllowed \u003cspan\u003e=\u003c/span\u003e condition2 \u003cspan\u003e||\u003c/span\u003e condition3\nisSecure \u003cspan\u003e=\u003c/span\u003e condition4 \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003econdition5\n\u003cspan\u003e// üß†, we don\u0026#39;t need to remember the conditions, there are descriptive variables\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e isValid \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e isAllowed \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e isSecure {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"nested-ifs\"\u003e\n    \u003ca href=\"#nested-ifs\"\u003eNested ifs\u003c/a\u003e\n\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eif\u003c/span\u003e isValid { \u003cspan\u003e// üß†+, okay nested code applies to valid input only\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e isSecure { \u003cspan\u003e// üß†++, we do stuff for valid and secure input only\u003c/span\u003e\n        stuff // üß†+++\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompare it with the early returns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003eisValid\n    \u003cspan\u003ereturn\u003c/span\u003e\n\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003eisSecure\n    \u003cspan\u003ereturn\u003c/span\u003e\n\n\u003cspan\u003e// üß†, we don\u0026#39;t really care about earlier returns, if we are here then all good\u003c/span\u003e\n\nstuff \u003cspan\u003e// üß†+\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can focus on the happy path only, thus freeing our working memory from all sorts of preconditions.\u003c/p\u003e\n\u003ch2 id=\"inheritance\"\u003e\n    \u003ca href=\"#inheritance\"\u003eInheritance nightmare\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eWe are asked to change a few things for our admin users: \u003ccode\u003eüß†\u003c/code\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eAdminController \u003cspan\u003eextends\u003c/span\u003e UserController \u003cspan\u003eextends\u003c/span\u003e GuestController \u003cspan\u003eextends\u003c/span\u003e BaseController\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOhh, part of the functionality is in \u003ccode\u003eBaseController\u003c/code\u003e, let\u0026#39;s have a look: \u003ccode\u003eüß†+\u003c/code\u003e\u003cbr/\u003eBasic role mechanics got introduced in \u003ccode\u003eGuestController\u003c/code\u003e: \u003ccode\u003eüß†++\u003c/code\u003e\u003cbr/\u003eThings got partially altered in \u003ccode\u003eUserController\u003c/code\u003e: \u003ccode\u003eüß†+++\u003c/code\u003e\u003cbr/\u003eFinally we are here, \u003ccode\u003eAdminController\u003c/code\u003e, let\u0026#39;s code stuff! \u003ccode\u003eüß†++++\u003c/code\u003e  \u003c/p\u003e\n\u003cp\u003eOh, wait, there\u0026#39;s \u003ccode\u003eSuperuserController\u003c/code\u003e which extends \u003ccode\u003eAdminController\u003c/code\u003e. By modifying \u003ccode\u003eAdminController\u003c/code\u003e we can break things in the inherited class, so let\u0026#39;s dive in \u003ccode\u003eSuperuserController\u003c/code\u003e first: \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ePrefer composition over inheritance. We won\u0026#39;t go into detail - there\u0026#39;s \u003ca target=\"_blank\" href=\"https://www.youtube.com/watch?v=hxGOiiR9ZKg\"\u003eplenty of material\u003c/a\u003e out there.\u003c/p\u003e\n\u003ch2 id=\"shallow-modules\"\u003e\n    \u003ca href=\"#shallow-modules\"\u003eToo many small methods, classes or modules\u003c/a\u003e\n\u003c/h2\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eMethod, class and module are interchangeable in this context \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMantras like \u0026#34;methods should be shorter than 15 lines of code\u0026#34; or \u0026#34;classes should be small\u0026#34; turned out to be somewhat wrong.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDeep module\u003c/strong\u003e - simple interface, complex functionality\u003cbr/\u003e\u003cstrong\u003eShallow module\u003c/strong\u003e - interface is relatively complex to the small functionality it provides \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/zakirullin/cognitive-load/blob/main/img/deepmodulev8paper.png?raw=true\" alt=\"Deep module\"/\u003e\u003c/p\u003e\n\u003cp\u003eHaving too many shallow modules can make it difficult to understand the project. \u003cstrong\u003eNot only do we have to keep in mind each module responsibilities, but also all their interactions\u003c/strong\u003e. To understand the purpose of a shallow module, we first need to look at the functionality of all the related modules. \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eInformation hiding is paramount, and we don\u0026#39;t hide as much complexity in shallow modules.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI have two pet projects, both of them are somewhat 5K lines of code. The first one has 80 shallow classes, whereas the second one has only 7 deep classes. I haven\u0026#39;t been maintaining any of these projects for one year and a half.\u003c/p\u003e\n\u003cp\u003eOnce I came back, I realised that it was extremely difficult to untangle all the interactions between those 80 classes in the first project. I would have to rebuild an enormous amount of cognitive load before I could start coding. On the other hand, I was able to grasp the second project quickly, because it had only a few deep classes with a simple interface.\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eThe best components are those that provide powerful functionality yet have simple interface.\u003cbr/\u003e\u003cstrong\u003eJohn K. Ousterhout\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe interface of the UNIX I/O is very simple. It has only five basic calls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eopen\u003c/span\u003e(path, flags, permissions)\n\u003cspan\u003eread\u003c/span\u003e(fd, buffer, count)\n\u003cspan\u003ewrite\u003c/span\u003e(fd, buffer, count)\n\u003cspan\u003elseek\u003c/span\u003e(fd, offset, referencePosition)\n\u003cspan\u003eclose\u003c/span\u003e(fd)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA modern implementation of this interface has \u003cstrong\u003ehundreds of thousands of lines of code\u003c/strong\u003e. Lots of complexity is hidden under the hood. Yet it is easy to use due to its simple interface.\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eThis deep module example is taken from the book \u003ca target=\"_blank\" href=\"https://web.stanford.edu/~ouster/cgi-bin/book.php\"\u003eA Philosophy of Software Design\u003c/a\u003e by John K. Ousterhout.\u003cspan\u003e Not only does this book cover the very essence of complexity in software development, but it also has the greatest interpretation of Parnas\u0026#39; influential paper \u003ca target=\"_blank\" href=\"https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf\"\u003eOn the Criteria To Be Used in Decomposing Systems into Modules\u003c/a\u003e. Both are essential reads. Other related readings: \u003ca target=\"_blank\" href=\"https://qntm.org/clean\"\u003eIt\u0026#39;s probably time to stop recommending Clean Code\u003c/a\u003e, \u003ca target=\"_blank\" href=\"https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29\"\u003eSmall Functions considered Harmful\u003c/a\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n    \u003cp\u003eP.S. If you think we are rooting for bloated God objects with too many responsibilities, you got it wrong.  \u003c/p\u003e\n\u003ch2 id=\"srp\"\u003e\n    \u003ca href=\"#srp\"\u003eShallow modules and SRP\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eAll too often, we end up creating lots of shallow modules, following some vague \u0026#34;a module should be responsible for one, and only one, thing\u0026#34; principle. What is this blurry one thing? Instantiating an object is one thing, right? So \u003ca href=\"https://minds.md/benji/frameworks\" target=\"_blank\"\u003eMetricsProviderFactoryFactory\u003c/a\u003e seems to be just fine. The names and interfaces of such classes tend to be more mentally taxing than their entire implementations, what kind of abstraction is that? Something went wrong.  \u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eJumping between such shallow components is mentally exhausting, \u003ca target=\"_blank\" href=\"https://blog.separateconcerns.com/2023-09-11-linear-code.html\"\u003elinear thinking\u003c/a\u003e is more natural to us humans.  \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe make changes to our systems to satisfy our users and stakeholders. We are responsible to them.  \u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eA module should be responsible to one, and only one, user or stakeholder.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is what this Single Responsibility Principle is all about. Simply put, if we introduce a bug in one place, and then two different business people come to complain, we\u0026#39;ve violated the principle. It has nothing to do with the number of things we do in our module.    \u003c/p\u003e\n\u003cp\u003eBut even now, this interpretation can do more harm than good. This rule can be understood in as many different ways as there are individuals. A better approach would be to look at how much cognitive load it all creates. It\u0026#39;s mentally demanding to remember that change in one module can trigger a chain of reactions across different business streams. And that\u0026#39;s about it.  \u003c/p\u003e\n\u003ch2 id=\"shallow-microservices\"\u003e\n    \u003ca href=\"#shallow-microservices\"\u003eToo many shallow microservices\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThis shallow-deep module principle is scale-agnostic, and we can apply it to microservices architecture. Too many shallow microservices won\u0026#39;t do any good - the industry is heading towards somewhat \u0026#34;macroservices\u0026#34;, i.e., services that are not so shallow (=deep). \u003cspan\u003eOne of the worst and hardest to fix phenomena is so-called distributed monolith, which is often the result of this overly granular shallow separation.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eI once consulted a startup where a team of five developers introduced 17(!) microservices. They were 10 months behind schedule and appeared nowhere close to the public release. Every new requirement led to changes in 4+ microservices. Diagnostic difficulty in integration space skyrocketed. Both time to market and cognitive load were unacceptably high. \u003ccode\u003eü§Ø\u003c/code\u003e  \u003c/p\u003e\n\n\u003cp\u003eIs this the right way to approach the uncertainty of a new system? It\u0026#39;s enormously difficult to elicit the right logical boundaries in the beginning. The key is to make decisions as late as you can responsibly wait, because that is when you have the most information on which to base the decision. By introducing a network layer up front, we make our design decisions hard to revert right from the start. The team\u0026#39;s only justification was: \u0026#34;The FAANG companies proved microservices architecture to be effective\u0026#34;. \u003cem\u003eHello, you got to stop dreaming big.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ca target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate\"\u003eTanenbaum-Torvalds debate\u003c/a\u003e argued that Linux\u0026#39;s monolithic design was flawed and obsolete, and that a microkernel architecture should be used instead. Indeed, the microkernel design seemed to be superior \u0026#34;from a theoretical and aesthetical\u0026#34; point of view. On the practical side of things - three decades on, microkernel-based GNU Hurd is still in development, and monolithic Linux is everywhere. This page is powered by Linux, your smart teapot is powered by Linux. By monolithic Linux.\u003c/p\u003e\n\u003cp\u003eA well-crafted monolith with truly isolated modules is often much more flexible than a bunch of microservices. It also requires far less cognitive effort to maintain. It\u0026#39;s only when the need for separate deployments becomes crucial, such as scaling the development team, that you should consider adding a network layer between the modules, future microservices.\u003c/p\u003e\n\u003ch2 id=\"feature-rich-languages\"\u003e\n    \u003ca href=\"#feature-rich-languages\"\u003eFeature-rich languages\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eWe feel excited when new features got released in our favourite language. We spend some time learning these features, we build code upon them.\u003c/p\u003e\n\u003cp\u003eIf there are lots of features, we may spend half an hour playing with a few lines of code, to use one or another feature. And it\u0026#39;s kind of a waste of time. But what\u0026#39;s worse, \u003cstrong\u003ewhen you come back later, you would have to recreate that thought process!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou not only have to understand this complicated program, you have to understand why a programmer decided this was the way to approach a problem from the features that are available.\u003c/strong\u003e \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThese statements are made by none other than Rob Pike.\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eReduce cognitive load by limiting the number of choices.  \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLanguage features are OK, as long as they are orthogonal to each other.\u003c/p\u003e\n\u003cdetails\u003e\n    \u003csummary\u003eThoughts from an engineer with 20 years of C++ experience ‚≠êÔ∏è\u003c/summary\u003e\n    \u003cp\u003eI was looking at my RSS reader the other day and noticed that I have somewhat three hundred unread articles under the \u0026#34;C++\u0026#34; tag. I haven\u0026#39;t read a single article about the language since last summer, and I feel great!\u003c/p\u003e\n    \u003cp\u003eI\u0026#39;ve been using C++ for 20 years for now, that\u0026#39;s almost two-thirds of my life. Most of my experience lies in dealing with the darkest corners of the language (such as undefined behaviours of all sorts). It\u0026#39;s not a reusable experience, and it\u0026#39;s kind of creepy to throw it all away now.\u003c/p\u003e\n    \u003cp\u003eLike, can you imagine, the token \u003ccode\u003e||\u003c/code\u003e has a different meaning in \u003ccode\u003erequires ((!P\u0026lt;T\u0026gt; || !Q\u0026lt;T\u0026gt;))\u003c/code\u003e and in \u003ccode\u003erequires (!(P\u0026lt;T\u0026gt; || Q\u0026lt;T\u0026gt;))\u003c/code\u003e. The first is the constraint disjunction, the second is the good-old logical \u003ccode\u003eor\u003c/code\u003e operator, and they behave differently.\u003c/p\u003e\n    \u003cp\u003eYou can\u0026#39;t allocate space for a trivial type and just \u003ccode\u003ememcpy\u003c/code\u003e a set of bytes there without extra effort - that won\u0026#39;t start the lifetime of an object. This was the case before C++20. It was fixed in C++20, but the cognitive load of the language has only increased.\u003c/p\u003e\n    \u003cp\u003eCognitive load is constantly growing, even though things got fixed. I should know what was fixed, when it was fixed, and what it was like before. I am a professional after all. Sure, C++ is good at legacy support, which also means that you \u003cstrong\u003ewill face\u003c/strong\u003e that legacy. For example, last month a colleague of mine asked me about some behaviour in C++03. \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n    \u003cp\u003eThere were 20 ways of initialization. Uniform initialization syntax has been added. Now we have 21 ways of initialization. By the way, does anyone remember the rules for selecting constructors from the initializer list? Something about implicit conversion with the least loss of information, \u003ci\u003ebut if\u003c/i\u003e the value is known statically, then... \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n    \u003cp\u003e\u003cstrong\u003eThis increased cognitive load is not caused by a business task at hand. It is not an intrinsic complexity of the domain. It is just there due to historical reasons\u003c/strong\u003e (\u003cem\u003eextraneous cognitive load\u003c/em\u003e).\u003c/p\u003e\n    \u003cdiv\u003e\u003cp\u003eI had to come up with some rules. Like, if that line of code is not as obvious and I have to remember the standard, I better not write it that way. The standard is somewhat 1500 pages long, by the way.\u003c/p\u003e\u003c/div\u003e\n    \u003cp\u003e\u003cstrong\u003eBy no means I am trying to blame C++.\u003c/strong\u003e I love the language. It\u0026#39;s just that I am tired now.\u003c/p\u003e\n\u003c/details\u003e\n\u003ch2 id=\"numeric-statuses\"\u003e\n    \u003ca href=\"#numeric-statuses\"\u003eBusiness logic and HTTP status codes\u003c/a\u003e\n\u003c/h2\u003e\n\u003cspan\u003eOn the backend we return:\u003c/span\u003e\n\u003cul\u003e\n    \u003cli\u003e\u003ccode\u003e401\u003c/code\u003e for expired jwt token\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003e403\u003c/code\u003e for not enough access\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003e418\u003c/code\u003e for banned users\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe guys on the frontend use backend API to implement login functionality. They would have to temporarily  create the following cognitive load in their brains:\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\u003ccode\u003e401\u003c/code\u003e is for expired jwt token // \u003ccode\u003eüß†+\u003c/code\u003e, ok just temporary remember it\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003e403\u003c/code\u003e is for not enough access // \u003ccode\u003eüß†++\u003c/code\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003e418\u003c/code\u003e is for banned users // \u003ccode\u003eüß†+++\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFrontend developers would (hopefully) introduce some kind \u003cstrong\u003enumeric status -\u0026gt; meaning\u003c/strong\u003e dictionary on their side, so that subsequent generations of contributors wouldn\u0026#39;t have to recreate this mapping in their brains.\u003c/p\u003e\n\u003cp\u003eThen QA people come into play:\n    \u0026#34;Hey, I got \u003ccode\u003e403\u003c/code\u003e status, is that expired token or not enough access?\u0026#34;\n    \u003cstrong\u003eQA people can\u0026#39;t jump straight to testing, because first they have to recreate the cognitive load that the guys on the backend once created.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhy hold this custom mapping in our working memory? It\u0026#39;s better to abstract away your business details from the HTTP transfer protocol, and return self-descriptive codes directly in the response body:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    \u003cspan\u003e\u0026#34;code\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;jwt_has_expired\u0026#34;\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCognitive load on the frontend side: \u003ccode\u003eüß†\u003c/code\u003e (fresh, no facts are held in mind)\u003cbr/\u003eCognitive load on the QA side: \u003ccode\u003eüß†\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe same rule applies to all sorts of numeric statuses (in the database or wherever) - \u003cstrong\u003eprefer self-describing strings\u003c/strong\u003e. We are not in the era of 640K computers to optimise for memory.  \u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003ePeople spend time arguing between \u003ccode\u003e401\u003c/code\u003e and \u003ccode\u003e403\u003c/code\u003e, making decisions based on their own mental models. New developers are coming in, and they need to recreate that thought process. You may have documented the \u0026#34;whys\u0026#34; (ADRs) for your code, helping newcomers to understand the decisions made. But in the end it just doesn\u0026#39;t make any sense. We can separate errors into either user-related or server-related, but apart from that, things are kind of blurry. \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eP.S. It\u0026#39;s often mentally taxing to distinguish between \u0026#34;authentication\u0026#34; and \u0026#34;authorization\u0026#34;. We can use simpler terms like \u003ca target=\"_blank\" href=\"https://ntietz.com/blog/lets-say-instead-of-auth/\"\u003e\u0026#34;login\u0026#34; and \u0026#34;permissions\u0026#34;\u003c/a\u003e to reduce the cognitive load.\u003c/p\u003e\n\u003ch2 id=\"dry\"\u003e\n    \u003ca href=\"#dry\"\u003eAbusing DRY principle\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eDo not repeat yourself - that is one of the first principles you are taught as a software engineer. It is so deeply embedded in ourselves that we can not stand the fact of a few extra lines of code. Although in general a good and fundamental rule, when overused it leads to the cognitive load we can not handle.\u003c/p\u003e\n\u003cp\u003eNowadays, everyone builds software based on logically separated components. Often those are distributed among multiple codebases representing separate services. When you strive to eliminate any repetition, you might end up creating tight coupling between unrelated components. As a result changes in one part may have unintended consequences in other seemingly unrelated areas. It can also hinder the ability to replace or modify individual components without impacting the entire system. \u003ccode\u003eü§Ø\u003c/code\u003e  \u003c/p\u003e\n\u003cp\u003eIn fact, the same problem arises even within a single module. You might extract common functionality too early, based on perceived similarities that might not actually exist in the long run. This can result in unnecessary abstractions that are difficult to modify or extend.  \u003c/p\u003e\n\u003cp\u003eRob Pike once said:\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eA little copying is better than a little dependency.  \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe are tempted to not reinvent the wheel so strong that we are ready to import large, heavy libraries to use a small function that we could easily write by ourselves. \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAll your dependencies are your code.\u003c/strong\u003e Going through 10+ levels of stack trace of some imported library and figuring out what went wrong (\u003cem\u003ebecause things go wrong\u003c/em\u003e) is painful.\u003c/p\u003e\n\n\u003ch2 id=\"framework\"\u003e\n    \u003ca href=\"#framework\"\u003eTight coupling with a framework\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThere\u0026#39;s a lot of \u0026#34;magic\u0026#34; in frameworks. By relying too heavily on a framework, \u003cstrong\u003ewe force all upcoming developers to learn that \u0026#34;magic\u0026#34; first\u003c/strong\u003e. It can take months. Even though frameworks enable us to launch MVPs in a matter of days, in the long run they tend to add unnecessary complexity and cognitive load.\u003c/p\u003e\n\u003cp\u003eWorse yet, at some point frameworks can become a significant constraint when faced with a new requirement that just doesn\u0026#39;t fit the architecture. From here onwards people end up forking a framework and maintaining their own custom version. Imagine the amount of cognitive load a newcomer would have to build (i.e. learn this custom framework) in order to deliver any value. \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBy no means do we advocate to invent everything from scratch!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWe can write code in a somewhat framework-agnostic way. The business logic should not reside within a framework; rather, it should use the framework\u0026#39;s components. Put a framework outside of your core logic. Use the framework in a library-like fashion. This would allow new contributors to add value from day one, without the need of going through debris of framework-related complexity first.\u003c/p\u003e\n\u003cblockquote\u003e\n    \u003ca href=\"https://minds.md/benji/frameworks\" target=\"_blank\"\u003eWhy I Hate Frameworks\u003c/a\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"layers\"\u003e\n    \u003ca href=\"#layers\"\u003eLayered architecture\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThere is a certain engineering excitement about all this stuff.\u003c/p\u003e\n\u003cp\u003eI myself was a passionate advocate of Hexagonal/Onion Architecture for years. I used it here and there and encouraged other teams to do so. The complexity of our projects went up, the sheer number of files alone had doubled. It felt like we were writing a lot of glue code. On ever changing requirements we had to make changes across multiple layers of abstractions, it all became tedious. \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eAbstraction is supposed to hide complexity, here it just adds \u003ca href=\"https://fhur.me/posts/2024/thats-not-an-abstraction\" target=\"_blank\"\u003eindirection\u003c/a\u003e. Jumping from call to call to read along and figure out what goes wrong and what is missing is a vital requirement to quickly solve a problem. With this architecture‚Äôs layer uncoupling it requires an exponential factor of extra, often disjointed, traces to get to the point where the failure occurs. Every such trace takes space in our limited working memory. \u003ccode\u003eü§Ø\u003c/code\u003e  \u003c/p\u003e\n\u003cp\u003eThis architecture was something that made intuitive sense at first, but every time we tried applying it to projects it made a lot more harm than good. In the end, we gave it all up in favour of the good old dependency inversion principle. \u003cstrong\u003eNo port/adapter terms to learn, no unnecessary layers of horizontal abstractions, no extraneous cognitive load.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf you think that such layering will allow you to quickly replace a database or other dependencies, you\u0026#39;re mistaken. Changing the storage causes lots of problems, and believe us, having some abstractions for the data access layer is the least of your worries. At best, abstractions can save somewhat 10% of your migration time (if any), the real pain is in data model incompatibilities, communication protocols, distributed systems challenges, and implicit interfaces.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\nWith a sufficient number of users of an API,\u003cbr/\u003e\nit does not matter what you promise in the contract:\u003cbr/\u003e\nall observable behaviors of your system\u003cbr/\u003e\nwill be depended on by somebody.\u003cbr/\u003e\n\u003ca target=\"_blank\" href=\"https://www.hyrumslaw.com/\"\u003eThe law of implicit interfaces\u003c/a\u003e\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe did a storage migration, and that took us about 10 months. The old system was single-threaded, so the exposed events were sequential. All our systems depended on that observed behaviour. This behavior was not part of the API contract, it was not reflected in the code. A new distributed storage didn\u0026#39;t have that guarantee - the events came out-of-order. We spent only a few hours coding a new storage adapter. We spent the next 10 months on dealing with out-of-order events and other challenges. It\u0026#39;s now funny to say that layering helps us replace components quickly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSo, why pay the price of high cognitive load for such a layered architecture, if it doesn\u0026#39;t pay off in the future?\u003c/strong\u003e \u003cspan\u003ePlus, in most cases, that future of replacing some core component never happens.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eThese architectures are not fundamental, they are just subjective, biased consequences of more fundamental principles. Why rely on those subjective interpretations? Follow the fundamental rules instead: dependency inversion principle, cognitive load and information hiding. \u003ca target=\"_blank\" href=\"https://github.com/zakirullin/cognitive-load/discussions/24\"\u003eDiscuss\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eDo not add layers of abstractions for the sake of an architecture. Add them whenever you need an extension point that is justified for practical reasons. \u003cstrong\u003e\u003ca target=\"_blank\" href=\"https://blog.jooq.org/why-you-should-not-implement-layered-architecture\"\u003eLayers of abstraction aren\u0026#39;t free of charge\u003c/a\u003e, they are to be held in our working memory\u003c/strong\u003e.  \u003c/p\u003e\n\u003ch2 id=\"ddd\"\u003e\n    \u003ca href=\"#ddd\"\u003eDDD\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eDomain-driven design has some great points, although it is often misinterpreted. People say \u0026#34;We write code in DDD\u0026#34;, which is a bit strange, because DDD is about problem space, not about solution space.\u003c/p\u003e\n\u003cp\u003eUbiquitous language, domain, bounded context, aggregate, event storming are all about problem space. They are meant to help us learn the insights about the domain and extract the boundaries. DDD enables developers, domain experts and business people to communicate effectively using a single, unified language. Rather than focusing on these problem space aspects of DDD, we tend to emphasise particular folder structures, services, repositories, and other solution space techniques. \u003c/p\u003e\n\u003cp\u003eChances are that the way we interpret DDD is likely to be unique and subjective. And if we build code upon this understanding, i.e., if we create a lot of extraneous cognitive load - future developers are doomed. \u003ccode\u003eü§Ø\u003c/code\u003e\u003c/p\u003e\n\n\u003ch2 id=\"examples\"\u003e\n    \u003ca href=\"#examples\"\u003eExamples\u003c/a\u003e\n\u003c/h2\u003e\n\u003cul\u003e\n    \u003cli\u003eOur architecture is a standard CRUD app architecture, \u003ca href=\"https://danluu.com/simple-architectures/\" target=\"_blank\"\u003ea Python monolith on top of Postgres\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003eHow Instagram scaled to 14 million users with \u003ca href=\"https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million\" target=\"_blank\"\u003eonly 3 engineers\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003eThe companies where we were like ‚Äùwoah, these folks are \u003ca href=\"https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/\" target=\"_blank\"\u003esmart as hell\u003c/a\u003e‚Äù for the most part failed\u003c/li\u003e\n    \u003cli\u003eOne function that wires up the entire system. If you want to know how the system works - \u003ca href=\"https://www.infoq.com/presentations/8-lines-code-refactoring\" target=\"_blank\"\u003ego read it\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003cp\u003e\n    These architectures are quite boring and easy to understand. Anyone can grasp them without much mental effort.\n\u003c/p\u003e\n\n\u003cp\u003e\n    Involve junior developers in architecture reviews. They will help you to identify the mentally demanding areas.\n\u003c/p\u003e\n\n\u003ch2 id=\"familiar\"\u003e\n    \u003ca href=\"#familiar\"\u003eCognitive load in familiar projects\u003c/a\u003e\n\u003c/h2\u003e\n\u003cblockquote\u003e\n    \u003cp\u003eThe problem is that \u003cstrong\u003efamiliarity is not the same as simplicity\u003c/strong\u003e. They \u003cem\u003efeel\u003c/em\u003e the same ‚Äî that same ease of moving through a space without much mental effort ‚Äî but for very different reasons. Every ‚Äúclever‚Äù (read: ‚Äúself-indulgent‚Äù) and non-idiomatic trick you use incurs a learning penalty for everyone else. Once they have done that learning, then they will find working with the code less difficult. So it is hard to recognise how to simplify code that you are already familiar with. This is why I try to get ‚Äúthe new kid‚Äù to critique the code before they get too institutionalised!  \u003c/p\u003e\n    \u003cp\u003eIt is likely that the previous author(s) created this huge mess one tiny increment at a time, not all at once. So you are the first person who has ever had to try to make sense of it all at once.  \u003c/p\u003e\n    \u003cp\u003eIn my class I describe a sprawling SQL stored procedure we were looking at one day, with hundreds of lines of conditionals in a huge WHERE clause. Someone asked how anyone could have let it get this bad. I told them: ‚ÄúWhen there are only 2 or 3 conditionals, adding another one doesn‚Äôt make any difference. By the time there are 20 or 30 conditionals, adding another one doesn‚Äôt make any difference!‚Äù  \u003c/p\u003e\n    \u003cp\u003eThere is no ‚Äúsimplifying force‚Äù acting on the code base other than deliberate choices that you make. Simplifying takes effort, and people are too often in a hurry.  \u003c/p\u003e\n    \u003cp\u003e\u003cem\u003eThanks to \u003ca target=\"_blank\" href=\"https://dannorth.net\"\u003eDan North\u003c/a\u003e for his comment\u003c/em\u003e.  \u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIf you\u0026#39;ve internalized the mental models of the project into your long-term memory, you won\u0026#39;t experience a high cognitive load.  \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/zakirullin/cognitive-load/blob/main/img/mentalmodelsv15paper.png?raw=true\" alt=\"Mental Models\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe more mental models there are to learn, the longer it takes for a new developer to deliver value.  \u003c/p\u003e\n\u003cp\u003eOnce you onboard new people on your project, try to measure the amount of confusion they have (pair programming may help). If they\u0026#39;re confused for more than ~40 minutes in a row - you\u0026#39;ve got things to improve in your code. \u003c/p\u003e\n\u003cp\u003eIf you keep the cognitive load low, people can contribute to your codebase within the first few hours of joining your company.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003e\n    \u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eImagine for a moment that what we inferred in the second chapter isn‚Äôt actually true. If that‚Äôs the case, then the conclusion we just negated, along with the conclusions in the previous chapter that we had accepted as valid, might not be correct either. \u003ccode\u003eü§Ø\u003c/code\u003e  \u003c/p\u003e\n\u003cp\u003eDo you feel it? Not only do you have to jump all over the article to get the meaning (shallow modules!), but the paragraph in general is difficult to understand. We have just created an unnecessary cognitive load in your head. \u003cstrong\u003eDo not do this to your colleagues.\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://github.com/zakirullin/cognitive-load/blob/main/img/smartauthorv14paperthanksmari.png?raw=true\" alt=\"Smart Author\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe should reduce any cognitive load above and beyond what is intrinsic to the work we do. \u003c/p\u003e\n\n\u003chr/\u003e\n\n\n\n\n\n        \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": null,
  "modifiedTime": null
}
