{
  "id": "05918846-71d2-4101-bfd4-fd3228479fcf",
  "title": "A brief history of code signing at Mozilla",
  "link": "https://hearsum.ca/posts/history-of-code-signing-at-mozilla/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 07 Feb 2025 17:51:49 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Ben Hearsum",
  "length": 11782,
  "excerpt": "Shipping large software to end-user devices is a complicated process. Shipping large software securely to end-user devices is even more complicated. Signing the things that ship to end-user devices is",
  "siteName": "Ben Hearsum",
  "favicon": "",
  "text": "Shipping large software to end-user devices is a complicated process. Shipping large software securely to end-user devices is even more complicated. Signing the things that ship to end-user devices is one of those complications, and it gets even more complicated when you sign thousands of artifacts per day. Mozilla has been signing Firefox in some form beginning with Firefox 1.0. This began with detached GPG signatures for builds, and progressed to Authenticode signing for Windows installers in Firefox 1.0.1. Since then it has evolved over time to encompass other platforms, other types of files within our products, and other ways that we ship (such as our own update packages). This post will provide a overview of the what, when, why, and how of code signing at Mozilla over the past ~20 years. What, when, and why Early GPG \u0026 Authenticode Signing When we first began signing, it happened on a Windows machine. Late in the release process, after Windows installers had been built, we would download all of the release artifacts to this machine, sign the Windows installers, and generate detached GPG signatures for those before pushing the artifacts elsewhere. At this time, the private keys and certificates were held on a USB stick that was kept removed from the machine at-rest. A Release Engineer needed to be physically present in Mountain View to perform this step. Once inserted, signing could be done via Remote Desktop rather than at the physical machine (but don't forget to remove the USB stick afterwards!). GPG signing was done with the standard GPG tools, running in cygwin. Authenticode signing was also done with the standard (at the time) Microsoft 'signcode.exe' tool. An annoying fact about that tool, is that it only accepted the necessary passphrase from a GUI dialog. To work around this, we had an AutoIt script running in the background that injected the passphrase into this dialog whenever it popped up. This interesting way of automating the process meant that mouse movements or keyboard interaction at the wrong time could interfere with the signing process. This process was partly scripted, but there was still a series of ~15 commands someone had to run by hand (and not mess up) to get everything done. You can see these commands for yourself in our now-ancient Unified Release Process documentation. Windows internal file signing Careful readers may have noted that early Authenticode signing only covered the Firefox installer itself, not the EXEs and DLLs inside of it. At some point (I haven't gone to the effort of tracking down exactly where...) we started signing these inner files as well. This process seems to have been lost to the sands of time, but I seem to recall it worked very similarly to the installer signing process, but without the GPG parts. Improved signing on Windows The first notable improvement we had to this process was to automate most of the copy/pasting that was done from the wiki. This came in the form of a Makefile that with a few mere inputs, would download, sign, and re-upload the signed builds. The main benefit of this was reduced opportunity for human error. Not long after that, we had our first real game-changing improvements. Chris AtLee wrote a nice post about it back in 2009, and how his changes took signing time from 8 hours all the way down to sub-15 minutes. This was accomplished through a combination of faster hardware, parallelized signing, in-process compression \u0026 decompression, and better caching. His changes also introduced a hefty amount of python into the signing process, which paved the way for the next big improvement... Automatic signing Despite the signing process now being very quick once it gets started, it could still sometimes take hours or longer to begin the process. Typically this would happen if our build and repack processes finished at a time when no Release Engineer was around to begin signing. This was solved with what we called \"autosign\". Rather than require a Release Engineer to be around at the right moment, we adjusted our scripts to allow them to be started ahead of time, and be smart enough to know when all of the files it needs to sign are ready. This work eliminated all wait time between builds being ready and signing running. Signing Windows builds...on Linux! In 2011, signing was rearchitected altogether. In short, the idea was to move signing to a highly secured Linux server, and sign builds through an API as part of the build process. This allowed builds to be signed as they were produced, and reduced the number of times builds had to move from one server to another before they shipped. An obvious question here is how we would manage to sign Windows binaries on Linux...as it turns out, the mono project had its own version of signcode that ran natively on Linux that we were able to make use of. MAR Signing Shortly after (and perhaps even motivating - I'm not sure at this point) the aforementioned signing server work, we began signing our MAR (Mozilla ARchive) packages that update users from an older version of Firefox to a newer version. Thanks to the earlier work, it was fairly trivial to use the same architecture to sign these files. macOS .app signing The idea of signing .app bundles for macOS was filed all the way back in 2007. There was some initial work on this in 2010, but we were unable to land it at that time. Around the same time that MAR signing was happening in 2012, we picked up this work again and managed to drive it home this time. Unfortunately, there were no tools available at the time to sign macOS builds on anything except a fairly modern macOS machine. For this reason, we had to run additional copies of our signing server on macOS and sign those builds with them. (If you've ever had to run macOS as a server you'll know just how unfortunate this was...) Taskcluster/signingscript/iscript In 2018, Mozilla migrated its CI and Release automation from our aging Buildbot systems to Taskcluster. As part of this, signing tasks moved to specialized Taskcluster workers known as \"signingscript\" and \"iscript\", used for signing non-macOS and macOS builds respectively. These specialized workers continued to outsource the actual work of signing to the previously discussed signing servers. An important part of this change is the introduction of Chain of Trust, a significant security enhancement that helps ensure that only authentic artifacts are signed to this day. Introducing...Autograph! Autograph is Mozilla's modern code signing service. It was built specifically to provide a signing service that allowed us to keep private key material in Hardware Security Modules (HSMs). Migrating release signing to it was a huge improvement over the existing signing server where Release Engineers had direct access to such things. It was initially used for signing XPIs and APKs, but by the end of 2019 we had migrated all non-macOS signing to it and retired the old Linux signing servers. In addition to the security enhancements it brought, we saw great performance wins with it as well, largely in thanks to it's support for only requiring a hash of the bytes being signed to be sent over the wire. (This requires that the client has some advanced knowledge of the file being signed, but it saves a tremendous amount of network traffic at our scale.) Notarization with rcodesign In 2023 we started making use of rcodesign to notarize and staple our macOS builds. While actual macOS code signing itself continues to happen on macOS machines, this allowed us to move at least some of our operations into the cloud and reduce our reliance on mac hardware. Tools and tech I've mentioned a number of tools and technology that we use as part of signing, but I've purposely glossed over some details in the interest of brevity. The following section is a glossary of sorts, and introduces some more under the hood tools that we use as part of signing. If you're interested in the gory details, the links below should be enough to find them for yourself! Or you can stop by #firefox-ci on Matrix to ask questions! osslsigncode osslsigncode is a tool that implements parts of Microsoft's signtool.exe. In the past, we used it to directly sign PE files. These days, we use it's support for attaching the signatures that Autograph makes to them. winsign Winsign is a python library for signing and manipulating Authenticode signatures. It relies on osslsigncode for writing signatures, and supports signing directly with a private key, or outsourcing the signing process to a passed in function. The latter is what we use, and it's how we inject a call to Autograph into the signing process. msix-packaging In 2021 we began shipping Firefox as an MSIX package. As part of this we discovered that osslsigncode does not support signing MSIX packages. Luckily for us, Microsoft's MSIX packaging tools are open source and run on Linux, and we found a fork that contained most of what was needed to support signing. With a few additional modifications, we were able to support signing these packages in our existing systems. apple-codesign apple-codesign is a very exciting project from Gregory Szorc which provides 3rd party tools capable of signing, notarizing, and stapling .app bundles and other Apple formats such as .pkg and .dmg. These tools run on Linux, and as noted above, we're already making use of them to notarize and staple our .app bundles. We're extremely excited about this project, and grateful to Gregory Szorc for all the effort he's bit into it. In the future we're looking forward to migrating our actual code signing to these tools which would (finally) allow us to retire our dedicated macOS signing machines. mardor mardor is a python tool to manage, and most importantly, sign, MAR files. In the days before Autograph it was used to directly sign MAR files. These days we only use it to inject signatures made by Autograph into the files, similar to our usage of osslsigncode. signingscript signingscript is the glue between our CI system (Taskcluster) and Autograph. Through a combination of the tools listed above, custom code in signingscript itself, and communication with Autograph it produces signed builds. It is additionally responsible for notarizing and stapling our macOS builds. iscript iscript is essentially a pared down version of signingscript (in fact their code is both derived from our early signing server code), and is responsible for signing our macOS builds. iscript runs on a small cluster of mac minis, which are a huge pain in the butt to manage. autograph As noted in an earlier section Autograph is our modern code signing service. It has a simple HTTP API that accepts signing requests and returns signed data or files. In addition to signing various artifacts that we ship it also makes Content Signatures on behalf of addons.mozilla.org, aus5.mozilla.org/Balrog (our update server), and some other backend services that Firefox communicates with, helping to ensure the security and integrity of requests made between Firefox and Mozilla-run services. Conclusion What a ride it's been over the last 20 years! We've gone from signing nothing to signing nearly everything in some form. Signing started off as a very manual process, and now happens seamlessly thousands of times per day. I don't think it would be possible to name everyone that contributed to this, but it took the ideas and efforts of tens, if not hundreds, of people to get to this point: release engineers, build system experts, security folks, and many others were all critical to getting us where we are today. I've got this post as brief as possible, but if you're interested in more details on any parts here feel free to reach out!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody text\"\u003e\n    \u003cp\u003eShipping large software to end-user devices is a complicated process. Shipping large software \u003cem\u003esecurely\u003c/em\u003e to end-user devices is even more complicated. Signing the things that ship to end-user devices is one of those complications, and it gets even more complicated when you sign thousands of artifacts per day.\u003c/p\u003e\n\n\u003cp\u003eMozilla has been signing Firefox in some form beginning with Firefox 1.0. This began with detached GPG signatures for builds, and progressed to Authenticode signing for Windows installers in Firefox 1.0.1. Since then it has evolved over time to encompass other platforms, other types of files within our products, and other ways that we ship (such as our own update packages). This post will provide a overview of the what, when, why, and how of code signing at Mozilla over the past ~20 years.\u003c/p\u003e\n\n\u003ch2\u003eWhat, when, and why\u003c/h2\u003e\n\n\u003ch3\u003eEarly GPG \u0026amp; Authenticode Signing\u003c/h3\u003e\n\n\u003cp\u003eWhen we first began signing, it happened on a Windows machine. Late in the release process, after Windows installers had been built, we would download all of the release artifacts to this machine, sign the Windows installers, and generate detached GPG signatures for those before pushing the artifacts elsewhere.\u003c/p\u003e\n\n\u003cp\u003eAt this time, the private keys and certificates were held on a USB stick that was kept removed from the machine at-rest. A Release Engineer needed to be physically present in Mountain View to perform this step. Once inserted, signing could be done via Remote Desktop rather than at the physical machine (but don\u0026#39;t forget to remove the USB stick afterwards!).\u003c/p\u003e\n\n\u003cp\u003eGPG signing was done with the standard GPG tools, running in cygwin. Authenticode signing was also done with the standard (at the time) Microsoft \u0026#39;signcode.exe\u0026#39; tool. An annoying fact about that tool, is that it only accepted the necessary passphrase from a GUI dialog. To work around this, we had an \u003ca href=\"https://en.wikipedia.org/wiki/AutoIt\"\u003eAutoIt\u003c/a\u003e script running in the background that injected the passphrase into this dialog whenever it popped up. This interesting way of automating the process meant that mouse movements or keyboard interaction at the wrong time could interfere with the signing process.\u003c/p\u003e\n\n\u003cp\u003eThis process was partly scripted, but there was still a series of ~15 commands someone had to run by hand (and not mess up) to get everything done. You can see these commands for yourself in our now-ancient \u003ca href=\"https://wiki.mozilla.org/ReleaseEngineering/Unified_Release_Process#Sign_builds\"\u003eUnified Release Process\u003c/a\u003e documentation.\u003c/p\u003e\n\n\u003ch3\u003eWindows internal file signing\u003c/h3\u003e\n\n\u003cp\u003eCareful readers may have noted that early Authenticode signing only covered the Firefox installer itself, not the EXEs and DLLs inside of it. At some point (I haven\u0026#39;t gone to the effort of tracking down exactly where...) we started signing these inner files as well. This process seems to have been \u003ca href=\"https://wiki.mozilla.org/ReleaseEngineering/Unified_Release_Process#Signing_windows_files\"\u003elost to the sands of time\u003c/a\u003e, but I seem to recall it worked very similarly to the installer signing process, but without the GPG parts.\u003c/p\u003e\n\n\u003ch3\u003eImproved signing on Windows\u003c/h3\u003e\n\n\u003cp\u003eThe first notable improvement we had to this process was to automate most of the copy/pasting that was done from the wiki. This came in the form of \u003ca href=\"https://github.com/mozilla/build-tools/blob/dba69406faad0c8e7a016150a3f5761ef83914d2/release/signing/Makefile\"\u003ea Makefile that with a few mere inputs\u003c/a\u003e, would download, sign, and re-upload the signed builds. The main benefit of this was reduced opportunity for human error.\u003c/p\u003e\n\n\u003cp\u003eNot long after that, \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=470146\"\u003ewe had our first real game-changing improvements\u003c/a\u003e. Chris AtLee \u003ca href=\"https://atlee.ca/posts/blog20090804faster-signing/\"\u003ewrote a nice post about it back in 2009\u003c/a\u003e, and how his changes took signing time from 8 hours all the way down to sub-15 minutes. This was accomplished through a combination of faster hardware, parallelized signing, in-process compression \u0026amp; decompression, and better caching. His changes also introduced \u003ca href=\"https://github.com/mozilla/build-tools/blob/c2e8e6f048db8990d629f169072d2a06b42e4759/release/signing/sign-release.py\"\u003ea hefty amount of python\u003c/a\u003e into the signing process, which paved the way for the next big improvement...\u003c/p\u003e\n\n\u003ch3\u003eAutomatic signing\u003c/h3\u003e\n\n\u003cp\u003eDespite the signing process now being very quick once it gets started, it could still sometimes take hours or longer to begin the process. Typically this would happen if our build and repack processes finished at a time when no Release Engineer was around to begin signing. This was solved with what we called \u0026#34;autosign\u0026#34;. Rather than require a Release Engineer to be around at the right moment, we adjusted our scripts to allow them to \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=558464#c1\"\u003ebe started ahead of time\u003c/a\u003e, and be smart enough to know when all of the files it needs to sign are ready. This work eliminated all wait time between builds being ready and signing running.\u003c/p\u003e\n\n\u003ch3\u003eSigning Windows builds...on Linux!\u003c/h3\u003e\n\n\u003cp\u003eIn 2011, \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=509158#c10\"\u003esigning was rearchitected altogether\u003c/a\u003e. In short, the idea was to move signing to a highly secured Linux server, and sign builds through an API as part of the build process. This allowed builds to be signed as they were produced, and reduced the number of times builds had to move from one server to another before they shipped.\n\nAn obvious question here is how we would manage to sign Windows binaries on Linux...as it turns out, the mono project had \u003ca href=\"https://manpages.debian.org/testing/mono-devel/signcode.1.en.html\"\u003eits own version of signcode that ran natively on Linux\u003c/a\u003e that we were able to make use of.\u003c/p\u003e\n\n\u003ch3\u003eMAR Signing\u003c/h3\u003e\n\n\u003cp\u003eShortly after (and perhaps even motivating - I\u0026#39;m not sure at this point) the aforementioned signing server work, we \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=699700\"\u003ebegan signing our MAR (Mozilla ARchive) packages\u003c/a\u003e that update users from an older version of Firefox to a newer version. Thanks to the earlier work, it was fairly trivial to use the same architecture to sign these files.\u003c/p\u003e\n\n\u003ch3\u003emacOS .app signing\u003c/h3\u003e\n\n\u003cp\u003eThe idea of signing .app bundles for macOS was filed \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=400296#c0\"\u003eall the way back in 2007\u003c/a\u003e. There was \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=400296#c25\"\u003esome initial work on this\u003c/a\u003e in 2010, but we were unable to land it at that time. Around the same time that MAR signing was happening in 2012, we \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=400296#c68\"\u003epicked up this work again\u003c/a\u003e and managed to drive it home this time.\u003c/p\u003e\n\n\u003cp\u003eUnfortunately, there were no tools available at the time to sign macOS builds on anything except a fairly modern macOS machine. For this reason, we had to run additional copies of our signing server on macOS and sign those builds with them. (If you\u0026#39;ve ever had to run macOS as a server you\u0026#39;ll know just how unfortunate this was...)\u003c/p\u003e\n\n\u003ch3\u003eTaskcluster/signingscript/iscript\u003c/h3\u003e\n\n\u003cp\u003eIn 2018, Mozilla migrated its CI and Release automation from our aging Buildbot systems to \u003ca href=\"https://taskcluster.net/\"\u003eTaskcluster\u003c/a\u003e. As part of this, signing tasks moved to specialized Taskcluster workers known as \u0026#34;signingscript\u0026#34; and \u0026#34;iscript\u0026#34;, used for signing non-macOS and macOS builds respectively. These specialized workers continued to outsource the actual work of signing to the previously discussed signing servers.\u003c/p\u003e\n\n\u003cp\u003eAn important part of this change is the introduction of \u003ca href=\"https://scriptworker.readthedocs.io/en/latest/chain_of_trust.html\"\u003eChain of Trust\u003c/a\u003e, a significant security enhancement that helps ensure that only authentic artifacts are signed to this day.\u003c/p\u003e\n\n\u003ch3\u003eIntroducing...Autograph!\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/mozilla-services/autograph\"\u003eAutograph\u003c/a\u003e is Mozilla\u0026#39;s modern code signing service. It was built specifically to provide a signing service that allowed us to keep private key material in Hardware Security Modules (HSMs). Migrating release signing to it was a huge improvement over the existing signing server where Release Engineers had direct access to such things. It was initially used for signing XPIs and APKs, but by the end of 2019 we had migrated all non-macOS signing to it and retired the old Linux signing servers.\u003c/p\u003e\n\n\u003cp\u003eIn addition to the security enhancements it brought, we saw great performance wins with it as well, largely in thanks to it\u0026#39;s support for \u003ca href=\"https://github.com/mozilla-services/autograph/blob/main/docs/architecture.md#overview\"\u003e only requiring a hash of the bytes being signed to be sent over the wire\u003c/a\u003e. (This requires that the client has some advanced knowledge of the file being signed, but it saves a \u003cem\u003etremendous\u003c/em\u003e amount of network traffic at our scale.)\n\n\u003c/p\u003e\n\u003ch3\u003eNotarization with rcodesign\u003c/h3\u003e\u003cp\u003e\n\nIn 2023 we started making use of \u003ca href=\"https://gregoryszorc.com/docs/apple-codesign/0.17.0/apple_codesign_rcodesign.html\"\u003ercodesign\u003c/a\u003e to \u003ca href=\"https://github.com/mozilla-releng/scriptworker-scripts/pull/714\"\u003enotarize and staple our macOS builds\u003c/a\u003e. While actual macOS code signing itself continues to happen on macOS machines, this allowed us to move at least some of our operations into the cloud and reduce our reliance on mac hardware.\n\n\u003c/p\u003e\u003ch2\u003eTools and tech\u003c/h2\u003e\n\n\u003cp\u003eI\u0026#39;ve mentioned a number of tools and technology that we use as part of signing, but I\u0026#39;ve purposely glossed over some details in the interest of brevity. The following section is a glossary of sorts, and introduces some more under the hood tools that we use as part of signing. If you\u0026#39;re interested in the gory details, the links below should be enough to find them for yourself! Or you can stop by \u003ca href=\"https://chat.mozilla.org/#/room/#firefox-ci:mozilla.org\"\u003e#firefox-ci on Matrix to ask questions!\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3\u003eosslsigncode\u003c/h3\u003e\n\u003cp\u003eosslsigncode is a \u003ca href=\"https://github.com/mtrojnar/osslsigncode\"\u003etool that implements parts of Microsoft\u0026#39;s signtool.exe\u003c/a\u003e. In the past, we used it to directly sign PE files. These days, we use it\u0026#39;s support for attaching the signatures that Autograph makes to them.\u003c/p\u003e\n\n\u003ch3\u003ewinsign\u003c/h3\u003e\n\u003cp\u003eWinsign is a \u003ca href=\"https://github.com/mozilla-releng/winsign\"\u003epython library for signing and manipulating Authenticode signatures\u003c/a\u003e. It relies on osslsigncode for writing signatures, and supports signing directly with a private key, or outsourcing the signing process to a passed in function. The latter is what we use, and it\u0026#39;s how we inject a call to Autograph into the signing process.\u003c/p\u003e\n\n\u003ch3\u003emsix-packaging\u003c/h3\u003e\n\u003cp\u003eIn 2021 we began shipping Firefox as an MSIX package. As part of this we discovered that osslsigncode does not support signing MSIX packages. Luckily for us, Microsoft\u0026#39;s MSIX packaging tools are open source and run on Linux, and we found a \u003ca href=\"https://github.com/microsoft/msix-packaging/issues/340#issuecomment-620797067\"\u003efork that contained most of what was needed\u003c/a\u003e to support signing. With a few additional modifications, we were able to support signing these packages in our existing systems.\u003c/p\u003e\n\n\u003ch3\u003eapple-codesign\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://gregoryszorc.com/docs/apple-codesign/0.17.0/index.html\"\u003eapple-codesign\u003c/a\u003e is a very exciting project from Gregory Szorc which provides 3rd party tools capable of signing, notarizing, and stapling .app bundles and other Apple formats such as .pkg and .dmg. These tools run on Linux, and as noted above, we\u0026#39;re already making use of them to notarize and staple our .app bundles.\n\nWe\u0026#39;re extremely excited about this project, and grateful to Gregory Szorc for all the effort he\u0026#39;s bit into it. In the future we\u0026#39;re looking forward to migrating our actual code signing to these tools which would (finally) allow us to retire our dedicated macOS signing machines.\u003c/p\u003e\n\n\u003ch3\u003emardor\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mozilla-releng/build-mar\"\u003emardor\u003c/a\u003e is a python tool to manage, and most importantly, sign, MAR files. In the days before Autograph it was used to directly sign MAR files. These days we only use it to inject signatures made by Autograph into the files, similar to our usage of osslsigncode.\u003c/p\u003e\n\n\u003ch3\u003esigningscript\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mozilla-releng/scriptworker-scripts/tree/master/signingscript\"\u003esigningscript\u003c/a\u003e is the glue between our CI system (Taskcluster) and Autograph. Through a combination of the tools listed above, custom code in signingscript itself, and communication with Autograph it produces signed builds. It is additionally responsible for notarizing and stapling our macOS builds.\u003c/p\u003e\n\n\u003ch3\u003eiscript\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mozilla-releng/scriptworker-scripts/tree/master/iscript\"\u003eiscript\u003c/a\u003e is essentially a pared down version of signingscript (in fact their code is both derived from our early signing server code), and is responsible for signing our macOS builds. iscript runs on a small cluster of mac minis, which are a huge pain in the butt to manage.\n\n\u003c/p\u003e\n\u003ch3\u003eautograph\u003c/h3\u003e\u003cp\u003e\nAs noted in an earlier section \u003ca href=\"https://github.com/mozilla-services/autograph\"\u003eAutograph\u003c/a\u003e is our modern code signing service. It has a simple HTTP API that accepts signing requests and returns signed data or files. In addition to signing various artifacts that we ship it also makes \u003ca href=\"https://github.com/mozilla-services/autograph/blob/main/signer/contentsignaturepki/README.md\"\u003eContent Signatures\u003c/a\u003e on behalf of addons.mozilla.org, aus5.mozilla.org/Balrog (our update server), and some other backend services that Firefox communicates with, helping to ensure the security and integrity of requests made between Firefox and Mozilla-run services.\n\n\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWhat a ride it\u0026#39;s been over the last 20 years! We\u0026#39;ve gone from signing nothing to signing nearly everything in some form. Signing started off as a very manual process, and now happens seamlessly thousands of times per day.\u003c/p\u003e\n\n\u003cp\u003eI don\u0026#39;t think it would be possible to name everyone that contributed to this, but it took the ideas and efforts of tens, if not hundreds, of people to get to this point: release engineers, build system experts, security folks, and many others were all critical to getting us where we are today.\u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;ve got this post as brief as possible, but if you\u0026#39;re interested in more details on any parts here feel free to reach out!\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-01-30T11:18:15-05:00",
  "modifiedTime": null
}
