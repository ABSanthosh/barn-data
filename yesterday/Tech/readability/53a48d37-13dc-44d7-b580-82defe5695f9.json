{
  "id": "53a48d37-13dc-44d7-b580-82defe5695f9",
  "title": "Why fastDOOM is fast",
  "link": "https://fabiensanglard.net/fastdoom/index.html",
  "description": "Comments",
  "author": "",
  "published": "Tue, 04 Mar 2025 19:05:43 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 19456,
  "excerpt": "Mar 04, 2025",
  "siteName": "",
  "favicon": "",
  "text": "Mar 04, 2025 Why fastDOOM is fast During the winter of 2024, I restored an IBM PS/1 486-DX2 66Mhz, \"Mini-Tower\", model 2168. It was the computer I always wanted as a teenager but could never afford. Words cannot do justice to the joy I felt while working on this machine. As soon as I got something able to boot, I benchmarked the one software I wanted to run. C:\\DOOM\u003edoom.exe -timedemo demo1 timed 1710 gametics in 2783 realtics Doom doesn't give the fps right away. You have to do a bit of math to get the framerate. In this instance, that's 1710/2783*35 = 21.5 fps. An honorable performance for the best machine money could (reasonably) buy in Dec 1993 (specs, chipset, video, disk1, disk2, speedsys). I was resigned to playing under Ibuprofen until I heard of fastDOOM. I am usually not a fan of ports because they tend to add features without cohesion (except for the dreamy Chocolate DOOM) but I gave it a try out of curiosity. C:\\DOOM\u003efdoom.exe -timedemo demo1 Timed 1710 gametics in 1988 realtics. FPS: 30.1 30% faster without cutting any features[1]! On a demanding map like doom2's demo1, the gain is even higher, from 16.8 fps to 24.9 fps. That is 48% faster! I did not suspect that DOOM had left that much on the table. Obviously shipping within one year left little time to optimize. I had to understand how this magic trick happened. A byte of history Before digging into fastDOOM, let's understand where the code comes from. DOOM was originally developed on NeXT Workstation. The game was structured to be easy to port with most of the code in a core surrounded by small sub-systems performing I/O. Source: Game Engine Black Book: DOOM During development, DOS I/Os were written by id Software. This became the commercial release of DOOM. But that version could not be open sourced in 1997 because it relied on a proprietary sound library called DMX. What ended up being open sourced was the linux version, cleaned up by Bernd Kreimeier when he was working on a book project to explain the engine. A DOS version of DOOM was reconstructed by using linux's core, Heretic I/O, and APODMX (Apogee Sound wrapper) to emulate DMX. Because Heretic used video mode 13h while DOOM used video mode Y, the graphic I/O (i_ibm.c) was reverse-engineered from DOOM.EXE disassembly. That is how the community got PCDOOM v2[2]. fastDOOM starting point was PCDOOM v2. ┌───────────────┐ │ NeXTStep DOOM │ └─────┬────┬────┘ │ │ │ │ │ │ ┌────────────┐ │ │ ┌──────┐ ┌─────────┐ │ Linux DOOM │◄─┘ └─►│ DOOM ├─────►│ Heretic │ └──────┬─────┘ └──────┘ └────┬────┘ │ ⁞ │ │ ▼ │ │ ┌──────────┐ │ └─────────────►│ PCDOOMv2 │◄────────┘ └─────┬────┘ ▼ ┌──────────┐ │ fastDOOM │ fastDoom genealogy └──────────┘ ────────────────── The big performance pictureVictor \"Viti95\" Nieto, wrote release notes to describe the performance improvement of each version but he seemed more interested in making FDOOM.EXE awesome than detailing how he did it. To get the big picture of performance evolution over time, I downloaded all 52 releases of fastDOOM, PCDOOMv2, and the original DOOM.EXE, wrote a go program to generate a RUN.BAT running -timedemo demo1 on all of them, and mounted it all with mTCP's NETDRIVE. I chose to timedemo DOOM.WAD with sound on and screen size = 10 (fullscreen with status bar). After several hours of shotguns and imps agony, I had run the whole suite five times and graphed the average fps with chart.js. The first thing this graph allows to rule out is that fastDOOM improvements were mostly due to using a modern compiler. PCDOOMv2 is built with OpenWatcom 2 but only gets a marginal improvement over DOOM.EXE. git archeologyOn top of releasing often, Viti95 displayed outstanding git discipline where one commit does one thing and each release was tagged. fastDOOM git history is made of 3,042 commits which allows to benchmark each feature. I wrote another go program to build every single commit. I will pass on the gory details of handling the many build system changes (especially from DOS to Linux). After an hour I had the most ugly program I ever wrote and 3,042 DOOM.EXE. I was pleased to see the build was almost never broken. Graphing the files size shows that the early effort was to be lean by cleaning and deleting code. There are major drops with bf0e983 (build 239 where sound recording was removed), 5f38323 (build 0340 where error code strings were deleted), and 8b9cac5 (build 1105 where TASM was replaced with NASM). Going deepTimedemoing all builds would have taken a very long time (3042x1.5/60/24 * 3 passes = 9 days) so I focused on the release where most of the speed was gained. I wrote yet another go program to generate a .BAT file running timedemo for all commits in v0.1, v0.6, v0.8, v0.9.2, and v0.9.7. I mounted 1.4 GiB of FDOOM.EXE with mTCP and ran it. It took a while because versions with 200+ commit runtime was 8h/pass. fastDOOM v0.1This release featured 220 commits. $ git log --reverse --oneline \"0.1\" | wc -l 220 Chart is click-able and mouseover-able The MPV patch of v0.1 is without a doubt build 36 (e16bab8). The \"Crispy optimization\" turns status bar percentage rendering into a noop if they have not changed. This prevents rendering to a scrap buffer and blitting to the screen for a total of 2 fps boost. At first I could not believe it. I assume my toolchain had a bug. But cherry-picking this patch on PCDOOMv2 confirmed the tremendous speed gain. Next is build 167 (a9359d5) which inlines FixedDiv via macro. Near the end, we see a series of optimizations granting 0.5 fps. Build 207 (9bd3f20): A PSX Doom optimization which optimizes the way the BSP is traversed. Build 212 (dc0f48e) \"Inlined R_MakeSpans\" which renders horizontal surfaces. Overall this version saw a lot of code being deleted (50% of commits were deletions) which probably helped to cuddle the 486 cachelines of my machine. git log --reverse --oneline \"0.1\" | grep -i -E \"remove|delete\" | wc -l 100 Somehow, one of my patches made it to fastDOOM. Probably when I was writing the Black Book? I have zero recollection of writing this! fastDOOM v0.6This release featured 33 commits. $ git log --reverse --oneline \"0.5\"^..\"0.6\" | wc -l 33 Chart is click-able and mouseover-able Among many small optimizations (hello GbaDOOM 341)) are MVP ones. Build 342 (22819fd) Skips rendering unneeded visplanes. Build 359 (40e0d4b) Removes a level of player pointer indirection. Build 360 (ccd296f) Double down on indirection removal. Build 369 (f29e665) Inlines the screenspace line splitter. fastDOOM v0.8This release featured 282 commits. $ git log --reverse --oneline \"0.7\"^..\"0.8\" | wc -l 282 The sound system was a bit unstable so I had to timedemo without sound and then normalize the fps. Moreover the focus of v0.8 seems to have been text-mode renderer so two regressions happened at Build 670 (a92c67f) and Build 730 (c3f5f50) where the Crispy optimization went away. Chart is click-able and mouseover-able MVPs: Build 792 (f279b7d): One executable per renderer (FDOOM.EXE, FDOOM13H.EXE, and so on). Build 793 (1874ee8): Disable debugging for compiler. Build 796 (6aae724): Bring back Crispy opt. Build 794 (1366ebf): Compile less code whenever possible. fastDOOM v0.9.2This release featured 110 commits. $ git log --reverse --oneline \"0.9.1\"^..\"0.9.2\" | wc -l 110 Chart is click-able and mouseover-able MVPs: Build 1639 (ae2a951): Optimize skyflatnum comparison. Build 1645 (0730cdc): Optimize R_DrawColumn for Mode Y. Build 1646 (17c9e83): Cleanup R_DrawSpan code. fastDOOM v0.9.7This release featured 293 commits. $ git log --reverse --oneline \"0.9.6\"^..\"0.9.7\" | wc -l 294 Despite running the benchmark several times, I was unable to reduce the noise of this release. Chart is click-able and mouseover-able MVPs: Build 1941 (0688235): Testing x86 ASM changes. Build 1943 (f326e73): Add CPU selection + CR2 optimization for 386SX. Build 1944 (a836abb): Add ESP optimization for R_DrawSpan386SX. Build 2000 (3432590): Add basecode for rendering fuzz columns in ASM. Build 2031 (0edab46): Remove a CMP comparison each loop (ken silverman's optimization?). Mode 13h vs Mode YfastDOOM explored many ways to make things faster, for a broad range of CPUs (386, 486, Pentium, Cyrix) and video buses (ISA, VLB, PCI). One optimization that did not work on my machine was to use video mode 13h instead of mode Y. In mode 13h dispatch of data toward the four VRAM banks of the VGA is done in hardware. To the CPU, the VRAM appears like a single linear 320x200 framebuffer. The inconvenience is that you can't double buffer in VRAM so you have to do it in RAM which means bytes are written twice. First into the framebuffer in RAM. And then a second time when sent to VRAM. Also, the engine must block on VSYNC. Mode 13h ──────── RAM VRAM (VGA card) SCREEN ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐ │ ┌───────────────┐ │ │ │ │ │ │ │ framebuffer 1 │ │ │ │ │ │ │ └───────────────┘ │ │ │ │ │ │ ┌───────────────┐ │ │ ┌───────────────┐ │ │ │ CPU ────►│ │ framebuffer 2 │ ├────► │ │framebuffer(fb)│ ├──────►│ │ │ └───────────────┘ │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ │ │ │ │ │ │ │ framebuffer 3 │ │ │ │ │ │ │ └───────────────┘ │ │ │ │ │ └───────────────────┘ └───────────────────┘ └───────────────────┘ The mode-Y lets programmers access the VGA banks individually. This allows triple-buffering in VRAM. Moreover, it has the advantage of writing bytes once, directly into VRAM. The target bank must be manually selected by the developer via very slow OUT instructions but that allows to duplicating pixels horizontally (which gives low-detail mode for free) by writing to two VGA banks at once via latches[3]. Another inconvenience is that it makes drawing invisible Specter much slower since it requires reading back from the VRAM. Mode Y ─────── VRAM (VGA card) SCREEN ┌───────────────────┐ ┌───────────────────┐ │ ┌───────────────┐ │ │ │ │ │fb1 | fb2 | fb3│ │ │ │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ │ │ │ │ │fb1 | fb2 | fb3│ │ │ │ CPU ──────────────────────────────► │ └───────────────┘ ├──────►│ │ │ ┌───────────────┐ │ │ │ │ │fb1 | fb2 | fb3│ │ │ │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ │ │ │ │ │fb1 | fb2 | fb3│ │ │ │ │ └───────────────┘ │ │ │ └───────────────────┘ └───────────────────┘ For machines with fast CPUs and bus (100+ Mhz/ Pentium and VLB/PCI) where video cards are less likely to handle OUT instruction well, mode 13h is better. For \"slow CPUs\", it is faster to write data once to VRAM via mode Y. Anyway, Doom used mode Y. DOOM uses 320*200*256 VGA mode, which is slightly different from MCGA mode (it would NOT run on an MCGA equiped machine). I access the frame buffer in an interleaved planar mode similar to Michael Abrash's \"Mode X\", but still at 200 scan lines instead of 240 (less pixels == faster update rate). DOOM cycles between three display pages. If only two were used, it would have to sync to the VBL to avoid possible display flicker. If you look carefully at a HOM effect, you should see three distinct images being cycled between. Another reason John game me for using Mode-Y back in the days is that the tools used by the graphic team (Deluxe Paint) only supported 320x200 (whereas Mode-X is 320x240). e...@agora.rdrop.com (Ed Hurtley) wrote: \u003eCheck, please... In case you haven't hit ESC ever, the Options menu \u003ehas a Low/High resolution toggle... Low is 320x200, High is \u003e640x400, with the border graphics (the score bar, menu, etc...) are \u003estill 320x200... (Just the same graphics files) Low detail is 160*200 in the view screen. This is done by setting two bits in the mapmask register whenever the texturing functions are writing to video memory, causing two pixels to be set for each byte written. ui...@freenet.Victoria.BC.CA (Ben Morris) wrote: \u003eJohn, \u003eYou're using a planar graphics system for a bitmapped game that \u003eupdates the entire screen at a respectable framrate on a 486/66? Its planar, but not bit planar (THAT would stink). Pixels 0,4,8 are in plane 0, pixels 1,5,9 are in plane 1, etc. \u003eThat's pretty incredible. I would have thought all the over- \u003ehead for programming the VGA registers would kill that \u003epossibility. The registers don't need to be programed all that much. The map mask register only needs to be set once for each vertical column, and four times for each horizontal row (I step by four pixels in the inner loop to stay on the same plane, then increment the start pixel and move to the next plane). It is still a lot of grief, and it polutes the program quite a bit, but texture mapping directly to the video memory gives you a fair amount of extra speed (10% - 15%) on most video cards because the video writes are interleaved with main memory accesses and texture calculations, giving the write time to complete without stalling. Going to that trouble also gets a perfect page flip, rather than the tearing you get with main memory buffering. Heretic was released in 1994. Hardware had evolved to make mode 13h[6][7] more appealing so Raven modified the DOOM engine to this effect. PCDoom v2 used Heretic I/O but re-implemented the video I/O with mode Y. Finally fastDOOM gives users the choice by providing several executable FDOOM.EXE, FDOOM13H.EXE, and FDOOMVBD.EXE. The DOOM press release beta (October '93) used Mode 13h, so I assume they switched to Mode Y to improve performance on slower machines (low-detail). I wonder why they didn’t also implement the so-called \"potato mode\", which writes four pixels with a single 8-bit write to VRAM. In FastDoom, I reintroduced Mode 13h because Heretic/Hexen had better-optimized ASM rendering code for this mode. Later, I was able to partially port this approach to column rendering in Mode Y, which resulted in a 5% to 7% performance improvement. Based on my testing, the best mode for 486 CPUs is the VESA direct mode (FDOOMVBD.EXE for 320x200). This mode combines the advantages of Mode Y with the optimized rendering code from Heretic while avoiding any OUT instructions—except for one to switch buffers, which executes only once per rendered frame. The only downside is that it requires a VLB or PCI graphics card with LFB enabled and has slower performance in low-detail and potato-detail modes.- Conversation with Viti95 Viti95 elaborated further on fastDOOM mode 13h during proof-reading. In FastDoom, Mode 13h uses a single framebuffer in RAM, which is copied to VRAM after the entire scene is rendered. Vsync is not enforced, which may result in flickering. There are two methods for copying the backbuffer to VRAM, optimized for different bus speeds. For slow buses (8-bit ISA), a differential copy method is used, transferring only modified pixels. This approach involves many branches but is faster overall because branching is less expensive than excessive bus transfers. For faster buses (16-bit ISA, VLB, PCI, etc.), a full backbuffer copy is performed using REP MOVS instructions, which is efficient when the bus bandwidth is sufficient. - Conversation with Viti95 More optimization which did not workAnother venue I appreciated seeing explored is OpenWatcom's processor-specific flags (4r/4s vs 3r/3s)[8]. Both wcc386's 386 and 486 flags were attempted but ultimately discontinued because the 386 version always seemed faster. One of my goals for FastDoom is to switch the compiler from OpenWatcom v2 to DJGPP (GCC), which has been shown to produce faster code with the same source. Alternatively, it would be great if someone could improve OpenWatcom v2 to close the performance gap. - Conversation with Viti95 Overall impressionWhat splendid work by Victor Nieto! If software can die from a thousand cuts, Viti95 made fastDOOM awesome with three thousand optimizations! Not only he leveraged existing improvements (crispy, psx, gba, Lee Killough), he also came up with many news one and generated so much hype that even Ken Silverman (author of Duke3D build engine) came to participate[9]. I tip my beret to you Victor!References^ [1]Note from Viti95: Joystick and network gameplay support have been removed, so it's not a completely feature-intact port ^^ (People are still trying to convince me to bring network gameplay back).^ [2]DOOM engine: gamesrc-ver-recreation^ [3]Game Engine Black Book: Wolfenstein 3D^ [4]Doom graphics modes usenet^ [5]Doom graphics modes usenet^ [6]Doom vs Heretic VGA performance difference^ [7]Doom in DOS: Original vs Source Ports ^ [8]OpenWatcom documentation^ [9]Note from Viti95: Some of Ken Silverman’s ideas and code made their way into the rendering functions for UMC Green CPUs, resulting in a significant speed boost on that hardware.. *",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cbr/\u003e\u003ccenter\u003e\n    \n\n\u003c/center\u003e\u003cp\u003e\nMar 04, 2025\u003c/p\u003e\n\u003cp\u003eWhy fastDOOM is fast\u003c/p\u003e\u003chr/\u003e\n \n\n\n\n\u003cp\u003eDuring the winter of 2024, I restored an IBM PS/1 486-DX2 66Mhz, \u0026#34;Mini-Tower\u0026#34;, model 2168. It was the computer I always wanted as a teenager but could never afford. Words cannot do justice\nto the joy I felt while working on this machine.\u003c/p\u003e\n\n\u003cimg loading=\"lazy\" src=\"https://fabiensanglard.net/fastdoom/2168.png\" width=\"1000\" height=\"598\"/\u003e\n \u003cp\u003eAs soon as I got something able to boot, I benchmarked the one software I wanted to run.\n\u003c/p\u003e\n\n\n\u003cpre\u003eC:\\DOOM\u0026gt;doom.exe -timedemo demo1\ntimed 1710 gametics in 2783 realtics  \n\u003c/pre\u003e\n\n\u003cp\u003eDoom doesn\u0026#39;t give the fps right away. You have to do a bit of math to get the framerate. In this instance, that\u0026#39;s 1710/2783*35 = \u003cspan\u003e\u003cb\u003e21.5\u003c/b\u003e\u003c/span\u003e fps. An honorable performance for the best machine money could (\u003ca href=\"https://fabiensanglard.net/fastdoom/pentium_ad_pcmag_nov_1993.jpg\"\u003ereasonably\u003c/a\u003e) buy in Dec 1993 (\u003ca href=\"https://fabiensanglard.net/fastdoom/ASTRA01.png\"\u003especs\u003c/a\u003e, \u003ca href=\"https://fabiensanglard.net/fastdoom/ASTRA02.png\"\u003echipset\u003c/a\u003e, \u003ca href=\"https://fabiensanglard.net/fastdoom/ASTRA06.png\"\u003evideo\u003c/a\u003e, \u003ca href=\"https://fabiensanglard.net/fastdoom/ASTRA03.png\"\u003edisk1\u003c/a\u003e, \u003ca href=\"https://fabiensanglard.net/fastdoom/ASTRA04.png\"\u003edisk2\u003c/a\u003e, \u003ca href=\"https://fabiensanglard.net/fastdoom/speedsys.png\"\u003espeedsys\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003eI was resigned to playing under Ibuprofen until I heard of fastDOOM. I am usually not a fan of ports\n  because they tend to add features without cohesion (except for the dreamy Chocolate DOOM) but I gave it a try out of curiosity.\n\u003c/p\u003e\n\n\u003cpre\u003eC:\\DOOM\u0026gt;fdoom.exe -timedemo demo1\nTimed 1710 gametics in 1988 realtics. FPS: \u003cspan\u003e\u003cb\u003e30.1\u003c/b\u003e\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e30% faster without cutting any features\u003ca name=\"back_1\" href=\"#footnote_1\"\u003e\u003csup\u003e[1]\u003c/sup\u003e\u003c/a\u003e! On a demanding map like doom2\u0026#39;s demo1, the gain is even higher, from \u003cspan\u003e\u003cb\u003e16.8\u003c/b\u003e\u003c/span\u003e fps to \u003cspan\u003e\u003cb\u003e24.9\u003c/b\u003e\u003c/span\u003e fps. That is 48% faster!\u003c/p\u003e\n\n\u003cp\u003eI did not suspect that DOOM had left that much on the table. Obviously shipping within one year left little time to optimize. I had to understand how this magic trick happened.\u003c/p\u003e\n\n\n\u003cp\u003eA byte of history \u003c/p\u003e\u003chr/\u003e\u003cp\u003eBefore digging into fastDOOM, let\u0026#39;s understand where the code comes from. DOOM was originally developed on NeXT Workstation. The game was structured to be easy to port with most of the code in a core surrounded by small sub-systems performing I/O.\u003c/p\u003e\n\n\n\u003cimg loading=\"lazy\" src=\"https://fabiensanglard.net/fastdoom/doom_arch.svg\" width=\"153.81099mm\" height=\"159.21635mm\"/\u003e\n \u003ccenter\u003e\u003csmall\u003eSource: Game Engine Black Book: DOOM\u003c/small\u003e\u003c/center\u003e\n\n\u003cp\u003eDuring development, DOS I/Os were written by id Software. This became the commercial release of DOOM.\nBut that version could not be open sourced in 1997 because it relied on a proprietary sound library called DMX.\u003c/p\u003e\n\n\u003cp\u003eWhat ended up being open sourced was the linux version, cleaned up by Bernd Kreimeier when he was working on a book project to explain the engine.\u003c/p\u003e\n\n\u003cp\u003eA DOS version of DOOM was reconstructed by using linux\u0026#39;s core, Heretic I/O, and APODMX (Apogee Sound wrapper) to emulate DMX. \n  Because Heretic used video mode 13h while DOOM used video mode Y, the graphic I/O (\u003ccode\u003ei_ibm.c\u003c/code\u003e)\nwas reverse-engineered from \u003ccode\u003eDOOM.EXE\u003c/code\u003e disassembly. That is how the community got PCDOOM v2\u003ca name=\"back_2\" href=\"#footnote_2\"\u003e\u003csup\u003e[2]\u003c/sup\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003efastDOOM starting point was PCDOOM v2.\u003c/p\u003e\n\n\u003cpre\u003e                    ┌───────────────┐                              \n                    │ NeXTStep DOOM │                              \n                    └─────┬────┬────┘                              \n                          │    │                                 \n                          │    │                                 \n                          │    │                                 \n          ┌────────────┐  │    │  ┌──────┐      ┌─────────┐      \n          │ Linux DOOM │◄─┘    └─►│ DOOM ├─────►│ Heretic │      \n          └──────┬─────┘          └──────┘      └────┬────┘      \n                 │                    ⁞              │           \n                 │                    ▼              │           \n                 │              ┌──────────┐         │           \n                 └─────────────►│ PCDOOMv2 │◄────────┘           \n                                └─────┬────┘                     \n                                      ▼                          \n                                ┌──────────┐                     \n                                │ fastDOOM │                     \nfastDoom genealogy              └──────────┘\n──────────────────\u003c/pre\u003e\n\n\n\u003cp\u003eThe big performance picture\u003c/p\u003e\u003chr/\u003e\u003cp\u003eVictor \u0026#34;Viti95\u0026#34; Nieto, wrote release notes to describe the performance improvement of each version but he seemed more interested in making \u003ccode\u003eFDOOM.EXE\u003c/code\u003e awesome than detailing how he did it.\u003c/p\u003e\n\n\n\u003cp\u003eTo get the big picture of performance evolution over time, I downloaded all 52 releases of fastDOOM, PCDOOMv2, and the original \u003ccode\u003eDOOM.EXE\u003c/code\u003e, wrote a go program to generate a \u003ccode\u003eRUN.BAT\u003c/code\u003e running \u003ccode\u003e-timedemo demo1\u003c/code\u003e on all of them, and mounted it all with mTCP\u0026#39;s \u003ccode\u003eNETDRIVE\u003c/code\u003e.\u003c/p\u003e\n\n\n\u003cp\u003eI chose to timedemo \u003ccode\u003eDOOM.WAD\u003c/code\u003e with sound on and screen size = 10 (fullscreen with status bar). After several hours of shotguns and imps agony, I had run the whole suite five times and graphed the average fps with \u003ccode\u003echart.js\u003c/code\u003e.\u003c/p\u003e\n\n\n\u003ccanvas id=\"bpChart\"\u003e\u003c/canvas\u003e\n\n\n\u003cp\u003eThe first thing this graph allows to rule out is that fastDOOM improvements were mostly due to using a modern compiler. \u003ccode\u003ePCDOOMv2\u003c/code\u003e is built with OpenWatcom 2 but only gets a marginal improvement over \u003ccode\u003eDOOM.EXE\u003c/code\u003e.\u003c/p\u003e \n\n\n\n\n\n\u003cp\u003egit archeology\u003c/p\u003e\u003chr/\u003e\u003cp\u003eOn top of releasing often, Viti95 displayed outstanding git discipline where one commit does one thing and each release was tagged. fastDOOM git history is made of 3,042 commits which allows to benchmark each feature.\u003c/p\u003e\n\n\u003cp\u003eI wrote another go program to build every single commit. I will pass on the gory details of handling the many build system changes (especially from DOS to Linux). After an hour I had the\n  most ugly program I ever wrote and 3,042 \u003ccode\u003eDOOM.EXE\u003c/code\u003e. I was pleased to see the build was almost never broken.\u003c/p\u003e\n\n\u003ccanvas id=\"sizesChart\"\u003e\u003c/canvas\u003e\n\n\n\n\u003cp\u003eGraphing the files size shows that the early effort was to be lean by cleaning and deleting code. There are major drops with \u003ca href=\"https://github.com/viti95/FastDoom/commit/bf0e983ed00f038b65a34f10fa626abb99c87fe6\"\u003ebf0e983\u003c/a\u003e \n  (build 239 where sound recording was removed), \u003ca href=\"https://github.com/viti95/FastDoom/commit/5f3832310b32c32895688b3112301f98e77119b8\" target=\"_blank\"\u003e5f38323\u003c/a\u003e\n  (build 0340 where error code strings were deleted), \n  and \u003ca href=\"https://github.com/viti95/FastDoom/commit/8b9cac591945fa93af84c0e85845b6a55bc76fe3\" target=\"_blank\"\u003e8b9cac5\u003c/a\u003e\n   (build 1105 where TASM was replaced with NASM).\n \u003c/p\u003e\n\n\n\u003cp\u003eGoing deep\u003c/p\u003e\u003chr/\u003e\u003cp\u003eTimedemoing all builds would have taken a very long time (3042x1.5/60/24 * 3 passes = 9 days) so I focused\non the release where most of the speed was gained. I wrote yet another go program to generate a \u003ccode\u003e.BAT\u003c/code\u003e file running timedemo for all commits in \u003ccode\u003ev0.1\u003c/code\u003e, \u003ccode\u003ev0.6\u003c/code\u003e, \u003ccode\u003ev0.8\u003c/code\u003e, \u003ccode\u003ev0.9.2\u003c/code\u003e, and \u003ccode\u003ev0.9.7\u003c/code\u003e.\nI mounted 1.4 GiB of \u003ccode\u003eFDOOM.EXE\u003c/code\u003e with mTCP and ran it. It took a while because versions with 200+ commit runtime was 8h/pass.\u003c/p\u003e\n\n\n\n\u003cp\u003efastDOOM v0.1\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis release featured \u003ca href=\"\"\u003e220 commits\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e$ git log --reverse --oneline \u0026#34;0.1\u0026#34; | wc -l\n     220\n\u003c/pre\u003e\n\n\n\n\u003ccanvas id=\"v0Chart\"\u003e\u003c/canvas\u003e\n\u003cp\u003eChart is click-able and mouseover-able\u003c/p\u003e\n\n\n\n\n\n\u003cp\u003eThe MPV patch of v0.1 is without a doubt build 36 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/e16bab87df86baaf2bdec5e17e4844fac9b110be\"\u003ee16bab8\u003c/a\u003e). The \u0026#34;Crispy optimization\u0026#34; turns status bar percentage rendering into a noop if they have not changed. This prevents rendering to a scrap buffer and blitting to the screen for a total\nof 2 fps boost. At first I could not believe it. I assume my toolchain had a bug. But cherry-picking this patch on PCDOOMv2 confirmed the tremendous speed gain.\u003c/p\u003e\n\n\u003cp\u003eNext is build 167 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/a9359d599e339d7e8bcd730ea2bed7cc22fa2947\"\u003ea9359d5\u003c/a\u003e)\nwhich inlines FixedDiv via macro.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cp\u003eNear the end, we see a series of optimizations granting 0.5 fps.\u003c/p\u003e\u003cp\u003e\n  \n  \n  Build 207 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/9bd3f207df1837f2b9cb87ca2e67fdc01fcc1a95\"\u003e9bd3f20\u003c/a\u003e): A PSX Doom optimization which optimizes the way the BSP is traversed.\u003cbr/\u003e\n\nBuild 212 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/dc0f48e22d2804bf025d1b8efe4436311ad1d56d\"\u003edc0f48e\u003c/a\u003e) \u0026#34;Inlined R_MakeSpans\u0026#34; which renders horizontal surfaces.\u003c/p\u003e\u003c/div\u003e\n\n\u003cp\u003eOverall this version saw a lot of code being deleted (50% of commits were deletions) which probably helped to cuddle the 486 cachelines of my machine.\u003c/p\u003e\n\u003cpre\u003egit log --reverse --oneline \u0026#34;0.1\u0026#34; | grep -i -E \u0026#34;remove|delete\u0026#34; | wc -l\n     100\n\u003c/pre\u003e\n\n\u003cp\u003eSomehow, \u003ca href=\"https://github.com/viti95/FastDoom/commit/609c42df\"\u003eone of my patches\u003c/a\u003e made it to fastDOOM. Probably when I was\nwriting the Black Book? I have zero recollection of writing this!\u003c/p\u003e\n\n\u003cp\u003efastDOOM v0.6\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis release featured 33 commits.\u003c/p\u003e\n\n\u003cpre\u003e$ git log --reverse --oneline \u0026#34;0.5\u0026#34;^..\u0026#34;0.6\u0026#34; | wc -l \n      33\n\u003c/pre\u003e\n\n\n\n\n\u003ccanvas id=\"v6Chart\"\u003e\u003c/canvas\u003e\n\u003cp\u003eChart is click-able and mouseover-able\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cp\u003eAmong many small optimizations (hello GbaDOOM \u003ca href=\"https://github.com/viti95/FastDoom/commit/e745a5dc62c21de8926e5845b41fea89cd7f03ad\"\u003e341\u003c/a\u003e)) are MVP ones.\u003c/p\u003e\u003cp\u003e\n  \nBuild 342 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/b6aea6ab6c966d1d78edb5da915871e6a22819fd\"\u003e22819fd\u003c/a\u003e) Skips rendering unneeded visplanes.\u003cbr/\u003e\nBuild 359 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/3329d704e081d8a18e7fd3a9c4a239d8840e0d4b\"\u003e40e0d4b\u003c/a\u003e) Removes a level of player pointer indirection.\u003cbr/\u003e\nBuild 360 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/8e5e6355d232d3f4dfd9203dc6aa963adccd296f\"\u003eccd296f\u003c/a\u003e) Double down on indirection removal.\u003cbr/\u003e\nBuild 369 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/dff38f9fa903f15b24fb13da712feeb09f29e665\"\u003ef29e665\u003c/a\u003e) Inlines the screenspace line splitter.\u003c/p\u003e\u003c/div\u003e\n\n\n\u003cp\u003efastDOOM v0.8\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis release featured \u003ca href=\"\"\u003e282 commits\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e$ git log --reverse --oneline \u0026#34;0.7\u0026#34;^..\u0026#34;0.8\u0026#34; | wc -l\n     282\n\u003c/pre\u003e\n\n\u003cp\u003eThe sound system was a bit unstable so I had to timedemo without sound and then normalize the fps. \n  Moreover the focus of v0.8 seems to have been text-mode renderer so two regressions happened at Build 670 \n  (\u003ca href=\"https://github.com/viti95/FastDoom/commit/50848560577f8d008b5c7f5bb69d7595fa92c67f\"\u003ea92c67f\u003c/a\u003e)\n   and Build 730 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/17095d801f6603f9ab8091fa60453d5b6c3f5f50\"\u003ec3f5f50\u003c/a\u003e) where the Crispy optimization went away.\u003c/p\u003e\n\n\u003ccanvas id=\"v8Chart\"\u003e\u003c/canvas\u003e\n\u003cp\u003eChart is click-able and mouseover-able\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cu\u003e\u003cb\u003eMVPs:\u003c/b\u003e\u003c/u\u003e\u003c/p\u003e\n\u003cp\u003e\nBuild 792 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/b253754a80045e9809ccfb7bf0f0cf680f279b7d\"\u003ef279b7d\u003c/a\u003e): One executable per renderer (\u003ccode\u003eFDOOM.EXE\u003c/code\u003e, \u003ccode\u003eFDOOM13H.EXE\u003c/code\u003e, and so on).\u003cbr/\u003e \nBuild 793 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/5ddc4e1c967a737c271327cbd4290137a1874ee8\"\u003e1874ee8\u003c/a\u003e): Disable debugging for compiler.\u003cbr/\u003e\nBuild 796 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/85a895802e750360e4251e7fd836906db6aae724\"\u003e6aae724\u003c/a\u003e): Bring back Crispy opt.\u003cbr/\u003e \nBuild 794 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/eefc599d6c740e890fffa96b5d68b03281366ebf\"\u003e1366ebf\u003c/a\u003e): Compile less code whenever possible.\u003cbr/\u003e\n\u003c/p\u003e\n\n\n\u003cp\u003efastDOOM v0.9.2\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis release featured \u003ca href=\"\"\u003e110 commits\u003c/a\u003e.\u003c/p\u003e\n  \n\u003cpre\u003e$ git log --reverse --oneline \u0026#34;0.9.1\u0026#34;^..\u0026#34;0.9.2\u0026#34; | wc -l\n     110\n\u003c/pre\u003e\n\n\u003ccanvas id=\"v92Chart\"\u003e\u003c/canvas\u003e\n\u003cp\u003eChart is click-able and mouseover-able\u003c/p\u003e\n\n\n\u003cp\u003e\u003cu\u003e\u003cb\u003eMVPs:\u003c/b\u003e\u003c/u\u003e\u003c/p\u003e\n\u003cp\u003e\nBuild 1639 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/7d992d86be7e3b3492e7c032d76ea90a2ae2a951\"\u003eae2a951\u003c/a\u003e): Optimize skyflatnum comparison.\u003cbr/\u003e\nBuild 1645 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/9fb58c2ec8072c5de6e5f4bf8094b51b30730cdc\"\u003e0730cdc\u003c/a\u003e): Optimize R_DrawColumn for Mode Y.\u003cbr/\u003e\nBuild 1646 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/c906b0cba8aac6e44698c7a942b77641217c9e83\"\u003e17c9e83\u003c/a\u003e): Cleanup R_DrawSpan code.\u003cbr/\u003e\n\u003c/p\u003e\n\n\n\n\n\u003cp\u003efastDOOM v0.9.7\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThis release featured \u003ca href=\"\"\u003e293 commits\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e$ git log --reverse --oneline \u0026#34;0.9.6\u0026#34;^..\u0026#34;0.9.7\u0026#34; | wc -l\n     294\n\u003c/pre\u003e\n\n\u003cp\u003eDespite running the benchmark several times, I was unable to reduce the noise of this release.\u003c/p\u003e\n\n\u003ccanvas id=\"v97Chart\"\u003e\u003c/canvas\u003e\n\u003cp\u003eChart is click-able and mouseover-able\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cu\u003e\u003cb\u003eMVPs:\u003c/b\u003e\u003c/u\u003e\u003c/p\u003e\n\u003cp\u003e\nBuild 1941 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/c0657d1eb1ca2f6caebbda58c5fb20b150688235\"\u003e0688235\u003c/a\u003e): Testing x86 ASM changes.\u003cbr/\u003e\nBuild 1943 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/cd506d432d63d0e0813b97c8d7c915c02f326e73\"\u003ef326e73\u003c/a\u003e): Add CPU selection + CR2 optimization for 386SX.\u003cbr/\u003e\nBuild 1944 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/7682c40f69bd7db825670758b9a0fb881a836abb\"\u003ea836abb\u003c/a\u003e): Add ESP optimization for R_DrawSpan386SX.\u003cbr/\u003e\nBuild 2000 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/38fbcdbd9ccc4c077daa8bd65138f2b403432590\"\u003e3432590\u003c/a\u003e): Add basecode for rendering fuzz columns in ASM.\u003cbr/\u003e\nBuild 2031 (\u003ca href=\"https://github.com/viti95/FastDoom/commit/95232f3d748978a27d142f1cbf7ef40710edab46\"\u003e0edab46\u003c/a\u003e): Remove a CMP comparison each loop (\u003ca href=\"https://github.com/viti95/FastDoom/issues/143\"\u003eken silverman\u0026#39;s optimization\u003c/a\u003e?).\u003cbr/\u003e\n\u003c/p\u003e\n\n\u003cp\u003eMode 13h vs Mode Y\u003c/p\u003e\u003chr/\u003e\u003cp\u003efastDOOM explored many ways to make things faster, for a broad range of CPUs (386, 486, Pentium, Cyrix) and video buses (ISA, VLB, PCI). One\noptimization that did not work on my machine was to use video mode 13h instead of mode Y.\u003c/p\u003e\n\n\u003cp\u003eIn mode 13h dispatch of data toward the four VRAM banks of the VGA is done in hardware. To the CPU, the VRAM appears like a single linear 320x200 framebuffer.\nThe inconvenience is that you can\u0026#39;t double buffer in VRAM so you have to do it in RAM which means bytes are written twice. First into the framebuffer in RAM. And then\na second time when sent to VRAM. Also, the engine must block on VSYNC.\u003c/p\u003e\n\n\u003cpre\u003eMode 13h                                                                                               \n────────             RAM                   VRAM (VGA card)                 SCREEN              \n             ┌───────────────────┐      ┌───────────────────┐       ┌───────────────────┐      \n             │ ┌───────────────┐ │      │                   │       │                   │      \n             │ │ framebuffer 1 │ │      │                   │       │                   │      \n             │ └───────────────┘ │      │                   │       │                   │      \n             │ ┌───────────────┐ │      │ ┌───────────────┐ │       │                   │      \n    CPU ────►│ │ framebuffer 2 │ ├────► │ │framebuffer(fb)│ ├──────►│                   │      \n             │ └───────────────┘ │      │ └───────────────┘ │       │                   │      \n             │ ┌───────────────┐ │      │                   │       │                   │      \n             │ │ framebuffer 3 │ │      │                   │       │                   │      \n             │ └───────────────┘ │      │                   │       │                   │      \n             └───────────────────┘      └───────────────────┘       └───────────────────┘      \n\u003c/pre\u003e\n\n\n\u003cp\u003eThe mode-Y lets programmers access the VGA banks individually. This allows triple-buffering in VRAM. Moreover, it has the advantage of writing bytes once, directly into\n VRAM. The target bank must be manually selected by the developer via very slow \u003ccode\u003eOUT\u003c/code\u003e instructions\n but that allows to duplicating pixels horizontally (which gives low-detail mode for free) by writing to two VGA banks at once via latches\u003ca name=\"back_3\" href=\"#footnote_3\"\u003e\u003csup\u003e[3]\u003c/sup\u003e\u003c/a\u003e. Another inconvenience is that it makes drawing invisible Specter much slower since it requires reading back from the VRAM.\u003c/p\u003e\n\n\u003cpre\u003eMode Y                                                                                               \n───────                                    VRAM (VGA card)                 SCREEN         \n                                        ┌───────────────────┐       ┌───────────────────┐ \n                                        │ ┌───────────────┐ │       │                   │ \n                                        │ │fb1 | fb2 | fb3│ │       │                   │ \n                                        │ └───────────────┘ │       │                   │ \n                                        │ ┌───────────────┐ │       │                   │ \n                                        │ │fb1 | fb2 | fb3│ │       │                   │ \n    CPU ──────────────────────────────► │ └───────────────┘ ├──────►│                   │ \n                                        │ ┌───────────────┐ │       │                   │ \n                                        │ │fb1 | fb2 | fb3│ │       │                   │ \n                                        │ └───────────────┘ │       │                   │ \n                                        │ ┌───────────────┐ │       │                   │ \n                                        │ │fb1 | fb2 | fb3│ │       │                   │ \n                                        │ └───────────────┘ │       │                   │ \n                                        └───────────────────┘       └───────────────────┘    \n\u003c/pre\u003e\n\n\u003cp\u003eFor machines with fast CPUs and bus (100+ Mhz/ Pentium and VLB/PCI) where video cards are less likely to handle \u003ccode\u003eOUT\u003c/code\u003e instruction well, mode 13h is better. \nFor \u0026#34;slow CPUs\u0026#34;, it is faster to write data once to VRAM via mode Y.\u003c/p\u003e\n\n\u003cp\u003eAnyway, Doom used mode Y.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n       DOOM uses 320*200*256 VGA mode, which is slightly different from MCGA\nmode (it would NOT run on an MCGA equiped machine). I access the\nframe buffer in an interleaved planar mode similar to Michael\nAbrash\u0026#39;s \u0026#34;Mode X\u0026#34;, but still at 200 scan lines instead of 240 (less\npixels == faster update rate).\u003cp\u003e\n\nDOOM cycles between three display pages. If only two were used, it\nwould have to sync to the VBL to avoid possible display flicker. If\nyou look carefully at a HOM effect, you should see three distinct\nimages being cycled between.\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n\u003cp\u003eAnother reason John game me for using Mode-Y back in the days is that the tools used by the graphic team (Deluxe Paint) only supported 320x200 (whereas Mode-X is 320x240).\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\u003cspan\u003e\ne...@agora.rdrop.com (Ed Hurtley) wrote:\n\u0026gt;Check, please... In case you haven\u0026#39;t hit ESC ever, the Options menu\n\u0026gt;has a Low/High resolution toggle... Low is 320x200, High is\n\u0026gt;640x400, with the border graphics (the score bar, menu, etc...) are\n\u0026gt;still 320x200... (Just the same graphics files)\u003c/span\u003e\n\u003cp\u003e\nLow detail is 160*200 in the view screen. This is done by setting\ntwo bits in the mapmask register whenever the texturing functions are\nwriting to video memory, causing two pixels to be set for each byte\nwritten.\n\u003c/p\u003e\u003cp\u003e\u003cspan\u003e\nui...@freenet.Victoria.BC.CA (Ben Morris) wrote:\n\u003cp\u003e\n\u0026gt;John,\n\u003c/p\u003e\u003cp\u003e\n\u0026gt;You\u0026#39;re using a planar graphics system for a bitmapped game that\n\u0026gt;updates the entire screen at a respectable framrate on a 486/66?\u003c/p\u003e\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\nIts planar, but not bit planar (THAT would stink). Pixels 0,4,8 are\nin plane 0, pixels 1,5,9 are in plane 1, etc.\n\u003c/p\u003e\u003cp\u003e\u003cspan\u003e\n\u0026gt;That\u0026#39;s pretty incredible. I would have thought all the over-\n\u0026gt;head for programming the VGA registers would kill that\n\u0026gt;possibility.\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\nThe registers don\u0026#39;t need to be programed all that much. The map mask\nregister only needs to be set once for each vertical column, and four\ntimes for each horizontal row (I step by four pixels in the inner\nloop to stay on the same plane, then increment the start pixel and\nmove to the next plane).\n\u003c/p\u003e\u003cp\u003e\nIt is still a lot of grief, and it polutes the program quite a bit,\nbut texture mapping directly to the video memory gives you a fair\namount of extra speed (10% - 15%) on most video cards because the\nvideo writes are interleaved with main memory accesses and texture\ncalculations, giving the write time to complete without stalling.\n\u003c/p\u003e\u003cp\u003e\nGoing to that trouble also gets a perfect page flip, rather than the\ntearing you get with main memory buffering.\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n\n\n  \u003cp\u003eHeretic was released in 1994. Hardware had evolved to make mode 13h\u003ca name=\"back_6\" href=\"#footnote_6\"\u003e\u003csup\u003e[6]\u003c/sup\u003e\u003c/a\u003e\u003ca name=\"back_7\" href=\"#footnote_7\"\u003e\u003csup\u003e[7]\u003c/sup\u003e\u003c/a\u003e  more appealing so Raven modified the DOOM engine to this effect. \n  PCDoom v2 used Heretic I/O but re-implemented the video I/O with mode Y. \n  Finally fastDOOM gives users the choice by providing several executable \u003ccode\u003eFDOOM.EXE\u003c/code\u003e, \u003ccode\u003eFDOOM13H.EXE\u003c/code\u003e, and \u003ccode\u003eFDOOMVBD.EXE\u003c/code\u003e.\n  \u003c/p\u003e\n\n  \u003cblockquote\u003e\nThe DOOM press release beta (October \u0026#39;93) used Mode 13h, so I assume they switched to Mode Y to improve performance on slower machines (low-detail). I wonder why they didn’t also implement the so-called \u0026#34;potato mode\u0026#34;, which writes four pixels with a single 8-bit write to VRAM.\n\u003cp\u003e\nIn FastDoom, I reintroduced Mode 13h because Heretic/Hexen had better-optimized ASM rendering code for this mode. Later, I was able to partially port this approach to column rendering in Mode Y, which resulted in a 5% to 7% performance improvement.\n\u003c/p\u003e\u003cp\u003e\nBased on my testing, the best mode for 486 CPUs is the VESA direct mode (FDOOMVBD.EXE for 320x200). This mode combines the advantages of Mode Y with the optimized rendering code from Heretic while avoiding any OUT instructions—except for one to switch buffers, which executes only once per rendered frame. The only downside is that it requires a VLB or PCI graphics card with LFB enabled and has slower performance in low-detail and potato-detail modes.\u003c/p\u003e\u003cp\u003e- Conversation with Viti95\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n\u003cp\u003eViti95 elaborated further on fastDOOM mode 13h during proof-reading.\u003c/p\u003e\n  \u003cblockquote\u003e\nIn FastDoom, Mode 13h uses a single framebuffer in RAM, which is copied to VRAM after the entire scene is rendered. Vsync is not enforced, which may result in flickering. There are two methods for copying the backbuffer to VRAM, optimized for different bus speeds. For slow buses (8-bit ISA), a differential copy method is used, transferring only modified pixels.\n\u003cp\u003e\nThis approach involves many branches but is faster overall because branching is less expensive than excessive bus transfers. For faster buses (16-bit ISA, VLB, PCI, etc.), a full backbuffer copy is performed using REP MOVS instructions, which is efficient when the bus bandwidth is sufficient.\n\u003c/p\u003e\u003cp\u003e- Conversation with Viti95\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n\u003cp\u003eMore optimization which did not work\u003c/p\u003e\u003chr/\u003e\u003cp\u003eAnother venue I appreciated seeing explored is OpenWatcom\u0026#39;s processor-specific flags (\u003ccode\u003e4r\u003c/code\u003e/\u003ccode\u003e4s\u003c/code\u003e vs \u003ccode\u003e3r\u003c/code\u003e/\u003ccode\u003e3s\u003c/code\u003e)\u003ca name=\"back_8\" href=\"#footnote_8\"\u003e\u003csup\u003e[8]\u003c/sup\u003e\u003c/a\u003e. Both wcc386\u0026#39;s 386 and 486 flags were attempted but ultimately discontinued\n  because the 386 version always seemed faster.\u003c/p\u003e\n\n\n\u003cblockquote\u003e\nOne of my goals for FastDoom is to switch the compiler from OpenWatcom v2 to DJGPP (GCC), which has been shown to produce faster code with the same source. Alternatively, it would be great if someone could improve OpenWatcom v2 to close the performance gap.\n \u003cp\u003e- Conversation with Viti95\u003c/p\u003e\n    \u003c/blockquote\u003e\n\n\n\u003cp\u003eOverall impression\u003c/p\u003e\u003chr/\u003e\u003cdiv\u003e\u003cp\u003eWhat splendid work by Victor Nieto!\n If software can die from a thousand cuts, Viti95 made fastDOOM awesome with three thousand optimizations! \n  Not only he leveraged existing improvements (crispy, psx, gba, Lee Killough), he also came up with many news one\nand generated so much hype that even Ken Silverman (author of Duke3D build engine) came \u003ca href=\"https://github.com/viti95/FastDoom/issues/143\"\u003eto participate\u003c/a\u003e\u003ca name=\"back_9\" href=\"#footnote_9\"\u003e\u003csup\u003e[9]\u003c/sup\u003e\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003e I tip my beret to you Victor!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eReferences\u003c/p\u003e\u003chr/\u003e\u003cp id=\"paperbox\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_1\"\u003e\u003c/a\u003e\u003ca href=\"#back_1\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [1]\u003c/td\u003e\u003ctd\u003e\u003cu\u003e\u003cb\u003eNote from Viti95:\u003c/b\u003e\u003c/u\u003e Joystick and network gameplay support have been removed, so it\u0026#39;s not a completely feature-intact port ^^ (People are still trying to convince me to bring network gameplay back).\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_2\"\u003e\u003c/a\u003e\u003ca href=\"#back_2\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [2]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://doomwiki.org/wiki/Gamesrc-ver-recreation\"\u003eDOOM engine: gamesrc-ver-recreation\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_3\"\u003e\u003c/a\u003e\u003ca href=\"#back_3\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [3]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://fabiensanglard.net/\"\u003eGame Engine \n Black Book: Wolfenstein 3D\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_4\"\u003e\u003c/a\u003e\u003ca href=\"#back_4\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [4]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://groups.google.com/g/alt.games.doom/c/3tMB2UmEBK0/m/m1VR6LiJRQMJ\"\u003eDoom graphics modes usenet\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_5\"\u003e\u003c/a\u003e\u003ca href=\"#back_5\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [5]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://groups.google.com/g/alt.games.doom/c/3tMB2UmEBK0/m/m1VR6LiJRQMJ\"\u003eDoom graphics modes usenet\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_6\"\u003e\u003c/a\u003e\u003ca href=\"#back_6\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [6]\u003c/td\u003e\u003ctd\u003e\u003ca href=\" https://www.vogons.org/viewtopic.php?t=61839\"\u003eDoom vs Heretic VGA performance difference\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_7\"\u003e\u003c/a\u003e\u003ca href=\"#back_7\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [7]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://www.vogons.org/viewtopic.php?f=7\u0026amp;t=40699\"\u003eDoom in DOS: Original vs Source Ports \u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_8\"\u003e\u003c/a\u003e\u003ca href=\"#back_8\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [8]\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://fabiensanglard.net/fastdoom/openwatcom_doc.pdf\"\u003eOpenWatcom documentation\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca name=\"footnote_9\"\u003e\u003c/a\u003e\u003ca href=\"#back_9\"\u003e^\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e [9]\u003c/td\u003e\u003ctd\u003e\u003cu\u003e\u003cb\u003eNote from Viti95:\u003c/b\u003e\u003c/u\u003e Some of Ken Silverman’s ideas and code made their way into the rendering functions for UMC Green CPUs, resulting in a significant speed boost on that hardware..\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/p\u003e \u003chr/\u003e\n \u003ccenter\u003e*\u003c/center\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": null,
  "modifiedTime": null
}
