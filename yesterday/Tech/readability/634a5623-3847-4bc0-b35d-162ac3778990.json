{
  "id": "634a5623-3847-4bc0-b35d-162ac3778990",
  "title": "An Alternative to Rewriting Memory-Unsafe Code in Rust: the 'Safe C++ Extensions' Proposal",
  "link": "https://developers.slashdot.org/story/24/10/20/2359227/an-alternative-to-rewriting-memory-unsafe-code-in-rust-the-safe-c-extensions-proposal?utm_source=rss1.0mainlinkanon\u0026utm_medium=feed",
  "description": "\"After two years of being beaten with the memory-safety stick, the C++ community has published a proposal to help developers write less vulnerable code,\" reports the Register. \"The Safe C++ Extensions proposal aims to address the vulnerable programming language's Achilles' heel, the challenge of ensuring that code is free of memory safety bugs...\" Acknowledging the now deafening chorus of calls to adopt memory safe programming languages, developers Sean Baxter, creator of the Circle compiler, and Christian Mazakas, from the C++ Alliance, argue that while Rust is the only popular systems level programming language without garbage collection that provides rigorous memory safety, migrating C++ code to Rust poses problems. \"Rust lacks function overloading, templates, inheritance and exceptions,\" they explain in the proposal. \"C++ lacks traits, relocation and borrow checking. These discrepancies are responsible for an impedance mismatch when interfacing the two languages. Most code generators for inter-language bindings aren't able to represent features of one language in terms of the features of another.\" Though DARPA is trying to develop better automated C++ to Rust conversion tools, Baxter and Mazakas argue telling veteran C++ developers to learn Rust isn't an answer... The Safe C++ project adds new technology for ensuring memory safety, Baxter explained, and isn't just a reiteration of best practices. \"Safe C++ prevents users from writing unsound code,\" he said. \"This includes compile-time intelligence like borrow checking to prevent use-after-free bugs and initialization analysis for type safety.\" Baxter said that rewriting a project in a different programming language is costly, so the aim here is to make memory safety more accessible by providing the same soundness guarantees as Rust at a lower cost. \"With Safe C++, existing code continues to work as always,\" he explained. \"Stakeholders have more control for incrementally opting in to safety.\" The next step, Baxter said, involves greater participation from industry to help realize the Safe C++ project. \"The foundations are in: We have fantastic borrow checking and initialization analysis which underpin the soundness guarantees,\" he said. \"The next step is to comprehensively visit all of C++'s features and specify memory-safe versions of them. It's a big effort, but given the importance of reducing C++ security vulnerabilities, it's an effort worth making.\" Read more of this story at Slashdot.",
  "author": "EditorDavid",
  "published": "2024-10-21T00:03:00+00:00",
  "source": "http://rss.slashdot.org/Slashdot/slashdotMain",
  "categories": [
    "programming"
  ],
  "byline": "",
  "length": 2461,
  "excerpt": "\"After two years of being beaten with the memory-safety stick, the C++ community has published a proposal to help developers write less vulnerable code,\" reports the Register. \"The Safe C++ Extensions proposal aims to address the vulnerable programming language's Achilles' heel, the challenge of e...",
  "siteName": "",
  "favicon": "",
  "text": "\"After two years of being beaten with the memory-safety stick, the C++ community has published a proposal to help developers write less vulnerable code,\" reports the Register. \"The Safe C++ Extensions proposal aims to address the vulnerable programming language's Achilles' heel, the challenge of ensuring that code is free of memory safety bugs...\" Acknowledging the now deafening chorus of calls to adopt memory safe programming languages, developers Sean Baxter, creator of the Circle compiler, and Christian Mazakas, from the C++ Alliance, argue that while Rust is the only popular systems level programming language without garbage collection that provides rigorous memory safety, migrating C++ code to Rust poses problems. \"Rust lacks function overloading, templates, inheritance and exceptions,\" they explain in the proposal. \"C++ lacks traits, relocation and borrow checking. These discrepancies are responsible for an impedance mismatch when interfacing the two languages. Most code generators for inter-language bindings aren't able to represent features of one language in terms of the features of another.\" Though DARPA is trying to develop better automated C++ to Rust conversion tools, Baxter and Mazakas argue telling veteran C++ developers to learn Rust isn't an answer... The Safe C++ project adds new technology for ensuring memory safety, Baxter explained, and isn't just a reiteration of best practices. \"Safe C++ prevents users from writing unsound code,\" he said. \"This includes compile-time intelligence like borrow checking to prevent use-after-free bugs and initialization analysis for type safety.\" Baxter said that rewriting a project in a different programming language is costly, so the aim here is to make memory safety more accessible by providing the same soundness guarantees as Rust at a lower cost. \"With Safe C++, existing code continues to work as always,\" he explained. \"Stakeholders have more control for incrementally opting in to safety.\" The next step, Baxter said, involves greater participation from industry to help realize the Safe C++ project. \"The foundations are in: We have fantastic borrow checking and initialization analysis which underpin the soundness guarantees,\" he said. \"The next step is to comprehensively visit all of C++'s features and specify memory-safe versions of them. It's a big effort, but given the importance of reducing C++ security vulnerabilities, it's an effort worth making.\"",
  "image": "https://a.fsdn.com/sd/topics/programming_64.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"fhbody-175291957\"\u003e\u003cp\u003e\n\t\t\t\n\t\t \t\n\t\t\t\t\u0026#34;After two years of being beaten with the memory-safety stick, the C++ community has published a proposal to help developers write less vulnerable code,\u0026#34; \u003ca href=\"https://www.theregister.com/2024/09/16/safe_c_plusplus/\"\u003ereports the \u003cem\u003eRegister\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e \n\n\u0026#34;The \u003ca href=\"https://safecpp.org/P3390R0.html\"\u003eSafe C++ Extensions proposal\u003c/a\u003e aims to address the vulnerable programming language\u0026#39;s Achilles\u0026#39; heel, the challenge of ensuring that code is free of memory safety bugs...\u0026#34;\n\n\u003ci\u003eAcknowledging the now deafening chorus of calls to adopt memory safe programming languages, developers Sean Baxter, creator of the \u003ca href=\"https://github.com/seanbaxter/circle\"\u003eCircle compiler\u003c/a\u003e, and Christian Mazakas, from the C++ Alliance, argue that while Rust is the only popular systems level programming language without garbage collection that provides rigorous memory safety, migrating C++ code to Rust poses problems.   \u0026#34;Rust lacks function overloading, templates, inheritance and exceptions,\u0026#34; they explain in the proposal. \u0026#34;C++ lacks traits, relocation and borrow checking. These discrepancies are responsible for an impedance mismatch when interfacing the two languages. Most code generators for inter-language bindings aren\u0026#39;t able to represent features of one language in terms of the features of another.\u0026#34;\u003cp\u003e \n\nThough DARPA is trying to develop better automated C++ to Rust conversion tools, Baxter and Mazakas argue telling veteran C++ developers to learn Rust isn\u0026#39;t an answer... The Safe C++ project adds new technology for ensuring memory safety, Baxter explained, and isn\u0026#39;t just a reiteration of best practices. \u0026#34;Safe C++ prevents users from writing unsound code,\u0026#34; he said. \u0026#34;This includes compile-time intelligence like borrow checking to prevent use-after-free bugs and initialization analysis for type safety.\u0026#34;  Baxter said that rewriting a project in a different programming language is costly, so the aim here is to make memory safety more accessible by providing the same soundness guarantees as Rust at a lower cost. \u0026#34;With Safe C++, existing code continues to work as always,\u0026#34; he explained. \u0026#34;Stakeholders have more control for incrementally opting in to safety.\u0026#34;\u003c/p\u003e\u003cp\u003e \n\nThe next step, Baxter said, involves greater participation from industry to help realize the Safe C++ project. \u0026#34;The foundations are in: We have fantastic borrow checking and initialization analysis which underpin the soundness guarantees,\u0026#34; he said. \u0026#34;The next step is to comprehensively visit all of C++\u0026#39;s features and specify memory-safe versions of them. It\u0026#39;s a big effort, but given the importance of reducing C++ security vulnerabilities, it\u0026#39;s an effort worth making.\u0026#34;\n\u003c/p\u003e\u003c/i\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": null,
  "modifiedTime": null
}
