{
  "id": "f4a2009b-6b22-45d2-9fa7-70d9124c2821",
  "title": "Why Android can't use CDC Ethernet (2023)",
  "link": "https://jordemort.dev/blog/why-android-cant-use-cdc-ethernet/",
  "description": "Comments",
  "author": "",
  "published": "Sun, 08 Jun 2025 20:49:07 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Jordan Webb Home Portfolio Blog GitHub Search",
  "length": 22118,
  "excerpt": "A detective story with a silly ending",
  "siteName": "",
  "favicon": "",
  "text": "If you just want the answer to the question posed in the title, click the TLDR below and then move on with your day. Otherwise, buckle in, we‚Äôre going debugging; this post is mostly about my thought process and techniques I used to arrive at the answer rather than the answer itself.TLDR: Just tell me why CDC Ethernet doesn't work on AndroidAndroid's EthernetTracker service only acknowledges interfaces that are named ethX; Linux's CDC Ethernet drivers create interfaces that are named usbX. There is no way to work around this, short of rooting the phone to change the value of config_ethernet_iface_regex.Android contains support for USB ethernet adapters. There‚Äôs even menus for them!This means that if you very carefully select a USB Ethernet adapter that you know has a chipset compatible with your Android device, you can plug it in and these settings will spring to life. How do you know what chipsets are compatible with your phone?Hearsay!I‚Äôm not entirely kidding. If the company that you bought your phone from sells a USB ethernet adapter as an accessory to it, you have a pretty good chance of that one working. Otherwise, it‚Äôs hit-or-miss; phone manufacturers rarely, if ever, publish lists of supported Ethernet adapters. The best you‚Äôre going to get is finding a forum post from someone that has the same phone as you saying that they bought a particular adapter that worked, and hoping you can find the same thing to buy.Or is it?As you may know, if you dig deep beneath Android‚Äôs Googly carapace, you‚Äôll find a Linux kernel. To build the Linux kernel, you must first configure it. This configuration determines what features and hardware the resulting kernel will support. Thus, the list of Ethernet adapters supported by your phone will more-or-less correspond to those selected in the kernel configuration for your phone, although it‚Äôs possible (but unlikely) that your phone‚Äôs manufacturer doesn‚Äôt ship all of the drivers that they build, or that they build additional third-party drivers separately.So, in order to figure out what Ethernet adapters your phone supports, you‚Äôre going to want to find your phone‚Äôs kernel configuration. How do we do that?First, enable USB debugging and install ADBIf you‚Äôd like to follow along with this blog post, you‚Äôre going to need enable USB debugging and to install ADB (Android Debug Bridge) ‚Äî this is a command-line tool that is used by developers to interact with Android devices. In this post, we will be using it to run shell commands on a phone.There‚Äôs good documentation elsewhere on how to do these things so I‚Äôm not going to waste time by rewriting it poorly. Instead, have some links:First, enable USB debugging on your phoneInstall ADB on your computerRun adb shell, which will give you a shell prompt on the phone.Congratulations, you can now run commands on your phone. Type exit and press enter when you‚Äôre ready to exit the ADB shell.Next, we need to switch things up so that ADB connects to the phone over the network, instead of via USB. We need to do this because we‚Äôre going to try plugging some network adapters into the phone‚Äôs USB port, so we can‚Äôt also use the port for debugging.With your phone connected to your computer via USB:Connect your phone to the same network as your computer via wifiFigure out your phone‚Äôs IP address - you can do this by digging around the Settings app, or you can try adb shell ifconfig wlan0With the phone still connected via USB, run adb tcpip 5555Disconnect the USB cable from the phoneReconnect to the phone by running adb connect YOUR_PHONE_IP:5555 (replacing YOUR_PHONE_IP with the IP address from the phone)Try adb shell to make sure it still worksOnce you have ADB working over the network, you can proceed with trying to figure out what version of the kernel your Android device is running.If you have a newer phone‚Ä¶These days, Google publishes an Android Common Kernel, which downstream phone manufacturers are required to derive their kernels from. The source to this kernel is hosted in a Git repository at googlesource.com.If your phone shipped with Android 11 or later, you have something called a GKI kernel - in this case, Google builds the kernel and the phone manufacturer puts all of their model-specific secret sauce into kernel modules. In this case, you can find the configuration that Google is using by navigating to the appropriate branch of the kernel repository, and looking at the file arch/$ARCH/configs/gki_defconfig, where $ARCH is the processor architecture of your phone. For example, if your phone has a 64-bit ARM processor (and it almost certainly does) then you will find this configuration at arch/arm64/configs/gki_defconfig.How do I find out for sure what kernel version and processor architecture my phone has?Now that we have the ability to run shell commands on the phone, we can turn to good old uname to discover the kernel version and architecture that‚Äôs currently running.Go back and enable USB debugging and install ADB, if you haven‚Äôt arleadyRun uname -a on the phone, either by running adb shell and then running uname -a, or all in one go by running adb shell uname -a.You should get output something like this:Linux localhost 4.19.113-26203352 #1 SMP PREEMPT Tue Apr 18 16:05:51 KST 2023 aarch64 ToyboxYou‚Äôll the kernel version in the third field and the architecture in the second-to-last; you‚Äôll have to make an educated guess about which branch or tag in Google‚Äôs kernel repository corresponds to the one running on your phone.What if I have an older phone?If you have an older phone, then you‚Äôre in the same boat as me; I have an iPhone as a daily driver, but I keep a Samsung Galaxy s20 around as an Android testbed. Unfortunately, the s20 shipped with Android 10, which is the version just before all of this standardized kernel stuff from Google became required. Even though the s20 has since been upgraded to Android 13, Google doesn‚Äôt require phone manufacturers to update the kernel along with the Android version, and so Samsung didn‚Äôt; it still runs a kernel based on Linux 4.19.In this case, you need to get the kernel configuration from your phone manufacturer, so you‚Äôd better hope they‚Äôre actually doing regular source releases. Samsung does do this; you can find sources for their phones at opensource.samsung.com.Once you have the sources for your device, you‚Äôre going to have to dig around a bit to figure out what kernel config. The sources I obtained for my phone from Samsung included a Kernel.tar.gz; inside of this archive was a Linux kernel source tree, along with a few additions. One of those additions was a shell script called build_kernel.sh, which goes a little something like this:#!/bin/bash export ARCH=arm64 mkdir out BUILD_CROSS_COMPILE=$(pwd)/toolchain/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android- KERNEL_LLVM_BIN=$(pwd)/toolchain/llvm-arm-toolchain-ship/10.0/bin/clang CLANG_TRIPLE=aarch64-linux-gnu- KERNEL_MAKE_ENV=\"DTC_EXT=$(pwd)/tools/dtc CONFIG_BUILD_ARM64_DT_OVERLAY=y\" make -j8 -C $(pwd) O=$(pwd)/out $KERNEL_MAKE_ENV ARCH=arm64 CROSS_COMPILE=$BUILD_CROSS_COMPILE REAL_CC=$KERNEL_LLVM_BIN CLANG_TRIPLE=$CLANG_TRIPLE vendor/x1q_usa_singlex_defconfig make -j8 -C $(pwd) O=$(pwd)/out $KERNEL_MAKE_ENV ARCH=arm64 CROSS_COMPILE=$BUILD_CROSS_COMPILE REAL_CC=$KERNEL_LLVM_BIN CLANG_TRIPLE=$CLANG_TRIPLE cp out/arch/arm64/boot/Image $(pwd)/arch/arm64/boot/ImageIf you squint at this long enough, you‚Äôll spot a reference to something that looks like a kernel config: vendor/x1q_usa_singlex_defconfig. There isn‚Äôt a subdirectory called vendor in the root of the archive, so I used find to figure out exactly where the file lives:$ find . -name x1q_usa_singlex_defconfig ./arch/arm64/configs/vendor/x1q_usa_singlex_defconfigAha, there it is, deeply nested in a subdirectory.Finding the kernel config sounds hard, is there an easier way?There might be, if you‚Äôre lucky! Give this a shot:$ adb shell zcat /proc/config.gzIf you‚Äôre lucky, and your phone manufacturer has enabled the relevant kernel option, then a compressed copy of the configuration that your kernel was compiled with is available at /proc/config.gz. If this is the case, you‚Äôll have a large amount of output streaming to your terminal. You probably want to redirect it somewhere so you can peruse it at your leisure:$ adb shell zcat /proc/config.gz \u003e my_kernel_configIf you‚Äôre unlucky, you‚Äôll see something like this:zcat: /proc/config.gz: No such file or directoryIn this case, there is no easy way out; you‚Äôll have to refer to the sources your phone‚Äôs kernel was built from.What does a kernel configuration look like?In case you‚Äôre interested, here is the kernel configuration for my Galaxy s20: x1q_usa_singlex_defconfigYour kernel configuration should look very similar to this, but not identical, unless you have the same phone that I do.OK, I have the kernel configuration for my phone, what now?For the purpose of determining which USB Ethernet adapters the kernel supports, most of the configuration variables that we are interested will start with USB_NET, so just grep the kernel configuration for that string:$ grep USB_NET my_kernel_config CONFIG_USB_NET_DRIVERS=y CONFIG_USB_NET_AX8817X=y CONFIG_USB_NET_AX88179_178A=y CONFIG_USB_NET_CDCETHER=y CONFIG_USB_NET_CDC_EEM=y CONFIG_USB_NET_CDC_NCM=y # CONFIG_USB_NET_HUAWEI_CDC_NCM is not set ... and so on ...Look for a CONFIG_USB_NET_something that looks like it relates to the chipset of the adapter you want to use. The best news is if it is set to y; that means the driver is built-in to your kernel and that your phone‚Äôs kernel definitely supports that chipset. If it‚Äôs set to m, that‚Äôs still probably good news; that means that the driver was compiled as a module when your kernel was built, and that the module is likely loadable on your phone unless your phone‚Äôs manufacturer specifically left it out. If you see is not set, then that is the worst news; the driver was neither built-in to your kernel, nor was it compiled as a module, so it‚Äôs likely not available for you to use.If you‚Äôre having trouble figuring out which configuration items correspond to which chipsets, have a look at drivers/net/usb/Kconfig in your kernel tree. This file will contain extended descriptions of each configuration item.Unfortunately, to figure out which chipset a particular adapter uses, you‚Äôre mostly back to hearsay; few manufacturers of USB Ethernet adapters explicitly advertise which chipset they use.So what‚Äôs this about CDC Ethernet and why should I care?CDC stands for Communications Device Class. This is a set of interrelated standards that manufacturers of USB devices can follow; among them are a trio of standards called EEM (Ethernet Emulation Model), ECM (Ethernet Control Model), and NCM (Network Control Model) that can be used to build USB Ethernet adapters. Most of the difference between these three standards is a matter of complexity; EEM is the simplest to implement and is easy to support on underpowered devices, but may not result in the best performance. ECM is more complex to implement for both the USB host and the device, but promises better performance than EEM; NCM is a successor to ECM that promises even higher speeds. Many devices implement more than one of these protocols, and leave it up to the host operating system to communicate with the device using the one that it prefers.The point of these standards is that, assuming manufacturers follow them, operating systems can provide a single common driver that works with a variety of drivers. You generally don‚Äôt need special drivers for USB keyboards or mice because of the USB HID standard; the USB CDC standard attempts to accomplish the same for USB networking devices.One particularly fun thing is that Linux implements both the host and the device side of the CDC Ethernet standards. That means that if you have hardware with a USB OTG port, which is common on the Raspberry Pi and other small ARM devices, you can tell the kernel to use that port to pretend to be an Ethernet adapter. This creates a USB network interface on the host that is directly connected to an interface on the guest; this lets you build cool things like embedded routers, firewalls, and VPN gateways that look like just another Ethernet adapter to the host.Linux, as well as Windows and macOS (but not iOS) include drivers for CDC Ethernet devices. Unfortunately, none of this works on Android devices, despite Android being based on Linux. Why is Android like this?Based on the kernel configuration, Android appears to support CDCLet‚Äôs have another look at our kernel config, and grep for USB_NET_CDC:$ grep USB_NET_CDC my_kernel_config CONFIG_USB_NET_CDCETHER=y CONFIG_USB_NET_CDC_EEM=y CONFIG_USB_NET_CDC_NCM=y ... and so on ...Here we can see that Samsung has built support for all 3 CDC Ethernet standards into their kernel (CONFIG_USB_NET_CDCETHER corresponds to ECM). Google‚Äôs GKI kernels are somewhat less generous and appear to leave out ECM and NCM, but still include support for EEM as a module.I‚Äôve got a device with an OTG port that I‚Äôve configured as an Ethernet gadget. It works when I plug it into my Mac. It works when I plug it into my Ubuntu desktop. It even works when I plug it into my Windows game machine (actually the same computer as the Ubuntu desktop, booted off of a different drive üòÅ). It doesn‚Äôt work at all when I plug it into my Galaxy s20. The Ethernet settings are still greyed out:Let‚Äôs grab a shell on the phone and dig in a bit.The Linux kernel exposes information about itself in a pseudo-filesystem called sysfs - this looks like a directory tree full of files, but reading the files actually gets you information about the current state of the kernel.Among other things, sysfs contains a directory named /sys/class/net, which contains one entry for every network interface that the kernel is aware of. Let‚Äôs connect our Ethernet gadget to the phone and see if anything shows up there:$ adb shell ls /sys/class/net ... lots of output ... usb0 wlan0Could usb0 be the gadget? Let‚Äôs use ifconfig to check it out:$ adb shell ifconfig usb0 usb0 Link encap:UNSPEC Driver cdc_eem BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 TX bytes:0That certainly looks like our gadget. Too bad the interface is down. Unfortunately, the Ethernet settings on the phone are still greyed out:Let‚Äôs unplug the gadget and make sure usb0 goes away when we do:$ adb shell ls /sys/class/net | grep usb $ # no outputYep, it‚Äôs gone.It looks like we‚Äôre using EEM mode. In addition to the g_ether module, Linux also includes a thing called configfs that can be used to create custom gadgets. Let‚Äôs try one that only supports ECM and see if that works:$ adb shell ls /sys/class/net | grep usb usb0 $ adb shell ifconfig usb0 usb0 Link encap:UNSPEC Driver cdc_ether BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 TX bytes:0It‚Äôs still detected, but it‚Äôs still down. Will NCM fare any better?$ adb shell ls /sys/class/net | grep usb usb0 $ adb shell ifconfig usb0 usb0 Link encap:UNSPEC Driver cdc_ncm BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 TX bytes:0No, it will not.So why doesn‚Äôt CDC work on Android?At this point, we‚Äôve more-or-less established that everything is fine on the kernel level. I‚Äôm pretty sure that if I wanted to, I could root this phone, manually configure the interface with ifconfig, and it would pass traffic just fine. That means the problem must be somewhere in the stack of software above the kernel.If this was a regular Linux system, this is the point where I‚Äôd start poking at systemd-networkd, or NetworkManager, or ifupdown, depending on the particulars. This is not a regular Linux system, though; it‚Äôs an Android device, and none of that stuff exists here. What do I know about how Android configures network interfaces?NOTHING. I know nothing about how Android configures network interfaces. How do we figure this out?Well, Android is at least sort of open source; many of the good bits are closed behind the veil of something called ‚ÄúGoogle Play Services‚Äù but maybe there‚Äôs enough in the sources that are released to figure this out.To play along with this bit, you‚Äôll need to download the source to Android. This is a whole process on its own, so I‚Äôll leave you to Google‚Äôs documentation for this, except to note that you‚Äôll need a special tool called repo. This seems to be meant to make it easier to download sources from multiple Git repositories at once; sometimes it feels like I‚Äôm the only person that actually likes Git submodules. There are a lot of sources to download, so start this process and then go knock off a few shrines in Zelda while it wraps up.I figure that searching for the string Ethernet is probably a good starting point. Because there is so much source to go through, I‚Äôm going to skip vanilla grep this time and enlist the aid of ripgrep. There‚Äôs a lot of configuration files and other clutter in the Android sources, as well as most of a Linux distro, but I know that any code that we‚Äôre going to care about here is likely written in Java, so I‚Äôm going to restrict rg to searching in Java files:$ rg -t java Ethernet ... SO MUCH OUTPUT ...At this point, there‚Äôs not much else to do but look at the files where we‚Äôve got hits and try to figure out what part of the code we can blame for our problem. Fortunately for you, I‚Äôve saved you the trouble. After reading a bunch of Android code, I‚Äôm certain that our culprit is EthernetTracker.java. This appears to be a service that listens on a Netlink socket and receives notifications from the kernel about new network interfaces. The EthernetTracker contains a method that determines if an Ethernet interface is ‚Äúvalid‚Äù; if it is valid, the EthernetTracker reports to the rest of the system that an interface is available, and the Settings app allows the interface to be configured. If an interface is not valid, then the EthernetTracker simply ignores it.How does the EthernetTracker determine if an interface is valid?private boolean isValidEthernetInterface(String iface) { return iface.matches(mIfaceMatch) || isValidTestInterface(iface); }With a regex, of course.Where does this regex come from?// Interface match regex. mIfaceMatch = mDeps.getInterfaceRegexFromResource(mContext);It comes from a method called getInterfaceRegexFromResource. Where does that method get it from?public String getInterfaceRegexFromResource(Context context) { final ConnectivityResources resources = new ConnectivityResources(context); return resources.get().getString( com.android.connectivity.resources.R.string.config_ethernet_iface_regex); }There‚Äôs actually a nice comment at the top of the file that explains this:/** * Tracks Ethernet interfaces and manages interface configurations. * * \u003cp\u003eInterfaces may have different {@link android.net.NetworkCapabilities}. This mapping is defined * in {@code config_ethernet_interfaces}. Notably, some interfaces could be marked as restricted by * not specifying {@link android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED} flag. * Interfaces could have associated {@link android.net.IpConfiguration}. * Ethernet Interfaces may be present at boot time or appear after boot (e.g., for Ethernet adapters * connected over USB). This class supports multiple interfaces. When an interface appears on the * system (or is present at boot time) this class will start tracking it and bring it up. Only * interfaces whose names match the {@code config_ethernet_iface_regex} regular expression are * tracked. * * \u003cp\u003eAll public or package private methods must be thread-safe unless stated otherwise. */Let‚Äôs go back to ripgrep to see if we can skip to finding out what config_ethernet_iface_regex is:$ rg config_ethernet_iface_regex ... frameworks/base/core/res/res/values/config.xml 410: \u003cstring translatable=\"false\" name=\"config_ethernet_iface_regex\"\u003eeth\\\\d\u003c/string\u003e ... packages/modules/Connectivity/service/ServiceConnectivityResources/res/values/config.xml 170: \u003cstring translatable=\"false\" name=\"config_ethernet_iface_regex\"\u003eeth\\\\d\u003c/string\u003e ...‚Ä¶and there it is. The default value of config_ethernet_iface_regex is eth\\d; in regex parlance, that means the literal string eth, followed by a digit.The kernel on the phone calls our CDC Ethernet gadget usb0. This doesn‚Äôt start with the string eth, so EthernetTracker ignores it. Unfortunately, this setting is not user-configurable, although you can hack it by rooting the phone.It really is that silly; an entire USB device class brought low by a bum regex.Is it a bug?I can‚Äôt tell if this is intentional or not; it feels like an oversight by Google, since even the newest GKI kernels apparently go out of their way to include support for EEM adapters, but because the interface name doesn‚Äôt match the regex, the kernel‚Äôs support for EEM adapters is unusable. This puts you in a rather perverse situation when shopping for USB Ethernet adapters to use with Android; instead of looking for devices that implement the CDC standards, you need to explicitly AVOID the standards-based devices and look for something that is supported with a vendor/chipset-specific driver.Thanks for playing!I hope you enjoyed going on this journey with me, or even better that I saved you from duplicating my efforts. Perhaps if I am feeling feisty, I will try to figure out how to submit a patch to Android to change that regex to (eth|usb)\\d in the next few weeks. If a real Android dev or someone at Google reads this and beats me to the punch, I owe you the beverage of your choice.",
  "image": "https://avatars.githubusercontent.com/jordemort",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\u003cp\u003eIf you just want the answer to the question posed in the title, click the TLDR below and then move on with your day. Otherwise, buckle in, we‚Äôre going debugging; this post is mostly about my thought process and techniques I used to arrive at the answer rather than the answer itself.\u003c/p\u003e\u003cdetails\u003e\u003csummary\u003e\u003cb\u003eTLDR:\u003c/b\u003e Just tell me why CDC Ethernet doesn\u0026#39;t work on Android\u003c/summary\u003e\u003cbr/\u003eAndroid\u0026#39;s EthernetTracker service only acknowledges interfaces that are named \u003ctt\u003eethX\u003c/tt\u003e; Linux\u0026#39;s CDC Ethernet drivers create interfaces that are named \u003ctt\u003eusbX\u003c/tt\u003e. There is no way to work around this, short of rooting the phone to change the value of \u003ctt\u003econfig_ethernet_iface_regex\u003c/tt\u003e.\u003c/details\u003e\u003cp\u003eAndroid contains support for USB ethernet adapters. There‚Äôs even menus for them!\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/connection-settings.jpg\" alt=\"Android connection settings, with \u0026#39;Ethernet\u0026#39; greyed out\" title=\"Android connection settings, with \u0026#39;Ethernet\u0026#39; greyed out\"/\u003e\u003c/p\u003e\u003cp\u003eThis means that if you very carefully select a USB Ethernet adapter that you know has a chipset compatible with your Android device, you can plug it in and these settings will spring to life. How do you know what chipsets are compatible with your phone?\u003c/p\u003e\u003cp\u003eHearsay!\u003c/p\u003e\u003cp\u003eI‚Äôm not entirely kidding. If the company that you bought your phone from sells a USB ethernet adapter as an accessory to it, you have a pretty good chance of that one working. Otherwise, it‚Äôs hit-or-miss; phone manufacturers rarely, if ever, publish lists of supported Ethernet adapters. The best you‚Äôre going to get is finding a forum post from someone that has the same phone as you saying that they bought a particular adapter that worked, and hoping you can find the same thing to buy.\u003c/p\u003e\u003cp\u003eOr is it?\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/i-know-this.jpg\" alt=\"This is a Linux system... I know this\" title=\"This is a Linux system... I know this\"/\u003e\u003c/p\u003e\u003cp\u003eAs you may know, if you dig deep beneath Android‚Äôs Googly carapace, you‚Äôll find a Linux kernel. To build the Linux kernel, you must first configure it. This configuration determines what features and hardware the resulting kernel will support. Thus, the list of Ethernet adapters supported by your phone will more-or-less correspond to those selected in the kernel configuration for your phone, although it‚Äôs possible (but unlikely) that your phone‚Äôs manufacturer doesn‚Äôt ship all of the drivers that they build, or that they build additional third-party drivers separately.\u003c/p\u003e\u003cp\u003eSo, in order to figure out what Ethernet adapters your phone supports, you‚Äôre going to want to find your phone‚Äôs kernel configuration. How do we do that?\u003c/p\u003e\u003ch3 id=\"first-enable-usb-debugging-and-install-adb\"\u003eFirst, enable USB debugging and install ADB\u003c/h3\u003e\u003cp\u003eIf you‚Äôd like to follow along with this blog post, you‚Äôre going to need enable USB debugging and to install ADB (Android Debug Bridge) ‚Äî this is a command-line tool that is used by developers to interact with Android devices. In this post, we will be using it to run shell commands on a phone.\u003c/p\u003e\u003cp\u003eThere‚Äôs good documentation elsewhere on how to do these things so I‚Äôm not going to waste time by rewriting it poorly. Instead, have some links:\u003c/p\u003e\u003col\u003e\u003cli\u003eFirst, \u003ca href=\"https://developer.android.com/studio/debug/dev-options#Enable-debugging\"\u003eenable USB debugging\u003c/a\u003e on your phone\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.xda-developers.com/install-adb-windows-macos-linux/\"\u003eInstall ADB\u003c/a\u003e on your computer\u003c/li\u003e\u003cli\u003eRun \u003ccode\u003eadb shell\u003c/code\u003e, which will give you a shell prompt on the phone.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/im-in.jpg\" alt=\"I\u0026#39;m in\" title=\"I\u0026#39;m in\"/\u003e\u003c/p\u003e\u003cp\u003eCongratulations, you can now run commands on your phone. Type \u003ccode\u003eexit\u003c/code\u003e and press enter when you‚Äôre ready to exit the ADB shell.\u003c/p\u003e\u003cp\u003eNext, we need to switch things up so that ADB connects to the phone over the network, instead of via USB. We need to do this because we‚Äôre going to try plugging some network adapters into the phone‚Äôs USB port, so we can‚Äôt also use the port for debugging.\u003c/p\u003e\u003cp\u003eWith your phone connected to your computer via USB:\u003c/p\u003e\u003col\u003e\u003cli\u003eConnect your phone to the same network as your computer via wifi\u003c/li\u003e\u003cli\u003eFigure out your phone‚Äôs IP address - you can do this by digging around the Settings app, or you can try \u003ccode\u003eadb shell ifconfig wlan0\u003c/code\u003e\u003c/li\u003e\u003cli\u003eWith the phone still connected via USB, run \u003ccode\u003eadb tcpip 5555\u003c/code\u003e\u003c/li\u003e\u003cli\u003eDisconnect the USB cable from the phone\u003c/li\u003e\u003cli\u003eReconnect to the phone by running \u003ccode\u003eadb connect YOUR_PHONE_IP:5555\u003c/code\u003e (replacing YOUR_PHONE_IP with the IP address from the phone)\u003c/li\u003e\u003cli\u003eTry \u003ccode\u003eadb shell\u003c/code\u003e to make sure it still works\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eOnce you have ADB working over the network, you can proceed with trying to figure out what version of the kernel your Android device is running.\u003c/p\u003e\u003ch3 id=\"if-you-have-a-newer-phone\"\u003eIf you have a newer phone‚Ä¶\u003c/h3\u003e\u003cp\u003eThese days, Google publishes an \u003ca href=\"https://source.android.com/docs/core/architecture/kernel/android-common\"\u003eAndroid Common Kernel\u003c/a\u003e, which downstream phone manufacturers are required to derive their kernels from. The source to this kernel is hosted in a \u003ca href=\"https://android.googlesource.com/kernel/common/\"\u003eGit repository at googlesource.com\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIf your phone shipped with Android 11 or later, you have something called a \u003ca href=\"https://source.android.com/docs/core/architecture/kernel/generic-kernel-image\"\u003eGKI kernel\u003c/a\u003e - in this case, Google builds the kernel and the phone manufacturer puts all of their model-specific secret sauce into kernel modules. In this case, you can find the configuration that Google is using by navigating to the appropriate branch of the kernel repository, and looking at the file \u003ccode\u003earch/$ARCH/configs/gki_defconfig\u003c/code\u003e, where \u003ccode\u003e$ARCH\u003c/code\u003e is the processor architecture of your phone. For example, if your phone has a 64-bit ARM processor (and it almost certainly does) then you will find this configuration at \u003ca href=\"https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/arch/arm64/configs/gki_defconfig\"\u003e\u003ccode\u003earch/arm64/configs/gki_defconfig\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"how-do-i-find-out-for-sure-what-kernel-version-and-processor-architecture-my-phone-has\"\u003eHow do I find out for sure what kernel version and processor architecture my phone has?\u003c/h3\u003e\u003cp\u003eNow that we have the ability to run shell commands on the phone, we can turn to good old \u003ca href=\"https://man7.org/linux/man-pages/man2/uname.2.html\"\u003e\u003ccode\u003euname\u003c/code\u003e\u003c/a\u003e to discover the kernel version and architecture that‚Äôs currently running.\u003c/p\u003e\u003col\u003e\u003cli\u003eGo back and \u003ca href=\"#first-enable-usb-debugging-and-install-adb\"\u003eenable USB debugging and install ADB\u003c/a\u003e, if you haven‚Äôt arleady\u003c/li\u003e\u003cli\u003eRun \u003ccode\u003euname -a\u003c/code\u003e on the phone, either by running \u003ccode\u003eadb shell\u003c/code\u003e and then running \u003ccode\u003euname -a\u003c/code\u003e, or all in one go by running \u003ccode\u003eadb shell uname -a\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eYou should get output something like this:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eLinux localhost 4.19.113-26203352 #1 SMP PREEMPT Tue Apr 18 16:05:51 KST 2023 aarch64 Toybox\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou‚Äôll the kernel version in the third field and the architecture in the second-to-last; you‚Äôll have to make an educated guess about which branch or tag in Google‚Äôs kernel repository corresponds to the one running on your phone.\u003c/p\u003e\u003ch3 id=\"what-if-i-have-an-older-phone\"\u003eWhat if I have an older phone?\u003c/h3\u003e\u003cp\u003eIf you have an older phone, then you‚Äôre in the same boat as me; I have an iPhone as a daily driver, but I keep a Samsung Galaxy s20 around as an Android testbed. Unfortunately, the s20 shipped with Android 10, which is the version just before all of this standardized kernel stuff from Google became required. Even though the s20 has since been upgraded to Android 13, Google doesn‚Äôt require phone manufacturers to update the kernel along with the Android version, and so Samsung didn‚Äôt; it still runs a kernel based on Linux 4.19.\u003c/p\u003e\u003cp\u003eIn this case, you need to get the kernel configuration from your phone manufacturer, so you‚Äôd better hope they‚Äôre actually doing regular source releases. Samsung does do this; you can find sources for their phones at \u003ca href=\"https://opensource.samsung.com/uploadList?menuItem=mobile\u0026amp;classification1=mobile_phone\"\u003eopensource.samsung.com\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eOnce you have the sources for your device, you‚Äôre going to have to dig around a bit to figure out what kernel config. The sources I obtained for my phone from Samsung included a \u003ccode\u003eKernel.tar.gz\u003c/code\u003e; inside of this archive was a Linux kernel source tree, along with a few additions. One of those additions was a shell script called \u003ccode\u003ebuild_kernel.sh\u003c/code\u003e, which goes a little something like this:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#!/bin/bash\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eARCH\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003earm64\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003emkdir\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eBUILD_CROSS_COMPILE\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/toolchain/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eKERNEL_LLVM_BIN\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/toolchain/llvm-arm-toolchain-ship/10.0/bin/clang\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCLANG_TRIPLE\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eaarch64-linux-gnu-\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eKERNEL_MAKE_ENV\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;DTC_EXT=$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/tools/dtc CONFIG_BUILD_ARM64_DT_OVERLAY=y\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-j8\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-C\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eO=$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/out\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e$KERNEL_MAKE_ENV\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eARCH=arm64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eCROSS_COMPILE=\u003c/span\u003e\u003cspan\u003e$BUILD_CROSS_COMPILE\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eREAL_CC=\u003c/span\u003e\u003cspan\u003e$KERNEL_LLVM_BIN\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eCLANG_TRIPLE=\u003c/span\u003e\u003cspan\u003e$CLANG_TRIPLE\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evendor/x1q_usa_singlex_defconfig\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003emake\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-j8\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e-C\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eO=$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/out\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e$KERNEL_MAKE_ENV\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eARCH=arm64\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eCROSS_COMPILE=\u003c/span\u003e\u003cspan\u003e$BUILD_CROSS_COMPILE\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eREAL_CC=\u003c/span\u003e\u003cspan\u003e$KERNEL_LLVM_BIN\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eCLANG_TRIPLE=\u003c/span\u003e\u003cspan\u003e$CLANG_TRIPLE\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ecp\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eout/arch/arm64/boot/Image\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003epwd\u003c/span\u003e\u003cspan\u003e)/arch/arm64/boot/Image\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you squint at this long enough, you‚Äôll spot a reference to something that looks like a kernel config: \u003ccode\u003evendor/x1q_usa_singlex_defconfig\u003c/code\u003e. There isn‚Äôt a subdirectory called \u003ccode\u003evendor\u003c/code\u003e in the root of the archive, so I used \u003ccode\u003efind\u003c/code\u003e to figure out exactly where the file lives:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ find . -name x1q_usa_singlex_defconfig\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e./arch/arm64/configs/vendor/x1q_usa_singlex_defconfig\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAha, there it is, deeply nested in a subdirectory.\u003c/p\u003e\u003ch3 id=\"finding-the-kernel-config-sounds-hard-is-there-an-easier-way\"\u003eFinding the kernel config sounds hard, is there an easier way?\u003c/h3\u003e\u003cp\u003eThere might be, if you‚Äôre lucky! Give this a shot:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell zcat /proc/config.gz\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you‚Äôre lucky, and your phone manufacturer has enabled the relevant kernel option, then a compressed copy of the configuration that your kernel was compiled with is available at \u003ccode\u003e/proc/config.gz\u003c/code\u003e. If this is the case, you‚Äôll have a large amount of output streaming to your terminal. You probably want to redirect it somewhere so you can peruse it at your leisure:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell zcat /proc/config.gz \u0026gt; my_kernel_config\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you‚Äôre unlucky, you‚Äôll see something like this:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003ezcat: /proc/config.gz: No such file or directory\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this case, there is no easy way out; you‚Äôll have to refer to the sources your phone‚Äôs kernel was built from.\u003c/p\u003e\u003ch3 id=\"what-does-a-kernel-configuration-look-like\"\u003eWhat does a kernel configuration look like?\u003c/h3\u003e\u003cp\u003eIn case you‚Äôre interested, here is the kernel configuration for my Galaxy s20: \u003ca href=\"https://gist.github.com/jordemort/bb9f15028dce9854f9bfd4e750522e48\"\u003e\u003ccode\u003ex1q_usa_singlex_defconfig\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eYour kernel configuration should look very similar to this, but not identical, unless you have the same phone that I do.\u003c/p\u003e\u003ch3 id=\"ok-i-have-the-kernel-configuration-for-my-phone-what-now\"\u003eOK, I have the kernel configuration for my phone, what now?\u003c/h3\u003e\u003cp\u003eFor the purpose of determining which USB Ethernet adapters the kernel supports, most of the configuration variables that we are interested will start with \u003ccode\u003eUSB_NET\u003c/code\u003e, so just \u003ccode\u003egrep\u003c/code\u003e the kernel configuration for that string:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ grep USB_NET my_kernel_config\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_DRIVERS=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_AX8817X=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_AX88179_178A=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDCETHER=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDC_EEM=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDC_NCM=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e... and so on ...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLook for a \u003ccode\u003eCONFIG_USB_NET_something\u003c/code\u003e that looks like it relates to the chipset of the adapter you want to use. The best news is if it is set to \u003ccode\u003ey\u003c/code\u003e; that means the driver is built-in to your kernel and that your phone‚Äôs kernel definitely supports that chipset. If it‚Äôs set to \u003ccode\u003em\u003c/code\u003e, that‚Äôs still \u003cem\u003eprobably\u003c/em\u003e good news; that means that the driver was compiled as a module when your kernel was built, and that the module is likely loadable on your phone unless your phone‚Äôs manufacturer specifically left it out. If you see \u003ccode\u003eis not set\u003c/code\u003e, then that is the worst news; the driver was neither built-in to your kernel, nor was it compiled as a module, so it‚Äôs likely not available for you to use.\u003c/p\u003e\u003cp\u003eIf you‚Äôre having trouble figuring out which configuration items correspond to which chipsets, have a look at \u003ca href=\"https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/net/usb/Kconfig\"\u003e\u003ccode\u003edrivers/net/usb/Kconfig\u003c/code\u003e\u003c/a\u003e in your kernel tree. This file will contain extended descriptions of each configuration item.\u003c/p\u003e\u003cp\u003eUnfortunately, to figure out which chipset a particular adapter uses, you‚Äôre mostly back to hearsay; few manufacturers of USB Ethernet adapters explicitly advertise which chipset they use.\u003c/p\u003e\u003ch3 id=\"so-whats-this-about-cdc-ethernet-and-why-should-i-care\"\u003eSo what‚Äôs this about CDC Ethernet and why should I care?\u003c/h3\u003e\u003cp\u003eCDC stands for \u003ca href=\"https://en.wikipedia.org/wiki/USB_communications_device_class\"\u003eCommunications Device Class\u003c/a\u003e. This is a set of interrelated standards that manufacturers of USB devices can follow; among them are a trio of standards called EEM (Ethernet Emulation Model), ECM (Ethernet Control Model), and NCM (Network Control Model) that can be used to build USB Ethernet adapters. Most of the difference between these three standards is a matter of complexity; EEM is the simplest to implement and is easy to support on underpowered devices, but may not result in the best performance. ECM is more complex to implement for both the USB host and the device, but promises better performance than EEM; NCM is a successor to ECM that promises even higher speeds. Many devices implement more than one of these protocols, and leave it up to the host operating system to communicate with the device using the one that it prefers.\u003c/p\u003e\u003cp\u003eThe point of these standards is that, assuming manufacturers follow them, operating systems can provide a single common driver that works with a variety of drivers. You generally don‚Äôt need special drivers for USB keyboards or mice because of the \u003ca href=\"https://en.wikipedia.org/wiki/USB_human_interface_device_class\"\u003eUSB HID\u003c/a\u003e standard; the USB CDC standard attempts to accomplish the same for USB networking devices.\u003c/p\u003e\u003cp\u003eOne particularly fun thing is that Linux implements both the host and the device side of the CDC Ethernet standards. That means that if you have hardware with a \u003ca href=\"https://en.wikipedia.org/wiki/USB_On-The-Go\"\u003eUSB OTG\u003c/a\u003e port, which is common on the Raspberry Pi and other small ARM devices, you can tell the kernel to use that port to \u003ca href=\"https://learn.adafruit.com/turning-your-raspberry-pi-zero-into-a-usb-gadget/ethernet-gadget\"\u003epretend to be an Ethernet adapter\u003c/a\u003e. This creates a USB network interface on the host that is directly connected to an interface on the guest; this lets you build cool things like embedded routers, firewalls, and VPN gateways that look like just another Ethernet adapter to the host.\u003c/p\u003e\u003cp\u003eLinux, as well as Windows and macOS (but not iOS) include drivers for CDC Ethernet devices. Unfortunately, none of this works on Android devices, despite Android being based on Linux. Why is Android like this?\u003c/p\u003e\u003ch3 id=\"based-on-the-kernel-configuration-android-appears-to-support-cdc\"\u003eBased on the kernel configuration, Android \u003cem\u003eappears\u003c/em\u003e to support CDC\u003c/h3\u003e\u003cp\u003eLet‚Äôs have another look at our kernel config, and grep for USB_NET_CDC:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ grep USB_NET_CDC my_kernel_config\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDCETHER=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDC_EEM=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eCONFIG_USB_NET_CDC_NCM=y\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e... and so on ...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we can see that Samsung has built support for all 3 CDC Ethernet standards into their kernel (\u003ccode\u003eCONFIG_USB_NET_CDCETHER\u003c/code\u003e corresponds to ECM). Google‚Äôs GKI kernels are somewhat less generous and appear to leave out ECM and NCM, but still include support for EEM as a module.\u003c/p\u003e\u003cp\u003eI‚Äôve got a device with an OTG port that I‚Äôve configured as an Ethernet gadget. It works when I plug it into my Mac. It works when I plug it into my Ubuntu desktop. It even works when I plug it into my Windows game machine (actually the same computer as the Ubuntu desktop, booted off of a different drive \u003cspan aria-label=\"grinning face with smiling eyes\" role=\"img\"\u003eüòÅ\u003c/span\u003e). It doesn‚Äôt work at all when I plug it into my Galaxy s20. The Ethernet settings are still greyed out:\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/grey-ethernet.jpg\" alt=\"\u0026#39;Ethernet\u0026#39; greyed out\" title=\"\u0026#39;Ethernet\u0026#39; greyed out\"/\u003e\u003c/p\u003e\u003cp\u003eLet‚Äôs grab a shell on the phone and dig in a bit.\u003c/p\u003e\u003cp\u003eThe Linux kernel exposes information about itself in a pseudo-filesystem called \u003ca href=\"https://en.wikipedia.org/wiki/Sysfs\"\u003esysfs\u003c/a\u003e - this looks like a directory tree full of files, but reading the files actually gets you information about the current state of the kernel.\u003c/p\u003e\u003cp\u003eAmong other things, sysfs contains a directory named \u003ccode\u003e/sys/class/net\u003c/code\u003e, which contains one entry for every network interface that the kernel is aware of. Let‚Äôs connect our Ethernet gadget to the phone and see if anything shows up there:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell ls /sys/class/net\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e... lots of output ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ewlan0\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCould \u003ccode\u003eusb0\u003c/code\u003e be the gadget? Let‚Äôs use \u003ccode\u003eifconfig\u003c/code\u003e to check it out:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell ifconfig usb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0      Link encap:UNSPEC    Driver cdc_eem\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          BROADCAST MULTICAST  MTU:1500  Metric:1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          collisions:0 txqueuelen:1000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX bytes:0 TX bytes:0\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat certainly looks like our gadget. Too bad the interface is down. Unfortunately, the Ethernet settings on the phone are still greyed out:\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/grey-ethernet.jpg\" alt=\"\u0026#39;Ethernet\u0026#39; greyed out\" title=\"\u0026#39;Ethernet\u0026#39; greyed out\"/\u003e\u003c/p\u003e\u003cp\u003eLet‚Äôs unplug the gadget and make sure \u003ccode\u003eusb0\u003c/code\u003e goes away when we do:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell ls /sys/class/net | grep usb\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e$ # no output\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYep, it‚Äôs gone.\u003c/p\u003e\u003cp\u003eIt looks like we‚Äôre using EEM mode. In addition to the \u003ccode\u003eg_ether\u003c/code\u003e module, Linux also includes a thing called \u003ca href=\"https://docs.kernel.org/usb/gadget_configfs.html\"\u003econfigfs\u003c/a\u003e that can be used to create custom gadgets. Let‚Äôs try one that only supports ECM and see if that works:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell ls /sys/class/net | grep usb\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e$ adb shell ifconfig usb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0      Link encap:UNSPEC    Driver cdc_ether\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          BROADCAST MULTICAST  MTU:1500  Metric:1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          collisions:0 txqueuelen:1000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX bytes:0 TX bytes:0\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/grey-ethernet.jpg\" alt=\"\u0026#39;Ethernet\u0026#39; greyed out\" title=\"\u0026#39;Ethernet\u0026#39; greyed out\"/\u003e\u003c/p\u003e\u003cp\u003eIt‚Äôs still detected, but it‚Äôs still down. Will NCM fare any better?\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ adb shell ls /sys/class/net | grep usb\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e$ adb shell ifconfig usb0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eusb0      Link encap:UNSPEC    Driver cdc_ncm\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          BROADCAST MULTICAST  MTU:1500  Metric:1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          collisions:0 txqueuelen:1000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          RX bytes:0 TX bytes:0\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://jordemort.dev/images/android-cdc/grey-ethernet.jpg\" alt=\"\u0026#39;Ethernet\u0026#39; greyed out\" title=\"\u0026#39;Ethernet\u0026#39; greyed out\"/\u003e\u003c/p\u003e\u003cp\u003eNo, it will not.\u003c/p\u003e\u003ch3 id=\"so-why-doesnt-cdc-work-on-android\"\u003eSo why doesn‚Äôt CDC work on Android?\u003c/h3\u003e\u003cp\u003eAt this point, we‚Äôve more-or-less established that everything is fine on the kernel level. I‚Äôm pretty sure that if I wanted to, I could root this phone, manually configure the interface with \u003ccode\u003eifconfig\u003c/code\u003e, and it would pass traffic just fine. That means the problem must be somewhere in the stack of software above the kernel.\u003c/p\u003e\u003cp\u003eIf this was a regular Linux system, this is the point where I‚Äôd start poking at systemd-networkd, or NetworkManager, or ifupdown, depending on the particulars. This is not a regular Linux system, though; it‚Äôs an Android device, and none of that stuff exists here. What do I know about how Android configures network interfaces?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNOTHING.\u003c/strong\u003e I know nothing about how Android configures network interfaces. How do we figure this out?\u003c/p\u003e\u003cp\u003eWell, Android is at least sort of open source; many of the good bits are closed behind the veil of something called ‚ÄúGoogle Play Services‚Äù but maybe there‚Äôs enough in the sources that are released to figure this out.\u003c/p\u003e\u003cp\u003eTo play along with this bit, you‚Äôll need to \u003ca href=\"https://source.android.com/docs/setup/download/downloading\"\u003edownload the source to Android\u003c/a\u003e. This is a whole process on its own, so I‚Äôll leave you to Google‚Äôs documentation for this, except to note that you‚Äôll need a special tool called \u003ccode\u003erepo\u003c/code\u003e. This seems to be meant to make it easier to download sources from multiple Git repositories at once; sometimes it feels like I‚Äôm the only person that actually likes \u003ca href=\"https://git-scm.com/book/en/v2/Git-Tools-Submodules\"\u003eGit submodules\u003c/a\u003e. There are a lot of sources to download, so start this process and then go knock off a few shrines in Zelda while it wraps up.\u003c/p\u003e\u003cp\u003eI figure that searching for the string \u003ccode\u003eEthernet\u003c/code\u003e is probably a good starting point. Because there is so much source to go through, I‚Äôm going to skip vanilla \u003ccode\u003egrep\u003c/code\u003e this time and enlist the aid of \u003ca href=\"https://github.com/BurntSushi/ripgrep\"\u003eripgrep\u003c/a\u003e. There‚Äôs a lot of configuration files and other clutter in the Android sources, as well as most of a Linux distro, but I know that any code that we‚Äôre going to care about here is likely written in Java, so I‚Äôm going to restrict \u003ccode\u003erg\u003c/code\u003e to searching in Java files:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ rg -t java Ethernet\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e... SO MUCH OUTPUT ...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point, there‚Äôs not much else to do but look at the files where we‚Äôve got hits and try to figure out what part of the code we can blame for our problem. Fortunately for you, I‚Äôve saved you the trouble. After reading a bunch of Android code, I‚Äôm certain that our culprit is \u003ca href=\"https://android.googlesource.com/platform/packages/modules/Connectivity/+/refs/heads/master/service-t/src/com/android/server/ethernet/EthernetTracker.java\"\u003e\u003ccode\u003eEthernetTracker.java\u003c/code\u003e\u003c/a\u003e. This appears to be a service that listens on a \u003ca href=\"https://docs.kernel.org/userspace-api/netlink/intro.html\"\u003eNetlink\u003c/a\u003e socket and receives notifications from the kernel about new network interfaces. The EthernetTracker contains a method that determines if an Ethernet interface is ‚Äúvalid‚Äù; if it is valid, the EthernetTracker reports to the rest of the system that an interface is available, and the Settings app allows the interface to be configured. If an interface is not valid, then the EthernetTracker simply ignores it.\u003c/p\u003e\u003cp\u003eHow does the EthernetTracker determine if an interface is valid?\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eprivate\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eboolean\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eisValidEthernetInterface\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e iface) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eiface\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ematches\u003c/span\u003e\u003cspan\u003e(mIfaceMatch) || \u003c/span\u003e\u003cspan\u003eisValidTestInterface\u003c/span\u003e\u003cspan\u003e(iface);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith a regex, of course.\u003c/p\u003e\u003cp\u003eWhere does this regex come from?\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e// Interface match regex.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003emIfaceMatch = \u003c/span\u003e\u003cspan\u003emDeps\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetInterfaceRegexFromResource\u003c/span\u003e\u003cspan\u003e(mContext);\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt comes from a method called \u003ccode\u003egetInterfaceRegexFromResource\u003c/code\u003e. Where does that method get it from?\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egetInterfaceRegexFromResource\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eContext\u003c/span\u003e\u003cspan\u003e context) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efinal\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eConnectivityResources\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eresources\u003c/span\u003e\u003cspan\u003e = \u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eConnectivityResources\u003c/span\u003e\u003cspan\u003e(context);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eresources\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003egetString\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ecom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eandroid\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econnectivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresources\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eR\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estring\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econfig_ethernet_iface_regex\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere‚Äôs actually a nice comment at the top of the file that explains this:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e/**\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * Tracks Ethernet interfaces and manages interface configurations.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e *\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * \u0026lt;p\u0026gt;Interfaces may have different {@link android.net.NetworkCapabilities}. This mapping is defined\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * in {@code config_ethernet_interfaces}. Notably, some interfaces could be marked as restricted by\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * not specifying {@link android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED} flag.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * Interfaces could have associated {@link android.net.IpConfiguration}.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * Ethernet Interfaces may be present at boot time or appear after boot (e.g., for Ethernet adapters\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * connected over USB). This class supports multiple interfaces. When an interface appears on the\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * system (or is present at boot time) this class will start tracking it and bring it up. Only\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * interfaces whose names match the {@code config_ethernet_iface_regex} regular expression are\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * tracked.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e *\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e * \u0026lt;p\u0026gt;All public or package private methods must be thread-safe unless stated otherwise.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e */\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet‚Äôs go back to ripgrep to see if we can skip to finding out what \u003ccode\u003econfig_ethernet_iface_regex\u003c/code\u003e is:\u003c/p\u003e\u003cpre is:raw=\"\" tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ rg config_ethernet_iface_regex\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eframeworks/base/core/res/res/values/config.xml\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e410:    \u0026lt;string translatable=\u0026#34;false\u0026#34; name=\u0026#34;config_ethernet_iface_regex\u0026#34;\u0026gt;eth\\\\d\u0026lt;/string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003epackages/modules/Connectivity/service/ServiceConnectivityResources/res/values/config.xml\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e170:    \u0026lt;string translatable=\u0026#34;false\u0026#34; name=\u0026#34;config_ethernet_iface_regex\u0026#34;\u0026gt;eth\\\\d\u0026lt;/string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e‚Ä¶and there it is. The default value of \u003ccode\u003econfig_ethernet_iface_regex\u003c/code\u003e is \u003ccode\u003eeth\\d\u003c/code\u003e; in regex parlance, that means the literal string \u003ccode\u003eeth\u003c/code\u003e, followed by a digit.\u003c/p\u003e\u003cp\u003eThe kernel on the phone calls our CDC Ethernet gadget \u003ccode\u003eusb0\u003c/code\u003e. This doesn‚Äôt start with the string \u003ccode\u003eeth\u003c/code\u003e, so EthernetTracker ignores it. Unfortunately, this setting is not user-configurable, although you can hack it by rooting the phone.\u003c/p\u003e\u003cp\u003eIt really is that silly; an entire USB device class brought low by a bum regex.\u003c/p\u003e\u003ch3 id=\"is-it-a-bug\"\u003eIs it a bug?\u003c/h3\u003e\u003cp\u003eI can‚Äôt tell if this is intentional or not; it feels like an oversight by Google, since even the newest GKI kernels apparently go out of their way to include support for EEM adapters, but because the interface name doesn‚Äôt match the regex, the kernel‚Äôs support for EEM adapters is unusable. This puts you in a rather perverse situation when shopping for USB Ethernet adapters to use with Android; instead of looking for devices that implement the CDC standards, you need to explicitly \u003cem\u003eAVOID\u003c/em\u003e the standards-based devices and look for something that is supported with a vendor/chipset-specific driver.\u003c/p\u003e\u003ch3 id=\"thanks-for-playing\"\u003eThanks for playing!\u003c/h3\u003e\u003cp\u003eI hope you enjoyed going on this journey with me, or even better that I saved you from duplicating my efforts. Perhaps if I am feeling feisty, I will try to figure out how to submit a patch to Android to change that regex to \u003ccode\u003e(eth|usb)\\d\u003c/code\u003e in the next few weeks. If a real Android dev or someone at Google reads this and beats me to the punch, I owe you the beverage of your choice.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": null,
  "modifiedTime": null
}
