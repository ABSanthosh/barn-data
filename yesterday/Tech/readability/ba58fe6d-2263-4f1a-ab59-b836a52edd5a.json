{
  "id": "ba58fe6d-2263-4f1a-ab59-b836a52edd5a",
  "title": "Dumping Memory to Bypass BitLocker on Windows 11",
  "link": "https://noinitrd.github.io/Memory-Dump-UEFI/",
  "description": "Comments",
  "author": "",
  "published": "Mon, 30 Dec 2024 18:43:01 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 6944,
  "excerpt": "A UEFI application for dumping the contents of RAM.",
  "siteName": "Dumping Memory to Bypass BitLocker on Windows 11",
  "favicon": "",
  "text": "In this article I will demonstrate how to bypass BitLocker encryption on Windows 11 (version 24H2). This was accomplished by extracting full volume encryption keys (FVEK) from memory using my tool Memory-Dump-UEFI. Background If an attacker has physical access to the device, they can potentially get access by apruptly restarting the computer and dumping RAM from recently running instances of Windows. The captured memory can be analyzed to locate sensitive information like FVEK keys. This technique is not foolproof as the contents of RAM will rapidly degrade when power is cut off. There are several techniques to mitigate this memory degradation, including cooling the RAM physically or using external power sources to maintain power delivery. In the case of this demo, I shorted the reset pins on the device’s motherboard, which causes the system to abruptly restart without losing power. Another potential issue is secure boot, which is a security standard that restricts what is allowed to run when a device starts up. This protection has its own limitations, and has been bypassed using shims or a variety of other means that are outside the scope of this demo. Step 1: Create a Bootable USB Device For this step you must obtain a USB storage device that is larger than however much RAM is on the target system. I have included a script called flashimage.sh to simplify this step. Follow the steps detailed here to create and use the bootable application. Step 2: Abruptly Restart the Target System This can be done in a variety of ways but the goal is to minimize how much time the computer is completely powered off. In my experience I have had the most success restarting the system while Windows is loading but before the login screen has appeared, at least in the case of finding FVEK keys. Step 3: Boot from the USB Device Immediately boot to Memory-Dump-UEFI from the USB device. You will arrive at the UEFI shell, where you can locate and execute app.efi. There are more details on how to do this in the README for the application. The amount of time it will take depends on the amount of RAM being dumped and the speed of the USB device. I recommend leaving any other USB storage devices unplugged during this step to avoid the program accidentally writing to the wrong drive. Above is an example of what it should look like when you make it to the shell. The memory dump will start generating dump files until it runs out of memory. After its completed, feel free to shut the computer off like normal. Step 4: Analyzing the Dumps Setup There will probably be several dumps produced by the application. This is due to the 4GB limit on file size imposed by the FAT32 filesystem. The filesystem has to be FAT32 meet UEFI specification. For convenience purposes I have included a script in the tools directory called concatDumps.py that can combine several dumps into one in chronological order. The content of the dump will consist of whatever raw data was inside memory at the time, so I recommend a tool like xxd to read it more easily. To help with searching the dumps I included a script called searchMem.py that allows you to search for a hex pattern within the dump. It will find the offset of instances of that hex pattern, which you can then jump to by using xxd -s \u003coffset\u003e \u003cdump\u003e. Pool Tags Pool tags are 4 character long identifiers that indicate where Windows kernel memory pools are. These pools are allocated by the Windows kernel and are great places to look for sensitive information. There are a large number of these pool tags, and I included a text file called pooltag.txt which contains a list of the pool tags with details about their respective purposes. Before continuing I’d like to give Microsoft a round of applause for being kind enough to plainly mark where cryptographic keys show up in memory. Back on Windows 7, key recovery was as simple as locating the FVEc pool tag, which corresponds to cryptographic allocations under fvevol.sys. On Windows 8.1 and 10 the key could be found in the memory pool tagged by Cngb which corresponds to the ksecdd.sys module. Throughout my study of the Windows 11 memory dump, I couldn’t locate the key in either of those places, but I did find it in two other locations. FVEK Key Recovery The first place I located the FVEK key was under the dFVE pool tag, which indicates memory allocated by dumpfve.sys, which pertains to the full volume encryption crash dump filter for bitlocker drive encryption. The pool tag is underlined in blue while the FVEK key is highlighted in red. This was the easiest and most consistent location I found the key, and it is also prefaced by 0x0480 which indicates the type of encryption being used, which in my case is XTS-AES-128. The second location is under the None tag, which pertains to calls to the ExAllocatePool routine. This time the first half of the key can be seen two times and the second half once. Next Steps It’s important to note that you need to preface whatever key you obtain with what algorithm is being used. That means if your key is: b2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b You need to add 0x8004 (or whatever the algorithm used was) to the beginning of the key in little endian format like this: 0480b2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b Next, you need to take that hex and dump it into a file, which can be done like: echo \"0480b2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b\" | xxd -r -p \u003e output.fvek I highly recommend using the dislocker suite of tools to figure out which algorithm/value you need and to ultimately unlock the drive. If you did everything correctly you can use output.fvek to unlock the bitlocker protected partition and access any data on the volume. Final Notes The best possible way to understand how Microsoft implemented bitlocker is to do kernel level debugging using windbg. This can be done fairly easily using virtual machines or a crossed over USB 3.0 A/A cable. The reason I was able to find the key in the first place is by stepping through the Windows boot process and watching bitlocker in action. Microsoft makes an effort to destroy keys using functions like SymCryptSessionDestroy but they fail to destroy every key, as evident by its presence on the heap. References https://tribalchicken.net/recovering-bitlocker-keys-on-windows-8-1-and-10/ https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc https://github.com/Aorimn/dislocker https://github.com/microsoft/SymCrypt https://github.com/libyal/libbde https://github.com/zodiacon/PoolMonX/blob/master/res/pooltag.txt https://techcommunity.microsoft.com/blog/askperf/an-introduction-to-pool-tags/372983 If you have any questions you can reach me at the email below, thank you for reading! NoInitRD@gmail.com",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection id=\"main_content\"\u003e\n        \n\n\u003cp\u003eIn this article I will demonstrate how to bypass BitLocker encryption on Windows 11 (version 24H2).\nThis was accomplished by extracting full volume encryption keys (FVEK) from memory using my tool Memory-Dump-UEFI.\u003c/p\u003e\n\n\u003ch2 id=\"background\"\u003eBackground\u003c/h2\u003e\n\n\u003cp\u003eIf an attacker has physical access to the device, they can potentially get access by \napruptly restarting the computer and dumping RAM from recently running instances of Windows. The captured\nmemory can be analyzed to locate sensitive information like FVEK keys.\nThis technique is not foolproof as the contents of RAM will rapidly degrade when power is cut off.\u003c/p\u003e\n\n\u003cp\u003e\n\t\u003cimg src=\"https://noinitrd.github.io/Memory-Dump-UEFI/images/image0.png\" width=\"600\"/\u003e\n\u003c/p\u003e\n\n\u003cp\u003eThere are several techniques to mitigate this memory degradation, including cooling the RAM physically or using\nexternal power sources to maintain power delivery. In the case of this demo, I shorted the reset pins on the device’s\nmotherboard, which causes the system to abruptly restart without losing power.\u003c/p\u003e\n\n\u003cp\u003eAnother potential issue is secure boot, which is a security standard that restricts what is allowed to run when\na device starts up. This protection has its own limitations, and has been bypassed using shims or a variety \nof other means that are outside the scope of this demo.\u003c/p\u003e\n\n\u003ch2 id=\"step-1-create-a-bootable-usb-device\"\u003eStep 1: Create a Bootable USB Device\u003c/h2\u003e\n\n\u003cp\u003eFor this step you must obtain a USB storage device that is larger than however much RAM is on\nthe target system. I have included a script called \u003ccode\u003eflashimage.sh\u003c/code\u003e to simplify this step.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/NoInitRD/MemoryDumpUEFI\"\u003eFollow the steps detailed here to create and use the bootable application.\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"step-2-abruptly-restart-the-target-system\"\u003eStep 2: Abruptly Restart the Target System\u003c/h2\u003e\n\n\u003cp\u003eThis can be done in a variety of ways but the goal is to minimize how much time the computer is completely powered off.\nIn my experience I have had the most success restarting the system while Windows is loading but before the login\nscreen has appeared, at least in the case of finding FVEK keys.\u003c/p\u003e\n\n\u003ch2 id=\"step-3-boot-from-the-usb-device\"\u003eStep 3: Boot from the USB Device\u003c/h2\u003e\n\n\u003cp\u003eImmediately boot to Memory-Dump-UEFI from the USB device. You will arrive at the UEFI shell, where you can locate\nand execute \u003ccode\u003eapp.efi\u003c/code\u003e. There are more details on how to do this in the \u003ca href=\"https://github.com/NoInitRD/Memory-Dump-UEFI/blob/d04feef409313f2ec3d314cb4d642e2ee0da9930/README.md\"\u003eREADME\u003c/a\u003e\nfor the application. The amount of time it will take depends on the amount of RAM being dumped and the speed of\nthe USB device. I recommend leaving any other USB storage devices unplugged during this step to avoid the \nprogram accidentally writing to the wrong drive.\u003c/p\u003e\n\n\u003cp\u003e\n\t\u003cimg src=\"https://noinitrd.github.io/Memory-Dump-UEFI/images/image1.png\"/\u003e\n\u003c/p\u003e\n\n\u003cp\u003eAbove is an example of what it should look like when you make it to the shell. The memory dump will start generating\ndump files until it runs out of memory. After its completed, feel free to shut the computer off like normal.\u003c/p\u003e\n\n\u003ch2 id=\"step-4-analyzing-the-dumps\"\u003eStep 4: Analyzing the Dumps\u003c/h2\u003e\n\n\u003ch3 id=\"setup\"\u003eSetup\u003c/h3\u003e\n\n\u003cp\u003eThere will probably be several dumps produced by the application. This is due to the 4GB limit on file size\nimposed by the FAT32 filesystem. The filesystem has to be FAT32 meet UEFI specification. For \nconvenience purposes I have included a script in the tools directory called \u003ccode\u003econcatDumps.py\u003c/code\u003e \nthat can combine several dumps into one in chronological order. The content of the dump will consist \nof whatever raw data was inside memory at the time, so I recommend a tool like \u003ccode\u003exxd\u003c/code\u003e to read it more easily.\nTo help with searching the dumps I included a script called \u003ccode\u003esearchMem.py\u003c/code\u003e that allows you to search for a\nhex pattern within the dump. It will find the offset of instances of that hex pattern, which you can then jump\nto by using \u003ccode\u003exxd -s \u0026lt;offset\u0026gt; \u0026lt;dump\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\n\t\u003cimg src=\"https://noinitrd.github.io/Memory-Dump-UEFI/images/image2.png\"/\u003e\n\u003c/p\u003e\n\n\u003ch3 id=\"pool-tags\"\u003ePool Tags\u003c/h3\u003e\n\n\u003cp\u003ePool tags are 4 character long identifiers that indicate where Windows kernel memory pools are. These pools \nare allocated by the Windows kernel and are great places to look for sensitive information. There are a large\nnumber of these pool tags, and I included a text file called \u003ccode\u003epooltag.txt\u003c/code\u003e which contains a list\nof the pool tags with details about their respective purposes.\u003c/p\u003e\n\n\u003cp\u003eBefore continuing I’d like to give Microsoft a round of applause for being kind enough to plainly mark where\ncryptographic keys show up in memory.\nBack on Windows 7, key recovery was as simple as locating the \u003ccode\u003eFVEc\u003c/code\u003e pool tag, which corresponds to cryptographic\nallocations under \u003ccode\u003efvevol.sys\u003c/code\u003e. On Windows 8.1 and 10 the key could be found in the memory pool tagged by \n\u003ccode\u003eCngb\u003c/code\u003e which corresponds to the \u003ccode\u003eksecdd.sys\u003c/code\u003e module. Throughout my study of the Windows 11 memory dump, I couldn’t\nlocate the key in either of those places, but I did find it in two other locations.\u003c/p\u003e\n\n\u003ch3 id=\"fvek-key-recovery\"\u003eFVEK Key Recovery\u003c/h3\u003e\n\n\u003cp\u003eThe first place I located the FVEK key was under the \u003ccode\u003edFVE\u003c/code\u003e pool tag, which indicates memory allocated by \n\u003ccode\u003edumpfve.sys\u003c/code\u003e, which pertains to the full volume encryption crash dump filter for bitlocker drive encryption.\nThe pool tag is underlined in blue while the FVEK key is highlighted in red. This was the easiest and most \nconsistent location I found the key, and it is also prefaced by \u003ccode\u003e0x0480\u003c/code\u003e which indicates the type of encryption\nbeing used, which in my case is XTS-AES-128.\u003c/p\u003e\n\n\u003cp\u003e\n\t\u003cimg src=\"https://noinitrd.github.io/Memory-Dump-UEFI/images/image3.png\"/\u003e\n\u003c/p\u003e\n\n\u003cp\u003eThe second location is under the \u003ccode\u003eNone\u003c/code\u003e tag, which pertains to calls to the \u003ccode\u003eExAllocatePool\u003c/code\u003e routine. This time\nthe first half of the key can be seen two times and the second half once.\u003c/p\u003e\n\n\u003cp\u003e\n\t\u003cimg src=\"https://noinitrd.github.io/Memory-Dump-UEFI/images/image4.png\"/\u003e\n\u003c/p\u003e\n\n\u003ch3 id=\"next-steps\"\u003eNext Steps\u003c/h3\u003e\n\n\u003cp\u003eIt’s important to note that you need to preface \nwhatever key you obtain with what algorithm is being used. That means if your key is:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eb2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eYou need to add \u003ccode\u003e0x8004\u003c/code\u003e (or whatever the algorithm used was) to the beginning of the key in little endian format\nlike this:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e0480b2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eNext, you need to take that hex and dump it into a file, which can be done like:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eecho \u0026#34;0480b2cbc06071931b7cc50b59f8789571f4dd815c2008e93c02d5c6cd98c83ef54b\u0026#34; | xxd -r -p \u0026gt; output.fvek\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eI highly recommend using the \u003ccode\u003edislocker\u003c/code\u003e suite of tools to figure out which algorithm/value you\nneed and to ultimately unlock the drive. If you did everything correctly you can use \u003ccode\u003eoutput.fvek\u003c/code\u003e to unlock\nthe bitlocker protected partition and access any data on the volume.\u003c/p\u003e\n\n\u003ch2 id=\"final-notes\"\u003eFinal Notes\u003c/h2\u003e\n\n\u003cp\u003eThe best possible way to understand how Microsoft implemented bitlocker is to do kernel level debugging using\n\u003ccode\u003ewindbg\u003c/code\u003e. This can be done fairly easily using virtual machines or a crossed over USB 3.0 A/A cable. The reason I was\nable to find the key in the first place is by stepping through the Windows boot process and watching bitlocker\nin action. Microsoft makes an effort to destroy keys using functions like \u003ccode\u003eSymCryptSessionDestroy\u003c/code\u003e but they \nfail to destroy every key, as evident by its presence on the heap.\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://tribalchicken.net/recovering-bitlocker-keys-on-windows-8-1-and-10/\"\u003ehttps://tribalchicken.net/recovering-bitlocker-keys-on-windows-8-1-and-10/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc\"\u003ehttps://github.com/libyal/libbde/blob/main/documentation/BitLocker%20Drive%20Encryption%20(BDE)%20format.asciidoc\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/Aorimn/dislocker\"\u003ehttps://github.com/Aorimn/dislocker\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/microsoft/SymCrypt\"\u003ehttps://github.com/microsoft/SymCrypt\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/libyal/libbde\"\u003ehttps://github.com/libyal/libbde\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/zodiacon/PoolMonX/blob/master/res/pooltag.txt\"\u003ehttps://github.com/zodiacon/PoolMonX/blob/master/res/pooltag.txt\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://techcommunity.microsoft.com/blog/askperf/an-introduction-to-pool-tags/372983\"\u003ehttps://techcommunity.microsoft.com/blog/askperf/an-introduction-to-pool-tags/372983\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you have any questions you can reach me at the email below, thank you for reading!\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"mailto:noinitrd@gmail.com\"\u003eNoInitRD@gmail.com\u003c/a\u003e\u003c/p\u003e\n\n      \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
