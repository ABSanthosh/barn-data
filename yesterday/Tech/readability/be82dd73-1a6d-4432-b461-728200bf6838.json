{
  "id": "be82dd73-1a6d-4432-b461-728200bf6838",
  "title": "Introducing tmux-rs",
  "link": "https://richardscollin.github.io/tmux-rs/",
  "description": "Comments",
  "author": "",
  "published": "Thu, 03 Jul 2025 15:03:14 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Collin Richards",
  "length": 20006,
  "excerpt": "A Rust port of tmux",
  "siteName": "tmux-rs",
  "favicon": "",
  "text": "3 July 2025 Introducing tmux-rs by Collin Richards For the 6 months or so I’ve been quietly porting tmux from C to Rust. I’ve recently reached a big milestone: the code base is now 100% (unsafe) Rust. I’d like to share the process of porting the original codebase from ~67,000 lines of C code to ~81,000 lines of Rust (excluding comments and empty lines). You might be asking: why did you rewrite tmux in Rust? And yeah, I don’t really have a good reason. It’s a hobby project. Like gardening, but with more segfaults. Starting with C2Rust Build process Interesting bugs Bug 1 Bug 2 C Patterns in Rust Raw pointers Considering Goto Intrusive Macros Yacc shaving Development process Vim AI Tools Conclusion Starting with C2Rust I started this project as a way of trying out C2Rust, a C to Rust transpiler. The tool was a little tricky to set up, but once it was running the generated output was a successful port of the tmux codebase in Rust. Despite the generated code working, it was basically unmaintainable and 3x larger than the original C. You wouldn’t want to touch it with a 10 foot pole. Here’s an example of the output: // original C code int colour_palette_get(struct colour_palette *p, int c) { if (p == NULL) return (-1); if (c \u003e= 90 \u0026\u0026 c \u003c= 97) c = 8 + c - 90; else if (c \u0026 y) c \u0026= ~COLOUR_FLAG_256; else if (c \u003e= 8) return (-1); if (p-\u003epalette != NULL \u0026\u0026 p-\u003epalette[c] != -1) return (p-\u003epalette[c]); if (p-\u003edefault_palette != NULL \u0026\u0026 p-\u003edefault_palette[c] != -1) return (p-\u003edefault_palette[c]); return (-1); } // generated Rust code #[no_mangle] pub unsafe extern \"C\" fn colour_palette_get( mut p: *mut colour_palette, mut c: libc::c_int, ) -\u003e libc::c_int { if p.is_null() { return -(1 as libc::c_int); } if c \u003e= 90 as libc::c_int \u0026\u0026 c \u003c= 97 as libc::c_int { c = 8 as libc::c_int + c - 90 as libc::c_int; } else if c \u0026 0x1000000 as libc::c_int != 0 { c \u0026= !(0x1000000 as libc::c_int); } else if c \u003e= 8 as libc::c_int { return -(1 as libc::c_int) } if !((*p).palette).is_null() \u0026\u0026 *((*p).palette).offset(c as isize) != -(1 as libc::c_int) { return *((*p).palette).offset(c as isize); } if !((*p).default_palette).is_null() \u0026\u0026 *((*p).default_palette).offset(c as isize) != -(1 as libc::c_int) { return *((*p).default_palette).offset(c as isize); } return -(1 as libc::c_int); } This snippet isn’t that bad, but things can get a lot worse. My main concern was losing information from named constants like COLOUR_FLAG_256 which is translated to 0x1000000. There are also a lot of casts to libc::c_int polluting the code as well. I suspect this is to handle C’s integer promotion rules. Most of them are completely unnecessary when doing operations on literals in Rust. I spent quite a lot of time manually refactoring the shitty Rust code to less shitty Rust code, but I kept finding myself having to look at the original C code to understand the program’s intent. After manually refactoring many files this way I gave up on this approach. I threw away all of the C2Rust output and decided I would translate all of the files into Rust manually from C. Despite not using C2Rust for this project I still think it’s a great tool. It was very important for me to actually be able to compile and run the project from the start. It made me realize this endeavour was achievable. I’ve even integrated it as part of one of my other side projects. Build process ┌─────────────┐ ┌────────────┐ ┌──────────────┐ ┌──────────┐ ┌───────┐ │ Makefile.am │───►│ autogen.sh ├────►│ configure.sh │───►│ Makefile │ │ cargo │ └─────────────┘ └────────────┘ └──────────────┘ └──────────┘ └───┬───┘ │ │ ┌──────┐ ┌──────┐ │ ┌───►│tmux.c├──────►│tmux.o├───────┐ │ ┌──────┐ │ └──────┘ └──────┘ │ │ │tmux.h├────┤ │ │ └──────┘ │ ┌────────┐ ┌────────┐ │ │ ├─►│window.c├────►│window.o├───────┤ │ ┌────────┐ │ └────────┘ └────────┘ │ │ │compat.h├───┤ │ │ └────────┘ │ ┌──────┐ ┌──────┐ │ │ └───►│pane.c├──────►│pane.o├───────┤ ▼ └──────┘ └──────┘ │ ┌──────────────┐ ┌───────────┐ │ ┌────┐ │ │ │ │ ├───►│tmux│◄──┤ libtmux_rs.a │ │ libc.so.6 ├───────┤ └────┘ │ │ │ │ │ └──────────────┘ └───────────┘ │ ┌───────────────┐ │ │ │ │ │ libtinfo.so.6 ├───────┘ │ │ └───────────────┘ The most important part of this rewrite was first developing a solid understanding of how the project was built. For tmux this is autotools. I figured out where to add/remove files in autogen.sh and how to modify the generated Makefile to link in a static library created by my rust crate using the crate-type = \"staticlib\" option. This did mean my build process wasn’t as simple as just running cargo build. I wrote a small build.sh script which would invoke cargo, then run make. This worked for a while, but any time I completed translating a file I had to reconfigure and modify the Makefile. Early on I tried to break things up into mini-crates. It ends up being easier to put everything in the same crate for two reasons: 1. Crates can’t have circular dependencies and 2. you can run into linking issues when linking multiple Rust libraries into the same binary. At first, I would translate one file at a time, with no way to validate the changes halfway through each file. After translating a large file and getting stuck debugging, I changed my development process to translate only one function at a time, with a quick build.sh run in between to make sure everything worked. This did mean adding extra headers in the C code for functions which were originally static. The new process looked like this: copy the header of the C function comment out the C function body int colour_palette_get(struct colour_palette *p, int c); // int colour_palette_get(struct colour_palette *p, int c) { // ... // implement the function in Rust The C code would link against the Rust implementation as long as the function had the #[unsafe(no_mangle)] attribute extern \"C\" annotation and importantly the correct signature. After translating about half of the C files I started thinking the current build process was a bit silly. Most of the code was now in Rust. Instead of building a C binary and linking in a Rust library I should be building a Rust binary and linking in a C library. Well that’s exactly what you can do using the cc crate. I set up a build.rs like so: // simplified version of tmux-rs/build.rs fn main() { println!(\"cargo::rerun-if-changed=build.rs\"); println!(\"cargo::rustc-link-lib=bsd\"); println!(\"cargo::rustc-link-lib=tinfo\"); println!(\"cargo::rustc-link-lib=event_core\"); println!(\"cargo::rustc-link-lib=m\"); println!(\"cargo::rustc-link-lib=resolv\"); let mut builder = \u0026mut cc::Build::new(); static FILES: \u0026[\u0026str] = \u0026[ \"osdep-linux.c\", \"cmd-new-session.c\", \"cmd-queue.c\", // ... \"window-customize.c\", \"window-tree.c\", ]; for f in FILES { builder = builder.file(std::path::PathBuf::from(\"..\").join(f)) } builder.compile(\"foo\"); } Interesting Bugs I introduced many bugs while translating the code. I’d like to share the process of discovering and fixing a couple. Bug 1 The program started segfaulting after translating a trivial function. The source and translation are below: void* get_addr(client* c) { return c-\u003ebar; } unsafe extern \"C\" fn get_addr(c: *mut client) -\u003e *mut c_void { unsafe { (*c).bar } } After running in the debugger the error was something like: Invalid read at address 0x2764. I walked through the code again. Inside of the Rust function (*c).bar has a valid address, like 0x60302764, but out the function, the value received from the calling C code was 0x2764. Do you know the problem yet? Need another hint? If I looked more closely at the C compilation warnings I would have seen: warning: implicit declaration of function ‘get_addr’ [-Wimplicit-function-declaration] That’s right, the C code was using the implicit declaration which is: That explains why the value was incorrect! The C compiler was thinking a 4 byte int was returned not an 8 byte pointer. So the top 4 bytes were being truncated or ignored. The fix was as simple as adding the correct prototype to the C code and the compiler would generate the correct code. Bug 2 Again I noticed this bug after translating a trivial function which shouldn’t have caused any issues. It was something like this: void set_value(client* c) { c-\u003efoo = 5; } unsafe extern \"C\" fn set_value(c: *mut client) { unsafe { (*c).foo = 5; } } I was shocked that after translating this simple function the program started segfaulting. Inspecting it in the debugger showed that the segfault in the Rust code was happening on that line, which should be identical to the C. In the debugger I noticed that the address was slightly different in the C from the Rust, maybe that’s just do address randomization. So what’s the issue? Well it just so happens that when I manually translated the type declaration of the client struct I missed an * on one of the types. This type was just above the data field. Meaning the C and Rust code had different views of the type after that mismatched field. For example the C struct looked like: struct client { int bar; int *baz; int foo; } And the Rust looked like: struct client { bar: i32, baz: i32, foo: i32, } Nothing in the Rust touched baz yet, so there were no compiler errors, but the data would be interpreted and accessed incorrectly. The fix this time was as easy as correcting the incorrect types in the Rust code. C Patterns in Rust Raw pointers Rust has two reference types: \u0026T: a shared reference or \u0026mut T: an exclusive (or mutable) reference. A Rust reference is a pointer with several other invariants.One of the invariants is that a Rust reference can never be null and the value pointed to must be fully initialized and valid. The natural mapping of pointers in a C program would be a reference in Rust, either exclusive or shared depending if it’s modified in the code. The problem is, often times some of the invariants required by references in Rust cannot always be upheld if we do a straight one-to-one mapping of the source from C to Rust. That means we can’t use Rust references in our port yet. We have to use another type, raw pointers: *mut T and *const T. Semantically raw pointers are the same as C pointers, but because you don’t really use them outside of unsafe Rust they are extremely unergonomic to use. Considering Goto C has goto. goto gets a bad wrap, but actually it’s usage in the tmux codebase is quite tame, and only one or two of the usages actually cause implementation difficulties. The c2rust transpiler uses an algorithm to emulate goto logic. A good video describing a similar algorithm can be found in this video. However most cases don’t actually require using this algorithm and can instead use a much simpler method. Forward jumps can be implemented using a labeled block with a break statement: fn foo() { 'error: { println!(\"hello\"); if random() % 2 == 0 { break 'error; // same as goto error in C } println!(\"world\"); return; } // 'error: println!(\"error\"); } Backward jumps can be implemented using a labeled loop with continue: fn bar() { 'again: loop { println!(\"hello\"); if random() % 2 == 0 { continue 'again; // same as goto again in C } println!(\"world\"); return; } } These are the most common types of usages of goto in the tmux codebase. Only a handful of more complex goto usage required me getting out a pencil and paper to trace out how to map the control flow (see window_copy_search_marks in the codebase if you’re interested). Intrusive Macros Tmux makes extensive use of two data structures defined using macros: an intrusion red black tree and linked list. An intrusive data structure is one where pieces of the data structure live within your struct. This is different from how most container data structures are implemented today where the container holds the unmodified struct and doesn’t require support from the struct to hold data for the collection. I went through many iterations of implementing a good Rust interface mimicking the C code. I ended up with this: // cmd-kill-session.c RB_FOREACH(wl, winlinks, \u0026s-\u003ewindows) { wl-\u003ewindow-\u003eflags \u0026= ~WINDOW_ALERTFLAGS; wl-\u003eflags \u0026= ~WINLINK_ALERTFLAGS; } // cmd_kill_session.rs for wl in rb_foreach(\u0026raw mut (*s).windows).map(NonNull::as_ptr) { (*(*wl).window).flags \u0026= !WINDOW_ALERTFLAGS; (*wl).flags \u0026= !WINLINK_ALERTFLAGS; } The code would actually be cleaner if I didn’t return a NonNull\u003cT\u003e from the iterator. I implemented my own trait in order to mimic this interface. One of the challenges of this some instances can live in different containers at the same time. This is problematic because a trait can only be implemented once for a given type. The solution was making the trait generic so that it’s not a single trait but multiple depending on the generic parameter. I used a dummy unit type when I need to distinguish which trait to use in the code. Here’s the ugly code that enables the nice interfaces which closely resemble the C: pub trait GetEntry\u003cT, D = ()\u003e { unsafe fn entry_mut(this: *mut Self) -\u003e *mut rb_entry\u003cT\u003e; unsafe fn entry(this: *const Self) -\u003e *const rb_entry\u003cT\u003e; unsafe fn cmp(this: *const Self, other: *const Self) -\u003e std::cmp::Ordering; } pub unsafe fn rb_foreach\u003cT, D\u003e(head: *mut rb_head\u003cT\u003e) -\u003e RbForwardIterator\u003cT, D\u003e where T: GetEntry\u003cT, D\u003e, { RbForwardIterator { curr: NonNull::new(unsafe { rb_min(head) }), _phantom: std::marker::PhantomData, } } pub struct RbForwardIterator\u003cT, D\u003e { curr: Option\u003cNonNull\u003cT\u003e\u003e, _phantom: std::marker::PhantomData\u003cD\u003e, } impl\u003cT, D\u003e Iterator for RbForwardIterator\u003cT, D\u003e where T: GetEntry\u003cT, D\u003e, { type Item = NonNull\u003cT\u003e; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { let curr = self.curr?.as_ptr(); std::mem::replace(\u0026mut self.curr, NonNull::new(unsafe { rb_next(curr) })) } } Yacc shaving Tmux uses yacc to implement a custom parser for it’s configuration language. I was aware of lex and yacc before, but had never used them. The last step to converting the project from C to Rust was figuring out how to reimplement the parser in cmd-parse.y from yacc to Rust. After completing this I’d be able to completely shed the cc crate and streamline the build process. After one or two failed attempts with different crates I settled on using the lalrpop crate to implement the parser. The structure of lalrpop code closely matches yacc which allowed me to do a one-to-one reimplementation like the rest of the project. The original yacc parser looks like this: lines : /* empty */ | statements { struct cmd_parse_state *ps = \u0026parse_state; ps-\u003ecommands = $1; } statements : statement '\\n' { $$ = $1; } | statements statement '\\n' { $$ = $1; TAILQ_CONCAT($$, $2, entry); free($2); } It’s a grammar with a series of actions to perform when the rules are matched. The equivalent section of the grammar translates to the following lalrpop snippet. grammar(ps: NonNull\u003ccmd_parse_state\u003e); pub Lines: () = { =\u003e (), \u003cs:Statements\u003e =\u003e unsafe { (*ps.as_ptr()).commands = s.as_ptr(); } }; pub Statements: NonNull\u003ccmd_parse_commands\u003e = { \u003cs:Statement\u003e \"\\n\" =\u003e s, \u003carg1:Statements\u003e \u003carg2:Statement\u003e \"\\n\" =\u003e unsafe { let mut value = arg1; tailq_concat(value.as_ptr(), arg2.as_ptr()); free_(arg2.as_ptr()); value } }; lalrpop has a few bugs, for example it can’t handle raw pointers properly (the * seems to throw off the parser), that’s fine I just ended up using NonNull\u003cT\u003e in all the places instead. After reimplementing the grammar, I also had to implement an adapter to interface lalrpop with the custom lexer. The lexer was the same from the original codebase, just wrapped in a Rust iterator. I was amazed that once the lexer was hooked up to the parser it just seemed to work. This last step enabled me to get rid of all of the remaining C code and headers. Development process Vim Throughout working on this project I used many different text editors and ides. My typical workflow used neovim while heavily relying on custom macros to speed up the translation process. For example, I made vim macros for things like converting: ptr == NULL to ptr.is_null() ptr-\u003efield to (*ptr).field Most of these mechanical changes are very easy to make, but are hard to do all at once with a find and replace. This means doing it by hand thousands of times. AI Tools I did start trying out Cursor towards the end of the development process. I ended up stopping using it though because I felt like it didn’t actually increase my speed. It only saved me from finger pain. That’s because when using cursor to translate the code it would still occasionally insert bugs, just like me. So, I spent as much time reviewing the generated code as it would have taken me to write it myself. The only thing it saved was my hands. Doing this large amount of refactoring is really hard on your fingers. So, even though I quit using cursor, my feeling is that I’d still reach for it if my hands are really physically hurting, and I need to keep working. Usually once I reach the point where I’ve got blisters on my fingers I think it’s better to just take a break. Given the pace at how fast the AI tooling is developing I wouldn’t be surprised if this project could be accomplished in significantly less time using a different approach. Conclusion Even though the code is now 100%, I’m not sure I’ve accomplished my main goal yet. My hand translated code isn’t that much better than the output from C2Rust. It’s also not very difficult to get it to crash and I am aware of many bugs. The next goal is to convert the codebase to safe Rust. Despite all of this, I’m releasing version 0.0.1 to share with other fans of Rust and tmux. If this project interests you, you can connect with me through Github Discussions. See the installation instructions in the README.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection id=\"main_content\"\u003e\n        \u003csmall\u003e3 July 2025\u003c/small\u003e\n\u003ch2\u003eIntroducing tmux-rs\u003c/h2\u003e\n\n\u003cp\u003eby Collin Richards\u003c/p\u003e\n\n\u003cp\u003eFor the 6 months or so I’ve been quietly porting tmux from C to Rust. I’ve recently reached a big milestone: the code base is now 100% (unsafe) Rust.\nI’d like to share the process of porting the original codebase from ~67,000 lines of C code to ~81,000 lines of Rust (excluding comments and empty lines).\nYou might be asking: why did you rewrite tmux in Rust? And yeah, I don’t really have a good reason. It’s a hobby project. Like gardening, but with more segfaults.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"#starting-with-c2rust\"\u003eStarting with C2Rust\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#build-process\"\u003eBuild process\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#interesting-bugs\"\u003eInteresting bugs\u003c/a\u003e\n    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#bug-1\"\u003eBug 1\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#bug-2\"\u003eBug 2\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#c-patterns-in-rust\"\u003eC Patterns in Rust\u003c/a\u003e\n    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#raw-pointers\"\u003eRaw pointers\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#considering-goto\"\u003eConsidering Goto\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#intrusive-macros\"\u003eIntrusive Macros\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#yacc-shaving\"\u003eYacc shaving\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#development-process\"\u003eDevelopment process\u003c/a\u003e\n    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#vim\"\u003eVim\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#ai-tools\"\u003eAI Tools\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"starting-with-c2rust\"\u003eStarting with C2Rust\u003c/h2\u003e\n\n\u003cp\u003eI started this project as a way of trying out \u003ca href=\"https://github.com/immunant/c2rust\"\u003eC2Rust\u003c/a\u003e, a C to Rust transpiler. The tool was a little tricky to set up, but once it was running the generated output was a successful port of the tmux codebase in Rust.\u003c/p\u003e\n\n\u003cp\u003eDespite the generated code working, it was basically unmaintainable and 3x larger than the original C. You wouldn’t want to touch it with a 10 foot pole. Here’s an example of the output:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// original C code\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecolour_palette_get\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003ecolour_palette\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eNULL\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026lt;=\u003c/span\u003e \u003cspan\u003e97\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e~\u003c/span\u003e\u003cspan\u003eCOLOUR_FLAG_256\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003epalette\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003eNULL\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003epalette\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003epalette\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e]);\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003edefault_palette\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003eNULL\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003edefault_palette\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003edefault_palette\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e]);\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// generated Rust code\u003c/span\u003e\n\u003cspan\u003e#[no_mangle]\u003c/span\u003e\n\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003eextern\u003c/span\u003e \u003cspan\u003e\u0026#34;C\u0026#34;\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003ecolour_palette_get\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ecolour_palette\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e.is_null\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026lt;=\u003c/span\u003e \u003cspan\u003e97\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e90\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003e0x1000000\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0x1000000\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.is_null\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.offset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eisize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.offset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eisize\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.default_palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.is_null\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.default_palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.offset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eisize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.default_palette\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.offset\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eisize\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003elibc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ec_int\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis snippet isn’t that bad, but things can get a lot worse. My main concern was losing information from named constants like \u003ccode\u003eCOLOUR_FLAG_256\u003c/code\u003e which is translated to \u003ccode\u003e0x1000000\u003c/code\u003e. There are also a lot of casts to \u003ccode\u003elibc::c_int\u003c/code\u003e polluting the code as well. I suspect this is to handle \u003ca href=\"https://stackoverflow.com/a/46073296\"\u003eC’s integer promotion rules\u003c/a\u003e. Most of them are completely unnecessary when doing operations on literals in Rust.\u003c/p\u003e\n\n\u003cp\u003eI spent quite a lot of time manually refactoring the shitty Rust code to less shitty Rust code, but I kept finding myself having to look at the original C code to understand the program’s intent. After manually refactoring many files this way I gave up on this approach. I threw away all of the C2Rust output and decided I would translate all of the files into Rust manually from C.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eDespite not using C2Rust for this project I still think it’s a great tool. It was very important for me to actually be able to compile and run the project from the start. It made me realize this endeavour was achievable. I’ve even integrated it as part of one of my \u003ca href=\"https://crates.io/crates/include\"\u003eother side projects\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"build-process\"\u003eBuild process\u003c/h2\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e┌─────────────┐    ┌────────────┐     ┌──────────────┐    ┌──────────┐         ┌───────┐    \n│ Makefile.am │───►│ autogen.sh ├────►│ configure.sh │───►│ Makefile │         │ cargo │    \n└─────────────┘    └────────────┘     └──────────────┘    └──────────┘         └───┬───┘    \n                                                                                   │        \n                                                                                   │        \n                                ┌──────┐       ┌──────┐                            │        \n                           ┌───►│tmux.c├──────►│tmux.o├───────┐                    │        \n               ┌──────┐    │    └──────┘       └──────┘       │                    │        \n               │tmux.h├────┤                                  │                    │        \n               └──────┘    │  ┌────────┐     ┌────────┐       │                    │        \n                           ├─►│window.c├────►│window.o├───────┤                    │        \n              ┌────────┐   │  └────────┘     └────────┘       │                    │        \n              │compat.h├───┤                                  │                    │        \n              └────────┘   │    ┌──────┐       ┌──────┐       │                    │        \n                           └───►│pane.c├──────►│pane.o├───────┤                    ▼        \n                                └──────┘       └──────┘       │             ┌──────────────┐\n                                          ┌───────────┐       │    ┌────┐   │              │\n                                          │           │       ├───►│tmux│◄──┤ libtmux_rs.a │\n                                          │ libc.so.6 ├───────┤    └────┘   │              │\n                                          │           │       │             └──────────────┘\n                                          └───────────┘       │                             \n                                      ┌───────────────┐       │                             \n                                      │               │       │                             \n                                      │ libtinfo.so.6 ├───────┘                             \n                                      │               │                                     \n                                      └───────────────┘                                     \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe most important part of this rewrite was first developing a solid understanding of how the project was built. For tmux this is \u003ccode\u003eautotools\u003c/code\u003e. I figured out where to add/remove files in \u003ccode\u003eautogen.sh\u003c/code\u003e and how to modify the generated \u003ccode\u003eMakefile\u003c/code\u003e to link in a static library created by my rust crate using the \u003ccode\u003ecrate-type = \u0026#34;staticlib\u0026#34;\u003c/code\u003e option.\u003c/p\u003e\n\n\u003cp\u003eThis did mean my build process wasn’t as simple as just running \u003ccode\u003ecargo build\u003c/code\u003e. I wrote a small \u003ccode\u003ebuild.sh\u003c/code\u003e script which would invoke cargo, then run \u003ccode\u003emake\u003c/code\u003e. This worked for a while, but any time I completed translating a file I had to reconfigure and modify the \u003ccode\u003eMakefile\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eEarly on I tried to break things up into mini-crates. It ends up being easier to put everything in the same crate for two reasons: 1. Crates can’t have circular dependencies and 2. you can run into linking issues when linking multiple Rust libraries into the same binary.\u003c/p\u003e\n\n\u003cp\u003eAt first, I would translate one file at a time, with no way to validate the changes halfway through each file. After translating a large file and getting stuck debugging, I changed my development process to translate only one function at a time, with a quick \u003ccode\u003ebuild.sh run\u003c/code\u003e in between to make sure everything worked. This did mean adding extra headers in the C code for functions which were originally static. The new process looked like this:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecopy the header of the C function\u003c/li\u003e\n  \u003cli\u003ecomment out the C function body\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ecolour_palette_get\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003ecolour_palette\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e// int colour_palette_get(struct colour_palette *p, int c) {\u003c/span\u003e\n\u003cspan\u003e// ...\u003c/span\u003e\n\u003cspan\u003e//\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003eimplement the function in Rust\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe C code would link against the Rust implementation as long as the function had\nthe \u003ccode\u003e#[unsafe(no_mangle)]\u003c/code\u003e attribute \u003ccode\u003eextern \u0026#34;C\u0026#34;\u003c/code\u003e annotation and importantly the correct signature.\u003c/p\u003e\n\n\u003cp\u003eAfter translating about half of the C files I started thinking the current build process was a bit silly. Most of the code was now in Rust. Instead of building a C binary and linking in a Rust library I should be building a Rust binary and linking in a C library. Well that’s exactly what you can do using the \u003ccode\u003ecc\u003c/code\u003e crate.\u003c/p\u003e\n\n\u003cp\u003eI set up a \u003ccode\u003ebuild.rs\u003c/code\u003e like so:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// simplified version of tmux-rs/build.rs\u003c/span\u003e\n\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rerun-if-changed=build.rs\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rustc-link-lib=bsd\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rustc-link-lib=tinfo\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rustc-link-lib=event_core\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rustc-link-lib=m\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cargo::rustc-link-lib=resolv\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ebuilder\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ecc\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eBuild\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eFILES\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\n        \u003cspan\u003e\u0026#34;osdep-linux.c\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003e\u0026#34;cmd-new-session.c\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003e\u0026#34;cmd-queue.c\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003e// ...\u003c/span\u003e\n        \u003cspan\u003e\u0026#34;window-customize.c\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003e\u0026#34;window-tree.c\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e];\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eFILES\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ebuilder\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebuilder\u003c/span\u003e\u003cspan\u003e.file\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ePathBuf\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;..\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.join\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003ebuilder\u003c/span\u003e\u003cspan\u003e.compile\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2 id=\"interesting-bugs\"\u003eInteresting Bugs\u003c/h2\u003e\n\n\u003cp\u003eI introduced many bugs while translating the code. I’d like to share the process of discovering and fixing a couple.\u003c/p\u003e\n\n\u003ch3 id=\"bug-1\"\u003eBug 1\u003c/h3\u003e\n\n\u003cp\u003eThe program started segfaulting after translating a trivial function. The source and translation are below:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003eget_addr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003eextern\u003c/span\u003e \u003cspan\u003e\u0026#34;C\u0026#34;\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eget_addr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003ec_void\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.bar\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAfter running in the debugger the error was something like: \u003ccode\u003eInvalid read at address 0x2764\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eI walked through the code again. Inside of the Rust function \u003ccode\u003e(*c).bar\u003c/code\u003e\nhas a valid address, like \u003ccode\u003e0x60302764\u003c/code\u003e, but out the function, the value received from the calling C code\nwas \u003ccode\u003e0x2764\u003c/code\u003e. Do you know the problem yet? Need another hint? If I looked more closely at the C compilation\nwarnings I would have seen:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003ewarning: implicit declaration of function ‘get_addr’ [-Wimplicit-function-declaration]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat’s right, the C code was using the implicit declaration which is:\u003c/p\u003e\n\n\n\n\u003cp\u003eThat explains why the value was incorrect! The C compiler was thinking a 4 byte int was returned not an 8 byte pointer.\nSo the top 4 bytes were being truncated or ignored. The fix was as simple as adding the correct prototype to the C code\nand the compiler would generate the correct code.\u003c/p\u003e\n\n\u003ch3 id=\"bug-2\"\u003eBug 2\u003c/h3\u003e\n\n\u003cp\u003eAgain I noticed this bug after translating a trivial function which shouldn’t have caused any issues. It was something like this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eset_value\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003efoo\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003eextern\u003c/span\u003e \u003cspan\u003e\u0026#34;C\u0026#34;\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eset_value\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.foo\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI was shocked that after translating this simple function the program started segfaulting. Inspecting it in the debugger showed that the segfault in the Rust code was happening on that line, which should be identical to the C. In the debugger I noticed that the address was slightly different in the C from the Rust, maybe that’s just do address randomization.\u003c/p\u003e\n\n\u003cp\u003eSo what’s the issue? Well it just so happens that when I manually translated the type declaration of the client struct I missed an \u003ccode\u003e*\u003c/code\u003e on one of the types. This type was just above the data field. Meaning the C and Rust code had different views of the type after that mismatched field.\u003c/p\u003e\n\n\u003cp\u003eFor example the C struct looked like:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eclient\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ebaz\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd the Rust looked like:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eclient\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003ebaz\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNothing in the Rust touched \u003ccode\u003ebaz\u003c/code\u003e yet, so there were no compiler errors, but the data would be interpreted and accessed incorrectly. The fix this time was as easy as correcting the incorrect types in the Rust code.\u003c/p\u003e\n\n\u003ch2 id=\"c-patterns-in-rust\"\u003eC Patterns in Rust\u003c/h2\u003e\n\n\u003ch3 id=\"raw-pointers\"\u003eRaw pointers\u003c/h3\u003e\n\n\u003cp\u003eRust has two reference types: \u003ccode\u003e\u0026amp;T\u003c/code\u003e: a shared reference or \u003ccode\u003e\u0026amp;mut T\u003c/code\u003e: an exclusive (or mutable) reference. A Rust reference is a pointer with several other invariants.One of the invariants is that a Rust reference can never be null and the value pointed to must be fully initialized and valid.\u003c/p\u003e\n\n\u003cp\u003eThe natural mapping of pointers in a C program would be a reference in Rust, either exclusive or shared depending if it’s modified in the code. The problem is, often times some of the invariants required by references in Rust cannot always be upheld if we do a straight one-to-one mapping of the source from C to Rust. That means we can’t use Rust references in our port yet. We have to use another type, raw pointers: \u003ccode\u003e*mut T\u003c/code\u003e and \u003ccode\u003e*const T\u003c/code\u003e. Semantically raw pointers are the same as C pointers, but because you don’t really use them outside of unsafe Rust they are extremely unergonomic to use.\u003c/p\u003e\n\n\u003ch3 id=\"considering-goto\"\u003eConsidering Goto\u003c/h3\u003e\n\n\u003cp\u003eC has \u003ccode\u003egoto\u003c/code\u003e. \u003ccode\u003egoto\u003c/code\u003e gets a bad wrap, but actually it’s usage in the tmux codebase is quite tame, and only one or two of the usages actually cause implementation difficulties.\u003c/p\u003e\n\n\u003cp\u003eThe c2rust transpiler uses an algorithm to emulate goto logic. A good video describing a similar algorithm can be found in this \u003ca href=\"https://www.youtube.com/watch?v=qAeEWKr9wfU\"\u003evideo\u003c/a\u003e. However most cases don’t actually require using this algorithm and can instead use a much simpler method.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eForward jumps can be implemented using a labeled block with a break statement:\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003efoo\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e\u0026#39;error\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ebreak\u003c/span\u003e \u003cspan\u003e\u0026#39;error\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// same as goto error in C\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003e// \u0026#39;error:\u003c/span\u003e\n  \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;error\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBackward jumps can be implemented using a labeled loop with continue:\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003ebar\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e\u0026#39;again\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eloop\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003econtinue\u003c/span\u003e \u003cspan\u003e\u0026#39;again\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// same as goto again in C\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003eprintln!\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThese are the most common types of usages of goto in the tmux codebase. Only a handful of more complex goto usage required me getting out a pencil and paper to trace out how to map the control flow (see \u003ccode\u003ewindow_copy_search_marks\u003c/code\u003e in the codebase if you’re interested).\u003c/p\u003e\n\n\u003ch3 id=\"intrusive-macros\"\u003eIntrusive Macros\u003c/h3\u003e\n\n\u003cp\u003eTmux makes extensive use of two data structures defined using macros: an intrusion red black tree and linked list. An intrusive data structure is one where pieces of the data structure live within your struct. This is different from how most container data structures are implemented today where the container holds the unmodified struct and doesn’t require support from the struct to hold data for the collection.\u003c/p\u003e\n\n\u003cp\u003eI went through many iterations of implementing a good Rust interface mimicking the C code. I ended up with this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// cmd-kill-session.c\u003c/span\u003e\n\u003cspan\u003eRB_FOREACH\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewl\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ewinlinks\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003ewindows\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ewl\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003ewindow\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003eflags\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e~\u003c/span\u003e\u003cspan\u003eWINDOW_ALERTFLAGS\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003ewl\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003eflags\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e~\u003c/span\u003e\u003cspan\u003eWINLINK_ALERTFLAGS\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// cmd_kill_session.rs\u003c/span\u003e\n\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ewl\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erb_foreach\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003eraw\u003c/span\u003e \u003cspan\u003emut\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.windows\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.map\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eas_ptr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ewl\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.window\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.flags\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eWINDOW_ALERTFLAGS\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ewl\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.flags\u003c/span\u003e \u003cspan\u003e\u0026amp;=\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eWINLINK_ALERTFLAGS\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe code would actually be cleaner if I didn’t return a \u003ccode\u003eNonNull\u0026lt;T\u0026gt;\u003c/code\u003e from the iterator. I implemented my own trait in order to mimic this interface. One\nof the challenges of this some instances can live in different containers at the same time. This is problematic because a trait can only be implemented once for a given type. The solution was making the trait generic so that it’s not a single trait but multiple depending on the generic parameter. I used a dummy unit type when I need to distinguish which trait to use in the code. Here’s the ugly code that enables the nice interfaces which closely resemble the C:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003etrait\u003c/span\u003e \u003cspan\u003eGetEntry\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eentry_mut\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003erb_entry\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eentry\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003erb_entry\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003ecmp\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eother\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecmp\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eOrdering\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003erb_foreach\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ehead\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003erb_head\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eRbForwardIterator\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003ewhere\u003c/span\u003e\n    \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eGetEntry\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eRbForwardIterator\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ecurr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003erb_min\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ehead\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}),\u003c/span\u003e\n        \u003cspan\u003e_phantom\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emarker\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ePhantomData\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eRbForwardIterator\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ecurr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e_phantom\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emarker\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ePhantomData\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eimpl\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eIterator\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eRbForwardIterator\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003ewhere\u003c/span\u003e\n    \u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eGetEntry\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eD\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003etype\u003c/span\u003e \u003cspan\u003eItem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003efn\u003c/span\u003e \u003cspan\u003enext\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eOption\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eItem\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ecurr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.curr\u003c/span\u003e\u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emem\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ereplace\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.curr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003erb_next\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecurr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}))\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"yacc-shaving\"\u003eYacc shaving\u003c/h3\u003e\n\n\u003cp\u003eTmux uses \u003ccode\u003eyacc\u003c/code\u003e to implement a custom parser for it’s configuration language. I was aware of \u003ccode\u003elex\u003c/code\u003e and \u003ccode\u003eyacc\u003c/code\u003e before, but had never used them. The last step to converting the project from C to Rust was figuring out how to reimplement the parser in \u003ccode\u003ecmd-parse.y\u003c/code\u003e from \u003ccode\u003eyacc\u003c/code\u003e to Rust. After completing this I’d be able to completely shed the \u003ccode\u003ecc\u003c/code\u003e crate and streamline the build process.\u003c/p\u003e\n\n\u003cp\u003eAfter one or two failed attempts with different crates I settled on using the \u003ccode\u003elalrpop\u003c/code\u003e crate to implement the parser. The structure of lalrpop code closely matches \u003ccode\u003eyacc\u003c/code\u003e which allowed me to do a one-to-one reimplementation like the rest of the project.\u003c/p\u003e\n\n\u003cp\u003eThe original yacc parser looks like this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elines\u003c/span\u003e\t\t\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e/* empty */\u003c/span\u003e\n\t\t\u003cspan\u003e|\u003c/span\u003e \u003cspan\u003estatements\u003c/span\u003e\n\t\t\u003cspan\u003e{\u003c/span\u003e\n\t\t\t\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003ecmd_parse_state\u003c/span\u003e\t\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eps\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003eparse_state\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\t\t\t\u003cspan\u003eps\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003ecommands\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\t\t\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003estatements\u003c/span\u003e\t\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estatement\u003c/span\u003e \u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e\n\t\t\u003cspan\u003e{\u003c/span\u003e\n\t\t\t\u003cspan\u003e$$\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\t\t\u003cspan\u003e}\u003c/span\u003e\n\t\t\u003cspan\u003e|\u003c/span\u003e \u003cspan\u003estatements\u003c/span\u003e \u003cspan\u003estatement\u003c/span\u003e \u003cspan\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e\n\t\t\u003cspan\u003e{\u003c/span\u003e\n\t\t\t\u003cspan\u003e$$\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\t\t\t\u003cspan\u003eTAILQ_CONCAT\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e$$\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eentry\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\t\t\t\u003cspan\u003efree\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\t\t\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt’s a grammar with a series of actions to perform when the rules are matched.\nThe equivalent section of the grammar translates to the following \u003ccode\u003elalrpop\u003c/code\u003e snippet.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003egrammar\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eps\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003ecmd_parse_state\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003eLines\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003e(),\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eStatements\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eps\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003cspan\u003e.commands\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003epub\u003c/span\u003e \u003cspan\u003eStatements\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eNonNull\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003ecmd_parse_commands\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eStatement\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003earg1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eStatements\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003earg2\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003eStatement\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emut\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003earg1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n      \u003cspan\u003etailq_concat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003earg2\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n      \u003cspan\u003efree_\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003earg2\u003c/span\u003e\u003cspan\u003e.as_ptr\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n      \u003cspan\u003evalue\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003elalrpop\u003c/code\u003e has a few bugs, for example it can’t handle raw pointers properly (the * seems to throw off the parser), that’s fine I just ended up using \u003ccode\u003eNonNull\u0026lt;T\u0026gt;\u003c/code\u003e in all the places instead.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eAfter reimplementing the grammar, I also had to implement an adapter to interface lalrpop with the custom lexer. The lexer was the same from the original codebase, just wrapped in a Rust iterator. I was amazed that once the lexer was hooked up to the parser it just seemed to work. This last step enabled me to get rid of all of the remaining C code and headers.\u003c/p\u003e\n\n\u003ch2 id=\"development-process\"\u003eDevelopment process\u003c/h2\u003e\n\n\u003ch3 id=\"vim\"\u003eVim\u003c/h3\u003e\n\n\u003cp\u003eThroughout working on this project I used many different text editors and ides. My typical workflow used neovim while heavily relying on custom macros to speed up the translation process. For example, I made vim macros for things like converting:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eptr == NULL\u003c/code\u003e to \u003ccode\u003eptr.is_null()\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eptr-\u0026gt;field\u003c/code\u003e to \u003ccode\u003e(*ptr).field\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMost of these mechanical changes are very easy to make, but are hard to do all at once with a find and replace. This means doing it by hand thousands of times.\u003c/p\u003e\n\n\u003ch3 id=\"ai-tools\"\u003eAI Tools\u003c/h3\u003e\n\n\u003cp\u003eI did start trying out Cursor towards the end of the development process. I ended up stopping using it though because I felt like it didn’t actually increase my speed. It only saved me from finger pain. That’s because when using cursor to translate the code it would still occasionally insert bugs, just like me. So, I spent as much time reviewing the generated code as it would have taken me to write it myself. The only thing it saved was my hands. Doing this large amount of refactoring is really hard on your fingers.\u003c/p\u003e\n\n\u003cp\u003eSo, even though I quit using cursor, my feeling is that I’d still reach for it if my hands are really physically hurting, and I need to keep working. Usually once I reach the point where I’ve got blisters on my fingers I think it’s better to just take a break. Given the pace at how fast the AI tooling is developing I wouldn’t be surprised if this project could be accomplished in significantly less time using a different approach.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eEven though the code is now 100%, I’m not sure I’ve accomplished my main goal yet. My hand translated code isn’t that much better than the output from C2Rust. It’s also not very difficult to get it to crash and I am aware of many bugs. The next goal is to convert the codebase to safe Rust.\u003c/p\u003e\n\n\u003cp\u003eDespite all of this, I’m releasing version 0.0.1 to share with other fans of Rust and \u003ccode\u003etmux\u003c/code\u003e. If this project interests you, you can connect with me through \u003ca href=\"https://github.com/richardscollin/tmux-rs/discussions\"\u003eGithub Discussions\u003c/a\u003e. See the installation instructions in the \u003ca href=\"https://github.com/richardscollin/tmux-rs\"\u003eREADME\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\n\n      \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": "2025-07-03T00:00:00Z",
  "modifiedTime": null
}
