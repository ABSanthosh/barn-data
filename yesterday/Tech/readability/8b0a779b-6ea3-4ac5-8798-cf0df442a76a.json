{
  "id": "8b0a779b-6ea3-4ac5-8798-cf0df442a76a",
  "title": "It's time for modern CSS to kill the SPA",
  "link": "https://www.jonoalderson.com/conjecture/its-time-for-modern-css-to-kill-the-spa/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 25 Jul 2025 21:08:00 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Jono Alderson",
  "length": 9955,
  "excerpt": "Native CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites.",
  "siteName": "Jono Alderson",
  "favicon": "",
  "text": "24th July, 2025 Native CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites. The app-like fallacy “Make it feel like an app.” At some point during the scoping process, someone says the words. A CMO. A digital lead. A brand manager. And with that single phrase, the architecture is locked in: it’ll be an SPA. Probably React. Maybe Vue. Almost certainly deployed on Vercel or Netlify, bundled with a headless CMS and a GraphQL API for good measure. But the decision wasn’t really about architecture. It wasn’t even about performance, scalability, or content management. It was about interactions. About how the site would feel when you click around.  The assumption was simple: Seamless navigation requires us to build an app. That assumption is now obsolete. The false promise of SPAs The reason SPAs became the default wasn’t because they were better. It was because, for a while, they were the only way to deliver something that felt fluid – something that didn’t flash white between pages or jank the scroll position. But here’s the uncomfortable truth: most SPAs don’t actually deliver the polish they promise. What you usually get is: A page transition that looks smooth, until you realise it’s just fading between two loading states Broken scroll restoration Inconsistent focus behaviour Delayed navigation while scripts rehydrate components Layout shift, content popping, or full-page skeletons A performance hit that’s entirely disproportionate to the effect This isn’t theoretical. Look at most sites built with Next.js, Gatsby, or Nuxt. They’re shipping kilobytes (often megabytes) of JavaScript just to fake native navigation. Routing logic, hydration code, loading spinners – all just to stitch together something that browsers already knew how to do natively. Instead of smoothness, you get simulation. And instead of a fast, stable, SEO-friendly experience, you get a heavy JavaScript machine trying to recreate the native behaviour we threw away. We’ve been adding mountains of JS to “feel” fast, while making everything slower. An aside – I went deeper on this in JavaScript broke the web, where I outlined how our obsession with JS-first development is actively eroding the web’s foundations. The web grew up While we were busy reinventing navigation in JavaScript, the platform quietly solved the problem. Modern browsers – specifically Chromium-based ones like Chrome and Edge – now support native, declarative page transitions. With the View Transitions API, you can animate between two documents – including full page navigations – without needing a single line of JavaScript. Yes, really. What we’re calling “modern CSS” here is shorthand for View Transitions, Speculation Rules, and a return to native browser features that were always designed to handle navigation, interaction, and layout. These capabilities let us build rich, seamless experiences – without rewriting the browser in JavaScript. An aside – CSS is also declarative, resilient, expressive, scalable, and increasingly intuitive. It’s accessible to anyone who can write plain HTML. And that structural clarity reinforces everything I argued in Why semantic HTML still matters – that clean, meaningful markup is the bedrock of performance, maintainability, and machine readability. That means you can: Fade between pages Animate shared elements (e.g. thumbnails → product detail) Maintain persistent elements like headers or navbars Do it all with real URLs, real page loads, and no JS routing hacks Let’s make this concrete. 🔄 Basic cross-page fade transition With just a few lines of CSS, you can trigger smooth visual transitions between pages. On both the current and destination page, add: @view-transition { navigation: auto; } ::view-transition-old(root), ::view-transition-new(root) { animation: fade 0.3s ease both; } @keyframes fade { from { opacity: 0; } to { opacity: 1; } } That’s it. The browser handles the transition – no client-side routing, no hydration, no loading spinners. 🔁 Shared element transitions Want to animate a thumbnail image into its full-size product counterpart on the next page? No JavaScript needed – just assign the same view-transition-name to the element on both pages: On the product listing page: \u003ca href=\"/product/red-shoes\"\u003e \u003cimg src=\"/images/red-shoes-thumb.jpg\" style=\"view-transition-name: product-image;\" /\u003e \u003c/a\u003e On the product detail page: \u003cimg src=\"/images/red-shoes-large.jpg\" style=\"view-transition-name: product-image;\" /\u003e The browser matches and animates the elements between navigations. You can animate position, scale, opacity, layout – all with CSS. 🤖 But what if I need JS-driven transitions? You can manually trigger transitions inside a page too: document.startViewTransition(() =\u003e { document.body.classList.toggle('dark-mode'); }); Perfect for things like tab toggles or theme switches — without needing a framework or hydration layer. 🔮 Speculation rules: instant navigation without JS View Transitions make things smooth. But what about fast? That’s where Speculation Rules come in. This lets the browser preload or prerender full pages based on user behaviour – like hovering or touching a link – before they click. \u003cscript type=\"speculationrules\"\u003e { \"prerender\": [ { \"where\": { \"selector_matches\": \"a\" } } ] } \u003c/script\u003e The result? Navigation that’s instant. No waiting. No loading. No spinners. ⚠️ A Note of Caution Speculation Rules are a performance multiplier. On a lean site, they make things feel instant. But if your pages are slow, bloated, or JS-heavy, speculation just front-loads those costs. If your site is bloated, speculation will still speculate – and the user pays the price. That means wasted CPU, network bandwidth, and mobile battery – often for pages the user never even visits. Use them carefully. On a fast site, they’re magic. On a slow one, they’re a trap. Browsers want to help – if we let them Modern browsers are smarter than ever. They’re constantly looking for ways to improve speed, responsiveness, and efficiency – but only if we let them. One of the clearest examples is the Back/Forward Cache (bfcache), which allows entire pages to be snapshotted and restored instantly when users navigate back or forward. It’s effectively free performance – but only for pages that behave. That means no rogue JavaScript, no intercepted navigation, no lifecycle chaos. Just clean, declarative architecture. Just HTML and CSS. Unsurprisingly, this plays beautifully with a well-structured, multi-page site. But for most SPAs, it’s a non-starter. The very design patterns that define them – hijacked routing, client-side rendering, complex state management – break the assumptions that bfcache relies on. This is a microcosm of a much bigger theme: browsers are evolving to reward simplicity and resilience. They’re building for the kind of web we should have been embracing all along. And SPAs are increasingly the odd ones out. 📊 SPA vs MPA: a performance reality check Average Next.js marketing site JS bundle: 1 – 3MB TTI: ~3.5 – 5s (depending on hydration strategy) Route transitions: simulated SEO: complex, fragile Scroll/anchor behaviour: unreliable Modern MPA + View Transitions + Speculation Rules JS bundle: 0KB (optional enhancements only) TTI: ~1s Route transitions: real, native SEO: trivial Scroll/focus/history: browser-default and perfect Modern CSS doesn’t just replace SPA behaviour – it outperforms it. Don’t build a website like it’s an app Most websites aren’t apps. They don’t need shared state. They don’t need client-side routing. They don’t need interactive components on every screen. But somewhere along the way, we stopped making the distinction. Now we’re building ecommerce stores, documentation portals, marketing sites, and blogs using stacks designed for real-time collaborative UIs. It’s madness. A homepage with six content blocks and a contact form doesn’t need hydration, suspense boundaries, and a rendering strategy. It needs fast markup, clean URLs, and maybe – maybe – a bit of interactivity layered on top. And yet, on every project: A stakeholder says, “make it feel like an app.” A dev team reaches for Next.js or Nuxt. Routing goes client-side. Performance falls off a cliff. Now you need edge functions, streaming, ISR, loading strategies, and a debugging plan. And somehow… it still feels slower than a regular link click and a CSS animation. This isn’t about being anti-framework. It’s about being intentional. Use React if you want. Use Tailwind, Vite, whatever. Just don’t ship it all to the browser unless you need to. Build a site like a site. Use HTML. Use navigation. Use the platform. It’s faster, simpler, and better for everyone. Build for the web we have SPAs were a clever solution to a temporary limitation. But that limitation no longer exists. We now have: Native, declarative transitions between real pages Instantaneous prerendered navigation via Speculation Rules Graceful degradation Clean markup, fast loads, and real URLs A platform that wants to help – if we let it If you’re still building your site as an SPA for the sake of “smoothness,” you’re solving a problem the browser already fixed – and you’re paying for it in complexity, performance, and maintainability. Use modern server rendering. Use actual pages. Animate with CSS. Preload with intent. Ship less JavaScript. Build like it’s 2025 – not like you’re trapped in a 2018 demo of Gatsby. You’ll end up with faster sites, happier users, and fewer regrets.",
  "image": "https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026f=auto\u0026fit=cover\u0026height=675\u0026q=85\u0026sharpen=1\u0026width=1200",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n\t\t\t\t\n\t\t\t\t\u003cdiv\u003e\u003cp\u003e24th July, 2025\u003c/p\u003e\u003cdiv\u003e\u003cpicture\u003e\u003cimg sizes=\"(max-width: 96px) 100vw, 96px\" alt=\"\" src=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=96\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=96\" srcset=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=96\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=96 96w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=144\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=144 144w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=192\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=192 192w\" height=\"96\" width=\"96\" decoding=\"async\" loading=\"eager\" acd-lazy-load=\"true\" fetchpriority=\"high\"/\u003e\u003c/picture\u003e\u003c/div\u003e\u003cpicture\u003e\u003cimg alt=\"\" decoding=\"async\" fetchpriority=\"high\" height=\"350\" sizes=\"(max-width: 760px) calc(100vw - 2.5rem), 760px\" src=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=350\u0026amp;q=85\u0026amp;width=760\" srcset=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=350\u0026amp;q=85\u0026amp;width=760 760w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=525\u0026amp;q=85\u0026amp;width=1140 1140w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=700\u0026amp;q=85\u0026amp;width=1520 1520w\" width=\"760\" loading=\"lazy\" acd-lazy-load=\"true\"/\u003e\u003c/picture\u003e\u003c/div\u003e\n\u003cp\u003eNative CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-the-app-like-fallacy\"\u003eThe app-like fallacy\u003c/h2\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e“\u003cem\u003eMake it feel like an app\u003c/em\u003e.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eAt some point during the scoping process, someone says the words. A CMO. A digital lead. A brand manager. And with that single phrase, the architecture is locked in: it’ll be an SPA. Probably React. Maybe Vue. Almost certainly deployed on Vercel or Netlify, bundled with a headless CMS and a GraphQL API for good measure.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut the decision wasn’t really about architecture. It wasn’t even about performance, scalability, or content management. It was about \u003cem\u003einteractions\u003c/em\u003e. About how the site would feel when you click around. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe assumption was simple: Seamless navigation requires us to build an app.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat assumption is now obsolete.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-the-false-promise-of-spas\"\u003eThe false promise of SPAs\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe reason SPAs became the default wasn’t because they were \u003cem\u003ebetter\u003c/em\u003e. It was because, for a while, they were the only way to deliver something that felt fluid – something that didn’t flash white between pages or jank the scroll position.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut here’s the uncomfortable truth: most SPAs don’t actually deliver the polish they promise.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat you usually get is:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA page transition that \u003cem\u003elooks\u003c/em\u003e smooth, until you realise it’s just fading between two loading states\u003c/li\u003e\n\n\n\n\u003cli\u003eBroken scroll restoration\u003c/li\u003e\n\n\n\n\u003cli\u003eInconsistent focus behaviour\u003c/li\u003e\n\n\n\n\u003cli\u003eDelayed navigation while scripts rehydrate components\u003c/li\u003e\n\n\n\n\u003cli\u003eLayout shift, content popping, or full-page skeletons\u003c/li\u003e\n\n\n\n\u003cli\u003eA performance hit that’s entirely disproportionate to the effect\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis isn’t theoretical. Look at most sites built with Next.js, Gatsby, or Nuxt. They’re shipping \u003cem\u003ekilobytes\u003c/em\u003e (often \u003cem\u003emegabytes\u003c/em\u003e) of JavaScript just to \u003cem\u003efake\u003c/em\u003e native navigation. Routing logic, hydration code, loading spinners – all just to stitch together something that browsers already knew how to do natively.\u003c/p\u003e\n\n\n\n\u003cp\u003eInstead of smoothness, you get simulation. And instead of a fast, stable, SEO-friendly experience, you get a heavy JavaScript machine trying to recreate the native behaviour we threw away.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’ve been adding mountains of JS to “feel” fast, while making everything slower.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAn aside – I went deeper on this in \u003ca href=\"https://www.jonoalderson.com/conjecture/javascript-broke-the-web-and-called-it-progress/\"\u003eJavaScript broke the web\u003c/a\u003e, where I outlined how our obsession with JS-first development is actively eroding the web’s foundations.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003ch2 id=\"h-the-web-grew-up\"\u003eThe web grew up\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile we were busy reinventing navigation in JavaScript, the platform quietly solved the problem.\u003c/p\u003e\n\n\n\n\u003cp\u003eModern browsers – specifically Chromium-based ones like Chrome and Edge – now support native, declarative page transitions. With the \u003ca href=\"https://developer.chrome.com/docs/web-platform/view-transitions/\"\u003eView Transitions API\u003c/a\u003e, you can animate between two documents – including full page navigations – without needing a single line of JavaScript.\u003c/p\u003e\n\n\n\n\u003cp\u003eYes, really.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat we’re calling “modern CSS” here is shorthand for \u003cstrong\u003eView Transitions\u003c/strong\u003e, \u003cstrong\u003eSpeculation Rules\u003c/strong\u003e, and a return to native browser features that were always designed to handle navigation, interaction, and layout. These capabilities let us build rich, seamless experiences – without rewriting the browser in JavaScript.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAn aside – CSS is also declarative, resilient, expressive, scalable, and increasingly intuitive. It’s accessible to anyone who can write plain HTML. And that structural clarity reinforces everything I argued in \u003ca href=\"https://www.jonoalderson.com/conjecture/why-semantic-html-still-matters/\"\u003eWhy semantic HTML still matters\u003c/a\u003e – that clean, meaningful markup is the bedrock of performance, maintainability, and machine readability.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThat means you can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFade between pages\u003c/li\u003e\n\n\n\n\u003cli\u003eAnimate shared elements (e.g. thumbnails → product detail)\u003c/li\u003e\n\n\n\n\u003cli\u003eMaintain persistent elements like headers or navbars\u003c/li\u003e\n\n\n\n\u003cli\u003eDo it all with real URLs, real page loads, and no JS routing hacks\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLet’s make this concrete.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-basic-cross-page-fade-transition\"\u003e🔄 Basic cross-page fade transition\u003c/h3\u003e\n\n\n\n\u003cp\u003eWith just a few lines of CSS, you can trigger smooth visual transitions between pages.\u003c/p\u003e\n\n\n\n\u003cp\u003eOn both the current and destination page, add:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e@view-transition {\n  navigation: auto;\n}\n\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation: fade 0.3s ease both;\n}\n\n@keyframes fade {\n  from { opacity: 0; }\n  to   { opacity: 1; }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat’s it. The browser handles the transition – no client-side routing, no hydration, no loading spinners.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-shared-element-transitions\"\u003e🔁 Shared element transitions\u003c/h3\u003e\n\n\n\n\u003cp\u003eWant to animate a thumbnail image into its full-size product counterpart on the next page?\u003c/p\u003e\n\n\n\n\u003cp\u003eNo JavaScript needed – just assign the same \u003ccode\u003eview-transition-name\u003c/code\u003e to the element on both pages:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eOn the product listing page:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;a href=\u0026#34;/product/red-shoes\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;/images/red-shoes-thumb.jpg\u0026#34; style=\u0026#34;view-transition-name: product-image;\u0026#34; /\u0026gt;\n\u0026lt;/a\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eOn the product detail page:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;img src=\u0026#34;/images/red-shoes-large.jpg\u0026#34; style=\u0026#34;view-transition-name: product-image;\u0026#34; /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe browser matches and animates the elements between navigations. You can animate position, scale, opacity, layout – all with CSS.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-but-what-if-i-need-js-driven-transitions\"\u003e🤖 But what if I need JS-driven transitions?\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou can manually trigger transitions inside a page too:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003edocument.startViewTransition(() =\u0026gt; {\n  document.body.classList.toggle(\u0026#39;dark-mode\u0026#39;);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003ePerfect for things like tab toggles or theme switches — without needing a framework or hydration layer.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-speculation-rules-instant-navigation-without-js\"\u003e🔮 Speculation rules: instant navigation without JS\u003c/h3\u003e\n\n\n\n\u003cp\u003eView Transitions make things smooth. But what about \u003cem\u003efast\u003c/em\u003e?\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s where \u003ca href=\"https://developer.chrome.com/docs/web-platform/implementing-speculation-rules/\"\u003eSpeculation Rules\u003c/a\u003e come in. This lets the browser preload or prerender full pages based on user behaviour – like hovering or touching a link – before they click.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;script type=\u0026#34;speculationrules\u0026#34;\u0026gt;\n{\n  \u0026#34;prerender\u0026#34;: [\n    {\n      \u0026#34;where\u0026#34;: {\n        \u0026#34;selector_matches\u0026#34;: \u0026#34;a\u0026#34;\n      }\n    }\n  ]\n}\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe result? Navigation that’s \u003cem\u003einstant\u003c/em\u003e. No waiting. No loading. No spinners.\u003c/p\u003e\n\n\n\n\u003ch4 id=\"h-a-note-of-caution\"\u003e⚠️ A Note of Caution\u003c/h4\u003e\n\n\n\n\u003cp\u003eSpeculation Rules are a performance multiplier. On a lean site, they make things feel instant. But if your pages are slow, bloated, or JS-heavy, speculation just front-loads those costs.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf your site is bloated, speculation will still speculate – and the user pays the price.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat means wasted CPU, network bandwidth, and mobile battery – often for pages the user never even visits.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse them carefully. On a fast site, they’re magic. On a slow one, they’re a trap.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-browsers-want-to-help-if-we-let-them\"\u003eBrowsers want to help – if we let them\u003c/h2\u003e\n\n\n\n\u003cp\u003eModern browsers are smarter than ever. They’re constantly looking for ways to improve speed, responsiveness, and efficiency – but only if we let them.\u003c/p\u003e\n\n\n\n\u003cp\u003eOne of the clearest examples is the \u003ca href=\"https://web.dev/articles/bfcache\"\u003eBack/Forward Cache (bfcache)\u003c/a\u003e, which allows entire pages to be snapshotted and restored instantly when users navigate back or forward.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt’s effectively free performance – but only for pages that behave. That means no rogue JavaScript, no intercepted navigation, no lifecycle chaos. Just clean, declarative architecture. Just HTML and CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnsurprisingly, this plays beautifully with a well-structured, multi-page site. But for most SPAs, it’s a non-starter. The very design patterns that define them – hijacked routing, client-side rendering, complex state management – break the assumptions that bfcache relies on.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is a microcosm of a much bigger theme: browsers are evolving to reward simplicity and resilience. They’re building for the kind of web we should have been embracing all along. And SPAs are increasingly the odd ones out.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-spa-vs-mpa-a-performance-reality-check\"\u003e📊 SPA vs MPA: a performance reality check\u003c/h2\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eAverage Next.js marketing site\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJS bundle: 1 – 3MB\u003c/li\u003e\n\n\n\n\u003cli\u003eTTI: ~3.5 – 5s (depending on hydration strategy)\u003c/li\u003e\n\n\n\n\u003cli\u003eRoute transitions: simulated\u003c/li\u003e\n\n\n\n\u003cli\u003eSEO: complex, fragile\u003c/li\u003e\n\n\n\n\u003cli\u003eScroll/anchor behaviour: unreliable\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eModern MPA + View Transitions + Speculation Rules\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJS bundle: 0KB (optional enhancements only)\u003c/li\u003e\n\n\n\n\u003cli\u003eTTI: ~1s\u003c/li\u003e\n\n\n\n\u003cli\u003eRoute transitions: real, native\u003c/li\u003e\n\n\n\n\u003cli\u003eSEO: trivial\u003c/li\u003e\n\n\n\n\u003cli\u003eScroll/focus/history: browser-default and perfect\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eModern CSS doesn’t just replace SPA behaviour – it \u003cem\u003eoutperforms\u003c/em\u003e it.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-don-t-build-a-website-like-it-s-an-app\"\u003eDon’t build a website like it’s an app\u003c/h2\u003e\n\n\n\n\u003cp\u003eMost websites aren’t apps.\u003c/p\u003e\n\n\n\n\u003cp\u003eThey don’t need shared state. They don’t need client-side routing. They don’t need interactive components on every screen. But somewhere along the way, we stopped making the distinction.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow we’re building ecommerce stores, documentation portals, marketing sites, and blogs using stacks designed for real-time collaborative UIs. It’s madness.\u003c/p\u003e\n\n\n\n\u003cp\u003eA homepage with six content blocks and a contact form doesn’t need hydration, suspense boundaries, and a rendering strategy.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt needs fast markup, clean URLs, and maybe – maybe – a bit of interactivity layered on top.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd yet, on every project:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eA stakeholder says, “make it feel like an app.”\u003c/li\u003e\n\n\n\n\u003cli\u003eA dev team reaches for Next.js or Nuxt.\u003c/li\u003e\n\n\n\n\u003cli\u003eRouting goes client-side.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerformance falls off a cliff.\u003c/li\u003e\n\n\n\n\u003cli\u003eNow you need edge functions, streaming, ISR, loading strategies, and a debugging plan.\u003c/li\u003e\n\n\n\n\u003cli\u003eAnd somehow… it \u003cem\u003estill\u003c/em\u003e feels slower than a regular link click and a CSS animation.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThis isn’t about being anti-framework. It’s about being intentional.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse React if you want. Use Tailwind, Vite, whatever. Just don’t ship it all to the browser unless you \u003cem\u003eneed\u003c/em\u003e to.\u003c/p\u003e\n\n\n\n\u003cp\u003eBuild a site like a site. Use HTML. Use navigation. Use the platform.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt’s faster, simpler, and better for everyone.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-build-for-the-web-we-have\"\u003eBuild for the web we have\u003c/h2\u003e\n\n\n\n\u003cp\u003eSPAs were a clever solution to a temporary limitation. But that limitation no longer exists.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe now have:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eNative, declarative transitions between real pages\u003c/li\u003e\n\n\n\n\u003cli\u003eInstantaneous prerendered navigation via Speculation Rules\u003c/li\u003e\n\n\n\n\u003cli\u003eGraceful degradation\u003c/li\u003e\n\n\n\n\u003cli\u003eClean markup, fast loads, and real URLs\u003c/li\u003e\n\n\n\n\u003cli\u003eA platform that \u003cem\u003ewants\u003c/em\u003e to help – if we let it\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf you’re still building your site as an SPA for the sake of “smoothness,” you’re solving a problem the browser already fixed – and you’re paying for it in complexity, performance, and maintainability.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse modern server rendering. Use actual pages. Animate with CSS. Preload with intent. Ship less JavaScript.\u003c/p\u003e\n\n\n\n\u003cp\u003eBuild like it’s 2025 – not like you’re trapped in a 2018 demo of Gatsby.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou’ll end up with faster sites, happier users, and fewer regrets.\u003c/p\u003e\n    \n    \n    \n    \n    \t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-07-24T21:07:49Z",
  "modifiedTime": "2025-07-25T09:37:56Z"
}
