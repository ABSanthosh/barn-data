{
  "id": "ac45263b-828d-42ba-8ace-b7d6fcc20e82",
  "title": "Five Unusual Raku Features",
  "link": "https://buttondown.com/hillelwayne/archive/five-unusual-raku-features/",
  "description": "Comments",
  "author": "",
  "published": "Tue, 12 Nov 2024 21:48:05 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Computer Things",
  "length": 11102,
  "excerpt": "Junctions, whatevers, hypers, and more!",
  "siteName": "Computer Things",
  "favicon": "https://buttondown.com/static/images/icons/icon@72.png",
  "text": "November 12, 2024 Junctions, whatevers, hypers, and more! Logic for Programmers is now in Beta! v0.5 marks the official end of alpha! With the new version, all of the content I wanted to put in the book is now present, and all that's left is copyediting, proofreading, and formatting. Which will probably take as long as it took to actually write the book. You can see the release notes on the leanpub page. And I've got a snazzy new cover: (I don't actually like the cover that much but it looks official enough until I can pay an actual cover designer.) \"Five\" Unusual Raku Features Last year I started learning Raku, and the sheer bizarreness of the language left me describing it as a language for gremlins. Now that I've used it in anger for over a year, I have a better way of describing it: Raku is a laboratory for language features. This is why it has five different models of concurrency and eighteen ways of doing anything else, because the point is to see what happens. It also explains why many of the features interact so strangely and why there's all that odd edge-case behavior. Getting 100 experiments polished and playing nicely with each other is much harder than running 100 experiments; we can sort out the polish after we figure out which ideas are good ones. So here are \"five\" Raku experiments you could imagine seeing in another programming language. If you squint. Junctions Junctions are \"superpositions of possible values\". Applying an operation to a junction instead applies it to every value inside the junction. \u003e 2|10 any(2, 10) \u003e 2\u002610 + 3 all(5, 13) \u003e(1\u00262) + (10^20) all(one(11, 21), one(12, 22)) As you can probably tell from the alls and anys, junctions are a feature meant for representing boolean formula. There's no way to destructure a junction, and the only way to use it is to collapse it to a boolean first. \u003e (1\u00262) + (10^20) \u003c 15 all(one(True, False), one(True, False)) # so coerces junctions to booleans \u003e so (1\u00262) + (10^20) \u003c 15 True \u003e so (1\u00262) + (10^20) \u003e 0 False \u003e 16 %% (3\u00265) ?? \"fizzbuzz\" !! * * The real interesting thing for me is how Raku elegantly uses junctions to represent quantifiers. In most languages, you either have the function all(list[T], T -\u003e bool) or the method [T].all(T -\u003e bool), both of which apply the test to every element of the list. In Raku, though, list.all doesn't take anything, it's just a niladic method that turns the list into a junction. \u003e my $x = \u003c1 2 3\u003e.all all(1, 2, 3) \u003e is-prime($x) all(False, True, True) This means we can combine junctions. If Raku didn't already have a unique method, we could build it by saying \"are all elements equal to exactly one element?\" \u003e so {.all == .one}(\u003c1 2 3 7\u003e) True \u003e so {.all == .one}(\u003c1 2 3 7 2\u003e) False Whatevers * is the \"whatever\" symbol and has a lot of different roles in Raku.1 Some functions and operators have special behavior when passed a *. In a range or sequence, * means \"unbound\". \u003e 1..* 1..Inf \u003e (2,4,8...*)[17] 262144 The main built-in use, though, is that expressions with * are lifted into anonymous functions. This is called \"whatever-priming\" and produces a WhateverCode, which is indistinguishable from other functions except for the type. \u003e {$_ + 10}(2) 12 \u003e (* + 10)(2) 12 \u003e (^10).map(* % 2) (0 1 0 1 0 1 0 1 0 1) There's actually a bit of weird behavior here: if two whatevers appear in the expression, they become separate positional variables. (2, 30, 4, 50).map(* + *) returns (32, 45). This makes it easy to express a tricky Fibonacci definition but otherwise I don't see how it's better than making each * the same value. Regardless, priming is useful because so many Raku methods are overloaded to take functions. You get the last element of a list with l[*-1]. This looks like standard negative-index syntax, but what actually happens is that when [] is passed a function, it passes in list length and looks up the result. So if the list has 10 elements, l[*-1] = l[10-1] = l[9], aka the last element. Similarly, l.head(2) is the first two elements of a list, l.head(*-2) is all-but-the-last-two. We can pass other functions to [], which e.g. makes implementing ring buffers easy. \u003e my @x = ^10 [0 1 2 3 4 5 6 7 8 9] \u003e @x[95 % *]--; @x [0 1 2 3 4 4 6 7 8 9] Regular Expressions There are two basic standards for regexes: POSIX regexes and Perl-compatible regexes (PCRE). POSIX regexes are a terrible mess of backslashes and punctuation. PCRE is backwards compatible with POSIX and is a more terrible mess of backslashes and punctuation. Most languages follow the PCRE standard, but Perl 6 breaks backwards compatibility with an entirely new regex syntax. The most obvious improvement: composability. In most languages \"combine\" two regexes by concating their strings together, which is terrible for many, many reasons. Raku has the standard \"embed another regex\" syntax: /\u003c foo \u003e+/ matches one-or-more of the foo regex without foo \"leaking\" into the top regex. This already does a lot to make regexes more tractable: you can break a complicated regular expression down into simpler and more legible parts. And in fact this is how Raku supports parsing grammars as a builtin language feature. I've only used grammars once but it was quite helpful. Since we're breaking backwards compatibility anyway, we can now add lots of small QOLs. There's a value separator modifier: \\d+ % ',' matches 1 / 1,2 / 1,1,4 but not 1, or 12. Lookaheads and non-capturing groups aren't nonsense glyphs. r1 \u0026\u0026 r2 only matches strings that match both r1 and r2. Backtracking can be stopped with :. Whitespace is ignored by default and has to be explicitly enabled in match patterns. There's more stuff Raku does with actually processing regular expressions, but the regex notation is something that might actually appear in another language someday. Hyperoperators This is a small one compared to the other features, but it's also the thing I miss most often in other languages. The most basic form l\u003e\u003e.method is basically equivalent to map, except it also recursively descends into sublists. \u003e [1, [2, 3], 4]\u003e\u003e.succ [2 [3 4] 5] This is more useful than it looks because any function call f(list, *args) can be rewritten in \"method form\" list.\u0026f(*args), so \u003e\u003e. becomes the generalized mapping operator. You can use it with whatevers, too. \u003e [1, [2, 3], 4]\u003e\u003e.\u0026(*+1) [2 [3 4] 5] Anyway, the more generalized binary hyperoperator l1 \u003c\u003c op \u003e\u003e l22 applies op elementwise to the two lists, looping the shorter list until the longer list is exhausted. \u003e\u003eop\u003e\u003e / \u003c\u003c op\u003c\u003c are the same except they instead loop until the lhs/rhs list is exhausted. Whew! \u003e [1, 2, 3, 4, 5] \u003c\u003c+\u003e\u003e [10, 20] [11 22 13 24 15] \u003e [1, 2, 3, 4, 5] \u003c\u003c+\u003c\u003c [10, 20] [11 22] \u003e [1, 2, 3, 4, 5] \u003e\u003e+\u003e\u003e [10, 20] [11 22 13 24 15] # Also works with single values \u003e [1, 2, 3, 4, 5] \u003c\u003c+\u003e\u003e 10 [11 12 13 14 15] # Does weird things with nested lists too \u003e [1, [2, 3], 4, 5] \u003c\u003c+\u003e\u003e [10, 20] [11 [22 23] 14 25] Also for some reason the hyperoperators have separate behaviors on two hashes, either applying op to the union/intersection/hash difference. Anyway it's a super weird (meta)operator but it's also quite useful! It's the closest thing I've seen to J verbs outside an APL. I like using it to run the same formula on multiple possible inputs at once. (20 * 10 \u003c\u003c-\u003e\u003e (21, 24)) \u003c\u003c*\u003e\u003e (10, 100) (1790 17600) Incidentally, it's called the hyperoperator because it evaluates all of the operations in parallel. Explicit loops can be parallelized by prefixing them with hyper. Pair Syntax I've talked about pairs a little in this newsletter, but the gist is that Raku hashes are composed of a set of pairs key =\u003e value. The pair is the basis type, the hash is the collection of pairs. There's also a ton of syntactic sugar for concisely specifying pairs via \"colon syntax\": \u003e my $x = 3; :$x x =\u003e 3 \u003e :a\u003c$x\u003e a =\u003e \"$x\" \u003e :a($x) a =\u003e 3 \u003e :3a a =\u003e 3 The most important sugars are :key and :!key, which map to key =\u003e True and key =\u003e False. This is a really elegant way to add flags to a methods! Take the definition of match: method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --\u003e Match) Probably should also mention that in a definition, :f(:$foo) defines the parameter $foo but also aliases it to :f, so you can set the flag with :f or :foo. Colon-pairs defined in the signature can be passed in anywhere, or even stuck together: \u003e \"abab\".match(/../) ｢ab｣ \u003e \"abab\".match(/../, :g) (｢ab｣ ｢ab｣) \u003e \"abab\".match(/../, :g, :ov) (｢ab｣ ｢ba｣ ｢ab｣) # Out of order stuck together \u003e \"abab\".match(:g:ov, /../) (｢ab｣ ｢ba｣ ｢ab｣) So that leads to extremely concise method configuration. Definitely beats match(global=True, overlap=True)! And for some reason you can place keyword arguments after the function call: \u003e \"abab\".match(:g, /../):ov:2nd ｢ba｣ The next-gen lab: Slangs and RakuAST These are features I have no experience in and certainly are not making their way into other languages, but they really expand the explorable space of new features. Slangs are modifications to the Raku syntax. This can be used for things like modifying loop syntax, changing identifiers, or adding actors or DNA sequences to the base language. I barely understand RakuAST. I think the idea is that all Raku expressions can be parsed as an AST from inside Raku itself. \u003e Q/my $x; $x++/.AST RakuAST::StatementList.new( RakuAST::Statement::Expression.new( expression =\u003e RakuAST::VarDeclaration::Simple.new( sigil =\u003e \"\\$\", desigilname =\u003e RakuAST::Name.from-identifier(\"x\") ) ), RakuAST::Statement::Expression.new( expression =\u003e RakuAST::ApplyPostfix.new( operand =\u003e RakuAST::Var::Lexical.new(\"\\$x\"), postfix =\u003e RakuAST::Postfix.new(\"++\") ) ) ) This allows for things like writing Raku in different languages: say Q/my $x; put $x/.AST.DEPARSE(\"NL\") mijn $x; zeg-het $x Bonus experiment Raku comes with a \"Rakudo Star\" installation, which comes with a set of blessed third party modules preinstalled. I love this! It's a great compromise between the maintainer burdens of a large standard library and the user burdens of making everybody find the right packages in the ecosystem. Blog Rec Feel obligated to recommend some Raku blogs! Elizabeth Mattijsen posts a ton of stuff to dev.to about Raku internals. Codesections has a pretty good blog; he's the person who eventually got me to try out Raku. Finally, the Raku Advent Calendar is a great dive into advanced Raku techniques. Bad news is it only updates once a year, good news is it's 25 updates that once a year. If you're reading this on the web, you can subscribe here. Updates are once a week. My main website is here. My new book, Logic for Programmers, is now in early access! Get it here.",
  "image": "https://image-generator.buttondown.email/api/emphasize-subject?subject=Five%20Unusual%20Raku%20Features\u0026author=Computer%20Things\u0026date=2024-11-12\u0026img=",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n                \n                    \u003cdate\u003e\n                        \n                            November 12, 2024\n                        \u003c/date\u003e\n                \n                \n                \n                    \u003ch2\u003e\n                        Junctions, whatevers, hypers, and more!\n                    \u003c/h2\u003e\n                \n\n                \n\n                \n                    \n                        \u003ch3\u003e\u003cem\u003eLogic for Programmers\u003c/em\u003e is now in Beta!\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://leanpub.com/logic/\" target=\"_blank\"\u003ev0.5 marks the official end of alpha\u003c/a\u003e! With the new version, all of the content I wanted to put in the book is now present, and all that\u0026#39;s left is copyediting, proofreading, and formatting. Which will probably take as long as it took to actually write the book. You can see the release notes on the leanpub page.\u003c/p\u003e\n\u003cp\u003eAnd I\u0026#39;ve got a snazzy new cover:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"The logic for programmers cover, a 40x zoom of a bird feather\" src=\"https://assets.buttondown.email/images/26c75f1e-e60a-4328-96e5-9878d96d3e53.png?w=960\u0026amp;fit=max\"/\u003e\u003c/p\u003e\n\u003cp\u003e(I don\u0026#39;t actually like the cover that much but it \u003cem\u003elooks\u003c/em\u003e official enough until I can pay an actual cover designer.)\u003c/p\u003e\n\u003ch2\u003e\u0026#34;Five\u0026#34; Unusual Raku Features\u003c/h2\u003e\n\u003cp\u003eLast year I started learning Raku, and the sheer bizarreness of the language left me describing it as \u003ca href=\"https://buttondown.com/hillelwayne/archive/raku-a-language-for-gremlins/\" target=\"_blank\"\u003ea language for gremlins\u003c/a\u003e. Now that I\u0026#39;ve used it in anger for over a year, I have a better way of describing it:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRaku is a laboratory for language features.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is why it has \u003ca href=\"https://docs.raku.org/language/concurrency\" target=\"_blank\"\u003efive different models of concurrency\u003c/a\u003e and eighteen ways of doing anything else, because the point is to \u003cem\u003esee\u003c/em\u003e what happens. It also explains why many of the features interact so strangely and why there\u0026#39;s all that odd edge-case behavior. Getting 100 experiments polished and playing nicely with each other is much harder than running 100 experiments; we can sort out the polish \u003cem\u003eafter\u003c/em\u003e we figure out which ideas are good ones.\u003c/p\u003e\n\u003cp\u003eSo here are \u0026#34;five\u0026#34; Raku experiments you could imagine seeing in another programming language. If you squint.\u003c/p\u003e\n\u003ch3\u003e\u003ca href=\"https://docs.raku.org/type/Junction\" target=\"_blank\"\u003eJunctions\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJunctions are \u0026#34;superpositions of possible values\u0026#34;. Applying an operation to a junction instead applies it to every value inside the junction.  \u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\n\u003cspan\u003eany\u003c/span\u003e(\u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e10\u003c/span\u003e)\n\n\u0026gt; \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e\u0026amp;10\u003c/span\u003e + \u003cspan\u003e3\u003c/span\u003e\n\u003cspan\u003eall\u003c/span\u003e(\u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e13\u003c/span\u003e)\n\n\u0026gt;(\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u0026amp;2\u003c/span\u003e) + (\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e)\n\u003cspan\u003eall\u003c/span\u003e(\u003cspan\u003eone\u003c/span\u003e(\u003cspan\u003e11\u003c/span\u003e, \u003cspan\u003e21\u003c/span\u003e), \u003cspan\u003eone\u003c/span\u003e(\u003cspan\u003e12\u003c/span\u003e, \u003cspan\u003e22\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAs you can probably tell from the \u003ccode\u003eall\u003c/code\u003es and \u003ccode\u003eany\u003c/code\u003es, junctions are a feature meant for representing boolean formula. There\u0026#39;s no way to destructure a junction, and the only way to use it is to collapse it to a boolean first.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; (\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u0026amp;2\u003c/span\u003e) + (\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e) \u0026lt; \u003cspan\u003e15\u003c/span\u003e\n\u003cspan\u003eall\u003c/span\u003e(\u003cspan\u003eone\u003c/span\u003e(\u003cspan\u003eTrue\u003c/span\u003e, \u003cspan\u003eFalse\u003c/span\u003e), \u003cspan\u003eone\u003c/span\u003e(\u003cspan\u003eTrue\u003c/span\u003e, \u003cspan\u003eFalse\u003c/span\u003e))\n\n\u003cspan\u003e# so coerces junctions to booleans\u003c/span\u003e\n\u0026gt; \u003cspan\u003eso\u003c/span\u003e (\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u0026amp;2\u003c/span\u003e) + (\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e) \u0026lt; \u003cspan\u003e15\u003c/span\u003e\n\u003cspan\u003eTrue\u003c/span\u003e\n\n\u0026gt; \u003cspan\u003eso\u003c/span\u003e (\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e\u0026amp;2\u003c/span\u003e) + (\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e\u003cspan\u003e20\u003c/span\u003e) \u0026gt; \u003cspan\u003e0\u003c/span\u003e\n\u003cspan\u003eFalse\u003c/span\u003e\n\n\u0026gt; \u003cspan\u003e16\u003c/span\u003e %% (\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e\u0026amp;5\u003c/span\u003e) ?? \u003cspan\u003e\u0026#34;fizzbuzz\u0026#34;\u003c/span\u003e !! *\n*\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe real interesting thing for me is how Raku elegantly uses junctions to represent quantifiers. In most languages, you either have the function \u003ccode\u003eall(list[T], T -\u0026gt; bool)\u003c/code\u003e or the method \u003ccode\u003e[T].all(T -\u0026gt; bool)\u003c/code\u003e, both of which apply the test to every element of the list. In Raku, though, \u003ccode\u003elist.all\u003c/code\u003e doesn\u0026#39;t take \u003cem\u003eanything\u003c/em\u003e, it\u0026#39;s just a niladic method that turns the list into a junction. \u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003emy\u003c/span\u003e \u003cspan\u003e$x\u003c/span\u003e = \u003cspan\u003e\u0026lt;1 2 3\u0026gt;\u003c/span\u003e.\u003cspan\u003eall\u003c/span\u003e\n\u003cspan\u003eall\u003c/span\u003e(\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e)\n\u0026gt; \u003cspan\u003eis-prime\u003c/span\u003e(\u003cspan\u003e$x\u003c/span\u003e)\n\u003cspan\u003eall\u003c/span\u003e(\u003cspan\u003eFalse\u003c/span\u003e, \u003cspan\u003eTrue\u003c/span\u003e, \u003cspan\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis means we can combine junctions. If Raku didn\u0026#39;t already have a \u003ccode\u003eunique\u003c/code\u003e method, we could build it by saying \u0026#34;are all elements equal to exactly one element?\u0026#34;\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003eso\u003c/span\u003e {.\u003cspan\u003eall\u003c/span\u003e == .\u003cspan\u003eone\u003c/span\u003e}(\u003cspan\u003e\u0026lt;1 2 3 7\u0026gt;\u003c/span\u003e)\n\u003cspan\u003eTrue\u003c/span\u003e\n\n\u0026gt; \u003cspan\u003eso\u003c/span\u003e {.\u003cspan\u003eall\u003c/span\u003e == .\u003cspan\u003eone\u003c/span\u003e}(\u003cspan\u003e\u0026lt;1 2 3 7 2\u0026gt;\u003c/span\u003e)\n\u003cspan\u003eFalse\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003e\u003ca href=\"https://docs.raku.org/type/Whatever\" target=\"_blank\"\u003eWhatevers\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e is the \u0026#34;whatever\u0026#34; symbol and has a lot of different roles in Raku.\u003csup id=\"fnref:analogs\"\u003e\u003ca href=\"#fn:analogs\"\u003e1\u003c/a\u003e\u003c/sup\u003e Some functions and operators have special behavior when passed a \u003ccode\u003e*\u003c/code\u003e. In a range or sequence, \u003ccode\u003e*\u003c/code\u003e means \u0026#34;unbound\u0026#34;.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003e1\u003c/span\u003e..*\n\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003eInf\u003c/span\u003e\n\n\u0026gt; (\u003cspan\u003e2\u003c/span\u003e,\u003cspan\u003e4\u003c/span\u003e,\u003cspan\u003e8\u003c/span\u003e...*)[\u003cspan\u003e17\u003c/span\u003e]\n\u003cspan\u003e262144\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe main built-in use, though, is that expressions with \u003ccode\u003e*\u003c/code\u003e are lifted into anonymous functions. This is called \u0026#34;whatever-priming\u0026#34; and produces a \u003ccode\u003eWhateverCode\u003c/code\u003e, which is indistinguishable from other functions except for the type.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; {\u003cspan\u003e$_\u003c/span\u003e + \u003cspan\u003e10\u003c/span\u003e}(\u003cspan\u003e2\u003c/span\u003e)\n\u003cspan\u003e12\u003c/span\u003e\n\n\u0026gt; (* + \u003cspan\u003e10\u003c/span\u003e)(\u003cspan\u003e2\u003c/span\u003e)\n\u003cspan\u003e12\u003c/span\u003e\n\n\u0026gt; (^\u003cspan\u003e10\u003c/span\u003e).\u003cspan\u003emap\u003c/span\u003e(* % \u003cspan\u003e2\u003c/span\u003e)\n(\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThere\u0026#39;s actually a bit of weird behavior here: if \u003cem\u003etwo\u003c/em\u003e whatevers appear in the expression, they become separate positional variables. \u003ccode\u003e(2, 30, 4, 50).map(* + *)\u003c/code\u003e returns \u003ccode\u003e(32, 45)\u003c/code\u003e. This makes it easy to express \u003ca href=\"https://docs.raku.org/language/operators#infix_...\" target=\"_blank\"\u003ea tricky Fibonacci definition\u003c/a\u003e but otherwise I don\u0026#39;t see how it\u0026#39;s better than making each \u003ccode\u003e*\u003c/code\u003e the same value.\u003c/p\u003e\n\u003cp\u003eRegardless, priming is useful because \u003cem\u003eso many\u003c/em\u003e Raku methods are overloaded to take functions. You get the last element of a list with \u003ccode\u003el[*-1]\u003c/code\u003e. This \u003cem\u003elooks\u003c/em\u003e like standard negative-index syntax, but what actually happens is that when \u003ccode\u003e[]\u003c/code\u003e is passed a function, it passes in list length and looks up the result. So if the list has 10 elements, \u003ccode\u003el[*-1] = l[10-1] = l[9]\u003c/code\u003e, aka the last element. Similarly, \u003ccode\u003el.head(2)\u003c/code\u003e is the first two elements of a list, \u003ccode\u003el.head(*-2)\u003c/code\u003e is all-but-the-last-two.\u003c/p\u003e\n\u003cp\u003eWe can pass other functions to \u003ccode\u003e[]\u003c/code\u003e, which e.g. makes implementing ring buffers easy.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003emy\u003c/span\u003e \u003cspan\u003e@x\u003c/span\u003e = ^\u003cspan\u003e10\u003c/span\u003e\n[\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e \u003cspan\u003e7\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e]\n\n\u0026gt; \u003cspan\u003e@x\u003c/span\u003e[\u003cspan\u003e95\u003c/span\u003e % *]--; \u003cspan\u003e@x\u003c/span\u003e\n[\u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e \u003cspan\u003e7\u003c/span\u003e \u003cspan\u003e8\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003e\u003ca href=\"https://docs.raku.org/language/regexes\" target=\"_blank\"\u003eRegular Expressions\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere are two basic standards for regexes: POSIX regexes and Perl-compatible regexes (PCRE). POSIX regexes are a terrible mess of backslashes and punctuation. PCRE is backwards compatible with POSIX and is a more terrible mess of backslashes and punctuation. Most languages follow the PCRE standard, but Perl 6 breaks backwards compatibility with an entirely new regex syntax. \u003c/p\u003e\n\u003cp\u003eThe most obvious improvement: \u003ca href=\"https://docs.raku.org/language/regexes#Subrules\" target=\"_blank\"\u003ecomposability\u003c/a\u003e. In most languages  \u0026#34;combine\u0026#34; two regexes by concating their strings together, which is terrible for many, many reasons. Raku has the standard \u0026#34;embed another regex\u0026#34; syntax: \u003ccode\u003e/\u0026lt; foo \u0026gt;+/\u003c/code\u003e matches one-or-more of the \u003ccode\u003efoo\u003c/code\u003e regex without \u003ccode\u003efoo\u003c/code\u003e \u0026#34;leaking\u0026#34; into the top regex. \u003c/p\u003e\n\u003cp\u003eThis already does a lot to make regexes more tractable: you can break a complicated regular expression down into simpler and more legible parts. And in fact this is how Raku supports \u003ca href=\"https://docs.raku.org/language/grammars\" target=\"_blank\"\u003eparsing grammars\u003c/a\u003e as a builtin language feature. I\u0026#39;ve only used grammars once but it \u003ca href=\"https://www.hillelwayne.com/post/picat/\" target=\"_blank\"\u003ewas quite helpful\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSince we\u0026#39;re breaking backwards compatibility anyway, we can now add lots of small QOLs. There\u0026#39;s a \u003ca href=\"https://docs.raku.org/language/regexes#Modified_quantifier:_%,_%%\" target=\"_blank\"\u003evalue separator\u003c/a\u003e modifier: \u003ccode\u003e\\d+ % \u0026#39;,\u0026#39;\u003c/code\u003e matches \u003ccode\u003e1\u003c/code\u003e / \u003ccode\u003e1,2\u003c/code\u003e / \u003ccode\u003e1,1,4\u003c/code\u003e but not \u003ccode\u003e1,\u003c/code\u003e or \u003ccode\u003e12\u003c/code\u003e. \u003ca href=\"https://docs.raku.org/language/regexes#Lookaround_assertions\" target=\"_blank\"\u003eLookaheads\u003c/a\u003e and non-capturing groups aren\u0026#39;t nonsense glyphs. \u003ccode\u003er1 \u0026amp;\u0026amp; r2\u003c/code\u003e only matches strings that match \u003cem\u003eboth\u003c/em\u003e \u003ccode\u003er1\u003c/code\u003e and \u003ccode\u003er2\u003c/code\u003e. Backtracking can be stopped with \u003ca href=\"https://docs.raku.org/language/regexes#Preventing_backtracking:_:\" target=\"_blank\"\u003e:\u003c/a\u003e. Whitespace is ignored by default and has to be explicitly enabled in match patterns.\u003c/p\u003e\n\u003cp\u003eThere\u0026#39;s more stuff Raku does with actually \u003cem\u003eprocessing\u003c/em\u003e regular expressions, but the regex notation is something that might actually appear in another language someday. \u003c/p\u003e\n\n\u003ch3\u003e\u003ca href=\"https://docs.raku.org/language/operators#Hyper_operators\" target=\"_blank\"\u003eHyperoperators\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThis is a small one compared to the other features, but it\u0026#39;s also the thing I miss most often in other languages. The most basic form \u003ccode\u003el\u0026gt;\u0026gt;.method\u003c/code\u003e is basically equivalent to \u003ccode\u003emap\u003c/code\u003e, except it also recursively descends into sublists.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, [\u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e], \u003cspan\u003e4\u003c/span\u003e]\u0026gt;\u0026gt;.\u003cspan\u003esucc\u003c/span\u003e\n[\u003cspan\u003e2\u003c/span\u003e [\u003cspan\u003e3\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e] \u003cspan\u003e5\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is more useful than it looks because any function call \u003ccode\u003ef(list, *args)\u003c/code\u003e can be rewritten in \u0026#34;method form\u0026#34; \u003ccode\u003elist.\u0026amp;f(*args)\u003c/code\u003e, so \u003ccode\u003e\u0026gt;\u0026gt;.\u003c/code\u003e becomes the generalized mapping operator. You can use it with whatevers, too.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, [\u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e], \u003cspan\u003e4\u003c/span\u003e]\u0026gt;\u0026gt;.\u0026amp;(*+\u003cspan\u003e1\u003c/span\u003e)\n[\u003cspan\u003e2\u003c/span\u003e [\u003cspan\u003e3\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e] \u003cspan\u003e5\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnyway, the more generalized \u003cem\u003ebinary\u003c/em\u003e hyperoperator \u003ccode\u003el1 \u0026lt;\u0026lt; op \u0026gt;\u0026gt; l2\u003c/code\u003e\u003csup id=\"fnref:spaces\"\u003e\u003ca href=\"#fn:spaces\"\u003e2\u003c/a\u003e\u003c/sup\u003e applies \u003ccode\u003eop\u003c/code\u003e elementwise to the two lists, looping the shorter list until the longer list is exhausted. \u003ccode\u003e\u0026gt;\u0026gt;op\u0026gt;\u0026gt;\u003c/code\u003e / \u003ccode\u003e\u0026lt;\u0026lt; op\u0026lt;\u0026lt;\u003c/code\u003e are the same except they instead loop until the lhs/rhs list is exhausted. Whew!\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e] \u003cspan\u003e\u0026lt;\u0026lt;+\u0026gt;\u003c/span\u003e\u0026gt; [\u003cspan\u003e10\u003c/span\u003e, \u003cspan\u003e20\u003c/span\u003e]\n[\u003cspan\u003e11\u003c/span\u003e \u003cspan\u003e22\u003c/span\u003e \u003cspan\u003e13\u003c/span\u003e \u003cspan\u003e24\u003c/span\u003e \u003cspan\u003e15\u003c/span\u003e]\n\n\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e] \u003cspan\u003e\u0026lt;\u0026lt;+\u0026lt;\u0026lt; [10, 20]\u003c/span\u003e\n\u003cspan\u003e[11 22]\u003c/span\u003e\n\n\u003cspan\u003e\u0026gt; [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u003c/span\u003e+\u0026gt;\u0026gt; [\u003cspan\u003e10\u003c/span\u003e, \u003cspan\u003e20\u003c/span\u003e]\n[\u003cspan\u003e11\u003c/span\u003e \u003cspan\u003e22\u003c/span\u003e \u003cspan\u003e13\u003c/span\u003e \u003cspan\u003e24\u003c/span\u003e \u003cspan\u003e15\u003c/span\u003e]\n\n\u003cspan\u003e# Also works with single values\u003c/span\u003e\n\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e] \u003cspan\u003e\u0026lt;\u0026lt;+\u0026gt;\u003c/span\u003e\u0026gt; \u003cspan\u003e10\u003c/span\u003e\n[\u003cspan\u003e11\u003c/span\u003e \u003cspan\u003e12\u003c/span\u003e \u003cspan\u003e13\u003c/span\u003e \u003cspan\u003e14\u003c/span\u003e \u003cspan\u003e15\u003c/span\u003e]\n\n\u003cspan\u003e# Does weird things with nested lists too\u003c/span\u003e\n\u0026gt; [\u003cspan\u003e1\u003c/span\u003e, [\u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e], \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e] \u003cspan\u003e\u0026lt;\u0026lt;+\u0026gt;\u003c/span\u003e\u0026gt; [\u003cspan\u003e10\u003c/span\u003e, \u003cspan\u003e20\u003c/span\u003e]\n[\u003cspan\u003e11\u003c/span\u003e [\u003cspan\u003e22\u003c/span\u003e \u003cspan\u003e23\u003c/span\u003e] \u003cspan\u003e14\u003c/span\u003e \u003cspan\u003e25\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAlso for some reason the hyperoperators have separate behaviors on two hashes, either applying \u003ccode\u003eop\u003c/code\u003e to the union/intersection/hash difference. \u003c/p\u003e\n\u003cp\u003eAnyway it\u0026#39;s a super weird (meta)operator but it\u0026#39;s also quite useful! It\u0026#39;s the closest thing I\u0026#39;ve seen to \u003ca href=\"https://hillelwayne.com/post/j-notation/\" target=\"_blank\"\u003eJ verbs\u003c/a\u003e outside an APL. I like using it to run the same formula on multiple possible inputs at once.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e(\u003cspan\u003e20\u003c/span\u003e * \u003cspan\u003e10\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;-\u0026gt;\u003c/span\u003e\u0026gt; (\u003cspan\u003e21\u003c/span\u003e, \u003cspan\u003e24\u003c/span\u003e)) \u003cspan\u003e\u0026lt;\u0026lt;*\u0026gt;\u003c/span\u003e\u0026gt; (\u003cspan\u003e10\u003c/span\u003e, \u003cspan\u003e100\u003c/span\u003e)\n(\u003cspan\u003e1790\u003c/span\u003e \u003cspan\u003e17600\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIncidentally, it\u0026#39;s called the hyperoperator because it evaluates all of the operations in parallel. Explicit loops can be parallelized by prefixing them with \u003ca href=\"https://docs.raku.org/language/statement-prefixes#hyper,_race\" target=\"_blank\"\u003e\u003ccode\u003ehyper\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003e\u003ca href=\"https://docs.raku.org/type/Pair\" target=\"_blank\"\u003ePair Syntax\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI\u0026#39;ve talked about pairs a little in \u003ca href=\"https://buttondown.com/hillelwayne/archive/unusual-basis-types-in-programming-languages/\" target=\"_blank\"\u003ethis newsletter\u003c/a\u003e, but the gist is that Raku hashes are composed of a set of pairs \u003ccode\u003ekey =\u0026gt; value\u003c/code\u003e. The pair is the basis type, the hash is the collection of pairs. There\u0026#39;s also a \u003cem\u003eton\u003c/em\u003e of syntactic sugar for concisely specifying pairs via \u0026#34;colon syntax\u0026#34;:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003emy\u003c/span\u003e \u003cspan\u003e$x\u003c/span\u003e = \u003cspan\u003e3\u003c/span\u003e; :\u003cspan\u003e$x\u003c/span\u003e\n\u003cspan\u003ex\u003c/span\u003e =\u0026gt; \u003cspan\u003e3\u003c/span\u003e\n\n\u0026gt; :\u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e\u0026lt;$x\u0026gt;\u003c/span\u003e\n\u003cspan\u003ea\u003c/span\u003e =\u0026gt; \u003cspan\u003e\u0026#34;$x\u0026#34;\u003c/span\u003e\n\n\u0026gt; :\u003cspan\u003ea\u003c/span\u003e(\u003cspan\u003e$x\u003c/span\u003e)\n\u003cspan\u003ea\u003c/span\u003e =\u0026gt; \u003cspan\u003e3\u003c/span\u003e\n\n\u0026gt; :\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003ea\u003c/span\u003e\n\u003cspan\u003ea\u003c/span\u003e =\u0026gt; \u003cspan\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe most important sugars are \u003ccode\u003e:key\u003c/code\u003e and \u003ccode\u003e:!key\u003c/code\u003e, which map to \u003ccode\u003ekey =\u0026gt; True\u003c/code\u003e and \u003ccode\u003ekey =\u0026gt; False\u003c/code\u003e. This is a really elegant way to add flags to a methods! Take the definition of \u003ca href=\"https://docs.raku.org/type/Str#method_match\" target=\"_blank\"\u003ematch\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003emethod\u003c/span\u003e \u003cspan\u003ematch\u003c/span\u003e(\u003cspan\u003e$pat\u003c/span\u003e, \n    :\u003cspan\u003econtinue\u003c/span\u003e(:\u003cspan\u003e$c\u003c/span\u003e), :\u003cspan\u003epos\u003c/span\u003e(:\u003cspan\u003e$p\u003c/span\u003e), :\u003cspan\u003eglobal\u003c/span\u003e(:\u003cspan\u003e$g\u003c/span\u003e), \n    :\u003cspan\u003eoverlap\u003c/span\u003e(:\u003cspan\u003e$ov\u003c/span\u003e), :\u003cspan\u003eexhaustive\u003c/span\u003e(:\u003cspan\u003e$ex\u003c/span\u003e), \n    :\u003cspan\u003est\u003c/span\u003e(:\u003cspan\u003e$nd\u003c/span\u003e), :\u003cspan\u003erd\u003c/span\u003e(:\u003cspan\u003e$th\u003c/span\u003e), :\u003cspan\u003e$nth\u003c/span\u003e, :\u003cspan\u003e$x\u003c/span\u003e --\u0026gt; \u003cspan\u003eMatch\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eProbably should also mention that in a definition, \u003ccode\u003e:f(:$foo)\u003c/code\u003e defines the parameter \u003ccode\u003e$foo\u003c/code\u003e but \u003ca href=\"https://docs.raku.org/language/signatures#Argument_aliases\" target=\"_blank\"\u003ealso aliases it\u003c/a\u003e to \u003ccode\u003e:f\u003c/code\u003e, so you can set the flag with \u003ccode\u003e:f\u003c/code\u003e or \u003ccode\u003e:foo\u003c/code\u003e. Colon-pairs defined in the signature can be passed in anywhere, or even stuck together:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003e\u0026#34;abab\u0026#34;\u003c/span\u003e.\u003cspan\u003ematch\u003c/span\u003e(\u003cspan\u003e/../\u003c/span\u003e)\n｢\u003cspan\u003eab\u003c/span\u003e｣\n\u0026gt; \u003cspan\u003e\u0026#34;abab\u0026#34;\u003c/span\u003e.\u003cspan\u003ematch\u003c/span\u003e(\u003cspan\u003e/../\u003c/span\u003e, :\u003cspan\u003eg\u003c/span\u003e)\n(｢\u003cspan\u003eab\u003c/span\u003e｣ ｢\u003cspan\u003eab\u003c/span\u003e｣)\n\u0026gt; \u003cspan\u003e\u0026#34;abab\u0026#34;\u003c/span\u003e.\u003cspan\u003ematch\u003c/span\u003e(\u003cspan\u003e/../\u003c/span\u003e, :\u003cspan\u003eg\u003c/span\u003e, :\u003cspan\u003eov\u003c/span\u003e)\n(｢\u003cspan\u003eab\u003c/span\u003e｣ ｢\u003cspan\u003eba\u003c/span\u003e｣ ｢\u003cspan\u003eab\u003c/span\u003e｣)\n\n\u003cspan\u003e# Out of order stuck together\u003c/span\u003e\n\u0026gt; \u003cspan\u003e\u0026#34;abab\u0026#34;\u003c/span\u003e.\u003cspan\u003ematch\u003c/span\u003e(:\u003cspan\u003eg:ov\u003c/span\u003e,\u003cspan\u003e /../\u003c/span\u003e)\n(｢\u003cspan\u003eab\u003c/span\u003e｣ ｢\u003cspan\u003eba\u003c/span\u003e｣ ｢\u003cspan\u003eab\u003c/span\u003e｣)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSo that leads to extremely concise method configuration. Definitely beats \u003ccode\u003ematch(global=True, overlap=True)\u003c/code\u003e!\u003c/p\u003e\n\u003cp\u003eAnd for some reason you can place keyword arguments \u003cem\u003eafter\u003c/em\u003e the function call:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003e\u0026#34;abab\u0026#34;\u003c/span\u003e.\u003cspan\u003ematch\u003c/span\u003e(:\u003cspan\u003eg\u003c/span\u003e,\u003cspan\u003e /../\u003c/span\u003e):\u003cspan\u003eov:2nd\u003c/span\u003e\n｢\u003cspan\u003eba\u003c/span\u003e｣\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2\u003eThe next-gen lab: Slangs and RakuAST\u003c/h2\u003e\n\u003cp\u003eThese are features I have no experience in and \u003cem\u003ecertainly\u003c/em\u003e are not making their way into other languages, but they really expand the explorable space of new features. \u003ca href=\"https://raku.land/zef:lizmat/Slangify\" target=\"_blank\"\u003eSlangs\u003c/a\u003e are modifications to the Raku syntax. This can be used for things like \u003ca href=\"https://raku.land/zef:elcaro/Slang::Otherwise\" target=\"_blank\"\u003emodifying loop syntax\u003c/a\u003e, \u003ca href=\"https://raku.land/zef:raku-community-modules/Slang::Piersing\" target=\"_blank\"\u003echanging identifiers\u003c/a\u003e, or adding \u003ca href=\"https://raku.land/zef:raku-community-modules/OO::Actors\" target=\"_blank\"\u003eactors\u003c/a\u003e or \u003ca href=\"https://raku.land/github:MattOates/BioInfo\" target=\"_blank\"\u003eDNA sequences\u003c/a\u003e to the base language.\u003c/p\u003e\n\u003cp\u003eI \u003cem\u003ebarely\u003c/em\u003e understand \u003ca href=\"https://dev.to/lizmat/rakuast-for-early-adopters-576n\" target=\"_blank\"\u003eRakuAST\u003c/a\u003e. I \u003cem\u003ethink\u003c/em\u003e the idea is that all Raku expressions can be parsed as an AST from inside Raku itself.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u0026gt; \u003cspan\u003eQ/my $x; $x++/\u003c/span\u003e.\u003cspan\u003eAST\u003c/span\u003e\n\u003cspan\u003eRakuAST::StatementList\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\n  \u003cspan\u003eRakuAST::Statement::Expression\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\n    \u003cspan\u003eexpression\u003c/span\u003e =\u0026gt; \u003cspan\u003eRakuAST::VarDeclaration::Simple\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\n      \u003cspan\u003esigil\u003c/span\u003e       =\u0026gt; \u003cspan\u003e\u0026#34;\\$\u0026#34;\u003c/span\u003e,\n      \u003cspan\u003edesigilname\u003c/span\u003e =\u0026gt; \u003cspan\u003eRakuAST::Name\u003c/span\u003e.\u003cspan\u003efrom-identifier\u003c/span\u003e(\u003cspan\u003e\u0026#34;x\u0026#34;\u003c/span\u003e)\n    )\n  ),\n  \u003cspan\u003eRakuAST::Statement::Expression\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\n    \u003cspan\u003eexpression\u003c/span\u003e =\u0026gt; \u003cspan\u003eRakuAST::ApplyPostfix\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\n      \u003cspan\u003eoperand\u003c/span\u003e =\u0026gt; \u003cspan\u003eRakuAST::Var::Lexical\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\u003cspan\u003e\u0026#34;\\$x\u0026#34;\u003c/span\u003e),\n      \u003cspan\u003epostfix\u003c/span\u003e =\u0026gt; \u003cspan\u003eRakuAST::Postfix\u003c/span\u003e.\u003cspan\u003enew\u003c/span\u003e(\u003cspan\u003e\u0026#34;++\u0026#34;\u003c/span\u003e)\n    )\n  )\n)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis allows for things like writing Raku in different languages:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003esay\u003c/span\u003e \u003cspan\u003eQ/my $x; put $x/\u003c/span\u003e.\u003cspan\u003eAST\u003c/span\u003e.\u003cspan\u003eDEPARSE\u003c/span\u003e(\u003cspan\u003e\u0026#34;NL\u0026#34;\u003c/span\u003e)\n\u003cspan\u003emijn\u003c/span\u003e \u003cspan\u003e$x\u003c/span\u003e;\n\u003cspan\u003ezeg-het\u003c/span\u003e \u003cspan\u003e$x\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eBonus experiment\u003c/h3\u003e\n\u003cp\u003eRaku comes with a \u0026#34;\u003ca href=\"https://rakudo.org/star\" target=\"_blank\"\u003eRakudo Star\u003c/a\u003e\u0026#34; installation, which comes with a set of \u003ca href=\"https://github.com/rakudo/star/blob/master/etc/modules.txt\" target=\"_blank\"\u003eblessed third party modules\u003c/a\u003e preinstalled. I love this! It\u0026#39;s a great compromise between the maintainer burdens of a large standard library and the user burdens of making everybody find the right packages in the ecosystem.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2\u003eBlog Rec\u003c/h2\u003e\n\u003cp\u003eFeel obligated to recommend some Raku blogs! Elizabeth Mattijsen posts \u003ca href=\"https://dev.to/lizmat\" target=\"_blank\"\u003ea ton of stuff\u003c/a\u003e to dev.to about Raku internals. \u003ca href=\"https://www.codesections.com/blog/\" target=\"_blank\"\u003eCodesections\u003c/a\u003e has a pretty good blog; he\u0026#39;s the person who eventually got me to try out Raku. Finally, the \u003ca href=\"https://raku-advent.blog/\" target=\"_blank\"\u003eRaku Advent Calendar\u003c/a\u003e is a great dive into advanced Raku techniques. Bad news is it only updates once a year, good news is it\u0026#39;s 25 updates that once a year.\u003c/p\u003e\n\n                    \n                \n\n                \n                    \u003cp\u003e\u003cem\u003eIf you\u0026#39;re reading this on the web, you can subscribe \u003ca href=\"https://buttondown.com/hillelwayne\" target=\"_blank\"\u003ehere\u003c/a\u003e. Updates are once a week. My main website is \u003ca href=\"https://www.hillelwayne.com\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eMy new book, \u003c/em\u003eLogic for Programmers\u003cem\u003e, is now in early access! Get it \u003ca href=\"https://leanpub.com/logic/\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n                \n\n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-11-12T20:06:55.105219Z",
  "modifiedTime": null
}
