{
  "id": "9af18a46-1ec1-4252-afdf-448ae48ec0f2",
  "title": "You can use C-Reduce for any language",
  "link": "https://bernsteinbear.com/blog/creduce/",
  "description": "Comments",
  "author": "",
  "published": "Wed, 27 Nov 2024 17:56:24 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Max Bernstein",
  "length": 2086,
  "excerpt": "C-Reduce is a tool by Regehr and friends for minimizing C compiler bug reproducers. Imagine if you had a 10,000 line long C file that triggered a Clang bug. You don’t want to send a massive blob to the compiler developers because that’s unhelpful, but you also don’t want to cut it down to size by hand. The good news is that C-Reduce can do that for you. The bad news is that everyone thinks it only works for C.",
  "siteName": "Max Bernstein",
  "favicon": "",
  "text": "November 15, 2024 C-Reduce is a tool by Regehr and friends for minimizing C compiler bug reproducers. Imagine if you had a 10,000 line long C file that triggered a Clang bug. You don’t want to send a massive blob to the compiler developers because that’s unhelpful, but you also don’t want to cut it down to size by hand. The good news is that C-Reduce can do that for you. The bad news is that everyone thinks it only works for C. It’s pretty widely applicable. You only need: A deterministic condition1 A reasonably quick reproducer (it helps with the speed of the reduction) One or more mutable source files for C-Reduce to cut down I ran into a bug with RustPython running scrapscript and wanted to report it. So I ran wrote a script interesting.sh to reproduce the bug: #!/bin/bash # No -o pipefail; we don't want rustpython failures to cause the script to fail set -eu # Note the absolute path to the binary, which is not in $PATH /path/to/RustPython/target/release/rustpython scrapscript.py 2\u003e\u00261 | grep \\ \"tried to push value onto stack but overflowed max_stackdepth\" And then I ran C-Reduce. This all happened within a couple of seconds: $ creduce --not-c interesting.sh scrapscript.py ===\u003c 2263604 \u003e=== running 4 interestingness tests in parallel ===\u003c pass_blank :: 0 \u003e=== (0.5 %, 200799 bytes) (0.6 %, 200607 bytes) ===\u003c pass_lines :: 0 \u003e=== (9.2 %, 183225 bytes) (18.1 %, 165228 bytes) (26.5 %, 148382 bytes) (29.3 %, 142674 bytes) (34.6 %, 131961 bytes) (38.1 %, 124960 bytes) (40.6 %, 119872 bytes) (42.3 %, 116504 bytes) (44.4 %, 112161 bytes) (46.4 %, 108180 bytes) (47.5 %, 105950 bytes) ... What you see is C-Reduce cutting down the file by 50% nearly instantly… and I don’t even have a very fast computer. We use --not-c because otherwise C-Reduce uses a bunch of C-specific passes. If we’re working on Python, it will likely just slow things down (but not materially change the outcome). There you have it. Fast and easy. As I finish typing these next couple of sentences, we’re already at 96.9% reduced.",
  "image": "https://bernsteinbear.com/favicon.ico",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n        \n\n        \n        \n        \u003cp\u003e\u003ci\u003eNovember 15, 2024\u003c/i\u003e\u003c/p\u003e\n        \n        \n        \u003cdiv\u003e\n            \u003cp\u003e\u003ca href=\"https://github.com/csmith-project/creduce\"\u003eC-Reduce\u003c/a\u003e is a tool by Regehr and\nfriends for minimizing C compiler bug reproducers. Imagine if you had a 10,000\nline long C file that triggered a Clang bug. You don’t want to send a massive\nblob to the compiler developers because that’s unhelpful, but you also don’t\nwant to cut it down to size by hand. The good news is that C-Reduce can do that\nfor you. The bad news is that everyone thinks it only works for C.\u003c/p\u003e\n\n\u003cp\u003eIt’s pretty widely applicable. You only need:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eA deterministic condition\u003csup id=\"fnref:loop\" role=\"doc-noteref\"\u003e\u003ca href=\"#fn:loop\" rel=\"footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n  \u003cli\u003eA reasonably quick reproducer (it helps with the speed of the reduction)\u003c/li\u003e\n  \u003cli\u003eOne or more mutable source files for C-Reduce to cut down\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI ran into a bug with \u003ca href=\"https://github.com/RustPython/RustPython\"\u003eRustPython\u003c/a\u003e\nrunning \u003ca href=\"https://github.com/tekknolagi/scrapscript\"\u003escrapscript\u003c/a\u003e and wanted to\nreport it. So I ran wrote a script \u003ccode\u003einteresting.sh\u003c/code\u003e to reproduce the bug:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e#!/bin/bash\u003c/span\u003e\n\u003cspan\u003e# No -o pipefail; we don\u0026#39;t want rustpython failures to cause the script to fail\u003c/span\u003e\n\u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e-eu\u003c/span\u003e\n\n\u003cspan\u003e# Note the absolute path to the binary, which is not in $PATH\u003c/span\u003e\n/path/to/RustPython/target/release/rustpython scrapscript.py 2\u0026gt;\u0026amp;1 | \u003cspan\u003egrep\u003c/span\u003e \u003cspan\u003e\\\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;tried to push value onto stack but overflowed max_stackdepth\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd then I ran C-Reduce. This all happened within a couple of seconds:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e \u003c/span\u003ecreduce \u003cspan\u003e--not-c\u003c/span\u003e interesting.sh scrapscript.py\n\u003cspan\u003e===\u0026lt; 2263604 \u0026gt;\u003c/span\u003e\u003cspan\u003e===\u003c/span\u003e\n\u003cspan\u003erunning 4 interestingness tests in parallel\n\u003c/span\u003e\u003cspan\u003e===\u0026lt; pass_blank :: 0 \u0026gt;\u003c/span\u003e\u003cspan\u003e===\u003c/span\u003e\n\u003cspan\u003e(0.5 %, 200799 bytes)\n(0.6 %, 200607 bytes)\n\u003c/span\u003e\u003cspan\u003e===\u0026lt; pass_lines :: 0 \u0026gt;\u003c/span\u003e\u003cspan\u003e===\u003c/span\u003e\n\u003cspan\u003e(9.2 %, 183225 bytes)\n(18.1 %, 165228 bytes)\n(26.5 %, 148382 bytes)\n(29.3 %, 142674 bytes)\n(34.6 %, 131961 bytes)\n(38.1 %, 124960 bytes)\n(40.6 %, 119872 bytes)\n(42.3 %, 116504 bytes)\n(44.4 %, 112161 bytes)\n(46.4 %, 108180 bytes)\n(47.5 %, 105950 bytes)\n\u003c/span\u003e\u003cspan\u003e...\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhat you see is C-Reduce cutting down the file by 50% nearly instantly… and I\ndon’t even have a very fast computer.\u003c/p\u003e\n\n\u003cp\u003eWe use \u003ccode\u003e--not-c\u003c/code\u003e because otherwise C-Reduce uses a bunch of C-specific passes.\nIf we’re working on Python, it will likely just slow things down (but not\nmaterially change the outcome).\u003c/p\u003e\n\n\u003cp\u003eThere you have it. Fast and easy. As I finish typing these next couple of\nsentences, we’re already at 96.9% reduced.\u003c/p\u003e\n\n\n        \u003c/div\u003e\n            \n    \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-11-15T00:00:00Z",
  "modifiedTime": null
}
