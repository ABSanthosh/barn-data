{
  "id": "925b832a-6424-47ef-8d83-f5ae76bfeff3",
  "title": "3,200% CPU Utilization",
  "link": "https://josephmate.github.io/2025-02-26-3200p-cpu-util/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 28 Feb 2025 17:01:43 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Joseph Mate",
  "length": 26163,
  "excerpt": "A while back my machine was so messed up that I could barely ssh onto it. 3,200% CPU utilization - all 32 cores on the host were fully utilized! Compare that to my last bug where it only used 1 core, 100% Fortunately, it was using Java 17 runtime which...",
  "siteName": "Joseph Mate",
  "favicon": "",
  "text": "A while back my machine was so messed up that I could barely ssh onto it. 3,200% CPU utilization - all 32 cores on the host were fully utilized! Compare that to my last bug where it only used 1 core, 100% Fortunately, it was using Java 17 runtime which had thread dumps with CPU time! Sorting by CPU time brought a bunch of threads that looked similar to this: \"Thread-0\" #22 [14700] prio=5 os_prio=0 cpu=10359.38ms elapsed=11.49s tid=0x000001cdc35aaf60 nid=14700 runnable [0x00000047cfffe000] java.lang.Thread.State: RUNNABLE at java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:826) at java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:534) at BusinessLogic.someFunction(BusinessLogic.java:29) ... I make a quick conclusion about this and thought to look at BusinessLogic:29 based on the stack trace and it looked like this: public void someFunction(SomeType relatedObject, List\u003cSomeOtherType\u003e unrelatedObjects) { ... for (SomeOtherType unrelatedObject : unrelatedObjects) { treeMap.put(relatedObject.a(), relatedObject.b()); // line 29 } ... } That code is odd. Notice we’re iterating over unrelatedObject, but the body of the loop only used relatedObject. The code can be reduced to simply: public void someFunction(SomeType relatedObject, List\u003cSomeOtherType\u003e unrelatedObjects) { ... treeMap.put(relatedObject.a(), relatedObject.b()); ... // unrelatedObjects is used later on in the function so the parameter cannot be removed } There must have been some refactoring in the area and unrelatedObject wasn’t used anymore. I prepared my unit test and ran the test before and after the fix. I tried treeMap and unrelatedObjects with 1,000,000 entries, well exceeding what the application ever saw and was not able to reproduce the problem. Assuming unrelatedObjects is size N and treeMap is size M, the complexity is O(N lg(M)). So it makes sense that I was unable to reproduce the problem. You wouldn’t really see one minute of execution time until 100 million to 1 billion entries.. It must be something else. I was certain treeMap and unrelatedObjects never exceed 1,000 entries. It’s not even close enough to cause an issue with an O(N lg(M)) algorithm. I wasn’t very familiar with the class so I started to look around, focusing on treeMap and unrelatedObjects to see if my assumption that they never exceed 1,000 holds. Could they be in the millions or even billions? Then I noticed the definition of the TreeMap as : // The field wasn't actually named treeMap. private final Map\u003cK,V\u003e treeMap = new TreeMap\u003c\u003e(); That’s scary. There were multiple threads accessing the TreeMap, and it was unguarded. At this point, I had an aha moment. Could an unguarded TreeMap cause 3,200% utilization? Experiment I put together a simple experiment to try to reproduce the problem. I created a bunch of threads randomly updating a shared TreeMap. for (int i = 0; i \u003c numThreads; i++) { threads.add(new Thread(() -\u003e { Random random = new Random(); for(int j = 0; j \u003c numUpdates; j++) { try { treeMap.put(random.nextInt(1000), random.nextInt(1000)); } catch (NullPointerException e) { // let it keep going so we can reproduce the issue. } } })); } That try catch was key. If no try catch, I wasn’t able to reproduce the problem. Some threads would crash with the above output: Exception in thread \"Thread-0\" java.lang.NullPointerException: Cannot read field \"right\" because \"l\" is null at java.base/java.util.TreeMap.rotateRight(TreeMap.java:2562) at java.base/java.util.TreeMap.fixAfterInsertion(TreeMap.java:2594) at java.base/java.util.TreeMap.addEntry(TreeMap.java:770) at java.base/java.util.TreeMap.put(TreeMap.java:828) at java.base/java.util.TreeMap.put(TreeMap.java:534) at SimpleRepro.lambda$main$0(SimpleRepro.java:28) at java.base/java.lang.Thread.run(Thread.java:833) but the program would still halt. Probably only languages that allow you to catch NPEs will encounter this issue. Other languages will just crash. After a few runs, I saw 500% cpu utilization. That’s crazy! I always thought of race conditions as corrupting the data or deadlocking. I never though it could cause performance issues. But it makes sense, you could corrupt the data in a way that creates an infinite loop. You can check out the java experiment from my GitHub java-by-experiments repo SimpleRepro.java To make extra sure, I created another experiment that uses reflection against the TreeMap to dump the nodes and their colours. (In Java, a TreeMap is implemented using a Red-Black tree.) The cycle in the TreeMap is highlighted in blue. So if you’re searching or putting something not already in the map, it could get stuck in that infinite loop. To reproduce the above graph you need to use reflection to access the root, and the left and right fields of the TreeMap.Entry. You recursively traverse the TreeMap.Entrys starting from root, keeping track of the Entries you visited. If you visit an entry you already visited, you know you’ve hit a loop. Print all the nodes from visited to show the cycle. private final TreeMap\u003cInteger,Integer\u003e treeMap; private static final Field treeMapRootField; private static final Field treeMapEntryLeft; private static final Field treeMapEntryRight; private static final Field treeMapEntryKey; private static final Field treeMapEntryColor; ... public void print() throws Exception { print(treeMapRootField.get(treeMap), \"\", new IdentityHashMap\u003c\u003e()); } private void print( Object treeMapEntry, String tabs, IdentityHashMap\u003cObject, Object\u003e visited ) throws Exception { if (treeMapEntry != null \u0026\u0026 !visited.containsKey(treeMapEntry)) { // in order traversal visited.put(treeMapEntry, treeMapEntry); print(treeMapEntryLeft.get(treeMapEntry), tabs + \" \", visited); System.out.println(tabs + treeMapEntryKey.get(treeMapEntry) + \":\" + (treeMapEntryColor.getBoolean(treeMapEntry) ? \"BLACK\" : \"RED\")); print(treeMapEntryRight.get(treeMapEntry), tabs + \" \", visited); } else if (treeMapEntry != null \u0026\u0026 visited.containsKey(treeMapEntry)) { System.out.println(tabs + treeMapEntryKey.get(treeMapEntry) + \":\" + (treeMapEntryColor.getBoolean(treeMapEntry) ? \"BLACK\" : \"RED\") + \" CYCLE\" ); } } Working code is available in my java-by-experiments GitHub project ExploringTreeMap.java and TreeMapExplorer.java I’m not the first person to write about this issue. While preparing this article I found: Ivo Anjo wrote: writing to a java treemap concurrently can lead to an infinite loop during reads Red Hat has a troubleshooting article: High CPU due to multiple Java threads accessing TreeMap simultaneously Originally reported as far back as June 20 2011 based on web archive There is even a Stack Overflow question about it: Java Process consumes more than 100% CPU However, this article provides a few new perspectives not previously discussed: Practical code that that reproduces the issue. Proposing that only a particular class of languages can encounter this issue and exploring that hypothesis A survey of languages to see if all can reproduce the issue A new approach to fixing TreeMap and red black tree to prevent this issue If any of these interest you, please keep reading. That code is not realistic Some might claim that my experimental code is unrealistic. Who ignores NPEs? There are two practical ways: uncaught exceptions in executors and services backed by a thread pool. Uncaught Exceptions in Executor We could reproduce this problem in conjunction with another common mistake that suppresses uncaught exceptions. The below code also reproduces the issue, but with a thread pool. final ExecutorService pool = Executors.newFixedThreadPool(numThreads); final TreeMap\u003cInteger,Integer\u003e treeMap = new TreeMap\u003c\u003e(); Random random = new Random(); for (int i = 0; i \u003c numThreads*numUpdatesPerThread; i++) { pool.submit( () -\u003e { treeMap.put(random.nextInt(10000), random.nextInt(10000)); }); } pool.shutdown(); pool.awaitTermination(1, TimeUnit.DAYS); snippet from ExecutorUncaughtRepro.java When you run it, you’ll see it hang. Take a thread dump and see the same symptoms: \"pool-1-thread-1\" #22 [15356] prio=5 os_prio=0 cpu=17734.38ms elapsed=21.39s tid=0x0000023c45dd3e90 nid=15356 runnable [0x000000780b4fe000] java.lang.Thread.State: RUNNABLE at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826) at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534) at ExecutorUncaughtRepro.lambda$main$0(ExecutorUncaughtRepro.java:33) at ExecutorUncaughtRepro$$Lambda$14/0x00000008010031f0.run(Unknown Source) at java.util.concurrent.Executors$RunnableAdapter.call(java.base@19.0.1/Executors.java:577) at java.util.concurrent.FutureTask.run(java.base@19.0.1/FutureTask.java:317) at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144) at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642) at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589) It’s stuck on the TreeMap and really high CPU utilization. However, when looking at standard out there is nothing! The thread pool swallowed all the NPEs not giving any indication of problem. Unfortunately, this was the case in my situation. When managing your own thread pools, you need to make sure you: Register an uncaught exception handler on the thread through a thread factory Operate on the futures it return. If you do future.get() you will get an ExectionException wrapping the NPE! Again with gRPC Another way is to have some sort of service back by a thread pool like a gRPC service. Here I recreate a realistic scenario in gRPC that reproduces the problem. The service is powered by an unguarded TreeMap. @Override public void addReceipt( ReceiptProcessorServiceOuterClass.AddReceiptRequest req, StreamObserver\u003cReceiptProcessorServiceOuterClass.AddReceiptResponse\u003e responseObserver ) { int timestamp = req.getTimestamp(); int totalPrice = req.getTotalPrice(); receipts.put(timestamp, totalPrice); ReceiptProcessorServiceOuterClass.AddReceiptResponse response = ReceiptProcessorServiceOuterClass.AddReceiptResponse.newBuilder().build(); responseObserver.onNext(response); responseObserver.onCompleted(); } snippet from GrpcRepro.java Dumping the threads gives us: \"grpc-default-executor-23\" #54 [8796] daemon prio=5 os_prio=0 cpu=18671.88ms elapsed=175.50s tid=0x00000168b6c707c0 nid=8796 runnable [0x000000059fbfe000] java.lang.Thread.State: RUNNABLE at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826) at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534) at ReceiptProcessorServiceImpl.addReceipt(GrpcRepro.java:59) at ReceiptProcessorServiceGrpc$MethodHandlers.invoke(ReceiptProcessorServiceGrpc.java:185) at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182) at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:346) at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860) at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37) at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133) at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144) at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642) at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589) showing that TreeMap.put() got stuck on an infinite loop. How did it happen? Rotations My suspicion is that two threads independently rotate the tree in opposite directions, resulting in a cycle. Or maybe, two overlaping rotations interleave their writes in a way that produces the cycle. However, I do not have proof of an interleaving between threads that shows this. I also suspect that the NPE is necessary. The problem will not reproduce without hitting an NPE as I saw with my Java experiments. Other languages I explore this idea that only languages with NPEs can exhibit this problem by trying to reproduce this problem in as many languages as I’ve programmed in before. If this claim is true, I expect it to only reproduce in Java, Kotlin, C#, Ruby, Typescript, and Python. I expect to not be able to reproduce the problem in Go, C++, Rust, and Elixir. Language Affected Explanation Code Java yes this whole article is based on this source C# yes SortedDictionary used red black tree source Ruby no Used red black tree from kanwei/algorithms but was unable to reproduce the issue. I believe it might not be able to reproduce the problem due to the Global Interpreter Lock (GIL), and how it limits when threads can context switch preventing interleavings of threads that cause an infinite loop. source C++ yes used red-black tree. I was expecting it to always segfault first preventing it from hitting the issue. source Go yes has popular datastructures library. Similar to C++, I was expecting it only segfault and not reproduce the infinite loop. I was wrong. source Rust no compiler prevented me. I don’t know enough about writing unsafe code to reproduce the problem source Kotlin yes uses java’s TreeMap, same issue expected   PHP no not in standard library and did not find any popular libraries with red black tree   JavaScript no multithreading model cannot share references   Typescript no same argument as JavaScript   Python no no red-black tree in standard library and popular libraries like Sorted Containers do not use red black tree. despite no red black tree, if I had run the experiment, I would expect to not to be able to reproduce for the same reason as ruby: the GIL.   Elixir no Although there are many third party implementations of the red black trees in Elixir (and Erlang), the programming model makes it impossible: data structures are immutable and interactions between threads are limited to message passing.   From the table, the most interesting one is C++ because I was not expecting to be able to reproduce the problem due to my hypothesis from the last section. As a result, I include the details from the experiment here. Similarly, go as unexpected, but trim the article, I left it out. You can see Go here. The code is essentially the same as the Java one, only using C++ standard libraries. I also added extra printing since I was so shocked that the problem reproduced, I just wanted to make extra sure. // Equivalent of TreeMap in C++ is std::map // Uses same red black tree data structure std::map\u003cint, int\u003e sortedMap; for (int i = 0; i \u003c numThreads; i++) { threads.emplace_back([\u0026]() { // copy so that we don't use the latest value of i (5) int threadId = threadIdGenerator.fetch_add(1); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution\u003c\u003e dis(0, 999); int progressThreshold = numUpdates / progressRatio; std::cout \u003c\u003c \"Thread \" \u003c\u003c threadId \u003c\u003c \" started.\"; for (int j = 0; j \u003c numUpdates; j++) { try { int key = dis(gen); int value = dis(gen); sortedMap[key] = value; } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Caught exception on thread \" \u003c\u003c threadId \u003c\u003c \":\" \u003c\u003c e.what() \u003c\u003c std::endl; } if ((j + 1) % progressThreshold == 0) { std::cout \u003c\u003c \"Thread \" \u003c\u003c threadId \u003c\u003c \": \" \u003c\u003c ((j + 1) * 100 / numUpdates) \u003c\u003c \"% complete (\" \u003c\u003c (j + 1) \u003c\u003c \"/\" \u003c\u003c numUpdates \u003c\u003c \" updates)\\n\"; } } std::cout \u003c\u003c \"Thread \" \u003c\u003c threadId \u003c\u003c \" completed.\"; }); } Occasionally, the program segfaults and crashes like before. This is what I was expecting the worst failure to look like. ./SimpleRepro zsh: segmentation fault ./SimpleRepro However, very rarely the output would look like below, indicating the threads got stuck. After waiting 10 minutes, the threads never completed. I did not expect this to happen because I thought it requires a thrown and swallowed exception. That is not happening here. ./SimpleRepro Thread 0 started.Thread Thread 0: 10% complete (Thread 10/10012Thread started.3 started.Thread 4 started.Thread 4: 10% complete (10/100 updates) updates) Thread 0: 20% complete (20/100 updates) Thread 0: 30% complete (30/100 updates) Thread 0: 40% complete (40/100 updates) Thread 1: 10% complete (10/100 updates) started.Thread 2: 10% complete (10/100 updates) Thread 1: 20% complete (20/100 updates) \u003cnothing output for 5 minutes\u003e From the tool top we can see that the problem reproduced because of the high cpu utilization. top PID COMMAND %CPU TIME ... 59815 SimpleRepro 170.8 08:49.61 ... This shows my claim is false. I was able to reproduce the problem in Go and C++. Although they sometimes segfaulted, there were times when they got stuck in the infinite loop. In a language like C++, when you reference a null pointer it always segfaults, so there must be an interleaving of the threads that does not hit a null! I have no idea why. I was expecting them to crash given how often I saw NPEs in the Java experiment. With this knowledge, I went back to my SimpeRepro java experiment and stopped catching the NPE. After re-running it 12 times, I was still able to reproduce the problem despite not catching the NPE: \"Thread-4\" #17 prio=5 os_prio=31 cpu=18597.02ms elapsed=23.79s tid=0x00007f81051ac200 nid=0x6a03 runnable [0x000070000bcb5000] java.lang.Thread.State: RUNNABLE at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:826) at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:534) at SimpleRepro.lambda$main$0(SimpleRepro.java:28) at SimpleRepro$$Lambda$1/0x0000000800c00a08.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.3/Thread.java:833) The other thing that surprised me was languages like Ruby, despite letting you catch NPEs did not let you reproduce the problem. The Global Interpreter Lock (GIL) somehow prevented all execution interleavings that would reproduce the problem. Easy Fix: Guard against concurrent modification The easiest way to fix this was to wrap the TreeMap with Collections.synchronizedMap or switch to ConcurrentHashMap and sort on demand. However, those fixes are boring and did not prevent us from making that mistake and taking down our host. Controversial Fix: Track visited nodes What if you could safely make the mistake, but not have a cycle? I modified the red-black tree to record the nodes it has already visited. The only requires an additional O(lg(n)) memory since it’s limited by the height of the tree. The height of a red-black tree is guaranteed to be O(lg(n)). If we encounter a node that we already visited, we throw a ConcurrentModificationException. This will not prevent the data corruption, but will prevent 100% cpu utilization from the infinite loop if someone makes that mistake again in the future. This would require standard libraries to adopt this technique though which I don’t think is likely to happen given the extra memory needed. diff --git a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java index 53c15bb..2713d5a 100644 --- a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java +++ b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java @@ -345,7 +345,9 @@ public class ProtectedTreeMap\u003cK,V\u003e @SuppressWarnings(\"unchecked\") Comparable\u003c? super K\u003e k = (Comparable\u003c? super K\u003e) key; Entry\u003cK,V\u003e p = root; + IdentityHashMap\u003cEntry\u003c?,?\u003e, Boolean\u003e visited = new IdentityHashMap\u003c\u003e(); while (p != null) { + visited.put(p, true); int cmp = k.compareTo(p.key); if (cmp \u003c 0) p = p.left; @@ -353,6 +355,10 @@ public class ProtectedTreeMap\u003cK,V\u003e p = p.right; else return p; + + if (visited.containsKey(p)) { + throw new ConcurrentModificationException(\"TreeMap corrupted. Loop detected\"); + } } return null; } @@ -779,6 +785,7 @@ public class ProtectedTreeMap\u003cK,V\u003e } private V put(K key, V value, boolean replaceOld) { + IdentityHashMap\u003cEntry\u003c?,?\u003e, Boolean\u003e visited = new IdentityHashMap\u003c\u003e(); Entry\u003cK,V\u003e t = root; if (t == null) { addEntryToEmptyMap(key, value); @@ -790,6 +797,7 @@ public class ProtectedTreeMap\u003cK,V\u003e Comparator\u003c? super K\u003e cpr = comparator; if (cpr != null) { do { + visited.put(t, true); parent = t; cmp = cpr.compare(key, t.key); if (cmp \u003c 0) @@ -803,12 +811,17 @@ public class ProtectedTreeMap\u003cK,V\u003e } return oldValue; } + + if (visited.containsKey(t)) { + throw new ConcurrentModificationException(\"TreeMap corrupted. Loop detected\"); + } } while (t != null); } else { Objects.requireNonNull(key); @SuppressWarnings(\"unchecked\") Comparable\u003c? super K\u003e k = (Comparable\u003c? super K\u003e) key; do { + visited.put(t, true); parent = t; cmp = k.compareTo(t.key); if (cmp \u003c 0) @@ -822,6 +835,10 @@ public class ProtectedTreeMap\u003cK,V\u003e } return oldValue; } + + if (visited.containsKey(t)) { + throw new ConcurrentModificationException(\"TreeMap corrupted. Loop detected\"); + } } while (t != null); } addEntry(key, value, parent, cmp \u003c 0); diff from my ProtectedTreeMap.java In the above code, you can see that I modified both the get and put methods to maintain the set of visited nodes and throw a ConcurrentModificationException when an already visited node is in the set. Mistakes Happen: Make Swiss Cheese Mistakes happen so it’s important that multiple layers are in place to detect the issue. Imaging a slice of Swiss cheese, each slice taken from a different block of cheese. Stacking enough of those slices would result in nothing being able to pass through. Alerts on NPEs We lacked an alarm on any instance of an NPE. We only had error rate alarms. This NPE only occurs once per API handler worker thread before which was not enough to trigger our error rate alarms. On top of that, none of the NPEs were logged because we had an unhandled exception in our Executor. Alerts on utilization anomalies We monitor the cpu utilization and use a naive threshold based approach to alarming. When the cpu utilization exceeds that threshold, we fire an alarm because it indicates abnormal behaviour. This is how we discovered the issue. Uncaught exceptions on Executors If you add your work to an executor you must ensure you have an uncaught exception handler. AtomicInteger threadNumber = new AtomicInteger(1); ThreadFactory customThreadFactory = new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setName(\"my-thread-pool-\" + threadNumber.getAndIncrement()); thread.setUncaughtExceptionHandler( (dyingThread, throwable) -\u003e { logger.error(\"uncaught exception!\", throwable); } ); return thread; } }; ExecutorService executor = Executors.newFixedThreadPool(2, customThreadFactory); This code is kind of ugly so you’re better off using Apache Common’s BasicThreadFactory: new BasicThreadFactory.Builder() .namingPattern(\"my-thread-pool-%d\") .uncaughtExceptionHandler( (dyingThread, throwable) -\u003e { logger.error(\"uncaught exception!\", throwable); } ) .build(); or guava’s ThreadFactoryBuilder: new ThreadFactoryBuilder() .setNameFormat(\"my-thread-pool-%d\") .setUncaughtExceptionHandler( (dyingThread, throwable) -\u003e { logger.error(\"uncaught exception!\", throwable); } ) .build() Without a handler, the exception will be swallowed and none of your log monitoring will be able to detect the issue. Code reviews Sometimes, a detail oriented developer will notice the combination of threads and TreeMap, or even suggest to not use a TreeMap if ordered elements are not needed. Unfortunately, that didn’t happen in this case. Static code analysis Static code analysis tools like SpotBugs (used to be called FindBugs), JLint, and Chord can detect these kinds of issues at build time. See the paper How Good is Static Analysis at Finding Concurrency Bugs?. Unfortunately, we didn’t start using them until after the bug. Tests Ensure your tests handle the multithreaded case! In my case, we did not have multithreaded tests for that part of the code. Conclusion Mistakes happen. Watch out, unprotected concurrent modification data corruption can present itself as infinite loops! Despite making multiple mistakes, that hid the problem at multiple layers but not all. As long as you adopt a layered approach, you will be able to respond quickly or prevent it entirely.",
  "image": "https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/A_small_cup_of_coffee.JPG/320px-A_small_cup_of_coffee.JPG",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n      \n\n      \n\n      \u003carticle role=\"main\"\u003e\n        \u003cp\u003eA while back my machine was so messed up that I could barely ssh onto it.\n3,200% CPU utilization - all 32 cores on the host were fully utilized!\n\u003ca href=\"https://josephmate.github.io/2021-10-03-my-bug-used-up-100cpu-or-did-it/\"\u003eCompare that to my last bug where it only used 1 core, 100%\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eFortunately, it was using Java 17 runtime which had thread dumps with CPU time!\nSorting by CPU time brought a bunch of threads that looked similar to this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;Thread-0\u0026#34; #22 [14700] prio=5 os_prio=0 cpu=10359.38ms elapsed=11.49s tid=0x000001cdc35aaf60 nid=14700 runnable  [0x00000047cfffe000]\n   java.lang.Thread.State: RUNNABLE\n\tat java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:826)\n\tat java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:534)\n\tat BusinessLogic.someFunction(BusinessLogic.java:29)\n    ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI make a quick conclusion about this and thought to look at BusinessLogic:29 based\non the stack trace and it looked like this:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003esomeFunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eSomeType\u003c/span\u003e \u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eSomeOtherType\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eunrelatedObjects\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e...\u003c/span\u003e\n  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eSomeOtherType\u003c/span\u003e \u003cspan\u003eunrelatedObject\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eunrelatedObjects\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eb\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e \u003cspan\u003e// line 29\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e...\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat code is odd.\nNotice we’re iterating over \u003ccode\u003eunrelatedObject\u003c/code\u003e, but the body of the loop only used \u003ccode\u003erelatedObject\u003c/code\u003e.\nThe code can be reduced to simply:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003esomeFunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eSomeType\u003c/span\u003e \u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eSomeOtherType\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eunrelatedObjects\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e...\u003c/span\u003e\n  \u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003erelatedObject\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eb\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n  \u003cspan\u003e...\u003c/span\u003e\n  \u003cspan\u003e// unrelatedObjects is used later on in the function so the parameter cannot be removed\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThere must have been some refactoring in the area and unrelatedObject wasn’t used anymore. \nI prepared my unit test and ran the test before and after the fix.\nI tried \u003ccode\u003etreeMap\u003c/code\u003e and \u003ccode\u003eunrelatedObjects\u003c/code\u003e with 1,000,000 entries, well exceeding what the application ever saw and was not able to reproduce the problem.\nAssuming unrelatedObjects is size N and treeMap is size M, the complexity is O(N lg(M)).\nSo it makes sense that I was unable to reproduce the problem.\n\u003ca href=\"https://josephmate.github.io/PowersOf2/\"\u003eYou wouldn’t really see one minute of execution time until 100 million to 1 billion entries.\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIt must be something else.\nI was certain treeMap and unrelatedObjects never exceed 1,000 entries.\nIt’s not even close enough to cause an issue with an O(N lg(M)) algorithm.\u003c/p\u003e\n\n\u003cp\u003eI wasn’t very familiar with the class so I started to look around,\nfocusing on \u003ccode\u003etreeMap\u003c/code\u003e and \u003ccode\u003eunrelatedObjects\u003c/code\u003e to see if my assumption that they\nnever exceed 1,000 holds. Could they be in the millions or even billions?\u003c/p\u003e\n\n\u003cp\u003eThen I noticed the definition of the TreeMap as :\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// The field wasn\u0026#39;t actually named treeMap.\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eK\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003eV\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003etreeMap\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eTreeMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026gt;();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat’s scary.\nThere were multiple threads accessing the TreeMap, and it was unguarded.\nAt this point, I had an aha moment.\nCould an unguarded TreeMap cause 3,200% utilization?\u003c/p\u003e\n\n\u003ch2 id=\"experiment\"\u003eExperiment\u003c/h2\u003e\n\n\u003cp\u003eI put together a simple experiment to try to reproduce the problem.\nI created a bunch of threads randomly updating a shared TreeMap.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003enumThreads\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e++)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ethreads\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eThread\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eRandom\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eRandom\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003enumUpdates\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e\u003cspan\u003e++)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enextInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enextInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003ecatch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eNullPointerException\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003e// let it keep going so we can reproduce the issue.\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}));\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat try catch was key.\nIf no try catch, I wasn’t able to reproduce the problem.\nSome threads would crash with the above output:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eException in thread \u0026#34;Thread-0\u0026#34; java.lang.NullPointerException: Cannot read field \u0026#34;right\u0026#34; because \u0026#34;l\u0026#34; is null\n        at java.base/java.util.TreeMap.rotateRight(TreeMap.java:2562)\n        at java.base/java.util.TreeMap.fixAfterInsertion(TreeMap.java:2594)\n        at java.base/java.util.TreeMap.addEntry(TreeMap.java:770)\n        at java.base/java.util.TreeMap.put(TreeMap.java:828)\n        at java.base/java.util.TreeMap.put(TreeMap.java:534)\n        at SimpleRepro.lambda$main$0(SimpleRepro.java:28)\n        at java.base/java.lang.Thread.run(Thread.java:833)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ebut the program would still halt.\u003c/p\u003e\n\n\u003cp\u003eProbably only languages that allow you to catch NPEs will encounter this issue.\nOther languages will just crash.\nAfter a few runs, I saw 500% cpu utilization.\nThat’s crazy!\nI always thought of race conditions as corrupting the data or deadlocking.\nI never though it could cause performance issues.\nBut it makes sense, you could corrupt the data in a way that creates an infinite loop.\u003c/p\u003e\n\n\u003cp\u003eYou can check out the java experiment from my GitHub java-by-experiments repo\n\u003ca href=\"https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/SimpleRepro.java\"\u003eSimpleRepro.java\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eTo make extra sure, I created another experiment that uses reflection\nagainst the TreeMap to dump the nodes and their colours.\n(In Java, a TreeMap is implemented using a Red-Black tree.)\nThe cycle in the TreeMap is highlighted in blue.\n\u003cimg src=\"https://josephmate.github.io/assets/2023-08-20_cpu_util_3200/red_black_tree_cycle.gv.svg\" alt=\"example cycle generated from TreeMap experiment\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eSo if you’re searching or putting something not already in the map,\nit could get stuck in that infinite loop.\u003c/p\u003e\n\n\u003cp\u003eTo reproduce the above graph you need to use reflection to access the root, \nand the left and right fields of the \u003ccode\u003eTreeMap.Entry\u003c/code\u003e.\nYou recursively traverse the \u003ccode\u003eTreeMap.Entry\u003c/code\u003es starting from root, keeping\ntrack of the Entries you visited.\nIf you visit an entry you already visited, you know you’ve hit a loop.\nPrint all the nodes from visited to show the cycle.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eTreeMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInteger\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003eInteger\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eField\u003c/span\u003e \u003cspan\u003etreeMapRootField\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eField\u003c/span\u003e \u003cspan\u003etreeMapEntryLeft\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eField\u003c/span\u003e \u003cspan\u003etreeMapEntryRight\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eField\u003c/span\u003e \u003cspan\u003etreeMapEntryKey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eField\u003c/span\u003e \u003cspan\u003etreeMapEntryColor\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003e...\u003c/span\u003e\n\n\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003eException\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapRootField\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eIdentityHashMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026gt;());\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eObject\u003c/span\u003e \u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003etabs\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eIdentityHashMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eObject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eObject\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003evisited\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ethrows\u003c/span\u003e \u003cspan\u003eException\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003e!\u003c/span\u003e\u003cspan\u003evisited\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtainsKey\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// in order traversal\u003c/span\u003e\n        \u003cspan\u003evisited\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntryLeft\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003etabs\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;  \u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evisited\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003eSystem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etabs\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etreeMapEntryKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e\n            \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntryColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetBoolean\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e\u0026#34;BLACK\u0026#34;\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;RED\u0026#34;\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n        \u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntryRight\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003etabs\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;  \u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evisited\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003evisited\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtainsKey\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eSystem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etabs\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etreeMapEntryKey\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e\n            \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntryColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetBoolean\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etreeMapEntry\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e\u0026#34;BLACK\u0026#34;\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;RED\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e\u0026#34; CYCLE\u0026#34;\u003c/span\u003e\n        \u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWorking code is available in my java-by-experiments GitHub project\n\u003ca href=\"https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/ExploringTreeMap.java\"\u003eExploringTreeMap.java\u003c/a\u003e\nand\n\u003ca href=\"https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/TreeMapExplorer.java\"\u003eTreeMapExplorer.java\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eI’m not the first person to write about this issue.\nWhile preparing this article I found:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eIvo Anjo wrote: \u003ca href=\"https://ivoanjo.me/blog/2018/07/21/writing-to-a-java-treemap-concurrently-can-lead-to-an-infinite-loop-during-reads/\"\u003ewriting to a java treemap concurrently can lead to an infinite loop during reads\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eRed Hat has a troubleshooting article: \u003ca href=\"https://access.redhat.com/solutions/58008\"\u003eHigh CPU due to multiple Java threads accessing TreeMap simultaneously\u003c/a\u003e\n    \u003cul\u003e\n      \u003cli\u003eOriginally reported as far back as June 20 2011 based on \u003ca href=\"https://web.archive.org/web/20190715204100/https://access.redhat.com/solutions/58008\"\u003eweb archive\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eThere is even a Stack Overflow question about it: \u003ca href=\"https://stackoverflow.com/questions/56234865/java-process-consumes-more-than-100-cpu\"\u003eJava Process consumes more than 100% CPU\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHowever, this article provides a few new perspectives not previously discussed:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ePractical code that that reproduces the issue.\u003c/li\u003e\n  \u003cli\u003eProposing that only a particular class of languages can encounter this issue\nand exploring that hypothesis\u003c/li\u003e\n  \u003cli\u003eA survey of languages to see if all can reproduce the issue\u003c/li\u003e\n  \u003cli\u003eA new approach to fixing TreeMap and red black tree to prevent this issue\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eIf any of these interest you, please keep reading.\u003c/p\u003e\n\n\u003ch2 id=\"that-code-is-not-realistic\"\u003eThat code is not realistic\u003c/h2\u003e\n\n\u003cp\u003eSome might claim that my experimental code is unrealistic.\nWho ignores NPEs?\nThere are two practical ways: uncaught exceptions in executors and services backed by a thread pool.\u003c/p\u003e\n\n\u003ch2 id=\"uncaught-exceptions-in-executor\"\u003eUncaught Exceptions in Executor\u003c/h2\u003e\n\n\u003cp\u003eWe could reproduce this problem in conjunction with another common mistake that suppresses uncaught exceptions.\u003c/p\u003e\n\n\u003cp\u003eThe below code also reproduces the issue, but with a thread pool.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eExecutorService\u003c/span\u003e \u003cspan\u003epool\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eExecutors\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enewFixedThreadPool\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enumThreads\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eTreeMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInteger\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003eInteger\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003etreeMap\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eTreeMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026gt;();\u003c/span\u003e\n\n\u003cspan\u003eRandom\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eRandom\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003enumThreads\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003enumUpdatesPerThread\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e++)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003epool\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubmit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003etreeMap\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enextInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e10000\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003erandom\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enextInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e10000\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\n    \u003cspan\u003e});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003epool\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eshutdown\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003epool\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eawaitTermination\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTimeUnit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eDAYS\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003esnippet from \u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/java/src/main/java/ExecutorUncaughtRepro.java\"\u003eExecutorUncaughtRepro.java\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eWhen you run it, you’ll see it hang.\nTake a thread dump and see the same symptoms:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;pool-1-thread-1\u0026#34; #22 [15356] prio=5 os_prio=0 cpu=17734.38ms elapsed=21.39s tid=0x0000023c45dd3e90 nid=15356 runnable  [0x000000780b4fe000]\n   java.lang.Thread.State: RUNNABLE\n\tat java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)\n\tat java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)\n\tat ExecutorUncaughtRepro.lambda$main$0(ExecutorUncaughtRepro.java:33)\n\tat ExecutorUncaughtRepro$$Lambda$14/0x00000008010031f0.run(Unknown Source)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(java.base@19.0.1/Executors.java:577)\n\tat java.util.concurrent.FutureTask.run(java.base@19.0.1/FutureTask.java:317)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)\n\tat java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIt’s stuck on the TreeMap and really high CPU utilization.\u003c/p\u003e\n\n\u003cp\u003eHowever, when looking at standard out there is nothing!\nThe thread pool swallowed all the NPEs not giving any indication of problem. \nUnfortunately, this was the case in my situation.\u003c/p\u003e\n\n\u003cp\u003eWhen managing your own thread pools, you need to make sure you:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eRegister an uncaught exception handler on the thread through a thread factory\u003c/li\u003e\n  \u003cli\u003eOperate on the futures it return. If you do \u003ccode\u003efuture.get()\u003c/code\u003e you will get an \u003ccode\u003eExectionException\u003c/code\u003e wrapping the NPE!\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"again-with-grpc\"\u003eAgain with gRPC\u003c/h2\u003e\n\n\u003cp\u003eAnother way is to have some sort of service back by a thread pool like a gRPC service.\nHere I recreate a realistic scenario in gRPC that reproduces the problem.\nThe service is powered by an unguarded TreeMap.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@Override\u003c/span\u003e\n\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eaddReceipt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eReceiptProcessorServiceOuterClass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eAddReceiptRequest\u003c/span\u003e \u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eStreamObserver\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eReceiptProcessorServiceOuterClass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eAddReceiptResponse\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003eresponseObserver\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003etimestamp\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetTimestamp\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n    \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003etotalPrice\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetTotalPrice\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n    \u003cspan\u003ereceipts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimestamp\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etotalPrice\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eReceiptProcessorServiceOuterClass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eAddReceiptResponse\u003c/span\u003e \u003cspan\u003eresponse\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eReceiptProcessorServiceOuterClass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eAddReceiptResponse\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enewBuilder\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n    \u003cspan\u003eresponseObserver\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eonNext\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresponse\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003eresponseObserver\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eonCompleted\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003esnippet from \u003ca href=\"https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/GrpcRepro.java\"\u003eGrpcRepro.java\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eDumping the threads gives us:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;grpc-default-executor-23\u0026#34; #54 [8796] daemon prio=5 os_prio=0 cpu=18671.88ms elapsed=175.50s tid=0x00000168b6c707c0 nid=8796 runnable  [0x000000059fbfe000]\n   java.lang.Thread.State: RUNNABLE\n\tat java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)\n\tat java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)\n\tat ReceiptProcessorServiceImpl.addReceipt(GrpcRepro.java:59)\n\tat ReceiptProcessorServiceGrpc$MethodHandlers.invoke(ReceiptProcessorServiceGrpc.java:185)\n\tat io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)\n\tat io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:346)\n\tat io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)\n\tat io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)\n\tat io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)\n\tat java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eshowing that TreeMap.put() got stuck on an infinite loop.\u003c/p\u003e\n\n\u003ch2 id=\"how-did-it-happen-rotations\"\u003eHow did it happen? Rotations\u003c/h2\u003e\n\n\u003cp\u003eMy suspicion is that two threads independently rotate the tree \nin opposite directions, resulting in a cycle.\nOr maybe, two overlaping rotations interleave their writes in a way that produces the\ncycle.\nHowever, I do not have proof of an interleaving between threads that shows this.\u003c/p\u003e\n\n\u003cp\u003eI also suspect that the NPE is necessary.\nThe problem will not reproduce without hitting an NPE as I saw with my Java experiments.\u003c/p\u003e\n\n\u003ch2 id=\"other-languages\"\u003eOther languages\u003c/h2\u003e\n\n\u003cp\u003eI explore this idea that only languages with NPEs can exhibit this problem by\ntrying to reproduce this problem in as many languages as I’ve programmed in\nbefore.\nIf this claim is true, I expect it to only reproduce in\nJava, Kotlin, C#, Ruby, Typescript, and Python.\nI expect to not be able to reproduce the problem in Go, C++, Rust, and Elixir.\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eLanguage\u003c/th\u003e\n      \u003cth\u003eAffected\u003c/th\u003e\n      \u003cth\u003eExplanation\u003c/th\u003e\n      \u003cth\u003eCode\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eJava\u003c/td\u003e\n      \u003ctd\u003eyes\u003c/td\u003e\n      \u003ctd\u003ethis whole article is based on this\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/java/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC#\u003c/td\u003e\n      \u003ctd\u003eyes\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://stackoverflow.com/questions/14909853/is-sorteddictionary-a-red-black-tree\"\u003eSortedDictionary\u003c/a\u003e used red black tree\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/csharp/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eRuby\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003eUsed red black tree from \u003ca href=\"http://kanwei.github.io/algorithms/classes/Containers/RubyRBTreeMap.html\"\u003ekanwei/algorithms\u003c/a\u003e but was unable to reproduce the issue. I believe it might not be able to reproduce the problem due to the Global Interpreter Lock (GIL), and how it limits when threads can context switch preventing interleavings of threads that cause an infinite loop.\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/ruby/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC++\u003c/td\u003e\n      \u003ctd\u003eyes\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://stackoverflow.com/questions/18414579/what-data-structure-is-inside-stdmap-in-c\"\u003eused red-black tree\u003c/a\u003e. I was expecting it to always segfault first preventing it from hitting the issue.\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/cpp/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eGo\u003c/td\u003e\n      \u003ctd\u003eyes\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/emirpasic/gods#redblacktree\"\u003ehas popular datastructures library\u003c/a\u003e. Similar to C++, I was expecting it only segfault and not reproduce the infinite loop. I was wrong.\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/golang/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eRust\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003ecompiler prevented me. I don’t know enough about writing unsafe code to reproduce the problem\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/rust/\"\u003esource\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eKotlin\u003c/td\u003e\n      \u003ctd\u003eyes\u003c/td\u003e\n      \u003ctd\u003euses java’s TreeMap, same issue expected\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ePHP\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003enot in standard library and did not find any popular libraries with red black tree\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eJavaScript\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://stackoverflow.com/questions/40028377/is-it-possible-to-achieve-multithreading-in-nodejs\"\u003emultithreading model cannot share references\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eTypescript\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003esame argument as JavaScript\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ePython\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003eno red-black tree in standard library and popular libraries like \u003ca href=\"https://grantjenks.com/docs/sortedcontainers/implementation.html\"\u003eSorted Containers do not use red black tree\u003c/a\u003e. despite no red black tree, if I had run the experiment, I would expect to not to be able to reproduce for the same reason as ruby: the GIL.\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eElixir\u003c/td\u003e\n      \u003ctd\u003eno\u003c/td\u003e\n      \u003ctd\u003eAlthough there are many third party implementations of the red black trees in Elixir (and Erlang), the programming model makes it impossible: data structures are immutable and interactions between threads are limited to message passing.\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eFrom the table, the most interesting one is C++ because I was not expecting to be able to reproduce the problem due to my hypothesis from the last section.\nAs a result, I include the details from the experiment here. Similarly, go as unexpected, but trim the article, I left it out. You can see \u003ca href=\"https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/golang/\"\u003eGo here\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe code is essentially the same as the Java one, only using C++ standard libraries.\nI also added extra printing since I was so shocked that the problem reproduced,\nI just wanted to make extra sure.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Equivalent of TreeMap in C++ is std::map\u003c/span\u003e\n\u003cspan\u003e// Uses same red black tree data structure\u003c/span\u003e\n\u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003esortedMap\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003enumThreads\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ethreads\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eemplace_back\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e]()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// copy so that we don\u0026#39;t use the latest value of i (5)\u003c/span\u003e\n        \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ethreadId\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ethreadIdGenerator\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efetch_add\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003erandom_device\u003c/span\u003e \u003cspan\u003erd\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003emt19937\u003c/span\u003e \u003cspan\u003egen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erd\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003euniform_int_distribution\u003c/span\u003e\u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan\u003edis\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e999\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n                    \n        \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003eprogressThreshold\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enumUpdates\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003eprogressRatio\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecout\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Thread \u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003ethreadId\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34; started.\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003enumUpdates\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ej\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ekey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edis\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003egen\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n                \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edis\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003egen\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n                \u003cspan\u003esortedMap\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ekey\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e \u003cspan\u003ecatch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eexception\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecerr\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Caught exception on thread \u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003ethreadId\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;:\u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewhat\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eendl\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n\n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003eprogressThreshold\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                    \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecout\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Thread \u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003ethreadId\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;: \u0026#34;\u003c/span\u003e \n                            \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e \u003cspan\u003e100\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e \u003cspan\u003enumUpdates\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;% complete (\u0026#34;\u003c/span\u003e \n                            \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;/\u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003enumUpdates\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34; updates)\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003estd\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003ecout\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;Thread \u0026#34;\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003ethreadId\u003c/span\u003e \u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34; completed.\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e});\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eOccasionally, the program segfaults and crashes like before.\nThis is what I was expecting the worst failure to look like.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e./SimpleRepro\nzsh: segmentation fault  ./SimpleRepro\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHowever, very rarely the output would look like below, indicating the threads got\nstuck.\nAfter waiting 10 minutes, the threads never completed.\nI did not expect this to happen because I thought it requires a thrown and\nswallowed exception. That is not happening here.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e./SimpleRepro\nThread 0 started.Thread Thread 0: 10% complete (Thread 10/10012Thread  started.3\nstarted.Thread 4 started.Thread 4: 10% complete (10/100 updates)\n updates)\nThread 0: 20% complete (20/100 updates)\nThread 0: 30% complete (30/100 updates)\nThread 0: 40% complete (40/100 updates)\nThread 1: 10% complete (10/100 updates)\n started.Thread 2: 10% complete (10/100 updates)\nThread 1: 20% complete (20/100 updates)\n\u0026lt;nothing output for 5 minutes\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFrom the tool \u003ccode\u003etop\u003c/code\u003e we can see that the problem reproduced because of the high cpu\nutilization.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003etop\nPID    COMMAND      %CPU  TIME     ...\n59815  SimpleRepro  170.8 08:49.61 ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis shows my claim is false.\nI was able to reproduce the problem in Go and C++.\nAlthough they sometimes segfaulted, there were times when they got stuck in the\ninfinite loop.\nIn a language like C++, when you reference a null pointer it always segfaults,\nso there must be an interleaving of the threads that does not hit a null!\nI have no idea why.\nI was expecting them to crash given how often I saw NPEs in the Java experiment.\u003c/p\u003e\n\n\u003cp\u003eWith this knowledge, I went back to my SimpeRepro java experiment and stopped catching the NPE.\nAfter re-running it 12 times, I was still able to reproduce the problem despite not catching the NPE:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;Thread-4\u0026#34; #17 prio=5 os_prio=31 cpu=18597.02ms elapsed=23.79s tid=0x00007f81051ac200 nid=0x6a03 runnable  [0x000070000bcb5000]\n   java.lang.Thread.State: RUNNABLE\n        at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:826)\n        at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:534)\n        at SimpleRepro.lambda$main$0(SimpleRepro.java:28)\n        at SimpleRepro$$Lambda$1/0x0000000800c00a08.run(Unknown Source)\n        at java.lang.Thread.run(java.base@17.0.3/Thread.java:833)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe other thing that surprised me was languages like Ruby, despite letting you\ncatch NPEs did not let you reproduce the problem. The Global Interpreter Lock (GIL)\nsomehow prevented all execution interleavings that would reproduce the problem.\u003c/p\u003e\n\n\u003ch2 id=\"easy-fix-guard-against-concurrent-modification\"\u003eEasy Fix: Guard against concurrent modification\u003c/h2\u003e\n\n\u003cp\u003eThe easiest way to fix this was to wrap the TreeMap with \u003ccode\u003eCollections.synchronizedMap\u003c/code\u003e or switch to \u003ccode\u003eConcurrentHashMap\u003c/code\u003e and sort on demand.\nHowever, those fixes are boring and did not prevent us from making that mistake and taking down our host.\u003c/p\u003e\n\n\u003ch2 id=\"controversial-fix-track-visited-nodes\"\u003eControversial Fix: Track visited nodes\u003c/h2\u003e\n\n\u003cp\u003eWhat if you could safely make the mistake, but not have a cycle?\u003c/p\u003e\n\n\u003cp\u003eI modified the red-black tree to record the nodes it has already visited.\nThe only requires an additional O(lg(n)) memory since it’s limited by the height of the tree.\nThe height of a red-black tree is guaranteed to be O(lg(n)).\nIf we encounter a node that we already visited, we throw a \u003ccode\u003eConcurrentModificationException\u003c/code\u003e.\nThis will not prevent the data corruption,\nbut will prevent 100% cpu utilization from the infinite loop if someone makes that mistake again in the future.\nThis would require standard libraries to adopt this technique though which I\ndon’t think is likely to happen given the extra memory needed.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003ediff --git a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java\nindex 53c15bb..2713d5a 100644\n\u003c/span\u003e\u003cspan\u003e--- a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java\n\u003c/span\u003e\u003cspan\u003e+++ b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java\n\u003c/span\u003e\u003cspan\u003e@@ -345,7 +345,9 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n         @SuppressWarnings(\u0026#34;unchecked\u0026#34;)\n             Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key;\n         Entry\u0026lt;K,V\u0026gt; p = root;\n\u003cspan\u003e+        IdentityHashMap\u0026lt;Entry\u0026lt;?,?\u0026gt;, Boolean\u0026gt; visited = new IdentityHashMap\u0026lt;\u0026gt;();\n\u003c/span\u003e         while (p != null) {\n\u003cspan\u003e+            visited.put(p, true);\n\u003c/span\u003e             int cmp = k.compareTo(p.key);\n             if (cmp \u0026lt; 0)\n                 p = p.left;\n\u003cspan\u003e@@ -353,6 +355,10 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n                 p = p.right;\n             else\n                 return p;\n\u003cspan\u003e+\n+            if (visited.containsKey(p)) {\n+                throw new ConcurrentModificationException(\u0026#34;TreeMap corrupted. Loop detected\u0026#34;);\n+            }\n\u003c/span\u003e         }\n         return null;\n     }\n\u003cspan\u003e@@ -779,6 +785,7 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n     }\n \n     private V put(K key, V value, boolean replaceOld) {\n\u003cspan\u003e+        IdentityHashMap\u0026lt;Entry\u0026lt;?,?\u0026gt;, Boolean\u0026gt; visited = new IdentityHashMap\u0026lt;\u0026gt;();\n\u003c/span\u003e         Entry\u0026lt;K,V\u0026gt; t = root;\n         if (t == null) {\n             addEntryToEmptyMap(key, value);\n\u003cspan\u003e@@ -790,6 +797,7 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n         Comparator\u0026lt;? super K\u0026gt; cpr = comparator;\n         if (cpr != null) {\n             do {\n\u003cspan\u003e+                visited.put(t, true);\n\u003c/span\u003e                 parent = t;\n                 cmp = cpr.compare(key, t.key);\n                 if (cmp \u0026lt; 0)\n\u003cspan\u003e@@ -803,12 +811,17 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n                     }\n                     return oldValue;\n                 }\n\u003cspan\u003e+\n+                if (visited.containsKey(t)) {\n+                    throw new ConcurrentModificationException(\u0026#34;TreeMap corrupted. Loop detected\u0026#34;);\n+                }\n\u003c/span\u003e             } while (t != null);\n         } else {\n             Objects.requireNonNull(key);\n             @SuppressWarnings(\u0026#34;unchecked\u0026#34;)\n             Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key;\n             do {\n\u003cspan\u003e+                                                               visited.put(t, true);\n\u003c/span\u003e                 parent = t;\n                 cmp = k.compareTo(t.key);\n                 if (cmp \u0026lt; 0)\n\u003cspan\u003e@@ -822,6 +835,10 @@\u003c/span\u003e public class ProtectedTreeMap\u0026lt;K,V\u0026gt;\n                     }\n                     return oldValue;\n                 }\n\u003cspan\u003e+\n+                if (visited.containsKey(t)) {\n+                    throw new ConcurrentModificationException(\u0026#34;TreeMap corrupted. Loop detected\u0026#34;);\n+                }\n\u003c/span\u003e             } while (t != null);\n         }\n         addEntry(key, value, parent, cmp \u0026lt; 0);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ediff from my \u003ca href=\"https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java\"\u003eProtectedTreeMap.java\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIn the above code, you can see that I modified both the get and put methods to\nmaintain the set of visited nodes and throw a \u003ccode\u003eConcurrentModificationException\u003c/code\u003e\nwhen an already visited node is in the set.\u003c/p\u003e\n\n\u003ch2 id=\"mistakes-happen-make-swiss-cheese\"\u003eMistakes Happen: Make Swiss Cheese\u003c/h2\u003e\n\n\u003cp\u003eMistakes happen so it’s important that multiple layers are in place to detect the issue.\nImaging a slice of Swiss cheese, each slice taken from a different block of cheese.\nStacking enough of those slices would result in nothing being able to pass through.\u003c/p\u003e\n\n\u003ch2 id=\"alerts-on-npes\"\u003eAlerts on NPEs\u003c/h2\u003e\n\n\u003cp\u003eWe lacked an alarm on any instance of an NPE.\nWe only had error rate alarms.\nThis NPE only occurs once per API handler worker thread before which was not enough to trigger our error rate alarms.\nOn top of that, none of the NPEs were logged because we had an unhandled exception in our Executor.\u003c/p\u003e\n\n\u003ch2 id=\"alerts-on-utilization-anomalies\"\u003eAlerts on utilization anomalies\u003c/h2\u003e\n\n\u003cp\u003eWe monitor the cpu utilization and use a naive threshold based approach to alarming.\nWhen the cpu utilization exceeds that threshold, we fire an alarm because it indicates abnormal behaviour.\nThis is how we discovered the issue.\u003c/p\u003e\n\n\u003ch2 id=\"uncaught-exceptions-on-executors\"\u003eUncaught exceptions on Executors\u003c/h2\u003e\n\n\u003cp\u003eIf you add your work to an executor you must ensure you have an uncaught exception handler.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eAtomicInteger\u003c/span\u003e \u003cspan\u003ethreadNumber\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eAtomicInteger\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003eThreadFactory\u003c/span\u003e \u003cspan\u003ecustomThreadFactory\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eThreadFactory\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e@Override\u003c/span\u003e\n    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eThread\u003c/span\u003e \u003cspan\u003enewThread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eRunnable\u003c/span\u003e \u003cspan\u003er\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eThread\u003c/span\u003e \u003cspan\u003ethread\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eThread\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003er\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003ethread\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetName\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;my-thread-pool-\u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ethreadNumber\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetAndIncrement\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n        \u003cspan\u003ethread\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetUncaughtExceptionHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n          \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edyingThread\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;uncaught exception!\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n          \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e);\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ethread\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e};\u003c/span\u003e\n\n\u003cspan\u003eExecutorService\u003c/span\u003e \u003cspan\u003eexecutor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eExecutors\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enewFixedThreadPool\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecustomThreadFactory\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis code is kind of ugly so you’re better off using\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/concurrent/BasicThreadFactory.html\"\u003eApache Common’s BasicThreadFactory\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBasicThreadFactory\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eBuilder\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enamingPattern\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;my-thread-pool-%d\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003euncaughtExceptionHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edyingThread\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;uncaught exception!\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eor \u003ca href=\"https://guava.dev/releases/19.0/api/docs/com/google/common/util/concurrent/ThreadFactoryBuilder.html\"\u003eguava’s ThreadFactoryBuilder\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eThreadFactoryBuilder\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetNameFormat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;my-thread-pool-%d\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetUncaughtExceptionHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edyingThread\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;uncaught exception!\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ethrowable\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWithout a handler, the exception will be swallowed and none of your log monitoring will be able to detect the issue.\u003c/p\u003e\n\n\u003ch2 id=\"code-reviews\"\u003eCode reviews\u003c/h2\u003e\n\n\u003cp\u003eSometimes, a detail oriented developer will notice the combination of threads\nand TreeMap, or even suggest to not use a TreeMap if ordered elements are not\nneeded. Unfortunately, that didn’t happen in this case.\u003c/p\u003e\n\n\u003ch2 id=\"static-code-analysis\"\u003eStatic code analysis\u003c/h2\u003e\n\n\u003cp\u003eStatic code analysis tools like SpotBugs (used to be called FindBugs), JLint, and Chord can detect these kinds of issues at build time. See the paper \u003ca href=\"https://www.sqrlab.ca/papers/SCAM2010.pdf\"\u003eHow Good is Static Analysis at Finding Concurrency Bugs?\u003c/a\u003e.\nUnfortunately, we didn’t start using them until after the bug.\u003c/p\u003e\n\n\u003ch2 id=\"tests\"\u003eTests\u003c/h2\u003e\n\n\u003cp\u003eEnsure your tests handle the multithreaded case!\nIn my case, we did not have multithreaded tests for that part of the code.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eMistakes happen.\nWatch out, unprotected concurrent modification data corruption can present itself as infinite loops!\nDespite making multiple mistakes, that hid the problem at multiple layers but not all.\nAs long as you adopt a layered approach, you will be able to respond quickly or\nprevent it entirely.\u003c/p\u003e\n\n\n      \u003c/article\u003e\n\n      \n\n      \n\n      \n        \n\n\n\n\n\n\n\n\n      \n\n      \n      \n  \n  \n  \n\n  \n\n\n  \n\n  \n\n\n\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "28 min read",
  "publishedTime": "2025-02-26T08:30:00-05:00",
  "modifiedTime": null
}
